declare namespace Ext.app {
	/** 
	 * [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)
	 * Represents an Ext JS application, which is typically a single page app using a
	 * [Viewport](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Viewport.html).
	 * 
	 * An application consists of one or more Views. The behavior of a View is managed by its
	 * corresponding [ViewController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html) and [ViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html).
	 * 
	 * Global activities are coordinated by [Controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html) which are
	 * ultimately instantiated by an instance of this (or a derived) class.
	 * 
	 *    Ext.application({
	 *        name: 'MyApp',
	 *    
	 *        // An instance of this view is created and set as the Viewport:
	 *        autoCreateViewport: 'MyApp.view.Main'
	 *    });
	 * 
	 * This does several things. First it creates a global variable called 'MyApp' - all of
	 * your Application's classes (such as its Models, Views and Controllers) will reside under
	 * this single namespace, which drastically lowers the chances of colliding global variables.
	 * 
	 * The MyApp global will also have a getApplication method to get a reference to the current
	 * application:
	 * 
	 *    var app = MyApp.getApplication();
	 * 
	 * # Telling Application about the rest of the app
	 * 
	 * Because an [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) represents an entire app, we should tell it about the other
	 * parts of the app - namely the Models, Views and Controllers that are bundled with the application. Let's say we have a blog management app; we
	 * might have Models and Controllers for Posts and Comments, and Views for listing, adding and editing Posts and Comments.
	 * Here's how we'd tell our Application about all these things:
	 * 
	 *    Ext.application({
	 *        name: 'Blog',
	 *    
	 *        models: ['Post', 'Comment'],
	 *    
	 *        controllers: ['Posts', 'Comments'],
	 *    
	 *        launch: function() {
	 *            ...
	 *        }
	 *    });
	 * 
	 * Note that we didn't actually list the Views directly in the Application itself. This is because Views are managed by
	 * Controllers, so it makes sense to keep those dependencies there. The Application will load each of the specified
	 * Controllers using the pathing conventions laid out in the [application architecture guide](../application_architecture/application_architecture.html) - in this case
	 * expecting the controllers to reside in app/controller/Posts.js and app/controller/Comments.js. In turn, each
	 * Controller simply needs to list the Views it uses and they will be automatically loaded. Here's how our Posts
	 * controller like be defined:
	 * 
	 *    Ext.define('MyApp.controller.Posts', {
	 *        extend: 'Ext.app.Controller',
	 *        views: ['posts.List', 'posts.Edit'],
	 *    
	 *        //the rest of the Controller here
	 *    });
	 * 
	 * Because we told our Application about our Models and Controllers, and our Controllers about their Views, Ext JS will
	 * automatically load all of our app files for us. This means we don't have to manually add script tags into our html
	 * files whenever we add a new class, but more importantly it enables us to create a minimized build of our entire
	 * application using Sencha Cmd.
	 * 
	 * # Deriving from [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)
	 * 
	 * Typically, applications do not derive directly from [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html). Rather, the
	 * configuration passed to [`Ext.application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-application) mimics what you might do in a derived class.
	 * In some cases, however, it can be desirable to share logic by using a derived class
	 * from [`Ext.app.Application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html).
	 * 
	 * Derivation works as you would expect, but using the derived class should still be the
	 * job of the [`Ext.application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-application) method.
	 * 
	 *    Ext.define('MyApp.Application', {
	 *        extend: 'Ext.app.Application',
	 *        name: 'MyApp',
	 *        ...
	 *    });
	 *    
	 *    Ext.application('MyApp.Application');
	 * 
	 * For more information about writing Ext JS applications, please see the [application architecture guide](../../../application_architecture/application_architecture.html).
	 */
	class Application extends Ext.app.Controller {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.app.Application.Statics}
		 */
		self?: Ext.app.Application.Statics | Ext.app.Controller.Statics | Ext.app.BaseController.Statics | Ext.Base.Statics;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                 members    The members to add to this class.
		 * @param   {boolean}                                                                [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.Application;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.Controller;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.BaseController;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                 members
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.app.Application;
		static addStatics? (members: object): typeof Ext.app.Controller;
		static addStatics? (members: object): typeof Ext.app.BaseController;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                 members
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.app.Application;
		static addInheritableStatics? (members: object): typeof Ext.app.Controller;
		static addInheritableStatics? (members: object): typeof Ext.app.BaseController;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                 name
		 * @param   {object}                                                                 member
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.app.Application;
		static addMember? (name: object, member: object): typeof Ext.app.Controller;
		static addMember? (name: object, member: object): typeof Ext.app.BaseController;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                 fn
		 * @param   {object}                                                                 scope
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.app.Application;
		static onExtended? (fn: object, scope: object): typeof Ext.app.Controller;
		static onExtended? (fn: object, scope: object): typeof Ext.app.BaseController;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Allow the controller to resume receiving events from the event bus.
		 * Routes will also be able to begin firing on this controller.
		 * Also see [deactivate](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-deactivate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		activate? (): void;
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Registers one or more [references](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-refs).
		 * @method
		 * @public (method)
		 * @param   {object|object[]} refs
		 * @returns {void}                 
		 */
		addRef? (refs: object | object[]): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Adds listeners to components selected via [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html). Accepts an
		 * object containing component paths mapped to a hash of listener functions.
		 * 
		 * In the following example the `updateUser` function is mapped to to the `click`
		 * event on a button component, which is a child of the `useredit` component.
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.control({
		 *                 'useredit button[action=save]': {
		 *                     click: this.updateUser
		 *                 }
		 *             });
		 *         },
		 *    
		 *         updateUser: function(button) {
		 *             console.log('clicked the Save button');
		 *         }
		 *     });
		 * 
		 * Or alternatively one call `control` with two arguments:
		 * 
		 *     this.control('useredit button[action=save]', {
		 *         click: this.updateUser
		 *     });
		 * 
		 * See [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) for more information on component selectors.
		 * @method
		 * @public (method)
		 * @param   {string|object} selectors
		 * If a String, the second argument is used as the
		 * listeners, otherwise an object of selectors -> listeners is assumed
		 * @param   {object}        [listeners] Config for listeners.
		 * @returns {void}                      
		 */
		control? (selectors: string | object, listeners?: object): void;
		/** 
		 * Create an instance of a controller by name.
		 * @method
		 * @public (method)
		 * @param   {string}             name
		 * The name of the controller. For a controller with the
		 * full class name `MyApp.controller.Foo`, the name parameter should be `Foo`.
		 * If the controller already exists, it will be returned.
		 * @returns {Ext.app.Controller}      controller
		 */
		createController? (name: string): Ext.app.Controller;
		/** 
		 * Prevent this controller from receiving events from the event bus.
		 * Routes will also not be triggered on inactive controllers unless
		 * the [Ext.app.route.Route.allowInactive](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.route.Route.html#cfg-allowInactive) flag is set.
		 * Also see [activate](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-activate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		deactivate? (): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @param   {object} destroyRefs
		 * @returns {void}               
		 */
		destroy? (destroyRefs: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.app.BaseController.destroy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-destroy).
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Destroys a controller, any listeners are unbound.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.app.Controller} controller The controller
		 * @returns {void}                                 
		 */
		destroyController? (controller: string | Ext.app.Controller): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [active](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-active).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getActive? (): boolean;
		/** 
		 * Returns the value of [appProperty](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-appProperty).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getAppProperty? (): string;
		/** 
		 * Returns the value of [application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-application).
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.app.Application}  
		 */
		getApplication? (): Ext.app.Application;
		getApplication? (): Ext.app.Application;
		/** 
		 * Returns the value of [before](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-before).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getBefore? (): object;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-control).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getControl? (): object;
		/** 
		 * Returns instance of a [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html) with the given id.
		 * When controller doesn't exist yet, it's created. Note that this method depends
		 * on Application instance and will return undefined when Application is not
		 * accessible. The only exception is when this Controller instance's id is requested;
		 * in that case we always return the instance even if Application is no available.
		 * @method
		 * @public (method)
		 * @param   {object}             name
		 * @param   {object}             preventCreate
		 * @returns {Ext.app.Controller}               controller instance or undefined.
		 */
		getController? (name: object, preventCreate: object): Ext.app.Controller;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.app.Controller.getController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-getController).
		 * Returns instance of a [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html) with the given id.
		 * When controller doesn't exist yet, it's created. Note that this method depends
		 * on Application instance and will return undefined when Application is not
		 * accessible. The only exception is when this Controller instance's id is requested;
		 * in that case we always return the instance even if Application is no available.
		 * @method
		 * @public (method)
		 * @param   {string}             id
		 * @returns {Ext.app.Controller}    controller instance or undefined.
		 */
		getController? (id: string): Ext.app.Controller;
		/** 
		 * Returns the value of [currentProfile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-currentProfile).
		 * @method
		 * @public (method)
		 * @returns {Ext.app.Profile}  
		 */
		getCurrentProfile? (): Ext.app.Profile;
		/** 
		 * Returns the value of [defaultToken](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-defaultToken).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDefaultToken? (): string;
		/** 
		 * Returns the value of [glyphFontFamily](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-glyphFontFamily).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGlyphFontFamily? (): string;
		/** 
		 * Returns the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-id).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getId? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-listen).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getListen? (): object;
		/** 
		 * Returns the value of [mainView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-mainView).
		 * @method
		 * @public (method)
		 * @returns {string|object}  
		 */
		getMainView? (): string | object;
		/** 
		 * Returns a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) class with the given name.
		 * @method
		 * @public (method)
		 * @param   {string}    name
		 * @returns {Ext.Class}      A class ultimately derived from [`Ext.data.Model`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html).
		 */
		getModel? (name: string): Ext.Class;
		/** 
		 * Returns the value of [name](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-name).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getName? (): string;
		/** 
		 * Returns instance of a [Profile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html) with the given name.
		 * @method
		 * @public (method)
		 * @param   {string} name
		 * @returns {string}      a profile instance.
		 */
		getProfile? (name: string): string;
		/** 
		 * Returns the value of [profiles](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-profiles).
		 * @method
		 * @public (method)
		 * @returns {string|string[]}  
		 */
		getProfiles? (): string | string[];
		/** 
		 * Returns the value of [refs](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-refs).
		 * @method
		 * @public (method)
		 * @returns {object|object[]}  
		 */
		getRefs? (): object | object[];
		/** 
		 * Returns the value of [routes](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-routes).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getRoutes? (): object;
		/** 
		 * Returns instance of a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) with the given name.
		 * When store doesn't exist yet, it's created.
		 * @method
		 * @public (method)
		 * @param   {string}         name
		 * @returns {Ext.data.Store}      a store instance.
		 */
		getStore? (name: string): Ext.data.Store;
		/** 
		 * Returns a View class with the given name.  To create an instance of the view,
		 * you can use it like it's used by Application to create the Viewport:
		 * 
		 *    this.getView('Viewport').create();
		 * 
		 * @method
		 * @public (method)
		 * @param   {string}   view
		 * @returns {Ext.Base}      a view class.
		 */
		getView? (view: string): Ext.Base;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Returns `true` if a [reference](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-refs) is registered.
		 * @method
		 * @public (method)
		 * @param   {string}  ref The name of the ref to check for.
		 * @returns {boolean}     
		 */
		hasRef? (ref: string): boolean;
		/** 
		 * A template method that is called when your application boots. It is called before the
		 * [Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)'s launch function is executed so gives a hook point
		 * to run any code before your Viewport is created.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.app.Application} application
		 * @returns {void}                            
		 */
		init? (application: Ext.app.Application): void;
		/** 
		 * Checks if this controller is active. See [activate](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-activate) &amp;
		 * [deactivate](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-deactivate).
		 * @method
		 * @public (method)
		 * @returns {boolean|void}  `true` if this controller is active.
		 */
		isActive? (): boolean;
		isActive? (): void;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Called automatically when the page has completely loaded. This is an empty function that should be
		 * overridden by each application that needs to take action on page load.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {string}  profile The detected application profile
		 * @returns {boolean} 
		 * By default, the Application will dispatch to the configured startup controller and
		 * action immediately after running the launch function. Return false to prevent this behavior.
		 */
		launch? (profile: string): boolean;
		/** 
		 * Adds listeners to different event sources (also called "event domains"). The
		 * primary event domain is that of components, but there are also other event domains:
		 * [Global](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html) domain that intercepts events fired from
		 * [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance, [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html)
		 * domain can be used to listen to events fired by other Controllers,
		 * [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html) domain gives access to Store events, and
		 * [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html) domain can be used with Ext Direct Providers
		 * to listen to their events.
		 * 
		 * To listen to "bar" events fired by a controller with id="foo":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 controller: {
		 *                     '#foo': {
		 *                        bar: this.onFooBar
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * To listen to "bar" events fired by any controller, and "baz" events
		 * fired by Store with storeId="baz":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 controller: {
		 *                     '*': {
		 *                        bar: this.onAnyControllerBar
		 *                     }
		 *                 },
		 *                 store: {
		 *                     '#baz': {
		 *                         baz: this.onStoreBaz
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * To listen to "idle" events fired by [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) when other event
		 * processing is complete and Ext JS is about to return control to the browser:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 global: {               // Global events are always fired
		 *                     idle: this.onIdle   // from the same object, so there
		 *                 }                       // are no selectors
		 *             });
		 *         }
		 *     });
		 * 
		 * As this relates to components, the following example:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 component: {
		 *                     'useredit button[action=save]': {
		 *                        click: this.updateUser
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * Is equivalent to:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.control({
		 *                 'useredit button[action=save]': {
		 *                    click: this.updateUser
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * Of course, these can all be combined in a single call and used instead of
		 * `control`, like so:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 global: {
		 *                     idle: this.onIdle
		 *                 },
		 *                 controller: {
		 *                     '*': {
		 *                        foobar: this.onAnyFooBar
		 *                     },
		 *                     '#foo': {
		 *                        bar: this.onFooBar
		 *                     }
		 *                 },
		 *                 component: {
		 *                     'useredit button[action=save]': {
		 *                        click: this.updateUser
		 *                     }
		 *                 },
		 *                 store: {
		 *                     '#qux': {
		 *                         load: this.onQuxLoad
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * @method
		 * @public (method)
		 * @param   {object}             to           Config object containing domains, selectors and listeners.
		 * @param   {Ext.app.Controller} [controller] The controller to add the listeners to. Defaults to the current controller.
		 * @returns {void}                            
		 */
		listen? (to: object, controller?: Ext.app.Controller): void;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Called automatically when an update to either the Application Cache or the Local Storage Cache is detected.
		 * This is mainly used during production builds.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {object} [updateInfo] updateInfo Update information object contains properties for checking which cache triggered the update
		 * @returns {void}                
		 */
		onAppUpdate? (updateInfo?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * A template method like [init](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-init), but called after the viewport is created.
		 * This is called after the [launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#method-launch) method of Application
		 * is executed.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.app.Application} application
		 * @returns {void}                            
		 */
		onLaunch? (application: Ext.app.Application): void;
		/** 
		 * Update the hash. By default, it will not execute the routes if the current token and the
		 * token passed are the same.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} token
		 * The token to redirect to.  Can be either a String
		 * or a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) instance - if a Model instance is passed it will
		 * internally be converted into a String token by calling the Model's
		 * [toUrl](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html#method-toUrl) function.
		 * @param   {boolean}               force Force the update of the hash regardless of the current token.
		 * @returns {boolean}                     Will return `true` if the token was updated.
		 */
		redirectTo? (token: string | Ext.data.Model, force: boolean): boolean;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [active](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-active).
		 * @method
		 * @public (method)
		 * @param   {boolean} active The new value.
		 * @returns {void}           
		 */
		setActive? (active: boolean): void;
		/** 
		 * Sets the value of [appProperty](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-appProperty).
		 * @method
		 * @public (method)
		 * @param   {string} appProperty The new value.
		 * @returns {void}               
		 */
		setAppProperty? (appProperty: string): void;
		/** 
		 * Sets the value of [application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-application).
		 * @method
		 * @public (method)
		 * @param   {Ext.app.Application} application The new value.
		 * @returns {void}                            
		 */
		setApplication? (application: Ext.app.Application): void;
		/** 
		 * Sets the value of [before](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-before).
		 * @method
		 * @public (method)
		 * @param   {object} before The new value.
		 * @returns {void}          
		 */
		setBefore? (before: object): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                          name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                 [value] The value to set for the name parameter.
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.Application;
		setConfig? (name: string | object, value?: object): Ext.app.Controller;
		setConfig? (name: string | object, value?: object): Ext.app.BaseController;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-control).
		 * @method
		 * @public (method)
		 * @param   {object} control The new value.
		 * @returns {void}           
		 */
		setControl? (control: object): void;
		/** 
		 * Sets the value of [currentProfile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-currentProfile).
		 * @method
		 * @public (method)
		 * @param   {Ext.app.Profile} currentProfile The new value.
		 * @returns {void}                           
		 */
		setCurrentProfile? (currentProfile: Ext.app.Profile): void;
		/** 
		 * Sets the value of [defaultToken](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-defaultToken).
		 * @method
		 * @public (method)
		 * @param   {string} defaultToken The new value.
		 * @returns {void}                
		 */
		setDefaultToken? (defaultToken: string): void;
		/** 
		 * Sets the value of [glyphFontFamily](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-glyphFontFamily).
		 * @method
		 * @public (method)
		 * @param   {string} glyphFontFamily The new value.
		 * @returns {void}                   
		 */
		setGlyphFontFamily? (glyphFontFamily: string): void;
		/** 
		 * Sets the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-id).
		 * @method
		 * @public (method)
		 * @param   {string} id The new value.
		 * @returns {void}      
		 */
		setId? (id: string): void;
		/** 
		 * Sets the value of [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-listen).
		 * @method
		 * @public (method)
		 * @param   {object} listen The new value.
		 * @returns {void}          
		 */
		setListen? (listen: object): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [mainView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-mainView).
		 * @method
		 * @public (method)
		 * @param   {string|object} mainView The new value.
		 * @returns {void}                   
		 */
		setMainView? (mainView: string | object): void;
		/** 
		 * Sets the value of [name](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-name).
		 * @method
		 * @public (method)
		 * @param   {string} name The new value.
		 * @returns {void}        
		 */
		setName? (name: string): void;
		/** 
		 * Sets the value of [profiles](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-profiles).
		 * @method
		 * @public (method)
		 * @param   {string|string[]} profiles The new value.
		 * @returns {void}                     
		 */
		setProfiles? (profiles: string | string[]): void;
		/** 
		 * Sets the value of [refs](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-refs).
		 * @method
		 * @public (method)
		 * @param   {object|object[]} refs The new value.
		 * @returns {void}                 
		 */
		setRefs? (refs: object | object[]): void;
		/** 
		 * Sets the value of [routes](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-routes).
		 * @method
		 * @public (method)
		 * @param   {object} routes The new value.
		 * @returns {void}          
		 */
		setRoutes? (routes: object): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                 config
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.app.Application;
		initConfig? (config: object): Ext.app.Controller;
		initConfig? (config: object): Ext.app.BaseController;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.Application.Statics|Ext.app.Controller.Statics|Ext.app.BaseController.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.app.Application.Statics;
		statics? (): Ext.app.Controller.Statics;
		statics? (): Ext.app.BaseController.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} control
		 * @returns {void}           
		 */
		applyControl? (control: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} listen
		 * @returns {void}          
		 */
		applyListen? (listen: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} refs
		 * @returns {void}        
		 */
		applyRefs? (refs: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} app
		 * @returns {void}       
		 */
		doInit? (app: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		ensureId? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} app
		 * @returns {void}       
		 */
		finishInit? (app: object): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Returns the value of [moduleClassName](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-moduleClassName).
		 * @method
		 * @private (method)
		 * @returns {object}  
		 */
		getModuleClassName? (): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ref
		 * @param   {object} info
		 * @param   {object} config
		 * @returns {void}          
		 */
		getRef? (ref: object, info: object, config: object): void;
		/** 
		 * Returns a map of reference names to selectors
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRefMap? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initAutoGetters? (): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Takes either an object and transforms it into an array. The following are valid refs values:
		 * 
		 *    refs: {
		 *        myComponent: 'container'
		 *    }
		 *    
		 *    refs: {
		 *        myComponent: {
		 *            selector: 'container'
		 *        }
		 *    }
		 *    
		 *    refs: [
		 *        {
		 *            ref: 'myComponent',
		 *            selector: 'container'
		 *        }
		 *    ]
		 * 
		 * @method
		 * @private (method)
		 * @param   {any[]|object} refs    The refs to normalize
		 * @param   {any[]}        newRefs An array to place the normalized refs on to
		 * @returns {any[]}                The normalized array of refs
		 */
		normalizeRefs? (refs: any[] | object, newRefs: any[]): any[];
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} cls
		 * @param   {object} data
		 * @param   {object} hooks
		 * @returns {void}         
		 */
		onClassExtended? (cls: object, data: object, hooks: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} refs
		 * @returns {void}        
		 */
		ref? (refs: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Sets the value of [moduleClassName](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-moduleClassName).
		 * @method
		 * @private (method)
		 * @param   {object} moduleClassName The new value.
		 * @returns {void}                   
		 */
		setModuleClassName? (moduleClassName: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                               names The names of the linked objects to destroy.
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.app.Application;
		unlink? (names: string[]): Ext.app.Controller;
		unlink? (names: string[]): Ext.app.BaseController;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} control The object to pass to the [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-control) method
		 * @returns {void}           
		 */
		updateControl? (control: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} listen The object to pass to the [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-listen) method
		 * @returns {void}          
		 */
		updateListen? (listen: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} refs The refs to pass to the [ref](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-ref) method.
		 * @returns {void}        
		 */
		updateRefs? (refs: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} routes The routes to connect to the [Ext.app.route.Router](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.route.Router.html)
		 * @returns {void}          
		 */
		updateRoutes? (routes: object): void;
	}
	/** 
	 * [Ext.app.BaseController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html)
	 * Base class for Controllers.
	 */
	class BaseController extends Ext.Base {
		/** 
		 * This object holds a key for any event that has a listener. The listener may be set
		 * directly on the instance, or on its class or a super class (via [observe](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#static-method-observe)) or
		 * on the [MVC EventBus](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventBus.html). The values of this object are truthy
		 * (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
		 * of listeners. The value for an event is truthy if the event must be fired and is
		 * falsy if there is no need to fire the event.
		 * 
		 * The intended use of this property is to avoid the expense of fireEvent calls when
		 * there are no listeners. This can be particularly helpful when one would otherwise
		 * have to call fireEvent hundreds or thousands of times. It is used like this:
		 * 
		 *     if (this.hasListeners.foo) {
		 *         this.fireEvent('foo', this, arg1);
		 *     }
		 * 
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		readonly hasListeners?: object;
		/** 
		 * `true` in this class to identify an object as an instantiated Observable, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isObservable?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.app.BaseController.Statics}
		 */
		self?: Ext.app.BaseController.Statics | Ext.Base.Statics;
		/** 
		 * Matches options property names within a listeners specification object  - property names which are never used as event names.
		 * @property
		 * @private (property)
		 * @default {scope: 1, delay: 1, buffer: 1, onFrame: 1, single: 1, args: 1, destroyable: 1, priority: 1, order: 1}
		 * @type {object}
		 */
		$eventOptions?: object;
		/** 
		 * Initial suspended call count. Incremented when [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents) is called, decremented when [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) is called.
		 * @property
		 * @private (property)
		 * @default 0
		 * @type {number}
		 */
		eventsSuspended?: number;
		/** 
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		isController?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members    The members to add to this class.
		 * @param   {boolean}                         [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                         [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.BaseController|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.BaseController;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members
		 * @returns {Ext.app.BaseController|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.app.BaseController;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members
		 * @returns {Ext.app.BaseController|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.app.BaseController;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          name
		 * @param   {object}                          member
		 * @returns {Ext.app.BaseController|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.app.BaseController;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          fn
		 * @param   {object}                          scope
		 * @returns {Ext.app.BaseController|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.app.BaseController;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates new Controller.
		 * @method
		 * @public (method)
		 * @param   {object} [config] Configuration object.
		 */
		constructor (config?: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                                  eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                                [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                                         [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.app.BaseController.methodParams.addListener.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                                         [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                                         
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addListener? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.app.BaseController.methodParams.addListener.Options, order?: string): object;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Adds listeners to components selected via [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html). Accepts an
		 * object containing component paths mapped to a hash of listener functions.
		 * 
		 * In the following example the `updateUser` function is mapped to to the `click`
		 * event on a button component, which is a child of the `useredit` component.
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.control({
		 *                 'useredit button[action=save]': {
		 *                     click: this.updateUser
		 *                 }
		 *             });
		 *         },
		 *    
		 *         updateUser: function(button) {
		 *             console.log('clicked the Save button');
		 *         }
		 *     });
		 * 
		 * Or alternatively one call `control` with two arguments:
		 * 
		 *     this.control('useredit button[action=save]', {
		 *         click: this.updateUser
		 *     });
		 * 
		 * See [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) for more information on component selectors.
		 * @method
		 * @public (method)
		 * @param   {string|object} selectors
		 * If a String, the second argument is used as the
		 * listeners, otherwise an object of selectors -> listeners is assumed
		 * @param   {object}        [listeners] Config for listeners.
		 * @returns {void}                      
		 */
		control? (selectors: string | object, listeners?: object): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [before](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-before).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getBefore? (): object;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-control).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getControl? (): object;
		/** 
		 * Returns the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-id).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getId? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-listen).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getListen? (): object;
		/** 
		 * Returns the value of [routes](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-routes).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getRoutes? (): object;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Adds listeners to different event sources (also called "event domains"). The
		 * primary event domain is that of components, but there are also other event domains:
		 * [Global](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html) domain that intercepts events fired from
		 * [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance, [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html)
		 * domain can be used to listen to events fired by other Controllers,
		 * [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html) domain gives access to Store events, and
		 * [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html) domain can be used with Ext Direct Providers
		 * to listen to their events.
		 * 
		 * To listen to "bar" events fired by a controller with id="foo":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 controller: {
		 *                     '#foo': {
		 *                        bar: this.onFooBar
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * To listen to "bar" events fired by any controller, and "baz" events
		 * fired by Store with storeId="baz":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 controller: {
		 *                     '*': {
		 *                        bar: this.onAnyControllerBar
		 *                     }
		 *                 },
		 *                 store: {
		 *                     '#baz': {
		 *                         baz: this.onStoreBaz
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * To listen to "idle" events fired by [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) when other event
		 * processing is complete and Ext JS is about to return control to the browser:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 global: {               // Global events are always fired
		 *                     idle: this.onIdle   // from the same object, so there
		 *                 }                       // are no selectors
		 *             });
		 *         }
		 *     });
		 * 
		 * As this relates to components, the following example:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 component: {
		 *                     'useredit button[action=save]': {
		 *                        click: this.updateUser
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * Is equivalent to:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.control({
		 *                 'useredit button[action=save]': {
		 *                    click: this.updateUser
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * Of course, these can all be combined in a single call and used instead of
		 * `control`, like so:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 global: {
		 *                     idle: this.onIdle
		 *                 },
		 *                 controller: {
		 *                     '*': {
		 *                        foobar: this.onAnyFooBar
		 *                     },
		 *                     '#foo': {
		 *                        bar: this.onFooBar
		 *                     }
		 *                 },
		 *                 component: {
		 *                     'useredit button[action=save]': {
		 *                        click: this.updateUser
		 *                     }
		 *                 },
		 *                 store: {
		 *                     '#qux': {
		 *                         load: this.onQuxLoad
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * @method
		 * @public (method)
		 * @param   {object}             to           Config object containing domains, selectors and listeners.
		 * @param   {Ext.app.Controller} [controller] The controller to add the listeners to. Defaults to the current controller.
		 * @returns {void}                            
		 */
		listen? (to: object, controller?: Ext.app.Controller): void;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                         eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                       [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                                [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.app.BaseController.methodParams.on.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                                [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                                
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		on? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.app.BaseController.methodParams.on.Options, order?: string): object;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Update the hash. By default, it will not execute the routes if the current token and the
		 * token passed are the same.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} token
		 * The token to redirect to.  Can be either a String
		 * or a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) instance - if a Model instance is passed it will
		 * internally be converted into a String token by calling the Model's
		 * [toUrl](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html#method-toUrl) function.
		 * @param   {boolean}               force Force the update of the hash regardless of the current token.
		 * @returns {boolean}                     Will return `true` if the token was updated.
		 */
		redirectTo? (token: string | Ext.data.Model, force: boolean): boolean;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [before](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-before).
		 * @method
		 * @public (method)
		 * @param   {object} before The new value.
		 * @returns {void}          
		 */
		setBefore? (before: object): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                   name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                          [value] The value to set for the name parameter.
		 * @returns {Ext.app.BaseController|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.BaseController;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-control).
		 * @method
		 * @public (method)
		 * @param   {object} control The new value.
		 * @returns {void}           
		 */
		setControl? (control: object): void;
		/** 
		 * Sets the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-id).
		 * @method
		 * @public (method)
		 * @param   {string} id The new value.
		 * @returns {void}      
		 */
		setId? (id: string): void;
		/** 
		 * Sets the value of [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-listen).
		 * @method
		 * @public (method)
		 * @param   {object} listen The new value.
		 * @returns {void}          
		 */
		setListen? (listen: object): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [routes](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-routes).
		 * @method
		 * @public (method)
		 * @param   {object} routes The new value.
		 * @returns {void}          
		 */
		setRoutes? (routes: object): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		isActive? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                          config
		 * @returns {Ext.app.BaseController|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.app.BaseController;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.BaseController.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.app.BaseController.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} control
		 * @returns {void}           
		 */
		applyControl? (control: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} listen
		 * @returns {void}          
		 */
		applyListen? (listen: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                        names The names of the linked objects to destroy.
		 * @returns {Ext.app.BaseController|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.app.BaseController;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} control The object to pass to the [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-control) method
		 * @returns {void}           
		 */
		updateControl? (control: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} listen The object to pass to the [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-listen) method
		 * @returns {void}          
		 */
		updateListen? (listen: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} routes The routes to connect to the [Ext.app.route.Router](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.route.Router.html)
		 * @returns {void}          
		 */
		updateRoutes? (routes: object): void;
	}
	/** 
	 * [Ext.app.Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html)
	 * Controllers are the glue that binds an application together. That said, their main
	 * purpose is to listen for events (usually from views) and take some action. Here's how
	 * we might create a Controller to manage Users:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         init: function() {
	 *             console.log('Initialized Users! This happens before ' +
	 *                         'the Application launch() function is called');
	 *         }
	 *     });
	 * 
	 * The init function is a special method that is called when your application boots. It is
	 * called before the [Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)'s launch function is executed.
	 * This creates an area you can run code prior to Viewport creation.
	 * 
	 * The controller's [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-control) function
	 * makes it easy to listen to events on your view classes and take some action with a
	 * handler function. Let's update our Users controller to tell us when the panel is
	 * rendered:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         control: {
	 *             'viewport &gt; panel': {
	 *                 render: 'onPanelRendered'
	 *             }
	 *         }
	 *    
	 *         onPanelRendered: function() {
	 *             console.log('The panel was rendered');
	 *         }
	 *     });
	 * 
	 * The [control method](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-control) has now set up
	 * listeners on views in our application. The control method uses the ComponentQuery
	 * engine to quickly and easily get references to components on the page. If you are not
	 * familiar with ComponentQuery yet, be sure to check out the
	 * [documentation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html). In brief, it allows us to pass a
	 * CSS-like selector that will find every matching component on the page.
	 * 
	 * In our init function above, we supplied 'viewport > panel', which translates to "find me
	 * every Panel that is a direct child of a Viewport". We then supplied an object that maps
	 * event names (just 'render' in this case) to handler functions. In short, whenever
	 * a component that matches our selector fires a 'render' event, our
	 * onPanelRendered function is called.
	 * 
	 * ## Event domains
	 * 
	 * In Ext JS 4.2, we introduced the concept of event domains. In terms of MVC, an event
	 * domain is one or more base classes that fire events to which a Controller wants to
	 * listen. Besides Component event domain that encompass [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)-descended
	 * Views, Controllers now can listen to events from data Stores, Ext Direct Providers,
	 * other Controllers, and [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html). This feature provides a way to communicate
	 * between parts of the whole application without the need to bind controllers together
	 * tightly, and allows to develop and test application parts in isolation.
	 * 
	 * See usage examples in [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-listen) method documentation.
	 * 
	 * ## Using refs
	 * 
	 * One of the most useful parts of Controllers is the ref system. These use
	 * [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) to make it really easy to get references to Views on your
	 * page. Let's look at an example of this now:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         refs: [{
	 *             ref: 'list',
	 *             selector: 'grid'
	 *         }],
	 *    
	 *         control: {
	 *             'button': {
	 *                 click: 'refreshGrid'
	 *             }
	 *         },
	 *    
	 *         refreshGrid: function() {
	 *             this.getList().store.load();
	 *         }
	 *     });
	 * 
	 * This example assumes the existence of a [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) on the page, which
	 * contains a single button to refresh the Grid when clicked. In our refs array, we set up
	 * a reference to the grid. There are two parts to this - the 'selector', which is a
	 * [ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) selector which finds any grid on the page and
	 * assigns it to the reference 'list'.
	 * 
	 * By giving the reference a name, we get a number of things for free. The first is the
	 * getList function that we use in the refreshGrid method above. This is generated
	 * automatically by the Controller based on the name of our ref, which was capitalized and
	 * prepended with get to go from 'list' to 'getList'.
	 * 
	 * The way this works is that the first time getList is called by your code, the
	 * ComponentQuery selector is run and the first component that matches the selector
	 * ('grid' in this case) will be returned. All future calls to getList will use a cached
	 * reference to that grid. Usually it is advised to use a specific ComponentQuery selector
	 * that will only match a single View in your application (in the case above our selector
	 * will match any grid on the page).
	 * 
	 * Bringing it all together, we configure control
	 * to listen to any click on a [button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) and call our refreshGrid
	 * function (again, this will match any button on the page so we advise a more specific
	 * selector than just 'button', but have left it this way for simplicity). When the button
	 * is clicked we use out getList function to refresh the grid.
	 * 
	 * You can create any number of refs and control any number of components this way, simply
	 * adding more functions to your Controller as you go. For an example of real-world usage
	 * of Controllers see the Feed Viewer example in the examples/app/feed-viewer folder in
	 * the SDK download.
	 * 
	 * ## Generated getter methods
	 * 
	 * Refs aren't the only thing that generate convenient getter methods. Controllers often
	 * have to deal with Models and Stores so the framework offers a couple of easy ways to
	 * get access to those too. Let's look at another example:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         models: ['User'],
	 *         stores: ['AllUsers', 'AdminUsers'],
	 *    
	 *         init: function() {
	 *             var User, allUsers, ed;
	 *    
	 *             User = this.getUserModel();
	 *             allUsers = this.getAllUsersStore();
	 *    
	 *             ed = new User({ name: 'Ed' });
	 *             allUsers.add(ed);
	 *         }
	 *     });
	 * 
	 * By specifying Models and Stores that the Controller cares about, it again dynamically
	 * loads them from the appropriate locations (app/model/User.js, app/store/AllUsers.js and
	 * app/store/AdminUsers.js in this case) and creates getter functions for them all. The
	 * example above will create a new User model instance and add it to the AllUsers Store.
	 * Of course, you could do anything in this function but in this case we just did
	 * something simple to demonstrate the functionality.
	 * 
	 * ## Further Reading
	 * 
	 * For more information about writing Ext JS 5 applications, please see the
	 * [Application Architecture](../../../application_architecture/application_architecture.html).
	 * Also see the [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) documentation.
	 */
	class Controller extends Ext.app.BaseController {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.app.Controller.Statics}
		 */
		self?: Ext.app.Controller.Statics | Ext.app.BaseController.Statics | Ext.Base.Statics;
		/** 
		 * @cmd-auto-dependency {aliasPrefix: "controller.", mvc: true, blame: "all"}
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		controllers?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                             members    The members to add to this class.
		 * @param   {boolean}                                            [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                            [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.Controller;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.BaseController;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                             members
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.app.Controller;
		static addStatics? (members: object): typeof Ext.app.BaseController;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                             members
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.app.Controller;
		static addInheritableStatics? (members: object): typeof Ext.app.BaseController;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                             name
		 * @param   {object}                                             member
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.app.Controller;
		static addMember? (name: object, member: object): typeof Ext.app.BaseController;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                             fn
		 * @param   {object}                                             scope
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.app.Controller;
		static onExtended? (fn: object, scope: object): typeof Ext.app.BaseController;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Allow the controller to resume receiving events from the event bus.
		 * Routes will also be able to begin firing on this controller.
		 * Also see [deactivate](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-deactivate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		activate? (): void;
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Registers one or more [references](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-refs).
		 * @method
		 * @public (method)
		 * @param   {object|object[]} refs
		 * @returns {void}                 
		 */
		addRef? (refs: object | object[]): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Adds listeners to components selected via [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html). Accepts an
		 * object containing component paths mapped to a hash of listener functions.
		 * 
		 * In the following example the `updateUser` function is mapped to to the `click`
		 * event on a button component, which is a child of the `useredit` component.
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.control({
		 *                 'useredit button[action=save]': {
		 *                     click: this.updateUser
		 *                 }
		 *             });
		 *         },
		 *    
		 *         updateUser: function(button) {
		 *             console.log('clicked the Save button');
		 *         }
		 *     });
		 * 
		 * Or alternatively one call `control` with two arguments:
		 * 
		 *     this.control('useredit button[action=save]', {
		 *         click: this.updateUser
		 *     });
		 * 
		 * See [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) for more information on component selectors.
		 * @method
		 * @public (method)
		 * @param   {string|object} selectors
		 * If a String, the second argument is used as the
		 * listeners, otherwise an object of selectors -> listeners is assumed
		 * @param   {object}        [listeners] Config for listeners.
		 * @returns {void}                      
		 */
		control? (selectors: string | object, listeners?: object): void;
		/** 
		 * Prevent this controller from receiving events from the event bus.
		 * Routes will also not be triggered on inactive controllers unless
		 * the [Ext.app.route.Route.allowInactive](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.route.Route.html#cfg-allowInactive) flag is set.
		 * Also see [activate](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-activate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		deactivate? (): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @param   {object} destroyRefs
		 * @param   {object} fromApp
		 * @returns {void}               
		 */
		destroy? (destroyRefs: object, fromApp: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.app.BaseController.destroy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-destroy).
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [active](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-active).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getActive? (): boolean;
		/** 
		 * Returns the value of [application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-application).
		 * @method
		 * @public (method)
		 * @returns {Ext.app.Application}  
		 */
		getApplication? (): Ext.app.Application;
		/** 
		 * Returns the value of [before](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-before).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getBefore? (): object;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-control).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getControl? (): object;
		/** 
		 * Returns instance of a [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html) with the given id.
		 * When controller doesn't exist yet, it's created. Note that this method depends
		 * on Application instance and will return undefined when Application is not
		 * accessible. The only exception is when this Controller instance's id is requested;
		 * in that case we always return the instance even if Application is no available.
		 * @method
		 * @public (method)
		 * @param   {string}             id
		 * @returns {Ext.app.Controller}    controller instance or undefined.
		 */
		getController? (id: string): Ext.app.Controller;
		/** 
		 * Returns the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-id).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getId? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-listen).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getListen? (): object;
		/** 
		 * Returns a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) class with the given name.
		 * @method
		 * @public (method)
		 * @param   {string}    name
		 * @returns {Ext.Class}      A class ultimately derived from [`Ext.data.Model`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html).
		 */
		getModel? (name: string): Ext.Class;
		/** 
		 * Returns instance of a [Profile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html) with the given name.
		 * @method
		 * @public (method)
		 * @param   {string} name
		 * @returns {string}      a profile instance.
		 */
		getProfile? (name: string): string;
		/** 
		 * Returns the value of [refs](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-refs).
		 * @method
		 * @public (method)
		 * @returns {object|object[]}  
		 */
		getRefs? (): object | object[];
		/** 
		 * Returns the value of [routes](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-routes).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getRoutes? (): object;
		/** 
		 * Returns instance of a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) with the given name.
		 * When store doesn't exist yet, it's created.
		 * @method
		 * @public (method)
		 * @param   {string}         name
		 * @returns {Ext.data.Store}      a store instance.
		 */
		getStore? (name: string): Ext.data.Store;
		/** 
		 * Returns a View class with the given name.  To create an instance of the view,
		 * you can use it like it's used by Application to create the Viewport:
		 * 
		 *    this.getView('Viewport').create();
		 * 
		 * @method
		 * @public (method)
		 * @param   {string}   view
		 * @returns {Ext.Base}      a view class.
		 */
		getView? (view: string): Ext.Base;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Returns `true` if a [reference](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-refs) is registered.
		 * @method
		 * @public (method)
		 * @param   {string}  ref The name of the ref to check for.
		 * @returns {boolean}     
		 */
		hasRef? (ref: string): boolean;
		/** 
		 * A template method that is called when your application boots. It is called before the
		 * [Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)'s launch function is executed so gives a hook point
		 * to run any code before your Viewport is created.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.app.Application} application
		 * @returns {void}                            
		 */
		init? (application: Ext.app.Application): void;
		/** 
		 * Checks if this controller is active. See [activate](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-activate) &amp;
		 * [deactivate](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-deactivate).
		 * @method
		 * @public (method)
		 * @returns {boolean|void}  `true` if this controller is active.
		 */
		isActive? (): boolean;
		isActive? (): void;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Adds listeners to different event sources (also called "event domains"). The
		 * primary event domain is that of components, but there are also other event domains:
		 * [Global](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html) domain that intercepts events fired from
		 * [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance, [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html)
		 * domain can be used to listen to events fired by other Controllers,
		 * [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html) domain gives access to Store events, and
		 * [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html) domain can be used with Ext Direct Providers
		 * to listen to their events.
		 * 
		 * To listen to "bar" events fired by a controller with id="foo":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 controller: {
		 *                     '#foo': {
		 *                        bar: this.onFooBar
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * To listen to "bar" events fired by any controller, and "baz" events
		 * fired by Store with storeId="baz":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 controller: {
		 *                     '*': {
		 *                        bar: this.onAnyControllerBar
		 *                     }
		 *                 },
		 *                 store: {
		 *                     '#baz': {
		 *                         baz: this.onStoreBaz
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * To listen to "idle" events fired by [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) when other event
		 * processing is complete and Ext JS is about to return control to the browser:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 global: {               // Global events are always fired
		 *                     idle: this.onIdle   // from the same object, so there
		 *                 }                       // are no selectors
		 *             });
		 *         }
		 *     });
		 * 
		 * As this relates to components, the following example:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 component: {
		 *                     'useredit button[action=save]': {
		 *                        click: this.updateUser
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * Is equivalent to:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.control({
		 *                 'useredit button[action=save]': {
		 *                    click: this.updateUser
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * Of course, these can all be combined in a single call and used instead of
		 * `control`, like so:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 global: {
		 *                     idle: this.onIdle
		 *                 },
		 *                 controller: {
		 *                     '*': {
		 *                        foobar: this.onAnyFooBar
		 *                     },
		 *                     '#foo': {
		 *                        bar: this.onFooBar
		 *                     }
		 *                 },
		 *                 component: {
		 *                     'useredit button[action=save]': {
		 *                        click: this.updateUser
		 *                     }
		 *                 },
		 *                 store: {
		 *                     '#qux': {
		 *                         load: this.onQuxLoad
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * @method
		 * @public (method)
		 * @param   {object}             to           Config object containing domains, selectors and listeners.
		 * @param   {Ext.app.Controller} [controller] The controller to add the listeners to. Defaults to the current controller.
		 * @returns {void}                            
		 */
		listen? (to: object, controller?: Ext.app.Controller): void;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * A template method like [init](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-init), but called after the viewport is created.
		 * This is called after the [launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#method-launch) method of Application
		 * is executed.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.app.Application} application
		 * @returns {void}                            
		 */
		onLaunch? (application: Ext.app.Application): void;
		/** 
		 * Update the hash. By default, it will not execute the routes if the current token and the
		 * token passed are the same.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} token
		 * The token to redirect to.  Can be either a String
		 * or a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) instance - if a Model instance is passed it will
		 * internally be converted into a String token by calling the Model's
		 * [toUrl](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html#method-toUrl) function.
		 * @param   {boolean}               force Force the update of the hash regardless of the current token.
		 * @returns {boolean}                     Will return `true` if the token was updated.
		 */
		redirectTo? (token: string | Ext.data.Model, force: boolean): boolean;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [active](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-active).
		 * @method
		 * @public (method)
		 * @param   {boolean} active The new value.
		 * @returns {void}           
		 */
		setActive? (active: boolean): void;
		/** 
		 * Sets the value of [application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-application).
		 * @method
		 * @public (method)
		 * @param   {Ext.app.Application} application The new value.
		 * @returns {void}                            
		 */
		setApplication? (application: Ext.app.Application): void;
		/** 
		 * Sets the value of [before](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-before).
		 * @method
		 * @public (method)
		 * @param   {object} before The new value.
		 * @returns {void}          
		 */
		setBefore? (before: object): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                      name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                             [value] The value to set for the name parameter.
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.Controller;
		setConfig? (name: string | object, value?: object): Ext.app.BaseController;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-control).
		 * @method
		 * @public (method)
		 * @param   {object} control The new value.
		 * @returns {void}           
		 */
		setControl? (control: object): void;
		/** 
		 * Sets the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-id).
		 * @method
		 * @public (method)
		 * @param   {string} id The new value.
		 * @returns {void}      
		 */
		setId? (id: string): void;
		/** 
		 * Sets the value of [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-listen).
		 * @method
		 * @public (method)
		 * @param   {object} listen The new value.
		 * @returns {void}          
		 */
		setListen? (listen: object): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [refs](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-refs).
		 * @method
		 * @public (method)
		 * @param   {object|object[]} refs The new value.
		 * @returns {void}                 
		 */
		setRefs? (refs: object | object[]): void;
		/** 
		 * Sets the value of [routes](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-routes).
		 * @method
		 * @public (method)
		 * @param   {object} routes The new value.
		 * @returns {void}          
		 */
		setRoutes? (routes: object): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                             config
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.app.Controller;
		initConfig? (config: object): Ext.app.BaseController;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.Controller.Statics|Ext.app.BaseController.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.app.Controller.Statics;
		statics? (): Ext.app.BaseController.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} control
		 * @returns {void}           
		 */
		applyControl? (control: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} listen
		 * @returns {void}          
		 */
		applyListen? (listen: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} refs
		 * @returns {void}        
		 */
		applyRefs? (refs: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} app
		 * @returns {void}       
		 */
		doInit? (app: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		ensureId? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} app
		 * @returns {void}       
		 */
		finishInit? (app: object): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Returns the value of [moduleClassName](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-moduleClassName).
		 * @method
		 * @private (method)
		 * @returns {object}  
		 */
		getModuleClassName? (): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ref
		 * @param   {object} info
		 * @param   {object} config
		 * @returns {void}          
		 */
		getRef? (ref: object, info: object, config: object): void;
		/** 
		 * Returns a map of reference names to selectors
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRefMap? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initAutoGetters? (): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Takes either an object and transforms it into an array. The following are valid refs values:
		 * 
		 *    refs: {
		 *        myComponent: 'container'
		 *    }
		 *    
		 *    refs: {
		 *        myComponent: {
		 *            selector: 'container'
		 *        }
		 *    }
		 *    
		 *    refs: [
		 *        {
		 *            ref: 'myComponent',
		 *            selector: 'container'
		 *        }
		 *    ]
		 * 
		 * @method
		 * @private (method)
		 * @param   {any[]|object} refs    The refs to normalize
		 * @param   {any[]}        newRefs An array to place the normalized refs on to
		 * @returns {any[]}                The normalized array of refs
		 */
		normalizeRefs? (refs: any[] | object, newRefs: any[]): any[];
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} cls
		 * @param   {object} data
		 * @param   {object} hooks
		 * @returns {void}         
		 */
		onClassExtended? (cls: object, data: object, hooks: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} refs
		 * @returns {void}        
		 */
		ref? (refs: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Sets the value of [moduleClassName](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-moduleClassName).
		 * @method
		 * @private (method)
		 * @param   {object} moduleClassName The new value.
		 * @returns {void}                   
		 */
		setModuleClassName? (moduleClassName: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                           names The names of the linked objects to destroy.
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.app.Controller;
		unlink? (names: string[]): Ext.app.BaseController;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} control The object to pass to the [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-control) method
		 * @returns {void}           
		 */
		updateControl? (control: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} listen The object to pass to the [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-listen) method
		 * @returns {void}          
		 */
		updateListen? (listen: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} refs The refs to pass to the [ref](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-ref) method.
		 * @returns {void}        
		 */
		updateRefs? (refs: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} routes The routes to connect to the [Ext.app.route.Router](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.route.Router.html)
		 * @returns {void}          
		 */
		updateRoutes? (routes: object): void;
	}
	/** 
	 * This class manages event dispatching for Controllers. The details of connecting classes
	 * to this dispatching mechanism is delegated to [Ext.app.EventDomain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html) instances.
	 * @private (class)
	 * @singleton (definition)
	 */
	interface EventBus extends Ext.Base {}
	/** 
	 * [Ext.app.EventDomain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html)
	 * This class is a base class for an event domain. In the context of MVC, an "event domain"
	 * is one or more base classes that fire events to which a Controller wants to listen. A
	 * controller listens to events by describing the selectors for events of interest to it.
	 * 
	 * Matching selectors to the firer of an event is one key aspect that defines an event
	 * domain. All event domain instances must provide a `match` method that tests selectors
	 * against the event firer.
	 * 
	 * When an event domain instance is created (typically as a `singleton`), its `type`
	 * property is used to catalog the domain in the
	 * [Ext.app.EventDomain.instances](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html#static-property-instances) map.
	 * 
	 * There are five event domains provided by default:
	 * 
	 * - [Component domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Component.html). This is the primary event domain that
	 *   has been available since Ext JS MVC was introduced. This domain is defined as any class that
	 *   extends [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html), where the selectors use
	 *   [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html#method-query).
	 * - [Global domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html). This domain provides Controllers with access
	 *   to events fired from [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance. These events represent
	 *   the state of the application as a whole, and are always anonymous. Because of this, Global
	 *   domain does not provide selectors at all.
	 * - [Controller domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html). This domain includes all classes
	 *   that extend [Ext.app.Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html). Events fired by Controllers will be available
	 *   within this domain; selectors are either Controller's [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-id) or
	 *   '*' wildcard for any Controller.
	 * - [Store domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html). This domain is for classes extending
	 *   [Ext.data.AbstractStore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.AbstractStore.html). Selectors are either Store's
	 *   [storeId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.AbstractStore.html#cfg-storeId) or '*' wildcard for any Store.
	 * - [Direct domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html). This domain includes all classes that extend
	 *   [Ext.direct.Provider](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Provider.html). Selectors are either Provider's [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Provider.html#cfg-id)
	 *   or '*' wildcard for any Provider. This domain is optional and will be loaded only if
	 *   [Ext.direct.Manager](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Manager.html) singleton is required in your application.
	 */
	class EventDomain extends Ext.Base {
		/** 
		 * An object map containing [`Ext.app.EventDomain`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html) instances keyed by the value
		 * of their `type` property.
		 * @property
		 * @public (property)
		 * @static
		 * @default {}
		 * @type {object}
		 */
		static instances?: object;
		/** 
		 * This value is `true` and is used to identify plain objects from instances of
		 * a defined class.
		 * @property
		 * @protected (property)
		 * @readonly
		 * @default false
		 * @type {boolean}
		 */
		readonly isInstance?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.app.EventDomain.Statics}
		 */
		self?: Ext.app.EventDomain.Statics | Ext.Base.Statics;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                       members    The members to add to this class.
		 * @param   {boolean}                      [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                      [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.EventDomain|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.EventDomain;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                       members
		 * @returns {Ext.app.EventDomain|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.app.EventDomain;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                       members
		 * @returns {Ext.app.EventDomain|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.app.EventDomain;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                       name
		 * @param   {object}                       member
		 * @returns {Ext.app.EventDomain|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.app.EventDomain;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                       fn
		 * @param   {object}                       scope
		 * @returns {Ext.app.EventDomain|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.app.EventDomain;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * @method
		 * @public (method)
		 */
		constructor ();
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.app.EventDomain|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.EventDomain;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.app.EventDomain|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.app.EventDomain;
		initConfig? (config: object): Ext.Base;
		/** 
		 * This method matches the firer of the event (the `target`) to the given `selector`.
		 * Default matching is very simple: a match is true when selector equals target's
		 * [idProperty](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html#cfg-idProperty), or when selector is '*' wildcard to match any
		 * target.
		 * @method
		 * @protected (method)
		 * @param   {object}  target   The firer of the event.
		 * @param   {string}  selector The selector to which to match the `target`.
		 * @returns {boolean}          `true` if the `target` matches the `selector`.
		 */
		match? (target: object, selector: string): boolean;
		/** 
		 * This method is called by the derived class to monitor `fireEvent` calls. Any call
		 * to `fireEvent` on the target Observable will be intercepted and dispatched to any
		 * listening Controllers. Assuming the original `fireEvent` method does not return
		 * `false`, the event is passed to the `dispatch` method of this object.
		 * 
		 * This is typically called in the `constructor` of derived classes.
		 * @method
		 * @protected (method)
		 * @param   {Ext.Class} observable The Observable to monitor for events.
		 * @returns {void}                 
		 */
		monitor? (observable: Ext.Class): void;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.EventDomain.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.app.EventDomain.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * This method dispatches an event fired by an object monitored by this domain. This
		 * is not called directly but is called by interceptors injected by the `monitor` method.
		 * @method
		 * @private (method)
		 * @param   {object}  target The firer of the event.
		 * @param   {string}  ev     The event being fired.
		 * @param   {any[]}   args
		 * The arguments for the event. This array **does not** include the event name.
		 * That has already been sliced off because this class intercepts the [fireEventArgs](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEventArgs)
		 * method which takes an array as the event's argument list.
		 * @returns {boolean}        `false` if any listener returned `false`, otherwise `true`.
		 */
		dispatch? (target: object, ev: string, args: any[]): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * This method adds listeners on behalf of a controller. This method is passed an
		 * object that is keyed by selectors. The value of these is also an object but now
		 * keyed by event name. For example:
		 * 
		 *     domain.listen({
		 *         'some[selector]': {
		 *             click: function() { ... }
		 *         },
		 *    
		 *         'other selector': {
		 *             change: {
		 *                 fn: function() { ... },
		 *                 delay: 10
		 *             }
		 *         }
		 *    
		 *     }, controller);
		 * 
		 * @method
		 * @private (method)
		 * @param   {object} selectors Config object containing selectors and listeners.
		 * @returns {void}             
		 */
		listen? (selectors: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                     names The names of the linked objects to destroy.
		 * @returns {Ext.app.EventDomain|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.app.EventDomain;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * Removes all of a controller's attached listeners.
		 * @method
		 * @private (method)
		 * @param   {string} controllerId The id of the controller.
		 * @returns {void}                
		 */
		unlisten? (controllerId: string): void;
	}
	/** 
	 * [Ext.app.Profile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html)
	 * A Profile represents a range of devices that fall under a common category. For the vast majority of apps that use
	 * device profiles, the app defines a Phone profile and a Tablet profile. Doing this enables you to easily customize
	 * the experience for the different sized screens offered by those device types.
	 * 
	 * Only one Profile can be active at a time, and each Profile defines a simple [isActive](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#method-isActive) function that should
	 * return either true or false. The first Profile to return true from its isActive function is set as your Application's
	 * [current profile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-currentProfile).
	 * 
	 * A Profile can define any number of [models](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-models), [views](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-views), [controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-controllers) and [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-stores) which
	 * will be loaded if the Profile is activated. It can also define a [launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#method-launch) function that will be called after
	 * all of its dependencies have been loaded, just before the [application launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#method-launch)
	 * function is called.
	 * 
	 * ## Sample Usage
	 * 
	 * First you need to tell your Application about your Profile(s):
	 * 
	 *    Ext.application({
	 *        name: 'MyApp',
	 *        profiles: ['Phone', 'Tablet']
	 *    });
	 * 
	 * This will load app/profile/Phone.js and app/profile/Tablet.js. Here's how we might define the Phone profile:
	 * 
	 *    Ext.define('MyApp.profile.Phone', {
	 *        extend: 'Ext.app.Profile',
	 *    
	 *        views: ['Main'],
	 *    
	 *        isActive: function() {
	 *            return Ext.os.is('Phone');
	 *        }
	 *    });
	 * 
	 * The isActive function returns true if we detect that we are running on a phone device. If that is the case the
	 * Application will set this Profile active and load the 'Main' view specified in the Profile's [views](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-views) config.
	 * 
	 * ## Class Specializations
	 * 
	 * Because Profiles are specializations of an application, all of the models, views, controllers and stores defined
	 * in a Profile are expected to be namespaced under the name of the Profile. Here's an expanded form of the example
	 * above:
	 * 
	 *    Ext.define('MyApp.profile.Phone', {
	 *        extend: 'Ext.app.Profile',
	 *    
	 *        views: ['Main'],
	 *        controllers: ['Signup'],
	 *        models: ['MyApp.model.Group'],
	 *    
	 *        isActive: function() {
	 *            return Ext.os.is('Phone');
	 *        }
	 *    });
	 * 
	 * In this case, the Profile is going to load _app/view/phone/Main.js_, _app/controller/phone/Signup.js_ and
	 * _app/model/Group.js_. Notice that in each of the first two cases the name of the profile ('phone' in this case) was
	 * injected into the class names. In the third case we specified the full Model name (for Group) so the Profile name
	 * was not injected.
	 * 
	 * For a fuller understanding of the ideas behind Profiles and how best to use them in your app, we suggest you read
	 * the [device profiles guide](/touch/2.4/core_concepts/device_profiles.html).
	 */
	class Profile extends Ext.Base {
		/** 
		 * This object holds a key for any event that has a listener. The listener may be set
		 * directly on the instance, or on its class or a super class (via [observe](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#static-method-observe)) or
		 * on the [MVC EventBus](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventBus.html). The values of this object are truthy
		 * (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
		 * of listeners. The value for an event is truthy if the event must be fired and is
		 * falsy if there is no need to fire the event.
		 * 
		 * The intended use of this property is to avoid the expense of fireEvent calls when
		 * there are no listeners. This can be particularly helpful when one would otherwise
		 * have to call fireEvent hundreds or thousands of times. It is used like this:
		 * 
		 *     if (this.hasListeners.foo) {
		 *         this.fireEvent('foo', this, arg1);
		 *     }
		 * 
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		readonly hasListeners?: object;
		/** 
		 * `true` in this class to identify an object as an instantiated Observable, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isObservable?: boolean;
		/** 
		 * `true` to identify an object as an instance of [`Ext.app.Profile`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html)
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isProfile?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.app.Profile.Statics}
		 */
		self?: Ext.app.Profile.Statics | Ext.Base.Statics;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                   members    The members to add to this class.
		 * @param   {boolean}                  [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                  [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.Profile|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.Profile;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                   members
		 * @returns {Ext.app.Profile|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.app.Profile;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                   members
		 * @returns {Ext.app.Profile|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.app.Profile;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                   name
		 * @param   {object}                   member
		 * @returns {Ext.app.Profile|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.app.Profile;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                   fn
		 * @param   {object}                   scope
		 * @returns {Ext.app.Profile|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.app.Profile;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates a new Profile instance
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                           eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                         [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                                  [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.app.Profile.methodParams.addListener.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                                  [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                                  
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addListener? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.app.Profile.methodParams.addListener.Options, order?: string): object;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-application).
		 * @method
		 * @public (method)
		 * @returns {Ext.app.Application}  
		 */
		getApplication? (): Ext.app.Application;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-controllers).
		 * @method
		 * @public (method)
		 * @returns {string[]}  
		 */
		getControllers? (): string[];
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [mainView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-mainView).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getMainView? (): string;
		/** 
		 * Returns the value of [models](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-models).
		 * @method
		 * @public (method)
		 * @returns {string[]}  
		 */
		getModels? (): string[];
		/** 
		 * Returns the value of [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-stores).
		 * @method
		 * @public (method)
		 * @returns {string[]}  
		 */
		getStores? (): string[];
		/** 
		 * Returns the value of [views](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-views).
		 * @method
		 * @public (method)
		 * @returns {object|string[]}  
		 */
		getViews? (): object | string[];
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Determines whether or not this Profile is active on the device isActive is executed on. Should return true if
		 * this profile is meant to be active on this device, false otherwise. Each Profile should implement this function
		 * (the default implementation just returns false).
		 * @method
		 * @public (method)
		 * @returns {boolean}  True if this Profile should be activated on the device it is running on, false otherwise
		 */
		isActive? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * The launch function is called by the [Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) if this Profile's [isActive](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#method-isActive)
		 * function returned true. This is typically the best place to run any profile-specific app launch code. Example
		 * usage:
		 * 
		 *    launch: function() {
		 *        Ext.create('MyApp.view.tablet.Main');
		 *    }
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		launch? (): void;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                  eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                         [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.app.Profile.methodParams.on.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                         [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                         
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		on? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.app.Profile.methodParams.on.Options, order?: string): object;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-application).
		 * @method
		 * @public (method)
		 * @param   {Ext.app.Application} application The new value.
		 * @returns {void}                            
		 */
		setApplication? (application: Ext.app.Application): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}            name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                   [value] The value to set for the name parameter.
		 * @returns {Ext.app.Profile|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.Profile;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-controllers).
		 * @method
		 * @public (method)
		 * @param   {string[]} controllers The new value.
		 * @returns {void}                 
		 */
		setControllers? (controllers: string[]): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [mainView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-mainView).
		 * @method
		 * @public (method)
		 * @param   {string} mainView The new value.
		 * @returns {void}            
		 */
		setMainView? (mainView: string): void;
		/** 
		 * Sets the value of [models](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-models).
		 * @method
		 * @public (method)
		 * @param   {string[]} models The new value.
		 * @returns {void}            
		 */
		setModels? (models: string[]): void;
		/** 
		 * Sets the value of [name](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-name).
		 * @method
		 * @public (method)
		 * @param   {string} name The new value.
		 * @returns {void}        
		 */
		setName? (name: string): void;
		/** 
		 * Sets the value of [namespace](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-namespace).
		 * @method
		 * @public (method)
		 * @param   {string} namespace The new value.
		 * @returns {void}             
		 */
		setNamespace? (namespace: string): void;
		/** 
		 * Sets the value of [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-stores).
		 * @method
		 * @public (method)
		 * @param   {string[]} stores The new value.
		 * @returns {void}            
		 */
		setStores? (stores: string[]): void;
		/** 
		 * Sets the value of [views](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-views).
		 * @method
		 * @public (method)
		 * @param   {object|string[]} views The new value.
		 * @returns {void}                  
		 */
		setViews? (views: object | string[]): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called once the profile is determined to be the active profile. This
		 * initialization is performed before controllers are initialized and therefore also
		 * before launch.
		 * @method
		 * @protected (method)
		 * @returns {void}  
		 */
		init? (): void;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                   config
		 * @returns {Ext.app.Profile|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.app.Profile;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.Profile.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.app.Profile.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                 names The names of the linked objects to destroy.
		 * @returns {Ext.app.Profile|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.app.Profile;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * @private (class)
	 */
	class Util extends Ext.Base {}
	/** 
	 * [Ext.app.ViewController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html)
	 * A view controller is a controller that can be attached to a specific view
	 * instance so it can manage the view and its child components. Each instance of the view
	 * will have a new view controller, so the instances are isolated.
	 * 
	 * When a controller is specified on a view, the view automatically becomes a [Ext.container.Container.referenceHolder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-referenceHolder),
	 * so it will receive inline events declared on the view. Sample usage:
	 * 
	 *    Ext.define('User', {
	 *       extend: 'Ext.data.Model',
	 *       fields: ['name', 'phone']    
	 *    });
	 *    
	 *    Ext.define('UserListController', {
	 *        extend : 'Ext.app.ViewController',
	 *        alias: 'controller.userlist',
	 *    
	 *        init: function(view) {
	 *            this.userCount = 0;
	 *            var users = [],
	 *                i;
	 *    
	 *            for (i = 0; i &lt; 5; ++i) {
	 *                users.push(this.getUser());
	 *            }  
	 *            view.getStore().add(users);
	 *        },
	 *    
	 *        onAddClick: function() {
	 *            this.addUser();
	 *        },
	 *    
	 *        onDeleteClick: function() {
	 *            var view = this.getView(),
	 *                selected = view.getSelectionModel().getSelection()[0],
	 *                store = view.getStore();
	 *    
	 *            store.remove(selected);
	 *        },
	 *    
	 *        onSelectionChange: function(selModel, selections) {
	 *            this.lookupReference('delete').setDisabled(selections.length === 0);
	 *        },
	 *    
	 *        getUser: function() {
	 *            ++this.userCount;
	 *            return {
	 *                name: 'User ' + this.userCount,
	 *                phone: this.generatePhone()
	 *            };
	 *        },
	 *    
	 *        addUser: function() {
	 *            this.getView().getStore().add(this.getUser());    
	 *        },
	 *    
	 *        generatePhone: function() {
	 *            var num = '',
	 *                i;
	 *    
	 *            for (i = 0; i &lt; 7; ++i) {
	 *                num += Ext.Number.randomInt(0, 9);
	 *                if (num.length === 3) {
	 *                    num += '-';
	 *                }
	 *            }    
	 *            return num;
	 *        }
	 *    });
	 *    
	 *    Ext.define('UserList', {
	 *        extend: 'Ext.grid.Panel',
	 *        controller: 'userlist',
	 *    
	 *        tbar: [{
	 *            text: 'Add',
	 *            listeners: {
	 *                click: 'onAddClick'
	 *            }    
	 *        }, {
	 *            text: 'Delete',
	 *            reference: 'delete',
	 *            listeners: {
	 *                click: 'onDeleteClick'
	 *            }
	 *        }],
	 *        store: {
	 *            model: 'User'
	 *        },
	 *        selModel: {
	 *            type: 'rowmodel',
	 *            listeners: {
	 *                selectionchange: 'onSelectionChange'
	 *            }    
	 *        },
	 *        columns: [{
	 *            flex: 1,
	 *            dataIndex: 'name',
	 *            text: 'Name'
	 *        }, {
	 *            flex: 1,
	 *            dataIndex: 'phone',
	 *            text: 'Phone'
	 *        }]
	 *    });
	 *    
	 *    Ext.onReady(function() {
	 *        new UserList({
	 *            renderTo: Ext.getBody(),
	 *            width: 400,
	 *            height: 200
	 *        });
	 *    });
	 * 
	 */
	class ViewController extends Ext.app.BaseController {
		/** 
		 * If this property is specified by the target class of this mixin its properties are
		 * used to configure the created [`Ext.Factory`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Factory.html).
		 * @property
		 * @public (property)
		 * @default {type: 'controller'}
		 * @type {object}
		 */
		factoryConfig?: object;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.app.ViewController.Statics}
		 */
		self?: Ext.app.ViewController.Statics | Ext.app.BaseController.Statics | Ext.Base.Statics;
		/** 
		 * ---
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                 members    The members to add to this class.
		 * @param   {boolean}                                                [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.ViewController;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.BaseController;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                 members
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.app.ViewController;
		static addStatics? (members: object): typeof Ext.app.BaseController;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                 members
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.app.ViewController;
		static addInheritableStatics? (members: object): typeof Ext.app.BaseController;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                 name
		 * @param   {object}                                                 member
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.app.ViewController;
		static addMember? (name: object, member: object): typeof Ext.app.BaseController;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                 fn
		 * @param   {object}                                                 scope
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.app.ViewController;
		static onExtended? (fn: object, scope: object): typeof Ext.app.BaseController;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * This method closes the associated view. The manner in which this is done (that is,
		 * the method called to close the view) is specified by `closeViewAction`.
		 * 
		 * It is common for views to map one or more events to this method to allow the view
		 * to be closed.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		closeView? (): void;
		/** 
		 * Destroy the view controller.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [before](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-before).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getBefore? (): object;
		/** 
		 * Returns the value of [closeViewAction](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html#cfg-closeViewAction).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getCloseViewAction? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-control).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getControl? (): object;
		/** 
		 * Returns the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-id).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getId? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-listen).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getListen? (): object;
		/** 
		 * Returns an object holding the descendants of this view keyed by their
		 * [`reference`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#cfg-reference). This object should not be held
		 * past the scope of the function calling this method. It will not be valid if items
		 * are added or removed from this or any sub-container.
		 * 
		 * The intended usage is shown here (assume there are 3 components with reference
		 * values of "foo", "bar" and "baz" at some level below this container):
		 * 
		 *     onClick: function () {
		 *         var refs = this.getReferences();
		 *    
		 *         // using "refs" we can access any descendant by its "reference"
		 *    
		 *         refs.foo.getValue() + refs.bar.getValue() + refs.baz.getValue();
		 *     }
		 * 
		 * If `this` component has a [`reference`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#cfg-reference) assigned
		 * to it, that is **not** included in this object. That reference is understood to
		 * belong to the ancestor container configured as the `referenceHolder`.
		 * @method
		 * @public (method)
		 * @returns {object} 
		 * An object with each child reference. This will be `null` if this
		 * container has no descendants with a [`reference`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#cfg-reference)
		 * specified.
		 */
		getReferences? (): object;
		/** 
		 * Returns the value of [routes](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-routes).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getRoutes? (): object;
		/** 
		 * Get a [Ext.data.Session](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Session.html) attached to the view for this controller.
		 * See [Ext.Component.lookupSession](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-lookupSession).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Session}  The session. `null` if no session is found.
		 */
		getSession? (): Ext.data.Session;
		/** 
		 * Get a [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) attached to the [ViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html#method-getViewModel) attached to
		 * this controller. See [Ext.app.ViewModel.getStore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#method-getStore).
		 * @method
		 * @public (method)
		 * @param   {string}         name The name of the store.
		 * @returns {Ext.data.Store} 
		 * The store. `null` if no store is found, or there is no
		 * [Ext.app.ViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html) attached to the view for this controller.
		 */
		getStore? (name: string): Ext.data.Store;
		/** 
		 * Get the view for this controller.
		 * @method
		 * @public (method)
		 * @returns {Ext.Component}  The view.
		 */
		getView? (): Ext.Component;
		/** 
		 * Get a [Ext.app.ViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html) attached to the view for this controller.
		 * See [Ext.Component.lookupViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-lookupViewModel).
		 * @method
		 * @public (method)
		 * @returns {Ext.app.ViewModel}  The ViewModel. `null` if no ViewModel is found.
		 */
		getViewModel? (): Ext.app.ViewModel;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Adds listeners to different event sources (also called "event domains"). The
		 * primary event domain is that of components, but there are also other event domains:
		 * [Global](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html) domain that intercepts events fired from
		 * [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance, [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html)
		 * domain can be used to listen to events fired by other Controllers,
		 * [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html) domain gives access to Store events, and
		 * [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html) domain can be used with Ext Direct Providers
		 * to listen to their events.
		 * 
		 * To listen to "bar" events fired by a controller with id="foo":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 controller: {
		 *                     '#foo': {
		 *                        bar: this.onFooBar
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * To listen to "bar" events fired by any controller, and "baz" events
		 * fired by Store with storeId="baz":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 controller: {
		 *                     '*': {
		 *                        bar: this.onAnyControllerBar
		 *                     }
		 *                 },
		 *                 store: {
		 *                     '#baz': {
		 *                         baz: this.onStoreBaz
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * To listen to "idle" events fired by [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) when other event
		 * processing is complete and Ext JS is about to return control to the browser:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 global: {               // Global events are always fired
		 *                     idle: this.onIdle   // from the same object, so there
		 *                 }                       // are no selectors
		 *             });
		 *         }
		 *     });
		 * 
		 * As this relates to components, the following example:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 component: {
		 *                     'useredit button[action=save]': {
		 *                        click: this.updateUser
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * Is equivalent to:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.control({
		 *                 'useredit button[action=save]': {
		 *                    click: this.updateUser
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * Of course, these can all be combined in a single call and used instead of
		 * `control`, like so:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 global: {
		 *                     idle: this.onIdle
		 *                 },
		 *                 controller: {
		 *                     '*': {
		 *                        foobar: this.onAnyFooBar
		 *                     },
		 *                     '#foo': {
		 *                        bar: this.onFooBar
		 *                     }
		 *                 },
		 *                 component: {
		 *                     'useredit button[action=save]': {
		 *                        click: this.updateUser
		 *                     }
		 *                 },
		 *                 store: {
		 *                     '#qux': {
		 *                         load: this.onQuxLoad
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} to
		 * @param   {object} controller
		 * @returns {void}              
		 */
		listen? (to: object, controller: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.app.BaseController.listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-listen).
		 * Adds listeners to different event sources (also called "event domains"). The
		 * primary event domain is that of components, but there are also other event domains:
		 * [Global](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html) domain that intercepts events fired from
		 * [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance, [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html)
		 * domain can be used to listen to events fired by other Controllers,
		 * [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html) domain gives access to Store events, and
		 * [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html) domain can be used with Ext Direct Providers
		 * to listen to their events.
		 * 
		 * To listen to "bar" events fired by a controller with id="foo":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 controller: {
		 *                     '#foo': {
		 *                        bar: this.onFooBar
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * To listen to "bar" events fired by any controller, and "baz" events
		 * fired by Store with storeId="baz":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 controller: {
		 *                     '*': {
		 *                        bar: this.onAnyControllerBar
		 *                     }
		 *                 },
		 *                 store: {
		 *                     '#baz': {
		 *                         baz: this.onStoreBaz
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * To listen to "idle" events fired by [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) when other event
		 * processing is complete and Ext JS is about to return control to the browser:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 global: {               // Global events are always fired
		 *                     idle: this.onIdle   // from the same object, so there
		 *                 }                       // are no selectors
		 *             });
		 *         }
		 *     });
		 * 
		 * As this relates to components, the following example:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 component: {
		 *                     'useredit button[action=save]': {
		 *                        click: this.updateUser
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * Is equivalent to:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.control({
		 *                 'useredit button[action=save]': {
		 *                    click: this.updateUser
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * Of course, these can all be combined in a single call and used instead of
		 * `control`, like so:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         init: function() {
		 *             this.listen({
		 *                 global: {
		 *                     idle: this.onIdle
		 *                 },
		 *                 controller: {
		 *                     '*': {
		 *                        foobar: this.onAnyFooBar
		 *                     },
		 *                     '#foo': {
		 *                        bar: this.onFooBar
		 *                     }
		 *                 },
		 *                 component: {
		 *                     'useredit button[action=save]': {
		 *                        click: this.updateUser
		 *                     }
		 *                 },
		 *                 store: {
		 *                     '#qux': {
		 *                         load: this.onQuxLoad
		 *                     }
		 *                 }
		 *             });
		 *         },
		 *         ...
		 *     });
		 * 
		 * @method
		 * @public (method)
		 * @param   {object}             to           Config object containing domains, selectors and listeners.
		 * @param   {Ext.app.Controller} [controller] The controller to add the listeners to. Defaults to the current controller.
		 * @returns {void}                            
		 */
		listen? (to: object, controller?: Ext.app.Controller): void;
		/** 
		 * Gets a reference to the component with the specified Ext.Componentreference
		 * value.
		 * 
		 * The method is a short-hand for the [lookupReference](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html#method-lookupReference) method.
		 * @method
		 * @public (method)
		 * @param   {string}        key The name of the reference to lookup.
		 * @returns {Ext.Component}     The component, `null` if the reference doesn't exist.
		 */
		lookup? (key: string): Ext.Component;
		/** 
		 * Gets a reference to the component with the specified Ext.Componentreference
		 * value.
		 * 
		 * The [lookup](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html#method-lookup) method is a short-hand version of this method.
		 * @method
		 * @public (method)
		 * @param   {string}        key The name of the reference to lookup.
		 * @returns {Ext.Component}     The component, `null` if the reference doesn't exist.
		 */
		lookupReference? (key: string): Ext.Component;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Update the hash. By default, it will not execute the routes if the current token and the
		 * token passed are the same.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} token
		 * The token to redirect to.  Can be either a String
		 * or a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) instance - if a Model instance is passed it will
		 * internally be converted into a String token by calling the Model's
		 * [toUrl](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html#method-toUrl) function.
		 * @param   {boolean}               force Force the update of the hash regardless of the current token.
		 * @returns {boolean}                     Will return `true` if the token was updated.
		 */
		redirectTo? (token: string | Ext.data.Model, force: boolean): boolean;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [before](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-before).
		 * @method
		 * @public (method)
		 * @param   {object} before The new value.
		 * @returns {void}          
		 */
		setBefore? (before: object): void;
		/** 
		 * Sets the value of [closeViewAction](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html#cfg-closeViewAction).
		 * @method
		 * @public (method)
		 * @param   {string} closeViewAction The new value.
		 * @returns {void}                   
		 */
		setCloseViewAction? (closeViewAction: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                          name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                 [value] The value to set for the name parameter.
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.ViewController;
		setConfig? (name: string | object, value?: object): Ext.app.BaseController;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-control).
		 * @method
		 * @public (method)
		 * @param   {object} control The new value.
		 * @returns {void}           
		 */
		setControl? (control: object): void;
		/** 
		 * Sets the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-id).
		 * @method
		 * @public (method)
		 * @param   {string} id The new value.
		 * @returns {void}      
		 */
		setId? (id: string): void;
		/** 
		 * Sets the value of [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-listen).
		 * @method
		 * @public (method)
		 * @param   {object} listen The new value.
		 * @returns {void}          
		 */
		setListen? (listen: object): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [routes](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#cfg-routes).
		 * @method
		 * @public (method)
		 * @param   {object} routes The new value.
		 * @returns {void}          
		 */
		setRoutes? (routes: object): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		isActive? (): void;
		/** 
		 * Called before the view initializes. This is called before the view's
		 * initComponent method has been called.
		 * @method
		 * @protected (method)
		 * @param   {Ext.Component} view The view
		 * @returns {void}               
		 */
		beforeInit? (view: Ext.Component): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Fires an event on the view. See [Ext.Component.fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-fireEvent).
		 * @method
		 * @protected (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireViewEvent? (eventName: string): boolean;
		/** 
		 * Fires an event on the view. See [Ext.Component.fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-fireEvent).
		 * @method
		 * @protected (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireViewEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Called when the view initializes. This is called after the view's initComponent
		 * method has been called.
		 * @method
		 * @protected (method)
		 * @param   {Ext.Component} view The view
		 * @returns {void}               
		 */
		init? (view: Ext.Component): void;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                 config
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.app.ViewController;
		initConfig? (config: object): Ext.app.BaseController;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Called when the view model instance for an attached view is first created.
		 * @method
		 * @protected (method)
		 * @param   {Ext.app.ViewModel} viewModel The ViewModel
		 * @returns {void}                        
		 */
		initViewModel? (viewModel: Ext.app.ViewModel): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.ViewController.Statics|Ext.app.BaseController.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.app.ViewController.Statics;
		statics? (): Ext.app.BaseController.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} control
		 * @returns {void}           
		 */
		applyControl? (control: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} listen
		 * @returns {void}          
		 */
		applyListen? (listen: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                               names The names of the linked objects to destroy.
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.app.ViewController;
		unlink? (names: string[]): Ext.app.BaseController;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} control The object to pass to the [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-control) method
		 * @returns {void}           
		 */
		updateControl? (control: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} listen The object to pass to the [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-listen) method
		 * @returns {void}          
		 */
		updateListen? (listen: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} routes The routes to connect to the [Ext.app.route.Router](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.route.Router.html)
		 * @returns {void}          
		 */
		updateRoutes? (routes: object): void;
	}
	/** 
	 * [Ext.app.ViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html)
	 * This class manages arbitrary data and its relationship to data models. Instances of
	 * `ViewModel` are associated with some `Component` and then used by their child items
	 * for the purposes of Data Binding.
	 * 
	 * # Binding
	 * 
	 * The most commonly used aspect of a `ViewModel` is the `bind` method. This method takes
	 * a "bind descriptor" (see below) and a callback to call when the data indicated by the
	 * bind descriptor either becomes available or changes.
	 * 
	 * The `bind` method, based on the bind descriptor given, will return different types of
	 * "binding" objects. These objects maintain the connection between the requested data and
	 * the callback. Bindings ultimately derive from [`Ext.app.bind.BaseBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.BaseBinding.html)
	 * which provides several methods to help manage the binding.
	 * 
	 * Perhaps the most important method is `destroy`. When the binding is no longer needed
	 * it is important to remember to `destroy` it. Leaking bindings can cause performance
	 * problems or worse when callbacks are called at unexpected times.
	 * 
	 * The types of bindings produced by `bind` are:
	 * 
	 * - [`Ext.app.bind.Binding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Binding.html)
	 * - [`Ext.app.bind.Multi`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Multi.html)
	 * - [`Ext.app.bind.TemplateBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.TemplateBinding.html)
	 * 
	 * ## Bind Descriptors
	 * 
	 * A "bind descriptor" is a value (a String, an Object or an array of these) that describe
	 * the desired data. Any piece of data in the `ViewModel` can be described by a bind
	 * descriptor.
	 * 
	 * ### Textual Bind Descriptors
	 * 
	 * The simplest and most common form of bind descriptors are strings that look like an
	 * [`Ext.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Template.html) containing text and tokens surrounded by "{}" with dot notation inside
	 * to traverse objects and their properties.
	 * 
	 * For example:
	 * 
	 * - `'Hello {user.name}!'`
	 * - `'You have selected "{selectedItem.text}".'`
	 * - `'{user.groups}'`
	 * 
	 * The first two bindings are [`template bindings`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.TemplateBinding.html)
	 * which use the familiar [`Ext.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Template.html) syntax with some slight differences. For more on
	 * templates see [`Ext.app.bind.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Template.html).
	 * 
	 * The third bind descriptor is called a "direct bind descriptor". This special form of
	 * bind maps one-to-one to some piece of data in the `ViewModel` and is managed by the
	 * [`Ext.app.bind.Binding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Binding.html) class.
	 * 
	 * #### Two-Way Descriptors
	 * 
	 * A direct bind descriptor may be able to write back a value to the `ViewModel` as well
	 * as retrieve one. When this is the case, they are said to be "two-way". For example:
	 * 
	 *     var binding = viewModel.bind('{s}', function(x) { console.log('s=' + s); });
	 *    
	 *     binding.setValue('abc');
	 * 
	 * Direct use of `ViewModel` in this way is not commonly needed because [`Ext.Component`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)
	 * automates this process. For example, a `textfield` component understands when it is
	 * given a "two-way" binding and automatically synchronizes its value bidirectionally using
	 * the above technique. For example:
	 * 
	 *     Ext.widget({
	 *         items: [{
	 *             xtype: 'textfield',
	 *             bind: '{s}'  // a two-way / direct bind descriptor
	 *         }]
	 *     });
	 * 
	 * ### Object and Array Descriptors / Multi-Bind
	 * 
	 * With two exceptions (see below) an Object is interpreted as a "shape" to produce by
	 * treating each of its properties as individual bind descriptors. An object of the same
	 * shape is passed as the value of the bind except that each property is populated with
	 * the appropriate value. Of course, this definition is recursive, so these properties
	 * may also be objects.
	 * 
	 * For example:
	 * 
	 *     viewModel.bind({
	 *             x: '{x}',
	 *             foo: {
	 *                 bar: 'Hello {foo.bar}'
	 *             }
	 *         },
	 *         function (obj) {
	 *             //  obj = {
	 *             //      x: 42,
	 *             //      foo: {
	 *             //          bar: 'Hello foobar'
	 *             //      }
	 *             //  }
	 *         });
	 * 
	 * Arrays are handled in the same way. Each element of the array is considered a bind
	 * descriptor (recursively) and the value produced for the binding is an array with each
	 * element set to the bound property.
	 * 
	 * ### Bind Options
	 * 
	 * One exception to the "object is a multi-bind" rule is when that object contains a
	 * `bindTo` property. When an object contains a `bindTo` property the object is understood
	 * to contain bind options and the value of `bindTo` is considered the actual bind
	 * descriptor.
	 * 
	 * For example:
	 * 
	 *     viewModel.bind({
	 *             bindTo: '{x}',
	 *             single: true
	 *         },
	 *         function (x) {
	 *             console.log('x: ' + x); // only called once
	 *         });
	 * 
	 * The available bind options depend on the type of binding, but since all bindings
	 * derive from [`Ext.app.bind.BaseBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.BaseBinding.html) its options are always applicable.
	 * For a list of the other types of bindings, see above.
	 * 
	 * #### Deep Binding
	 * 
	 * When a direct bind is made and the bound property is an object, by default the binding
	 * callback is only called when that reference changes. This is the most efficient way to
	 * understand a bind of this type, but sometimes you may need to be notified if any of the
	 * properties of that object change.
	 * 
	 * To do this, we create a "deep bind":
	 * 
	 *     viewModel.bind({
	 *             bindTo: '{someObject}',
	 *             deep: true
	 *         },
	 *         function (someObject) {
	 *             // called when reference changes or *any* property changes
	 *         });
	 * 
	 * #### Binding Timings
	 * 
	 * The `ViewModel` has a [scheduler](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-scheduler) attached that is used to coordinate the firing of bindings.
	 * It serves 2 main purposes:
	 * 
	 * - To coordinate dependencies between bindings. This means bindings will be fired in an order such that
	 *   the any dependencies for a binding are fired before the binding itself.
	 * - To batch binding firings. The scheduler runs on a short timer, so the following code will only trigger
	 *   a single binding (the last), the changes in between will never be triggered.
	 * 
	 *      viewModel.bind('{val}', function(v) {
	 *          console.log(v);
	 *      });
	 *      viewModel.set('val', 1);
	 *      viewModel.set('val', 2);
	 *      viewModel.set('val', 3);
	 *      viewModel.set('val', 4);
	 * 
	 * The `ViewModel` can be forced to process by calling [`notify`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#method-notify), which will force the
	 * scheduler to run immediately in the current state.
	 * 
	 *    viewModel.bind('{val}', function(v) {
	 *        console.log(v);
	 *    });
	 *    viewModel.set('val', 1);
	 *    viewModel.notify();
	 *    viewModel.set('val', 2);
	 *    viewModel.notify();
	 *    viewModel.set('val', 3);
	 *    viewModel.notify();
	 *    viewModel.set('val', 4);
	 *    viewModel.notify();
	 * 
	 * #### Models, Stores and Associations
	 * 
	 * A [Session](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Session.html) manages model instances and their associations.
	 * The `ViewModel` may be used with or without a `Session`. When a `Session` is attached, the
	 * `ViewModel` will always consult the `Session` to ask about records and stores. The `Session`
	 * ensures that only a single instance of each model Type/Id combination is created. This is
	 * important when tracking changes in models so that we always have the same reference.
	 * 
	 * A `ViewModel` provides functionality to easily consume the built in data package types
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) and [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), as well as their associations.
	 * 
	 * ### Model Links
	 * 
	 * A model can be described declaratively using a [&lt;code&gt;link&lt;/code&gt;](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-links). In the example code below,
	 * We ask the `ViewModel` to construct a record of type `User` with `id: 17`. The model will be loaded
	 * from the server and the bindings will trigger once the load has completed. Similarly, we could also
	 * attach a model instance to the `ViewModel` data directly.
	 * 
	 *    Ext.define('MyApp.model.User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name']
	 *    });
	 *    
	 *    var rec = new MyApp.model.User({
	 *        id: 12,
	 *        name: 'Foo'
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            theUser: {
	 *                type: 'User',
	 *                id: 17
	 *            }
	 *        },
	 *        data: {
	 *            otherUser: rec
	 *        }
	 *    });
	 *    viewModel.bind('{theUser.name}', function(v) {
	 *        console.log(v);
	 *    });
	 *    viewModel.bind('{otherUser.name}', function(v) {
	 *        console.log(v);
	 *    });
	 * 
	 * ### Model Fields
	 * 
	 * Bindings have the functionality to inspect the parent values and resolve the underlying
	 * value dynamically. This behavior allows model fields to be interrogated as part of a binding.
	 * 
	 *    Ext.define('MyApp.model.User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name', 'age']
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            theUser: {
	 *                type: 'User',
	 *                id: 22
	 *            }
	 *        }
	 *    });
	 *    
	 *    // Server responds with:
	 *    {
	 *        "id": 22,
	 *        "name": "Foo",
	 *        "age": 100
	 *    }
	 *    
	 *    viewModel.bind('Hello {name}, you are {age} years old', function(v) {
	 *        console.log(v);
	 *    });
	 * 
	 * ### Associations
	 * 
	 * In the same way as fields, the bindings can also traverse associations in a bind statement.
	 * The `ViewModel` will handle the asynchronous loading of data and only present the value once
	 * the full path has been loaded. For more information on associations see [OneToOne](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.schema.OneToOne.html) and
	 * [ManyToOne](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.schema.ManyToOne.html) associations.
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name']
	 *    });
	 *    
	 *    Ext.define('Order', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['date', {
	 *            name: 'userId',
	 *            reference: 'User'
	 *        }]
	 *    });
	 *    
	 *    Ext.define('OrderItem', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['price', 'qty', {
	 *            name: 'orderId',
	 *            reference: 'Order'
	 *        }]
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            orderItem: {
	 *                type: 'OrderItem',
	 *                id: 13
	 *            }
	 *        }
	 *    });
	 *    // The viewmodel will handle both ways of loading the data:
	 *    // a) If the data is loaded inline in a nested fashion it will
	 *    //    not make requests for extra data
	 *    // b) Only loading a single model at a time. So the Order will be loaded once
	 *    //    the OrderItem returns. The User will be loaded once the Order loads.
	 *    viewModel.bind('{orderItem.order.user.name}', function(name) {
	 *        console.log(name);
	 *    });
	 * 
	 * ### Stores
	 * 
	 * Stores can be created as part of the `ViewModel` definition. The definitions are processed
	 * like bindings which allows for very powerful dynamic functionality.
	 * 
	 * It is important to ensure that you name viewModel's data keys uniquely. If data is not named<br/>
	 * uniquely, binds and formulas may receive information from an unintended data source.<br/>
	 * This applies to keys in the viewModel's data block, stores, and links configs.
	 * 
	 *    var viewModel = new Ext.app.ViewModel({
	 *        stores: {
	 *            users: {
	 *                model: 'User',
	 *                autoLoad: true,
	 *                filters: [{
	 *                    property: 'createdDate',
	 *                    value: '{createdFilter}',
	 *                    operator: '&gt;'
	 *                }]
	 *            }
	 *        }
	 *    });
	 *    // Later on in our code, we set the date so that the store is created.
	 *    viewModel.set('createdFilter', Ext.Date.subtract(new Date(), Ext.Date.DAY, 7));
	 * 
	 * See [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-stores) for more detail.
	 * 
	 * #### Formulas
	 * 
	 * Formulas allow for calculated `ViewModel` data values. The dependencies for these formulas
	 * are automatically determined so that the formula will not be processed until the required
	 * data is present.
	 * 
	 *     var viewModel = new Ext.app.ViewModel({
	 *         formulas: {
	 *             fullName: function(get) {
	 *                 return get('firstName') + ' ' + get('lastName');
	 *             }
	 *         },
	 *         data: {firstName: 'John', lastName: 'Smith'}
	 *     });
	 *     viewModel.bind('{fullName}', function(v) {
	 *         console.log(v);
	 *     });
	 * 
	 * See [formulas](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-formulas) for more detail.
	 */
	class ViewModel extends Ext.Base {
		/** 
		 * If this property is specified by the target class of this mixin its properties are
		 * used to configure the created [`Ext.Factory`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Factory.html).
		 * @property
		 * @public (property)
		 * @default {name: 'viewModel'}
		 * @type {object}
		 */
		factoryConfig?: object;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.app.ViewModel.Statics}
		 */
		self?: Ext.app.ViewModel.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * This object holds all of the properties of this `ViewModel`. It is
		 * prototype chained to the `linkData` which is, in turn, prototype chained
		 * to (if present) the `data` object of the parent `ViewModel`.
		 * @property
		 * @private (property)
		 * @readonly
		 * @type {object}
		 */
		readonly data?: object;
		/** 
		 * ---
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                     members    The members to add to this class.
		 * @param   {boolean}                    [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                    [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.ViewModel|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.ViewModel;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                     members
		 * @returns {Ext.app.ViewModel|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.app.ViewModel;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                     members
		 * @returns {Ext.app.ViewModel|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.app.ViewModel;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                     name
		 * @param   {object}                     member
		 * @returns {Ext.app.ViewModel|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.app.ViewModel;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                     fn
		 * @param   {object}                     scope
		 * @returns {Ext.app.ViewModel|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.app.ViewModel;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * This method requests that data in this `ViewModel` be delivered to the specified
		 * `callback`. The data desired is given in a "bind descriptor" which is the first
		 * argument.
		 * 
		 * A simple call might look like this:
		 * 
		 *    var binding = vm.bind('{foo}', this.onFoo, this);
		 *    
		 *    binding.destroy();  // when done with the binding
		 * 
		 * Options for the binding can be provided in the last argument:
		 * 
		 *    var binding = vm.bind('{foo}', this.onFoo, this, {
		 *        deep: true
		 *    });
		 * 
		 * Alternatively, bind options can be combined with the bind descriptor using only
		 * the first argument:
		 * 
		 *    var binding = vm.bind({
		 *        bindTo: '{foo}',  // the presence of bindTo identifies this form
		 *        deep: true
		 *    }, this.onFoo, this);
		 * 
		 * See the class documentation for more details on Bind Descriptors and options.
		 * @method
		 * @public (method)
		 * @param   {string|object|any[]}                           descriptor
		 * The bind descriptor. See class description
		 * for details.
		 * @param   {Function}                                      callback   The function to call with the value of the bound property.
		 * @param   {object}                                        [scope]    The scope (`this` pointer) for the `callback`.
		 * @param   {object}                                        [options]
		 * Additional options to configure the [binding](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Binding.html).
		 * If this parameter is provided, the `bindTo` form of combining options and bind descriptor is not
		 * recognized.
		 * @returns {Ext.app.bind.BaseBinding|Ext.app.bind.Binding}            The binding.
		 */
		bind? (descriptor: string | object | any[], callback: ExtGlobalFunction, scope?: object, options?: object): Ext.app.bind.BaseBinding | Ext.app.bind.Binding;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Get a value from the data for this viewmodel.
		 * @method
		 * @public (method)
		 * @param   {string} path
		 * The path of the data to retrieve.
		 * 
		 *    var value = vm.get('theUser.address.city');
		 * @returns {object}      The data stored at the passed path.
		 */
		get? (path: string): object;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [data](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-data).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getData? (): object;
		/** 
		 * Returns the value of [formulas](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-formulas).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getFormulas? (): object;
		/** 
		 * Retrieves the id of this component. Will autogenerate an id if one has not already been set.
		 * @method
		 * @public (method)
		 * @returns {string}  id
		 */
		getId? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [links](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-links).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getLinks? (): object;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-parent).
		 * @method
		 * @public (method)
		 * @returns {Ext.app.ViewModel}  
		 */
		getParent? (): Ext.app.ViewModel;
		/** 
		 * Returns the value of [schema](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-schema).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.schema.Schema}  
		 */
		getSchema? (): string | Ext.data.schema.Schema;
		/** 
		 * Gets the session attached to this (or a parent) ViewModel. See the [session](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-session) configuration.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Session}  The session. `null` if no session exists.
		 */
		getSession? (): Ext.data.Session;
		/** 
		 * Gets a store configured via the [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-stores) configuration.
		 * @method
		 * @public (method)
		 * @param   {string}         key The name of the store.
		 * @returns {Ext.data.Store}     The store. `null` if no store exists.
		 */
		getStore? (key: string): Ext.data.Store;
		/** 
		 * Returns the value of [view](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-view).
		 * @method
		 * @public (method)
		 * @returns {Ext.container.Container}  
		 */
		getView? (): Ext.container.Container;
		/** 
		 * Create a link to a reference. See the [links](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-links) configuration.
		 * @method
		 * @public (method)
		 * @param   {string} key       The name for the link.
		 * @param   {object} reference The reference descriptor.
		 * @returns {void}             
		 */
		linkTo? (key: string, reference: object): void;
		/** 
		 * Forces all bindings in this ViewModel hierarchy to evaluate immediately. Use this to do a synchronous flush
		 * of all bindings.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		notify? (): void;
		/** 
		 * Set  a value in the data for this viewmodel.
		 * @method
		 * @public (method)
		 * @param   {object|string} path
		 * The path of the value to set, or an object literal to set
		 * at the root of the viewmodel.
		 * @param   {object}        value
		 * The data to set at the value. If the value is an object literal,
		 * any required paths will be created.
		 * 
		 *    // Set a single property at the root level
		 *    viewModel.set('expiry', Ext.Date.add(new Date(), Ext.Date.DAY, 7));
		 *    console.log(viewModel.get('expiry'));
		 *    // Sets a single property in user.address, does not overwrite any hierarchy.
		 *    viewModel.set('user.address.city', 'London');
		 *    console.log(viewModel.get('user.address.city'));
		 *    // Sets 2 properties of "user". Overwrites any existing hierarchy.
		 *    viewModel.set('user', {firstName: 'Foo', lastName: 'Bar'});
		 *    console.log(viewModel.get('user.firstName'));
		 *    // Sets a single property at the root level. Overwrites any existing hierarchy.
		 *    viewModel.set({rootKey: 1});
		 *    console.log(viewModel.get('rootKey'));
		 * 
		 * @returns {void}                
		 */
		set? (path: object | string, value: object): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}              name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                     [value] The value to set for the name parameter.
		 * @returns {Ext.app.ViewModel|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.ViewModel;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [data](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-data).
		 * @method
		 * @public (method)
		 * @param   {object} data The new value.
		 * @returns {void}        
		 */
		setData? (data: object): void;
		/** 
		 * Sets the value of [formulas](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-formulas).
		 * @method
		 * @public (method)
		 * @param   {object} formulas The new value.
		 * @returns {void}            
		 */
		setFormulas? (formulas: object): void;
		/** 
		 * Sets the value of [links](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-links).
		 * @method
		 * @public (method)
		 * @param   {object} links The new value.
		 * @returns {void}         
		 */
		setLinks? (links: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-parent).
		 * @method
		 * @public (method)
		 * @param   {Ext.app.ViewModel} parent The new value.
		 * @returns {void}                     
		 */
		setParent? (parent: Ext.app.ViewModel): void;
		/** 
		 * Sets the value of [schema](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-schema).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.schema.Schema} schema The new value.
		 * @returns {void}                                 
		 */
		setSchema? (schema: string | Ext.data.schema.Schema): void;
		/** 
		 * Sets the value of [session](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-session).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} session The new value.
		 * @returns {void}                     
		 */
		setSession? (session: Ext.data.Session): void;
		/** 
		 * Sets the value of [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-stores).
		 * @method
		 * @public (method)
		 * @param   {object} stores The new value.
		 * @returns {void}          
		 */
		setStores? (stores: object): void;
		/** 
		 * Sets the value of [view](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-view).
		 * @method
		 * @public (method)
		 * @param   {Ext.container.Container} view The new value.
		 * @returns {void}                         
		 */
		setView? (view: Ext.container.Container): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                     config
		 * @returns {Ext.app.ViewModel|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.app.ViewModel;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.ViewModel.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.app.ViewModel.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                   names The names of the linked objects to destroy.
		 * @returns {Ext.app.ViewModel|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.app.ViewModel;
		unlink? (names: string[]): Ext.Base;
	}
}
declare namespace Ext {
	class app {
		/** 
		 * This class manages event dispatching for Controllers. The details of connecting classes
		 * to this dispatching mechanism is delegated to [Ext.app.EventDomain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html) instances.
		 * @private (class)
		 * @singleton (instance)
		 */
		static readonly EventBus?: Ext.app.EventBus;
	}
}
declare namespace Ext.app.Application {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)
	 * Represents an Ext JS application, which is typically a single page app using a
	 * [Viewport](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Viewport.html).
	 * 
	 * An application consists of one or more Views. The behavior of a View is managed by its
	 * corresponding [ViewController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html) and [ViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html).
	 * 
	 * Global activities are coordinated by [Controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html) which are
	 * ultimately instantiated by an instance of this (or a derived) class.
	 * 
	 *    Ext.application({
	 *        name: 'MyApp',
	 *    
	 *        // An instance of this view is created and set as the Viewport:
	 *        autoCreateViewport: 'MyApp.view.Main'
	 *    });
	 * 
	 * This does several things. First it creates a global variable called 'MyApp' - all of
	 * your Application's classes (such as its Models, Views and Controllers) will reside under
	 * this single namespace, which drastically lowers the chances of colliding global variables.
	 * 
	 * The MyApp global will also have a getApplication method to get a reference to the current
	 * application:
	 * 
	 *    var app = MyApp.getApplication();
	 * 
	 * # Telling Application about the rest of the app
	 * 
	 * Because an [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) represents an entire app, we should tell it about the other
	 * parts of the app - namely the Models, Views and Controllers that are bundled with the application. Let's say we have a blog management app; we
	 * might have Models and Controllers for Posts and Comments, and Views for listing, adding and editing Posts and Comments.
	 * Here's how we'd tell our Application about all these things:
	 * 
	 *    Ext.application({
	 *        name: 'Blog',
	 *    
	 *        models: ['Post', 'Comment'],
	 *    
	 *        controllers: ['Posts', 'Comments'],
	 *    
	 *        launch: function() {
	 *            ...
	 *        }
	 *    });
	 * 
	 * Note that we didn't actually list the Views directly in the Application itself. This is because Views are managed by
	 * Controllers, so it makes sense to keep those dependencies there. The Application will load each of the specified
	 * Controllers using the pathing conventions laid out in the [application architecture guide](../application_architecture/application_architecture.html) - in this case
	 * expecting the controllers to reside in app/controller/Posts.js and app/controller/Comments.js. In turn, each
	 * Controller simply needs to list the Views it uses and they will be automatically loaded. Here's how our Posts
	 * controller like be defined:
	 * 
	 *    Ext.define('MyApp.controller.Posts', {
	 *        extend: 'Ext.app.Controller',
	 *        views: ['posts.List', 'posts.Edit'],
	 *    
	 *        //the rest of the Controller here
	 *    });
	 * 
	 * Because we told our Application about our Models and Controllers, and our Controllers about their Views, Ext JS will
	 * automatically load all of our app files for us. This means we don't have to manually add script tags into our html
	 * files whenever we add a new class, but more importantly it enables us to create a minimized build of our entire
	 * application using Sencha Cmd.
	 * 
	 * # Deriving from [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)
	 * 
	 * Typically, applications do not derive directly from [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html). Rather, the
	 * configuration passed to [`Ext.application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-application) mimics what you might do in a derived class.
	 * In some cases, however, it can be desirable to share logic by using a derived class
	 * from [`Ext.app.Application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html).
	 * 
	 * Derivation works as you would expect, but using the derived class should still be the
	 * job of the [`Ext.application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-application) method.
	 * 
	 *    Ext.define('MyApp.Application', {
	 *        extend: 'Ext.app.Application',
	 *        name: 'MyApp',
	 *        ...
	 *    });
	 *    
	 *    Ext.application('MyApp.Application');
	 * 
	 * For more information about writing Ext JS applications, please see the [application architecture guide](../../../application_architecture/application_architecture.html).
	 */
	interface Def extends Ext.app.Application {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.app.Application.Cfg}
		 */
		config?: Ext.app.Application.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.app.Application.Statics|Ext.app.Controller.Statics|Ext.app.BaseController.Statics|Ext.Base.Statics}  
		 * @type {Ext.app.Application.Statics}
		 */
		statics?: (() => Ext.app.Application.Statics | Ext.app.Controller.Statics | Ext.app.BaseController.Statics | Ext.Base.Statics) | Ext.app.Application.Statics | any;
	}
}
declare namespace Ext.app.BaseController {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.app.BaseController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html)
	 * Base class for Controllers.
	 */
	interface Def extends Ext.app.BaseController {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.app.BaseController.Cfg}
		 */
		config?: Ext.app.BaseController.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.app.BaseController.Statics|Ext.Base.Statics}  
		 * @type {Ext.app.BaseController.Statics}
		 */
		statics?: (() => Ext.app.BaseController.Statics | Ext.Base.Statics) | Ext.app.BaseController.Statics | any;
	}
}
declare namespace Ext.app.Controller {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.app.Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html)
	 * Controllers are the glue that binds an application together. That said, their main
	 * purpose is to listen for events (usually from views) and take some action. Here's how
	 * we might create a Controller to manage Users:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         init: function() {
	 *             console.log('Initialized Users! This happens before ' +
	 *                         'the Application launch() function is called');
	 *         }
	 *     });
	 * 
	 * The init function is a special method that is called when your application boots. It is
	 * called before the [Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)'s launch function is executed.
	 * This creates an area you can run code prior to Viewport creation.
	 * 
	 * The controller's [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-control) function
	 * makes it easy to listen to events on your view classes and take some action with a
	 * handler function. Let's update our Users controller to tell us when the panel is
	 * rendered:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         control: {
	 *             'viewport &gt; panel': {
	 *                 render: 'onPanelRendered'
	 *             }
	 *         }
	 *    
	 *         onPanelRendered: function() {
	 *             console.log('The panel was rendered');
	 *         }
	 *     });
	 * 
	 * The [control method](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-control) has now set up
	 * listeners on views in our application. The control method uses the ComponentQuery
	 * engine to quickly and easily get references to components on the page. If you are not
	 * familiar with ComponentQuery yet, be sure to check out the
	 * [documentation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html). In brief, it allows us to pass a
	 * CSS-like selector that will find every matching component on the page.
	 * 
	 * In our init function above, we supplied 'viewport > panel', which translates to "find me
	 * every Panel that is a direct child of a Viewport". We then supplied an object that maps
	 * event names (just 'render' in this case) to handler functions. In short, whenever
	 * a component that matches our selector fires a 'render' event, our
	 * onPanelRendered function is called.
	 * 
	 * ## Event domains
	 * 
	 * In Ext JS 4.2, we introduced the concept of event domains. In terms of MVC, an event
	 * domain is one or more base classes that fire events to which a Controller wants to
	 * listen. Besides Component event domain that encompass [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)-descended
	 * Views, Controllers now can listen to events from data Stores, Ext Direct Providers,
	 * other Controllers, and [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html). This feature provides a way to communicate
	 * between parts of the whole application without the need to bind controllers together
	 * tightly, and allows to develop and test application parts in isolation.
	 * 
	 * See usage examples in [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-listen) method documentation.
	 * 
	 * ## Using refs
	 * 
	 * One of the most useful parts of Controllers is the ref system. These use
	 * [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) to make it really easy to get references to Views on your
	 * page. Let's look at an example of this now:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         refs: [{
	 *             ref: 'list',
	 *             selector: 'grid'
	 *         }],
	 *    
	 *         control: {
	 *             'button': {
	 *                 click: 'refreshGrid'
	 *             }
	 *         },
	 *    
	 *         refreshGrid: function() {
	 *             this.getList().store.load();
	 *         }
	 *     });
	 * 
	 * This example assumes the existence of a [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) on the page, which
	 * contains a single button to refresh the Grid when clicked. In our refs array, we set up
	 * a reference to the grid. There are two parts to this - the 'selector', which is a
	 * [ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) selector which finds any grid on the page and
	 * assigns it to the reference 'list'.
	 * 
	 * By giving the reference a name, we get a number of things for free. The first is the
	 * getList function that we use in the refreshGrid method above. This is generated
	 * automatically by the Controller based on the name of our ref, which was capitalized and
	 * prepended with get to go from 'list' to 'getList'.
	 * 
	 * The way this works is that the first time getList is called by your code, the
	 * ComponentQuery selector is run and the first component that matches the selector
	 * ('grid' in this case) will be returned. All future calls to getList will use a cached
	 * reference to that grid. Usually it is advised to use a specific ComponentQuery selector
	 * that will only match a single View in your application (in the case above our selector
	 * will match any grid on the page).
	 * 
	 * Bringing it all together, we configure control
	 * to listen to any click on a [button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) and call our refreshGrid
	 * function (again, this will match any button on the page so we advise a more specific
	 * selector than just 'button', but have left it this way for simplicity). When the button
	 * is clicked we use out getList function to refresh the grid.
	 * 
	 * You can create any number of refs and control any number of components this way, simply
	 * adding more functions to your Controller as you go. For an example of real-world usage
	 * of Controllers see the Feed Viewer example in the examples/app/feed-viewer folder in
	 * the SDK download.
	 * 
	 * ## Generated getter methods
	 * 
	 * Refs aren't the only thing that generate convenient getter methods. Controllers often
	 * have to deal with Models and Stores so the framework offers a couple of easy ways to
	 * get access to those too. Let's look at another example:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         models: ['User'],
	 *         stores: ['AllUsers', 'AdminUsers'],
	 *    
	 *         init: function() {
	 *             var User, allUsers, ed;
	 *    
	 *             User = this.getUserModel();
	 *             allUsers = this.getAllUsersStore();
	 *    
	 *             ed = new User({ name: 'Ed' });
	 *             allUsers.add(ed);
	 *         }
	 *     });
	 * 
	 * By specifying Models and Stores that the Controller cares about, it again dynamically
	 * loads them from the appropriate locations (app/model/User.js, app/store/AllUsers.js and
	 * app/store/AdminUsers.js in this case) and creates getter functions for them all. The
	 * example above will create a new User model instance and add it to the AllUsers Store.
	 * Of course, you could do anything in this function but in this case we just did
	 * something simple to demonstrate the functionality.
	 * 
	 * ## Further Reading
	 * 
	 * For more information about writing Ext JS 5 applications, please see the
	 * [Application Architecture](../../../application_architecture/application_architecture.html).
	 * Also see the [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) documentation.
	 */
	interface Def extends Ext.app.Controller {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.app.Controller.Cfg}
		 */
		config?: Ext.app.Controller.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.app.Controller.Statics|Ext.app.BaseController.Statics|Ext.Base.Statics}  
		 * @type {Ext.app.Controller.Statics}
		 */
		statics?: (() => Ext.app.Controller.Statics | Ext.app.BaseController.Statics | Ext.Base.Statics) | Ext.app.Controller.Statics | any;
	}
}
declare namespace Ext.app.EventDomain {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.app.EventDomain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html)
	 * This class is a base class for an event domain. In the context of MVC, an "event domain"
	 * is one or more base classes that fire events to which a Controller wants to listen. A
	 * controller listens to events by describing the selectors for events of interest to it.
	 * 
	 * Matching selectors to the firer of an event is one key aspect that defines an event
	 * domain. All event domain instances must provide a `match` method that tests selectors
	 * against the event firer.
	 * 
	 * When an event domain instance is created (typically as a `singleton`), its `type`
	 * property is used to catalog the domain in the
	 * [Ext.app.EventDomain.instances](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html#static-property-instances) map.
	 * 
	 * There are five event domains provided by default:
	 * 
	 * - [Component domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Component.html). This is the primary event domain that
	 *   has been available since Ext JS MVC was introduced. This domain is defined as any class that
	 *   extends [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html), where the selectors use
	 *   [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html#method-query).
	 * - [Global domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html). This domain provides Controllers with access
	 *   to events fired from [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance. These events represent
	 *   the state of the application as a whole, and are always anonymous. Because of this, Global
	 *   domain does not provide selectors at all.
	 * - [Controller domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html). This domain includes all classes
	 *   that extend [Ext.app.Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html). Events fired by Controllers will be available
	 *   within this domain; selectors are either Controller's [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-id) or
	 *   '*' wildcard for any Controller.
	 * - [Store domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html). This domain is for classes extending
	 *   [Ext.data.AbstractStore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.AbstractStore.html). Selectors are either Store's
	 *   [storeId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.AbstractStore.html#cfg-storeId) or '*' wildcard for any Store.
	 * - [Direct domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html). This domain includes all classes that extend
	 *   [Ext.direct.Provider](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Provider.html). Selectors are either Provider's [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Provider.html#cfg-id)
	 *   or '*' wildcard for any Provider. This domain is optional and will be loaded only if
	 *   [Ext.direct.Manager](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Manager.html) singleton is required in your application.
	 */
	interface Def extends Ext.app.EventDomain {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.app.EventDomain.Cfg}
		 */
		config?: Ext.app.EventDomain.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.app.EventDomain.Statics|Ext.Base.Statics}  
		 * @type {Ext.app.EventDomain.Statics}
		 */
		statics?: (() => Ext.app.EventDomain.Statics | Ext.Base.Statics) | Ext.app.EventDomain.Statics | any;
	}
}
declare namespace Ext.app.Profile {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.app.Profile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html)
	 * A Profile represents a range of devices that fall under a common category. For the vast majority of apps that use
	 * device profiles, the app defines a Phone profile and a Tablet profile. Doing this enables you to easily customize
	 * the experience for the different sized screens offered by those device types.
	 * 
	 * Only one Profile can be active at a time, and each Profile defines a simple [isActive](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#method-isActive) function that should
	 * return either true or false. The first Profile to return true from its isActive function is set as your Application's
	 * [current profile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-currentProfile).
	 * 
	 * A Profile can define any number of [models](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-models), [views](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-views), [controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-controllers) and [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-stores) which
	 * will be loaded if the Profile is activated. It can also define a [launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#method-launch) function that will be called after
	 * all of its dependencies have been loaded, just before the [application launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#method-launch)
	 * function is called.
	 * 
	 * ## Sample Usage
	 * 
	 * First you need to tell your Application about your Profile(s):
	 * 
	 *    Ext.application({
	 *        name: 'MyApp',
	 *        profiles: ['Phone', 'Tablet']
	 *    });
	 * 
	 * This will load app/profile/Phone.js and app/profile/Tablet.js. Here's how we might define the Phone profile:
	 * 
	 *    Ext.define('MyApp.profile.Phone', {
	 *        extend: 'Ext.app.Profile',
	 *    
	 *        views: ['Main'],
	 *    
	 *        isActive: function() {
	 *            return Ext.os.is('Phone');
	 *        }
	 *    });
	 * 
	 * The isActive function returns true if we detect that we are running on a phone device. If that is the case the
	 * Application will set this Profile active and load the 'Main' view specified in the Profile's [views](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-views) config.
	 * 
	 * ## Class Specializations
	 * 
	 * Because Profiles are specializations of an application, all of the models, views, controllers and stores defined
	 * in a Profile are expected to be namespaced under the name of the Profile. Here's an expanded form of the example
	 * above:
	 * 
	 *    Ext.define('MyApp.profile.Phone', {
	 *        extend: 'Ext.app.Profile',
	 *    
	 *        views: ['Main'],
	 *        controllers: ['Signup'],
	 *        models: ['MyApp.model.Group'],
	 *    
	 *        isActive: function() {
	 *            return Ext.os.is('Phone');
	 *        }
	 *    });
	 * 
	 * In this case, the Profile is going to load _app/view/phone/Main.js_, _app/controller/phone/Signup.js_ and
	 * _app/model/Group.js_. Notice that in each of the first two cases the name of the profile ('phone' in this case) was
	 * injected into the class names. In the third case we specified the full Model name (for Group) so the Profile name
	 * was not injected.
	 * 
	 * For a fuller understanding of the ideas behind Profiles and how best to use them in your app, we suggest you read
	 * the [device profiles guide](/touch/2.4/core_concepts/device_profiles.html).
	 */
	interface Def extends Ext.app.Profile {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.app.Profile.Cfg}
		 */
		config?: Ext.app.Profile.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.app.Profile.Statics|Ext.Base.Statics}  
		 * @type {Ext.app.Profile.Statics}
		 */
		statics?: (() => Ext.app.Profile.Statics | Ext.Base.Statics) | Ext.app.Profile.Statics | any;
	}
}
declare namespace Ext.app.ViewController {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.app.ViewController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html)
	 * A view controller is a controller that can be attached to a specific view
	 * instance so it can manage the view and its child components. Each instance of the view
	 * will have a new view controller, so the instances are isolated.
	 * 
	 * When a controller is specified on a view, the view automatically becomes a [Ext.container.Container.referenceHolder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-referenceHolder),
	 * so it will receive inline events declared on the view. Sample usage:
	 * 
	 *    Ext.define('User', {
	 *       extend: 'Ext.data.Model',
	 *       fields: ['name', 'phone']    
	 *    });
	 *    
	 *    Ext.define('UserListController', {
	 *        extend : 'Ext.app.ViewController',
	 *        alias: 'controller.userlist',
	 *    
	 *        init: function(view) {
	 *            this.userCount = 0;
	 *            var users = [],
	 *                i;
	 *    
	 *            for (i = 0; i &lt; 5; ++i) {
	 *                users.push(this.getUser());
	 *            }  
	 *            view.getStore().add(users);
	 *        },
	 *    
	 *        onAddClick: function() {
	 *            this.addUser();
	 *        },
	 *    
	 *        onDeleteClick: function() {
	 *            var view = this.getView(),
	 *                selected = view.getSelectionModel().getSelection()[0],
	 *                store = view.getStore();
	 *    
	 *            store.remove(selected);
	 *        },
	 *    
	 *        onSelectionChange: function(selModel, selections) {
	 *            this.lookupReference('delete').setDisabled(selections.length === 0);
	 *        },
	 *    
	 *        getUser: function() {
	 *            ++this.userCount;
	 *            return {
	 *                name: 'User ' + this.userCount,
	 *                phone: this.generatePhone()
	 *            };
	 *        },
	 *    
	 *        addUser: function() {
	 *            this.getView().getStore().add(this.getUser());    
	 *        },
	 *    
	 *        generatePhone: function() {
	 *            var num = '',
	 *                i;
	 *    
	 *            for (i = 0; i &lt; 7; ++i) {
	 *                num += Ext.Number.randomInt(0, 9);
	 *                if (num.length === 3) {
	 *                    num += '-';
	 *                }
	 *            }    
	 *            return num;
	 *        }
	 *    });
	 *    
	 *    Ext.define('UserList', {
	 *        extend: 'Ext.grid.Panel',
	 *        controller: 'userlist',
	 *    
	 *        tbar: [{
	 *            text: 'Add',
	 *            listeners: {
	 *                click: 'onAddClick'
	 *            }    
	 *        }, {
	 *            text: 'Delete',
	 *            reference: 'delete',
	 *            listeners: {
	 *                click: 'onDeleteClick'
	 *            }
	 *        }],
	 *        store: {
	 *            model: 'User'
	 *        },
	 *        selModel: {
	 *            type: 'rowmodel',
	 *            listeners: {
	 *                selectionchange: 'onSelectionChange'
	 *            }    
	 *        },
	 *        columns: [{
	 *            flex: 1,
	 *            dataIndex: 'name',
	 *            text: 'Name'
	 *        }, {
	 *            flex: 1,
	 *            dataIndex: 'phone',
	 *            text: 'Phone'
	 *        }]
	 *    });
	 *    
	 *    Ext.onReady(function() {
	 *        new UserList({
	 *            renderTo: Ext.getBody(),
	 *            width: 400,
	 *            height: 200
	 *        });
	 *    });
	 * 
	 */
	interface Def extends Ext.app.ViewController {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.app.ViewController.Cfg}
		 */
		config?: Ext.app.ViewController.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.app.ViewController.Statics|Ext.app.BaseController.Statics|Ext.Base.Statics}  
		 * @type {Ext.app.ViewController.Statics}
		 */
		statics?: (() => Ext.app.ViewController.Statics | Ext.app.BaseController.Statics | Ext.Base.Statics) | Ext.app.ViewController.Statics | any;
	}
}
declare namespace Ext.app.ViewModel {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.app.ViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html)
	 * This class manages arbitrary data and its relationship to data models. Instances of
	 * `ViewModel` are associated with some `Component` and then used by their child items
	 * for the purposes of Data Binding.
	 * 
	 * # Binding
	 * 
	 * The most commonly used aspect of a `ViewModel` is the `bind` method. This method takes
	 * a "bind descriptor" (see below) and a callback to call when the data indicated by the
	 * bind descriptor either becomes available or changes.
	 * 
	 * The `bind` method, based on the bind descriptor given, will return different types of
	 * "binding" objects. These objects maintain the connection between the requested data and
	 * the callback. Bindings ultimately derive from [`Ext.app.bind.BaseBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.BaseBinding.html)
	 * which provides several methods to help manage the binding.
	 * 
	 * Perhaps the most important method is `destroy`. When the binding is no longer needed
	 * it is important to remember to `destroy` it. Leaking bindings can cause performance
	 * problems or worse when callbacks are called at unexpected times.
	 * 
	 * The types of bindings produced by `bind` are:
	 * 
	 * - [`Ext.app.bind.Binding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Binding.html)
	 * - [`Ext.app.bind.Multi`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Multi.html)
	 * - [`Ext.app.bind.TemplateBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.TemplateBinding.html)
	 * 
	 * ## Bind Descriptors
	 * 
	 * A "bind descriptor" is a value (a String, an Object or an array of these) that describe
	 * the desired data. Any piece of data in the `ViewModel` can be described by a bind
	 * descriptor.
	 * 
	 * ### Textual Bind Descriptors
	 * 
	 * The simplest and most common form of bind descriptors are strings that look like an
	 * [`Ext.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Template.html) containing text and tokens surrounded by "{}" with dot notation inside
	 * to traverse objects and their properties.
	 * 
	 * For example:
	 * 
	 * - `'Hello {user.name}!'`
	 * - `'You have selected "{selectedItem.text}".'`
	 * - `'{user.groups}'`
	 * 
	 * The first two bindings are [`template bindings`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.TemplateBinding.html)
	 * which use the familiar [`Ext.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Template.html) syntax with some slight differences. For more on
	 * templates see [`Ext.app.bind.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Template.html).
	 * 
	 * The third bind descriptor is called a "direct bind descriptor". This special form of
	 * bind maps one-to-one to some piece of data in the `ViewModel` and is managed by the
	 * [`Ext.app.bind.Binding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Binding.html) class.
	 * 
	 * #### Two-Way Descriptors
	 * 
	 * A direct bind descriptor may be able to write back a value to the `ViewModel` as well
	 * as retrieve one. When this is the case, they are said to be "two-way". For example:
	 * 
	 *     var binding = viewModel.bind('{s}', function(x) { console.log('s=' + s); });
	 *    
	 *     binding.setValue('abc');
	 * 
	 * Direct use of `ViewModel` in this way is not commonly needed because [`Ext.Component`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)
	 * automates this process. For example, a `textfield` component understands when it is
	 * given a "two-way" binding and automatically synchronizes its value bidirectionally using
	 * the above technique. For example:
	 * 
	 *     Ext.widget({
	 *         items: [{
	 *             xtype: 'textfield',
	 *             bind: '{s}'  // a two-way / direct bind descriptor
	 *         }]
	 *     });
	 * 
	 * ### Object and Array Descriptors / Multi-Bind
	 * 
	 * With two exceptions (see below) an Object is interpreted as a "shape" to produce by
	 * treating each of its properties as individual bind descriptors. An object of the same
	 * shape is passed as the value of the bind except that each property is populated with
	 * the appropriate value. Of course, this definition is recursive, so these properties
	 * may also be objects.
	 * 
	 * For example:
	 * 
	 *     viewModel.bind({
	 *             x: '{x}',
	 *             foo: {
	 *                 bar: 'Hello {foo.bar}'
	 *             }
	 *         },
	 *         function (obj) {
	 *             //  obj = {
	 *             //      x: 42,
	 *             //      foo: {
	 *             //          bar: 'Hello foobar'
	 *             //      }
	 *             //  }
	 *         });
	 * 
	 * Arrays are handled in the same way. Each element of the array is considered a bind
	 * descriptor (recursively) and the value produced for the binding is an array with each
	 * element set to the bound property.
	 * 
	 * ### Bind Options
	 * 
	 * One exception to the "object is a multi-bind" rule is when that object contains a
	 * `bindTo` property. When an object contains a `bindTo` property the object is understood
	 * to contain bind options and the value of `bindTo` is considered the actual bind
	 * descriptor.
	 * 
	 * For example:
	 * 
	 *     viewModel.bind({
	 *             bindTo: '{x}',
	 *             single: true
	 *         },
	 *         function (x) {
	 *             console.log('x: ' + x); // only called once
	 *         });
	 * 
	 * The available bind options depend on the type of binding, but since all bindings
	 * derive from [`Ext.app.bind.BaseBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.BaseBinding.html) its options are always applicable.
	 * For a list of the other types of bindings, see above.
	 * 
	 * #### Deep Binding
	 * 
	 * When a direct bind is made and the bound property is an object, by default the binding
	 * callback is only called when that reference changes. This is the most efficient way to
	 * understand a bind of this type, but sometimes you may need to be notified if any of the
	 * properties of that object change.
	 * 
	 * To do this, we create a "deep bind":
	 * 
	 *     viewModel.bind({
	 *             bindTo: '{someObject}',
	 *             deep: true
	 *         },
	 *         function (someObject) {
	 *             // called when reference changes or *any* property changes
	 *         });
	 * 
	 * #### Binding Timings
	 * 
	 * The `ViewModel` has a [scheduler](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-scheduler) attached that is used to coordinate the firing of bindings.
	 * It serves 2 main purposes:
	 * 
	 * - To coordinate dependencies between bindings. This means bindings will be fired in an order such that
	 *   the any dependencies for a binding are fired before the binding itself.
	 * - To batch binding firings. The scheduler runs on a short timer, so the following code will only trigger
	 *   a single binding (the last), the changes in between will never be triggered.
	 * 
	 *      viewModel.bind('{val}', function(v) {
	 *          console.log(v);
	 *      });
	 *      viewModel.set('val', 1);
	 *      viewModel.set('val', 2);
	 *      viewModel.set('val', 3);
	 *      viewModel.set('val', 4);
	 * 
	 * The `ViewModel` can be forced to process by calling [`notify`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#method-notify), which will force the
	 * scheduler to run immediately in the current state.
	 * 
	 *    viewModel.bind('{val}', function(v) {
	 *        console.log(v);
	 *    });
	 *    viewModel.set('val', 1);
	 *    viewModel.notify();
	 *    viewModel.set('val', 2);
	 *    viewModel.notify();
	 *    viewModel.set('val', 3);
	 *    viewModel.notify();
	 *    viewModel.set('val', 4);
	 *    viewModel.notify();
	 * 
	 * #### Models, Stores and Associations
	 * 
	 * A [Session](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Session.html) manages model instances and their associations.
	 * The `ViewModel` may be used with or without a `Session`. When a `Session` is attached, the
	 * `ViewModel` will always consult the `Session` to ask about records and stores. The `Session`
	 * ensures that only a single instance of each model Type/Id combination is created. This is
	 * important when tracking changes in models so that we always have the same reference.
	 * 
	 * A `ViewModel` provides functionality to easily consume the built in data package types
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) and [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), as well as their associations.
	 * 
	 * ### Model Links
	 * 
	 * A model can be described declaratively using a [&lt;code&gt;link&lt;/code&gt;](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-links). In the example code below,
	 * We ask the `ViewModel` to construct a record of type `User` with `id: 17`. The model will be loaded
	 * from the server and the bindings will trigger once the load has completed. Similarly, we could also
	 * attach a model instance to the `ViewModel` data directly.
	 * 
	 *    Ext.define('MyApp.model.User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name']
	 *    });
	 *    
	 *    var rec = new MyApp.model.User({
	 *        id: 12,
	 *        name: 'Foo'
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            theUser: {
	 *                type: 'User',
	 *                id: 17
	 *            }
	 *        },
	 *        data: {
	 *            otherUser: rec
	 *        }
	 *    });
	 *    viewModel.bind('{theUser.name}', function(v) {
	 *        console.log(v);
	 *    });
	 *    viewModel.bind('{otherUser.name}', function(v) {
	 *        console.log(v);
	 *    });
	 * 
	 * ### Model Fields
	 * 
	 * Bindings have the functionality to inspect the parent values and resolve the underlying
	 * value dynamically. This behavior allows model fields to be interrogated as part of a binding.
	 * 
	 *    Ext.define('MyApp.model.User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name', 'age']
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            theUser: {
	 *                type: 'User',
	 *                id: 22
	 *            }
	 *        }
	 *    });
	 *    
	 *    // Server responds with:
	 *    {
	 *        "id": 22,
	 *        "name": "Foo",
	 *        "age": 100
	 *    }
	 *    
	 *    viewModel.bind('Hello {name}, you are {age} years old', function(v) {
	 *        console.log(v);
	 *    });
	 * 
	 * ### Associations
	 * 
	 * In the same way as fields, the bindings can also traverse associations in a bind statement.
	 * The `ViewModel` will handle the asynchronous loading of data and only present the value once
	 * the full path has been loaded. For more information on associations see [OneToOne](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.schema.OneToOne.html) and
	 * [ManyToOne](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.schema.ManyToOne.html) associations.
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name']
	 *    });
	 *    
	 *    Ext.define('Order', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['date', {
	 *            name: 'userId',
	 *            reference: 'User'
	 *        }]
	 *    });
	 *    
	 *    Ext.define('OrderItem', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['price', 'qty', {
	 *            name: 'orderId',
	 *            reference: 'Order'
	 *        }]
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            orderItem: {
	 *                type: 'OrderItem',
	 *                id: 13
	 *            }
	 *        }
	 *    });
	 *    // The viewmodel will handle both ways of loading the data:
	 *    // a) If the data is loaded inline in a nested fashion it will
	 *    //    not make requests for extra data
	 *    // b) Only loading a single model at a time. So the Order will be loaded once
	 *    //    the OrderItem returns. The User will be loaded once the Order loads.
	 *    viewModel.bind('{orderItem.order.user.name}', function(name) {
	 *        console.log(name);
	 *    });
	 * 
	 * ### Stores
	 * 
	 * Stores can be created as part of the `ViewModel` definition. The definitions are processed
	 * like bindings which allows for very powerful dynamic functionality.
	 * 
	 * It is important to ensure that you name viewModel's data keys uniquely. If data is not named<br/>
	 * uniquely, binds and formulas may receive information from an unintended data source.<br/>
	 * This applies to keys in the viewModel's data block, stores, and links configs.
	 * 
	 *    var viewModel = new Ext.app.ViewModel({
	 *        stores: {
	 *            users: {
	 *                model: 'User',
	 *                autoLoad: true,
	 *                filters: [{
	 *                    property: 'createdDate',
	 *                    value: '{createdFilter}',
	 *                    operator: '&gt;'
	 *                }]
	 *            }
	 *        }
	 *    });
	 *    // Later on in our code, we set the date so that the store is created.
	 *    viewModel.set('createdFilter', Ext.Date.subtract(new Date(), Ext.Date.DAY, 7));
	 * 
	 * See [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-stores) for more detail.
	 * 
	 * #### Formulas
	 * 
	 * Formulas allow for calculated `ViewModel` data values. The dependencies for these formulas
	 * are automatically determined so that the formula will not be processed until the required
	 * data is present.
	 * 
	 *     var viewModel = new Ext.app.ViewModel({
	 *         formulas: {
	 *             fullName: function(get) {
	 *                 return get('firstName') + ' ' + get('lastName');
	 *             }
	 *         },
	 *         data: {firstName: 'John', lastName: 'Smith'}
	 *     });
	 *     viewModel.bind('{fullName}', function(v) {
	 *         console.log(v);
	 *     });
	 * 
	 * See [formulas](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-formulas) for more detail.
	 */
	interface Def extends Ext.app.ViewModel {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.app.ViewModel.Cfg}
		 */
		config?: Ext.app.ViewModel.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.app.ViewModel.Statics|Ext.Base.Statics}  
		 * @type {Ext.app.ViewModel.Statics}
		 */
		statics?: (() => Ext.app.ViewModel.Statics | Ext.Base.Statics) | Ext.app.ViewModel.Statics | any;
	}
}
declare namespace Ext.app.Application {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)
	 * Represents an Ext JS application, which is typically a single page app using a
	 * [Viewport](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Viewport.html).
	 * 
	 * An application consists of one or more Views. The behavior of a View is managed by its
	 * corresponding [ViewController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html) and [ViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html).
	 * 
	 * Global activities are coordinated by [Controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html) which are
	 * ultimately instantiated by an instance of this (or a derived) class.
	 * 
	 *    Ext.application({
	 *        name: 'MyApp',
	 *    
	 *        // An instance of this view is created and set as the Viewport:
	 *        autoCreateViewport: 'MyApp.view.Main'
	 *    });
	 * 
	 * This does several things. First it creates a global variable called 'MyApp' - all of
	 * your Application's classes (such as its Models, Views and Controllers) will reside under
	 * this single namespace, which drastically lowers the chances of colliding global variables.
	 * 
	 * The MyApp global will also have a getApplication method to get a reference to the current
	 * application:
	 * 
	 *    var app = MyApp.getApplication();
	 * 
	 * # Telling Application about the rest of the app
	 * 
	 * Because an [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) represents an entire app, we should tell it about the other
	 * parts of the app - namely the Models, Views and Controllers that are bundled with the application. Let's say we have a blog management app; we
	 * might have Models and Controllers for Posts and Comments, and Views for listing, adding and editing Posts and Comments.
	 * Here's how we'd tell our Application about all these things:
	 * 
	 *    Ext.application({
	 *        name: 'Blog',
	 *    
	 *        models: ['Post', 'Comment'],
	 *    
	 *        controllers: ['Posts', 'Comments'],
	 *    
	 *        launch: function() {
	 *            ...
	 *        }
	 *    });
	 * 
	 * Note that we didn't actually list the Views directly in the Application itself. This is because Views are managed by
	 * Controllers, so it makes sense to keep those dependencies there. The Application will load each of the specified
	 * Controllers using the pathing conventions laid out in the [application architecture guide](../application_architecture/application_architecture.html) - in this case
	 * expecting the controllers to reside in app/controller/Posts.js and app/controller/Comments.js. In turn, each
	 * Controller simply needs to list the Views it uses and they will be automatically loaded. Here's how our Posts
	 * controller like be defined:
	 * 
	 *    Ext.define('MyApp.controller.Posts', {
	 *        extend: 'Ext.app.Controller',
	 *        views: ['posts.List', 'posts.Edit'],
	 *    
	 *        //the rest of the Controller here
	 *    });
	 * 
	 * Because we told our Application about our Models and Controllers, and our Controllers about their Views, Ext JS will
	 * automatically load all of our app files for us. This means we don't have to manually add script tags into our html
	 * files whenever we add a new class, but more importantly it enables us to create a minimized build of our entire
	 * application using Sencha Cmd.
	 * 
	 * # Deriving from [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)
	 * 
	 * Typically, applications do not derive directly from [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html). Rather, the
	 * configuration passed to [`Ext.application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-application) mimics what you might do in a derived class.
	 * In some cases, however, it can be desirable to share logic by using a derived class
	 * from [`Ext.app.Application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html).
	 * 
	 * Derivation works as you would expect, but using the derived class should still be the
	 * job of the [`Ext.application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-application) method.
	 * 
	 *    Ext.define('MyApp.Application', {
	 *        extend: 'Ext.app.Application',
	 *        name: 'MyApp',
	 *        ...
	 *    });
	 *    
	 *    Ext.application('MyApp.Application');
	 * 
	 * For more information about writing Ext JS applications, please see the [application architecture guide](../../../application_architecture/application_architecture.html).
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                 members    The members to add to this class.
		 * @param   {boolean}                                                                [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.Application;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.Controller;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.BaseController;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                 members
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.app.Application;
		addStatics? (members: object): typeof Ext.app.Controller;
		addStatics? (members: object): typeof Ext.app.BaseController;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                 members
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.app.Application;
		addInheritableStatics? (members: object): typeof Ext.app.Controller;
		addInheritableStatics? (members: object): typeof Ext.app.BaseController;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                 name
		 * @param   {object}                                                                 member
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.app.Application;
		addMember? (name: object, member: object): typeof Ext.app.Controller;
		addMember? (name: object, member: object): typeof Ext.app.BaseController;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                 fn
		 * @param   {object}                                                                 scope
		 * @returns {Ext.app.Application|Ext.app.Controller|Ext.app.BaseController|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.app.Application;
		onExtended? (fn: object, scope: object): typeof Ext.app.Controller;
		onExtended? (fn: object, scope: object): typeof Ext.app.BaseController;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.app.BaseController {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.app.BaseController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html)
	 * Base class for Controllers.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members    The members to add to this class.
		 * @param   {boolean}                         [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                         [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.BaseController|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.BaseController;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members
		 * @returns {Ext.app.BaseController|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.app.BaseController;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members
		 * @returns {Ext.app.BaseController|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.app.BaseController;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          name
		 * @param   {object}                          member
		 * @returns {Ext.app.BaseController|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.app.BaseController;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          fn
		 * @param   {object}                          scope
		 * @returns {Ext.app.BaseController|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.app.BaseController;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.app.Controller {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.app.Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html)
	 * Controllers are the glue that binds an application together. That said, their main
	 * purpose is to listen for events (usually from views) and take some action. Here's how
	 * we might create a Controller to manage Users:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         init: function() {
	 *             console.log('Initialized Users! This happens before ' +
	 *                         'the Application launch() function is called');
	 *         }
	 *     });
	 * 
	 * The init function is a special method that is called when your application boots. It is
	 * called before the [Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)'s launch function is executed.
	 * This creates an area you can run code prior to Viewport creation.
	 * 
	 * The controller's [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-control) function
	 * makes it easy to listen to events on your view classes and take some action with a
	 * handler function. Let's update our Users controller to tell us when the panel is
	 * rendered:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         control: {
	 *             'viewport &gt; panel': {
	 *                 render: 'onPanelRendered'
	 *             }
	 *         }
	 *    
	 *         onPanelRendered: function() {
	 *             console.log('The panel was rendered');
	 *         }
	 *     });
	 * 
	 * The [control method](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-control) has now set up
	 * listeners on views in our application. The control method uses the ComponentQuery
	 * engine to quickly and easily get references to components on the page. If you are not
	 * familiar with ComponentQuery yet, be sure to check out the
	 * [documentation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html). In brief, it allows us to pass a
	 * CSS-like selector that will find every matching component on the page.
	 * 
	 * In our init function above, we supplied 'viewport > panel', which translates to "find me
	 * every Panel that is a direct child of a Viewport". We then supplied an object that maps
	 * event names (just 'render' in this case) to handler functions. In short, whenever
	 * a component that matches our selector fires a 'render' event, our
	 * onPanelRendered function is called.
	 * 
	 * ## Event domains
	 * 
	 * In Ext JS 4.2, we introduced the concept of event domains. In terms of MVC, an event
	 * domain is one or more base classes that fire events to which a Controller wants to
	 * listen. Besides Component event domain that encompass [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)-descended
	 * Views, Controllers now can listen to events from data Stores, Ext Direct Providers,
	 * other Controllers, and [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html). This feature provides a way to communicate
	 * between parts of the whole application without the need to bind controllers together
	 * tightly, and allows to develop and test application parts in isolation.
	 * 
	 * See usage examples in [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-listen) method documentation.
	 * 
	 * ## Using refs
	 * 
	 * One of the most useful parts of Controllers is the ref system. These use
	 * [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) to make it really easy to get references to Views on your
	 * page. Let's look at an example of this now:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         refs: [{
	 *             ref: 'list',
	 *             selector: 'grid'
	 *         }],
	 *    
	 *         control: {
	 *             'button': {
	 *                 click: 'refreshGrid'
	 *             }
	 *         },
	 *    
	 *         refreshGrid: function() {
	 *             this.getList().store.load();
	 *         }
	 *     });
	 * 
	 * This example assumes the existence of a [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) on the page, which
	 * contains a single button to refresh the Grid when clicked. In our refs array, we set up
	 * a reference to the grid. There are two parts to this - the 'selector', which is a
	 * [ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) selector which finds any grid on the page and
	 * assigns it to the reference 'list'.
	 * 
	 * By giving the reference a name, we get a number of things for free. The first is the
	 * getList function that we use in the refreshGrid method above. This is generated
	 * automatically by the Controller based on the name of our ref, which was capitalized and
	 * prepended with get to go from 'list' to 'getList'.
	 * 
	 * The way this works is that the first time getList is called by your code, the
	 * ComponentQuery selector is run and the first component that matches the selector
	 * ('grid' in this case) will be returned. All future calls to getList will use a cached
	 * reference to that grid. Usually it is advised to use a specific ComponentQuery selector
	 * that will only match a single View in your application (in the case above our selector
	 * will match any grid on the page).
	 * 
	 * Bringing it all together, we configure control
	 * to listen to any click on a [button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) and call our refreshGrid
	 * function (again, this will match any button on the page so we advise a more specific
	 * selector than just 'button', but have left it this way for simplicity). When the button
	 * is clicked we use out getList function to refresh the grid.
	 * 
	 * You can create any number of refs and control any number of components this way, simply
	 * adding more functions to your Controller as you go. For an example of real-world usage
	 * of Controllers see the Feed Viewer example in the examples/app/feed-viewer folder in
	 * the SDK download.
	 * 
	 * ## Generated getter methods
	 * 
	 * Refs aren't the only thing that generate convenient getter methods. Controllers often
	 * have to deal with Models and Stores so the framework offers a couple of easy ways to
	 * get access to those too. Let's look at another example:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         models: ['User'],
	 *         stores: ['AllUsers', 'AdminUsers'],
	 *    
	 *         init: function() {
	 *             var User, allUsers, ed;
	 *    
	 *             User = this.getUserModel();
	 *             allUsers = this.getAllUsersStore();
	 *    
	 *             ed = new User({ name: 'Ed' });
	 *             allUsers.add(ed);
	 *         }
	 *     });
	 * 
	 * By specifying Models and Stores that the Controller cares about, it again dynamically
	 * loads them from the appropriate locations (app/model/User.js, app/store/AllUsers.js and
	 * app/store/AdminUsers.js in this case) and creates getter functions for them all. The
	 * example above will create a new User model instance and add it to the AllUsers Store.
	 * Of course, you could do anything in this function but in this case we just did
	 * something simple to demonstrate the functionality.
	 * 
	 * ## Further Reading
	 * 
	 * For more information about writing Ext JS 5 applications, please see the
	 * [Application Architecture](../../../application_architecture/application_architecture.html).
	 * Also see the [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) documentation.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                             members    The members to add to this class.
		 * @param   {boolean}                                            [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                            [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.Controller;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.BaseController;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                             members
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.app.Controller;
		addStatics? (members: object): typeof Ext.app.BaseController;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                             members
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.app.Controller;
		addInheritableStatics? (members: object): typeof Ext.app.BaseController;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                             name
		 * @param   {object}                                             member
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.app.Controller;
		addMember? (name: object, member: object): typeof Ext.app.BaseController;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                             fn
		 * @param   {object}                                             scope
		 * @returns {Ext.app.Controller|Ext.app.BaseController|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.app.Controller;
		onExtended? (fn: object, scope: object): typeof Ext.app.BaseController;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.app.EventBus {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.app.EventBus](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventBus.html)
	 * This class manages event dispatching for Controllers. The details of connecting classes
	 * to this dispatching mechanism is delegated to [Ext.app.EventDomain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html) instances.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                    members    The members to add to this class.
		 * @param   {boolean}                   [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                   [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.EventBus|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.EventBus;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                    members
		 * @returns {Ext.app.EventBus|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.app.EventBus;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                    members
		 * @returns {Ext.app.EventBus|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.app.EventBus;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                    name
		 * @param   {object}                    member
		 * @returns {Ext.app.EventBus|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.app.EventBus;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                    fn
		 * @param   {object}                    scope
		 * @returns {Ext.app.EventBus|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.app.EventBus;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.app.EventDomain {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.app.EventDomain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html)
	 * This class is a base class for an event domain. In the context of MVC, an "event domain"
	 * is one or more base classes that fire events to which a Controller wants to listen. A
	 * controller listens to events by describing the selectors for events of interest to it.
	 * 
	 * Matching selectors to the firer of an event is one key aspect that defines an event
	 * domain. All event domain instances must provide a `match` method that tests selectors
	 * against the event firer.
	 * 
	 * When an event domain instance is created (typically as a `singleton`), its `type`
	 * property is used to catalog the domain in the
	 * [Ext.app.EventDomain.instances](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html#static-property-instances) map.
	 * 
	 * There are five event domains provided by default:
	 * 
	 * - [Component domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Component.html). This is the primary event domain that
	 *   has been available since Ext JS MVC was introduced. This domain is defined as any class that
	 *   extends [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html), where the selectors use
	 *   [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html#method-query).
	 * - [Global domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html). This domain provides Controllers with access
	 *   to events fired from [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance. These events represent
	 *   the state of the application as a whole, and are always anonymous. Because of this, Global
	 *   domain does not provide selectors at all.
	 * - [Controller domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html). This domain includes all classes
	 *   that extend [Ext.app.Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html). Events fired by Controllers will be available
	 *   within this domain; selectors are either Controller's [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-id) or
	 *   '*' wildcard for any Controller.
	 * - [Store domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html). This domain is for classes extending
	 *   [Ext.data.AbstractStore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.AbstractStore.html). Selectors are either Store's
	 *   [storeId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.AbstractStore.html#cfg-storeId) or '*' wildcard for any Store.
	 * - [Direct domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html). This domain includes all classes that extend
	 *   [Ext.direct.Provider](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Provider.html). Selectors are either Provider's [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Provider.html#cfg-id)
	 *   or '*' wildcard for any Provider. This domain is optional and will be loaded only if
	 *   [Ext.direct.Manager](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Manager.html) singleton is required in your application.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * An object map containing [`Ext.app.EventDomain`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html) instances keyed by the value
		 * of their `type` property.
		 * @property
		 * @public (property)
		 * @static
		 * @default {}
		 * @type {object}
		 */
		instances?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                       members    The members to add to this class.
		 * @param   {boolean}                      [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                      [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.EventDomain|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.EventDomain;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                       members
		 * @returns {Ext.app.EventDomain|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.app.EventDomain;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                       members
		 * @returns {Ext.app.EventDomain|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.app.EventDomain;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                       name
		 * @param   {object}                       member
		 * @returns {Ext.app.EventDomain|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.app.EventDomain;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                       fn
		 * @param   {object}                       scope
		 * @returns {Ext.app.EventDomain|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.app.EventDomain;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.app.Profile {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.app.Profile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html)
	 * A Profile represents a range of devices that fall under a common category. For the vast majority of apps that use
	 * device profiles, the app defines a Phone profile and a Tablet profile. Doing this enables you to easily customize
	 * the experience for the different sized screens offered by those device types.
	 * 
	 * Only one Profile can be active at a time, and each Profile defines a simple [isActive](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#method-isActive) function that should
	 * return either true or false. The first Profile to return true from its isActive function is set as your Application's
	 * [current profile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-currentProfile).
	 * 
	 * A Profile can define any number of [models](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-models), [views](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-views), [controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-controllers) and [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-stores) which
	 * will be loaded if the Profile is activated. It can also define a [launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#method-launch) function that will be called after
	 * all of its dependencies have been loaded, just before the [application launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#method-launch)
	 * function is called.
	 * 
	 * ## Sample Usage
	 * 
	 * First you need to tell your Application about your Profile(s):
	 * 
	 *    Ext.application({
	 *        name: 'MyApp',
	 *        profiles: ['Phone', 'Tablet']
	 *    });
	 * 
	 * This will load app/profile/Phone.js and app/profile/Tablet.js. Here's how we might define the Phone profile:
	 * 
	 *    Ext.define('MyApp.profile.Phone', {
	 *        extend: 'Ext.app.Profile',
	 *    
	 *        views: ['Main'],
	 *    
	 *        isActive: function() {
	 *            return Ext.os.is('Phone');
	 *        }
	 *    });
	 * 
	 * The isActive function returns true if we detect that we are running on a phone device. If that is the case the
	 * Application will set this Profile active and load the 'Main' view specified in the Profile's [views](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-views) config.
	 * 
	 * ## Class Specializations
	 * 
	 * Because Profiles are specializations of an application, all of the models, views, controllers and stores defined
	 * in a Profile are expected to be namespaced under the name of the Profile. Here's an expanded form of the example
	 * above:
	 * 
	 *    Ext.define('MyApp.profile.Phone', {
	 *        extend: 'Ext.app.Profile',
	 *    
	 *        views: ['Main'],
	 *        controllers: ['Signup'],
	 *        models: ['MyApp.model.Group'],
	 *    
	 *        isActive: function() {
	 *            return Ext.os.is('Phone');
	 *        }
	 *    });
	 * 
	 * In this case, the Profile is going to load _app/view/phone/Main.js_, _app/controller/phone/Signup.js_ and
	 * _app/model/Group.js_. Notice that in each of the first two cases the name of the profile ('phone' in this case) was
	 * injected into the class names. In the third case we specified the full Model name (for Group) so the Profile name
	 * was not injected.
	 * 
	 * For a fuller understanding of the ideas behind Profiles and how best to use them in your app, we suggest you read
	 * the [device profiles guide](/touch/2.4/core_concepts/device_profiles.html).
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                   members    The members to add to this class.
		 * @param   {boolean}                  [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                  [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.Profile|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.Profile;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                   members
		 * @returns {Ext.app.Profile|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.app.Profile;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                   members
		 * @returns {Ext.app.Profile|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.app.Profile;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                   name
		 * @param   {object}                   member
		 * @returns {Ext.app.Profile|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.app.Profile;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                   fn
		 * @param   {object}                   scope
		 * @returns {Ext.app.Profile|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.app.Profile;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.app.Util {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.app.Util](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Util.html)
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                members    The members to add to this class.
		 * @param   {boolean}               [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}               [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.Util|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.Util;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                members
		 * @returns {Ext.app.Util|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.app.Util;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                members
		 * @returns {Ext.app.Util|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.app.Util;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                name
		 * @param   {object}                member
		 * @returns {Ext.app.Util|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.app.Util;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                fn
		 * @param   {object}                scope
		 * @returns {Ext.app.Util|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.app.Util;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.app.ViewController {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.app.ViewController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html)
	 * A view controller is a controller that can be attached to a specific view
	 * instance so it can manage the view and its child components. Each instance of the view
	 * will have a new view controller, so the instances are isolated.
	 * 
	 * When a controller is specified on a view, the view automatically becomes a [Ext.container.Container.referenceHolder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-referenceHolder),
	 * so it will receive inline events declared on the view. Sample usage:
	 * 
	 *    Ext.define('User', {
	 *       extend: 'Ext.data.Model',
	 *       fields: ['name', 'phone']    
	 *    });
	 *    
	 *    Ext.define('UserListController', {
	 *        extend : 'Ext.app.ViewController',
	 *        alias: 'controller.userlist',
	 *    
	 *        init: function(view) {
	 *            this.userCount = 0;
	 *            var users = [],
	 *                i;
	 *    
	 *            for (i = 0; i &lt; 5; ++i) {
	 *                users.push(this.getUser());
	 *            }  
	 *            view.getStore().add(users);
	 *        },
	 *    
	 *        onAddClick: function() {
	 *            this.addUser();
	 *        },
	 *    
	 *        onDeleteClick: function() {
	 *            var view = this.getView(),
	 *                selected = view.getSelectionModel().getSelection()[0],
	 *                store = view.getStore();
	 *    
	 *            store.remove(selected);
	 *        },
	 *    
	 *        onSelectionChange: function(selModel, selections) {
	 *            this.lookupReference('delete').setDisabled(selections.length === 0);
	 *        },
	 *    
	 *        getUser: function() {
	 *            ++this.userCount;
	 *            return {
	 *                name: 'User ' + this.userCount,
	 *                phone: this.generatePhone()
	 *            };
	 *        },
	 *    
	 *        addUser: function() {
	 *            this.getView().getStore().add(this.getUser());    
	 *        },
	 *    
	 *        generatePhone: function() {
	 *            var num = '',
	 *                i;
	 *    
	 *            for (i = 0; i &lt; 7; ++i) {
	 *                num += Ext.Number.randomInt(0, 9);
	 *                if (num.length === 3) {
	 *                    num += '-';
	 *                }
	 *            }    
	 *            return num;
	 *        }
	 *    });
	 *    
	 *    Ext.define('UserList', {
	 *        extend: 'Ext.grid.Panel',
	 *        controller: 'userlist',
	 *    
	 *        tbar: [{
	 *            text: 'Add',
	 *            listeners: {
	 *                click: 'onAddClick'
	 *            }    
	 *        }, {
	 *            text: 'Delete',
	 *            reference: 'delete',
	 *            listeners: {
	 *                click: 'onDeleteClick'
	 *            }
	 *        }],
	 *        store: {
	 *            model: 'User'
	 *        },
	 *        selModel: {
	 *            type: 'rowmodel',
	 *            listeners: {
	 *                selectionchange: 'onSelectionChange'
	 *            }    
	 *        },
	 *        columns: [{
	 *            flex: 1,
	 *            dataIndex: 'name',
	 *            text: 'Name'
	 *        }, {
	 *            flex: 1,
	 *            dataIndex: 'phone',
	 *            text: 'Phone'
	 *        }]
	 *    });
	 *    
	 *    Ext.onReady(function() {
	 *        new UserList({
	 *            renderTo: Ext.getBody(),
	 *            width: 400,
	 *            height: 200
	 *        });
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                 members    The members to add to this class.
		 * @param   {boolean}                                                [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.ViewController;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.BaseController;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                 members
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.app.ViewController;
		addStatics? (members: object): typeof Ext.app.BaseController;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                 members
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.app.ViewController;
		addInheritableStatics? (members: object): typeof Ext.app.BaseController;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                 name
		 * @param   {object}                                                 member
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.app.ViewController;
		addMember? (name: object, member: object): typeof Ext.app.BaseController;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                 fn
		 * @param   {object}                                                 scope
		 * @returns {Ext.app.ViewController|Ext.app.BaseController|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.app.ViewController;
		onExtended? (fn: object, scope: object): typeof Ext.app.BaseController;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.app.ViewModel {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.app.ViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html)
	 * This class manages arbitrary data and its relationship to data models. Instances of
	 * `ViewModel` are associated with some `Component` and then used by their child items
	 * for the purposes of Data Binding.
	 * 
	 * # Binding
	 * 
	 * The most commonly used aspect of a `ViewModel` is the `bind` method. This method takes
	 * a "bind descriptor" (see below) and a callback to call when the data indicated by the
	 * bind descriptor either becomes available or changes.
	 * 
	 * The `bind` method, based on the bind descriptor given, will return different types of
	 * "binding" objects. These objects maintain the connection between the requested data and
	 * the callback. Bindings ultimately derive from [`Ext.app.bind.BaseBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.BaseBinding.html)
	 * which provides several methods to help manage the binding.
	 * 
	 * Perhaps the most important method is `destroy`. When the binding is no longer needed
	 * it is important to remember to `destroy` it. Leaking bindings can cause performance
	 * problems or worse when callbacks are called at unexpected times.
	 * 
	 * The types of bindings produced by `bind` are:
	 * 
	 * - [`Ext.app.bind.Binding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Binding.html)
	 * - [`Ext.app.bind.Multi`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Multi.html)
	 * - [`Ext.app.bind.TemplateBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.TemplateBinding.html)
	 * 
	 * ## Bind Descriptors
	 * 
	 * A "bind descriptor" is a value (a String, an Object or an array of these) that describe
	 * the desired data. Any piece of data in the `ViewModel` can be described by a bind
	 * descriptor.
	 * 
	 * ### Textual Bind Descriptors
	 * 
	 * The simplest and most common form of bind descriptors are strings that look like an
	 * [`Ext.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Template.html) containing text and tokens surrounded by "{}" with dot notation inside
	 * to traverse objects and their properties.
	 * 
	 * For example:
	 * 
	 * - `'Hello {user.name}!'`
	 * - `'You have selected "{selectedItem.text}".'`
	 * - `'{user.groups}'`
	 * 
	 * The first two bindings are [`template bindings`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.TemplateBinding.html)
	 * which use the familiar [`Ext.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Template.html) syntax with some slight differences. For more on
	 * templates see [`Ext.app.bind.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Template.html).
	 * 
	 * The third bind descriptor is called a "direct bind descriptor". This special form of
	 * bind maps one-to-one to some piece of data in the `ViewModel` and is managed by the
	 * [`Ext.app.bind.Binding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Binding.html) class.
	 * 
	 * #### Two-Way Descriptors
	 * 
	 * A direct bind descriptor may be able to write back a value to the `ViewModel` as well
	 * as retrieve one. When this is the case, they are said to be "two-way". For example:
	 * 
	 *     var binding = viewModel.bind('{s}', function(x) { console.log('s=' + s); });
	 *    
	 *     binding.setValue('abc');
	 * 
	 * Direct use of `ViewModel` in this way is not commonly needed because [`Ext.Component`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)
	 * automates this process. For example, a `textfield` component understands when it is
	 * given a "two-way" binding and automatically synchronizes its value bidirectionally using
	 * the above technique. For example:
	 * 
	 *     Ext.widget({
	 *         items: [{
	 *             xtype: 'textfield',
	 *             bind: '{s}'  // a two-way / direct bind descriptor
	 *         }]
	 *     });
	 * 
	 * ### Object and Array Descriptors / Multi-Bind
	 * 
	 * With two exceptions (see below) an Object is interpreted as a "shape" to produce by
	 * treating each of its properties as individual bind descriptors. An object of the same
	 * shape is passed as the value of the bind except that each property is populated with
	 * the appropriate value. Of course, this definition is recursive, so these properties
	 * may also be objects.
	 * 
	 * For example:
	 * 
	 *     viewModel.bind({
	 *             x: '{x}',
	 *             foo: {
	 *                 bar: 'Hello {foo.bar}'
	 *             }
	 *         },
	 *         function (obj) {
	 *             //  obj = {
	 *             //      x: 42,
	 *             //      foo: {
	 *             //          bar: 'Hello foobar'
	 *             //      }
	 *             //  }
	 *         });
	 * 
	 * Arrays are handled in the same way. Each element of the array is considered a bind
	 * descriptor (recursively) and the value produced for the binding is an array with each
	 * element set to the bound property.
	 * 
	 * ### Bind Options
	 * 
	 * One exception to the "object is a multi-bind" rule is when that object contains a
	 * `bindTo` property. When an object contains a `bindTo` property the object is understood
	 * to contain bind options and the value of `bindTo` is considered the actual bind
	 * descriptor.
	 * 
	 * For example:
	 * 
	 *     viewModel.bind({
	 *             bindTo: '{x}',
	 *             single: true
	 *         },
	 *         function (x) {
	 *             console.log('x: ' + x); // only called once
	 *         });
	 * 
	 * The available bind options depend on the type of binding, but since all bindings
	 * derive from [`Ext.app.bind.BaseBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.BaseBinding.html) its options are always applicable.
	 * For a list of the other types of bindings, see above.
	 * 
	 * #### Deep Binding
	 * 
	 * When a direct bind is made and the bound property is an object, by default the binding
	 * callback is only called when that reference changes. This is the most efficient way to
	 * understand a bind of this type, but sometimes you may need to be notified if any of the
	 * properties of that object change.
	 * 
	 * To do this, we create a "deep bind":
	 * 
	 *     viewModel.bind({
	 *             bindTo: '{someObject}',
	 *             deep: true
	 *         },
	 *         function (someObject) {
	 *             // called when reference changes or *any* property changes
	 *         });
	 * 
	 * #### Binding Timings
	 * 
	 * The `ViewModel` has a [scheduler](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-scheduler) attached that is used to coordinate the firing of bindings.
	 * It serves 2 main purposes:
	 * 
	 * - To coordinate dependencies between bindings. This means bindings will be fired in an order such that
	 *   the any dependencies for a binding are fired before the binding itself.
	 * - To batch binding firings. The scheduler runs on a short timer, so the following code will only trigger
	 *   a single binding (the last), the changes in between will never be triggered.
	 * 
	 *      viewModel.bind('{val}', function(v) {
	 *          console.log(v);
	 *      });
	 *      viewModel.set('val', 1);
	 *      viewModel.set('val', 2);
	 *      viewModel.set('val', 3);
	 *      viewModel.set('val', 4);
	 * 
	 * The `ViewModel` can be forced to process by calling [`notify`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#method-notify), which will force the
	 * scheduler to run immediately in the current state.
	 * 
	 *    viewModel.bind('{val}', function(v) {
	 *        console.log(v);
	 *    });
	 *    viewModel.set('val', 1);
	 *    viewModel.notify();
	 *    viewModel.set('val', 2);
	 *    viewModel.notify();
	 *    viewModel.set('val', 3);
	 *    viewModel.notify();
	 *    viewModel.set('val', 4);
	 *    viewModel.notify();
	 * 
	 * #### Models, Stores and Associations
	 * 
	 * A [Session](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Session.html) manages model instances and their associations.
	 * The `ViewModel` may be used with or without a `Session`. When a `Session` is attached, the
	 * `ViewModel` will always consult the `Session` to ask about records and stores. The `Session`
	 * ensures that only a single instance of each model Type/Id combination is created. This is
	 * important when tracking changes in models so that we always have the same reference.
	 * 
	 * A `ViewModel` provides functionality to easily consume the built in data package types
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) and [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), as well as their associations.
	 * 
	 * ### Model Links
	 * 
	 * A model can be described declaratively using a [&lt;code&gt;link&lt;/code&gt;](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-links). In the example code below,
	 * We ask the `ViewModel` to construct a record of type `User` with `id: 17`. The model will be loaded
	 * from the server and the bindings will trigger once the load has completed. Similarly, we could also
	 * attach a model instance to the `ViewModel` data directly.
	 * 
	 *    Ext.define('MyApp.model.User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name']
	 *    });
	 *    
	 *    var rec = new MyApp.model.User({
	 *        id: 12,
	 *        name: 'Foo'
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            theUser: {
	 *                type: 'User',
	 *                id: 17
	 *            }
	 *        },
	 *        data: {
	 *            otherUser: rec
	 *        }
	 *    });
	 *    viewModel.bind('{theUser.name}', function(v) {
	 *        console.log(v);
	 *    });
	 *    viewModel.bind('{otherUser.name}', function(v) {
	 *        console.log(v);
	 *    });
	 * 
	 * ### Model Fields
	 * 
	 * Bindings have the functionality to inspect the parent values and resolve the underlying
	 * value dynamically. This behavior allows model fields to be interrogated as part of a binding.
	 * 
	 *    Ext.define('MyApp.model.User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name', 'age']
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            theUser: {
	 *                type: 'User',
	 *                id: 22
	 *            }
	 *        }
	 *    });
	 *    
	 *    // Server responds with:
	 *    {
	 *        "id": 22,
	 *        "name": "Foo",
	 *        "age": 100
	 *    }
	 *    
	 *    viewModel.bind('Hello {name}, you are {age} years old', function(v) {
	 *        console.log(v);
	 *    });
	 * 
	 * ### Associations
	 * 
	 * In the same way as fields, the bindings can also traverse associations in a bind statement.
	 * The `ViewModel` will handle the asynchronous loading of data and only present the value once
	 * the full path has been loaded. For more information on associations see [OneToOne](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.schema.OneToOne.html) and
	 * [ManyToOne](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.schema.ManyToOne.html) associations.
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name']
	 *    });
	 *    
	 *    Ext.define('Order', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['date', {
	 *            name: 'userId',
	 *            reference: 'User'
	 *        }]
	 *    });
	 *    
	 *    Ext.define('OrderItem', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['price', 'qty', {
	 *            name: 'orderId',
	 *            reference: 'Order'
	 *        }]
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            orderItem: {
	 *                type: 'OrderItem',
	 *                id: 13
	 *            }
	 *        }
	 *    });
	 *    // The viewmodel will handle both ways of loading the data:
	 *    // a) If the data is loaded inline in a nested fashion it will
	 *    //    not make requests for extra data
	 *    // b) Only loading a single model at a time. So the Order will be loaded once
	 *    //    the OrderItem returns. The User will be loaded once the Order loads.
	 *    viewModel.bind('{orderItem.order.user.name}', function(name) {
	 *        console.log(name);
	 *    });
	 * 
	 * ### Stores
	 * 
	 * Stores can be created as part of the `ViewModel` definition. The definitions are processed
	 * like bindings which allows for very powerful dynamic functionality.
	 * 
	 * It is important to ensure that you name viewModel's data keys uniquely. If data is not named<br/>
	 * uniquely, binds and formulas may receive information from an unintended data source.<br/>
	 * This applies to keys in the viewModel's data block, stores, and links configs.
	 * 
	 *    var viewModel = new Ext.app.ViewModel({
	 *        stores: {
	 *            users: {
	 *                model: 'User',
	 *                autoLoad: true,
	 *                filters: [{
	 *                    property: 'createdDate',
	 *                    value: '{createdFilter}',
	 *                    operator: '&gt;'
	 *                }]
	 *            }
	 *        }
	 *    });
	 *    // Later on in our code, we set the date so that the store is created.
	 *    viewModel.set('createdFilter', Ext.Date.subtract(new Date(), Ext.Date.DAY, 7));
	 * 
	 * See [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-stores) for more detail.
	 * 
	 * #### Formulas
	 * 
	 * Formulas allow for calculated `ViewModel` data values. The dependencies for these formulas
	 * are automatically determined so that the formula will not be processed until the required
	 * data is present.
	 * 
	 *     var viewModel = new Ext.app.ViewModel({
	 *         formulas: {
	 *             fullName: function(get) {
	 *                 return get('firstName') + ' ' + get('lastName');
	 *             }
	 *         },
	 *         data: {firstName: 'John', lastName: 'Smith'}
	 *     });
	 *     viewModel.bind('{fullName}', function(v) {
	 *         console.log(v);
	 *     });
	 * 
	 * See [formulas](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-formulas) for more detail.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                     members    The members to add to this class.
		 * @param   {boolean}                    [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                    [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.app.ViewModel|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.app.ViewModel;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                     members
		 * @returns {Ext.app.ViewModel|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.app.ViewModel;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                     members
		 * @returns {Ext.app.ViewModel|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.app.ViewModel;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                     name
		 * @param   {object}                     member
		 * @returns {Ext.app.ViewModel|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.app.ViewModel;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                     fn
		 * @param   {object}                     scope
		 * @returns {Ext.app.ViewModel|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.app.ViewModel;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.app.Application.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.app.Application.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.app.Application.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.app.Application.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.app.BaseController.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.app.BaseController.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.app.BaseController.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.app.BaseController.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.app.Controller.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.app.Controller.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.app.Controller.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.app.Controller.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.app.Profile.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.app.Profile.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.app.Profile.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.app.Profile.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.app.ViewController.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.app.ViewController.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.app.ViewController.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.app.ViewController.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.app.Application {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)
	 * Represents an Ext JS application, which is typically a single page app using a
	 * [Viewport](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Viewport.html).
	 * 
	 * An application consists of one or more Views. The behavior of a View is managed by its
	 * corresponding [ViewController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html) and [ViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html).
	 * 
	 * Global activities are coordinated by [Controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html) which are
	 * ultimately instantiated by an instance of this (or a derived) class.
	 * 
	 *    Ext.application({
	 *        name: 'MyApp',
	 *    
	 *        // An instance of this view is created and set as the Viewport:
	 *        autoCreateViewport: 'MyApp.view.Main'
	 *    });
	 * 
	 * This does several things. First it creates a global variable called 'MyApp' - all of
	 * your Application's classes (such as its Models, Views and Controllers) will reside under
	 * this single namespace, which drastically lowers the chances of colliding global variables.
	 * 
	 * The MyApp global will also have a getApplication method to get a reference to the current
	 * application:
	 * 
	 *    var app = MyApp.getApplication();
	 * 
	 * # Telling Application about the rest of the app
	 * 
	 * Because an [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) represents an entire app, we should tell it about the other
	 * parts of the app - namely the Models, Views and Controllers that are bundled with the application. Let's say we have a blog management app; we
	 * might have Models and Controllers for Posts and Comments, and Views for listing, adding and editing Posts and Comments.
	 * Here's how we'd tell our Application about all these things:
	 * 
	 *    Ext.application({
	 *        name: 'Blog',
	 *    
	 *        models: ['Post', 'Comment'],
	 *    
	 *        controllers: ['Posts', 'Comments'],
	 *    
	 *        launch: function() {
	 *            ...
	 *        }
	 *    });
	 * 
	 * Note that we didn't actually list the Views directly in the Application itself. This is because Views are managed by
	 * Controllers, so it makes sense to keep those dependencies there. The Application will load each of the specified
	 * Controllers using the pathing conventions laid out in the [application architecture guide](../application_architecture/application_architecture.html) - in this case
	 * expecting the controllers to reside in app/controller/Posts.js and app/controller/Comments.js. In turn, each
	 * Controller simply needs to list the Views it uses and they will be automatically loaded. Here's how our Posts
	 * controller like be defined:
	 * 
	 *    Ext.define('MyApp.controller.Posts', {
	 *        extend: 'Ext.app.Controller',
	 *        views: ['posts.List', 'posts.Edit'],
	 *    
	 *        //the rest of the Controller here
	 *    });
	 * 
	 * Because we told our Application about our Models and Controllers, and our Controllers about their Views, Ext JS will
	 * automatically load all of our app files for us. This means we don't have to manually add script tags into our html
	 * files whenever we add a new class, but more importantly it enables us to create a minimized build of our entire
	 * application using Sencha Cmd.
	 * 
	 * # Deriving from [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)
	 * 
	 * Typically, applications do not derive directly from [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html). Rather, the
	 * configuration passed to [`Ext.application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-application) mimics what you might do in a derived class.
	 * In some cases, however, it can be desirable to share logic by using a derived class
	 * from [`Ext.app.Application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html).
	 * 
	 * Derivation works as you would expect, but using the derived class should still be the
	 * job of the [`Ext.application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-application) method.
	 * 
	 *    Ext.define('MyApp.Application', {
	 *        extend: 'Ext.app.Application',
	 *        name: 'MyApp',
	 *        ...
	 *    });
	 *    
	 *    Ext.application('MyApp.Application');
	 * 
	 * For more information about writing Ext JS applications, please see the [application architecture guide](../../../application_architecture/application_architecture.html).
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		active?: boolean;
		/** 
		 * The path to the directory which contains all application's classes.
		 * This path will be registered via [Ext.Loader.setPath](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#method-setPath) for the namespace specified
		 * in the [name](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-name) config.
		 * @configuration
		 * @optional
		 * @default "app"
		 * @type {string}
		 */
		appFolder?: string;
		/** 
		 * The name of a property to be assigned to the main namespace to gain a reference to
		 * this application. Can be set to an empty value to prevent the reference from
		 * being created
		 * 
		 *    Ext.application({
		 *        name: 'MyApp',
		 *        appProperty: 'myProp',
		 *    
		 *        launch: function() {
		 *            console.log(MyApp.myProp === this);
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @default 'app'
		 * @type {string}
		 */
		appProperty?: string;
		/** 
		 * The [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) for this controller accessible via the getApplication method.
		 * @configuration
		 * @optional
		 * @type {Ext.app.Application}
		 */
		application?: Ext.app.Application;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		before?: object;
		/** 
		 * Adds listeners to components selected via [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html). Accepts an
		 * object containing component paths mapped to a hash of listener functions.<br/>
		 * The function value may also be a string matching the name of a method on the
		 * controller.
		 * 
		 * In the following example the `updateUser` function is mapped to to the `click`
		 * event on a button component, which is a child of the `useredit` component.
		 * 
		 *     Ext.define('MyApp.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         control: {
		 *             'useredit button[action=save]': {
		 *                 click: 'updateUser'
		 *             }
		 *         },
		 *    
		 *         updateUser: function(button) {
		 *             console.log('clicked the Save button');
		 *         }
		 *     });
		 * 
		 * The method you pass to the listener will automatically be resolved on the controller.
		 * In this case, the `updateUser` method that will get executed on the `button` `click`
		 * event will resolve to the `updateUser` method on the controller,
		 * 
		 * See [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) for more information on component selectors.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		control?: object;
		/** 
		 * Names of [controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html) that the app uses.  By default,
		 * the framework will look for the controllers in the "controller" folder within the
		 * [appFolder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-appFolder).  Controller classes should be named using the syntax of
		 * "{appName}.controller.{ClassName}" with additional sub-folders under the
		 * "controller" folder specified within the class name following "controller.".
		 * 
		 *    // by default, the following controller class would be located at:
		 *    // app/controller/Main.js
		 *    controllers: '.Main' // or 'MyApp.controller.Main'
		 *    
		 *    // while the following would be located at:
		 *    // app/controller/customer/Main.js
		 *    controllers: 'customer.Main' // or 'MyApp.controller.customer.Main'
		 * 
		 * **Note:** If the controller has a different namespace than that of the
		 * application you will need to specify the full class name as well as define a path
		 * in the [Loader's paths](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#cfg-paths) config or
		 * [setPath](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#method-setPath) method.
		 * @configuration
		 * @optional
		 * @type {string|string[]}
		 */
		controllers?: string | string[];
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.app.Profile}
		 */
		currentProfile?: Ext.app.Profile;
		/** 
		 * The default token to be used at application launch
		 * if one is not present. Often this is set to something like `'home'`.
		 * @configuration
		 * @optional
		 * @default null
		 * @type {string}
		 */
		defaultToken?: string;
		/** 
		 * A class name to use with the [`Ext.application`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-application) call. The class must also extend [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html).
		 * 
		 *    Ext.define('MyApp.Application', {
		 *        extend: 'Ext.app.Application',
		 *    
		 *        launch: function() {
		 *            Ext.direct.Manager.addProvider(Ext.REMOTING_API);
		 *        }
		 *    });
		 *    
		 *    Ext.application({
		 *        extend: 'MyApp.Application'
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * The glyphFontFamily to use for this application.  Used as the default font-family
		 * for all components that support a `glyph` config.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		glyphFontFamily?: string;
		/** 
		 * The id of this controller. You can use this id when dispatching.
		 * 
		 * For an example of dispatching, see the examples under the
		 * [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-listen) config.
		 * 
		 * If an id is not explicitly set, it will default to the controller's full classname.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		id?: string;
		/** 
		 * Adds listeners to different event sources (also called "event domains"). The
		 * primary event domain is that of components, but there are also other event domains:
		 * [Global](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html) domain that intercepts events fired from
		 * [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance,
		 * [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html) domain can be used to listen to events
		 * fired by other Controllers, [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html) domain gives access to
		 * Store events, and [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html) domain can be used with
		 * Ext Direct Providers to listen to their events.
		 * 
		 * To listen to "bar" events fired by a controller with id="foo":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             controller: {
		 *                 '#foo': {
		 *                     bar: 'onFooBar'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * To listen to "bar" events fired by any controller, and "baz" events
		 * fired by Store with storeId="baz":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             controller: {
		 *                 '*': {
		 *                     bar: 'onAnyControllerBar'
		 *                 }
		 *             },
		 *             store: {
		 *                 '#baz': {
		 *                     baz: 'onStoreBaz'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * To listen to "idle" events fired by [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) when other event
		 * processing is complete and Ext JS is about to return control to the browser:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             global: {            // Global events are always fired
		 *                 idle: 'onIdle'   // from the same object, so there
		 *             }                    // are no selectors
		 *         }
		 *     });
		 * 
		 * As this relates to components, the following example:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             component: {
		 *                 'useredit button[action=save]': {
		 *                     click: 'updateUser'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * Is equivalent to:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         control: {
		 *             'useredit button[action=save]': {
		 *                 click: 'updateUser'
		 *             }
		 *         }
		 *     });
		 * 
		 * Of course, these can all be combined in a single call and used instead of
		 * `control`, like so:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             global: {
		 *                 idle: 'onIdle'
		 *             },
		 *             controller: {
		 *                 '*': {
		 *                     foobar: 'onAnyFooBar'
		 *                 },
		 *                 '#foo': {
		 *                     bar: 'onFooBar'
		 *                 }
		 *             },
		 *             component: {
		 *                 'useredit button[action=save]': {
		 *                     click: 'updateUser'
		 *                 }
		 *             },
		 *             store: {
		 *                 '#qux': {
		 *                     load: 'onQuxLoad'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listen?: object;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * @configuration
		 * @optional
		 * @default {$value: null, lazy: true}
		 * @type {string|object}
		 */
		mainView?: string | object;
		/** 
		 * Array of models to require from AppName.model namespace. For example:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *         models: ['User', 'Vehicle']
		 *     });
		 * 
		 * This is equivalent to:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *         requires: ['MyApp.model.User', 'MyApp.model.Vehicle'],
		 *    
		 *         getUserModel: function() {
		 *             return this.getModel("User");
		 *         },
		 *    
		 *         getVehicleModel: function() {
		 *             return this.getModel("Vehicle");
		 *         }
		 *     });
		 * 
		 * **Note:** If the model has a different namespace than that of the
		 * application you will need to specify the full class name as well as define a path
		 * in the [Loader's paths](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#cfg-paths) config or
		 * [setPath](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#method-setPath) method.
		 * @configuration
		 * @optional
		 * @type {string|string[]}
		 */
		models?: string | string[];
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		moduleClassName?: object;
		/** 
		 * The name of your application. This will also be the namespace for your views, controllers
		 * models and stores. Don't use spaces or special characters in the name. **Application name
		 * is mandatory**.
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		name?: string;
		/** 
		 * The list of namespace prefixes used in the application to resolve dependencies
		 * like Views and Stores:
		 * 
		 *     Ext.application({
		 *         name: 'MyApp',
		 *    
		 *         namespaces: ['Common.code'],
		 *    
		 *         controllers: [ 'Common.code.controller.Foo', 'Bar' ]
		 *     });
		 *    
		 *     Ext.define('Common.code.controller.Foo', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         models: ['Foo'],    // Loads Common.code.model.Foo
		 *         views:  ['Bar']     // Loads Common.code.view.Bar
		 *     });
		 *    
		 *     Ext.define('MyApp.controller.Bar', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         models: ['Foo'],    // Loads MyApp.model.Foo
		 *         views:  ['Bar']     // Loads MyApp.view.Bar
		 *     });
		 * 
		 * You don't need to include main namespace (MyApp), it will be added to the list
		 * automatically.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {string|string[]}
		 */
		namespaces?: string | string[];
		/** 
		 * Additional load paths to add to [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html).
		 * See [Ext.Loader.paths](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#cfg-paths) config for more details.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		paths?: object;
		/** 
		 * Names of the profiles that the app uses.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {string|string[]}
		 */
		profiles?: string | string[];
		/** 
		 * The refs config creates a getter method on the controller that internally
		 * uses [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) to fetch the component instance using the configured
		 * selector.  The following example will add the `getList` method to
		 * the controller and will return the first component in the application
		 * hierarchy with an xtype of "grid".  By default, _undefined_ will be returned
		 * when the query does not locate the target component.
		 * 
		 *    Ext.define('MyApp.controller.Foo', {
		 *        extend: 'Ext.app.Controller',
		 *    
		 *        refs: [{
		 *            ref: 'list',
		 *            selector: 'grid'
		 *        }]
		 *    });
		 * 
		 * The following fields may be used in the ref definition:
		 * 
		 * - `ref` - name of the reference.
		 * - `selector` - [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) selector to access the component.
		 * - `autoCreate` - True to create the component automatically if not found on
		 *   page.
		 * - `forceCreate` - True to force the creation of the component every time
		 *   reference is accessed (when `get&lt;REFNAME&gt;` is called).
		 * - `xtype` - Used to create the component by its xtype with `autoCreate` or
		 *   `forceCreate`. If you don't provide `xtype`, an [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) instance will
		 *   be created.
		 * 
		 * The following example will create a `getList` and `getUser` method on the
		 * controller.
		 * 
		 *    Ext.define('MyApp.controller.Foo', {
		 *        extend: 'Ext.app.Controller',
		 *    
		 *        refs: [{
		 *            list: 'grid',
		 *            user: {
		 *                autoCreate: true,
		 *                selector: 'form',
		 *                xtype: 'form'
		 *            }
		 *        }]
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object|object[]}
		 */
		refs?: object | object[];
		/** 
		 * An object of routes to handle hash changes. A route can be defined in a simple way:
		 * 
		 *    routes : {
		 *        'foo/bar'  : 'handleFoo',
		 *        'user/:id' : 'showUser'
		 *    }
		 * 
		 * Where the property is the hash (which can accept a parameter defined by a colon) and the value
		 * is the method on the controller to execute. The parameters will get sent in the action method.
		 * 
		 * At the application level, you can define a event that will be executed when no matching
		 * routes are found.
		 * 
		 *    Ext.application({
		 *        name: 'MyApp',
		 *        listen: {
		 *            controller: {
		 *                '#': {
		 *                    unmatchedroute: 'onUnmatchedRoute'
		 *                }
		 *            }
		 *        },
		 *    
		 *        onUnmatchedRoute: function(hash) {
		 *            console.log('Unmatched', hash);
		 *            // Do something...
		 *        }
		 *    });
		 * 
		 * There is also a complex means of defining a route where you can use a before action and even
		 * specify your own RegEx for the parameter:
		 * 
		 *    routes : {
		 *        'foo/bar'  : {
		 *            action  : 'handleFoo',
		 *            before  : 'beforeHandleFoo'
		 *        },
		 *        'user/:id' : {
		 *            action     : 'showUser',
		 *            before     : 'beforeShowUser',
		 *            conditions : {
		 *                ':id' : '([0-9]+)'
		 *            }
		 *        }
		 *    }
		 * 
		 * This will only match if the `id` parameter is a number.
		 * 
		 * The before action allows you to cancel an action. Every before action will get passed an `action` argument with
		 * a `resume` and `stop` methods as the last argument of the method and you _MUST_ execute either method:
		 * 
		 *    beforeHandleFoo : function(action) {
		 *        //some logic here
		 *    
		 *        //this will allow the handleFoo action to be executed
		 *        action.resume();
		 *    },
		 *    handleFoo : function() {
		 *        //will get executed due to true being passed in callback in beforeHandleFoo
		 *    },
		 *    beforeShowUser : function(id, action) {
		 *        //allows for async process like an Ajax
		 *        Ext.Ajax.request({
		 *            url     : 'foo.php',
		 *            success : function() {
		 *                //will not allow the showUser method to be executed but will continue other queued actions.
		 *                action.stop();
		 *            },
		 *            failure : function() {
		 *                //will not allow the showUser method to be executed and will not allow other queued actions to be executed.
		 *                action.stop(true);
		 *            }
		 *        });
		 *    },
		 *    showUser : function(id) {
		 *        //will not get executed due to false being passed in callback in beforeShowUser
		 *    }
		 * 
		 * You _MUST_ execute the `resume` or `stop` method on the `action` argument. Executing `action.resume();` will continue
		 * the action, `action.stop();` will not allow the action to resume but will allow other queued actions to resume,
		 * `action.stop(true);` will not allow the action and any other queued actions to resume.
		 * 
		 * The default RegEx that will be used is `([%a-zA-Z0-9\\-\\_\\s,]+)` but you can specify any
		 * that may suit what you need to accomplish. An example of an advanced condition may be to make
		 * a parameter optional and case-insensitive:
		 * 
		 *    routes : {
		 *        'user:id' : {
		 *            action     : 'showUser',
		 *            before     : 'beforeShowUser',
		 *            conditions : {
		 *                ':id' : '(?:(?:\/){1}([%a-z0-9_,\s\-]+))?'
		 *            }
		 *        }
		 *    }
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		routes?: object;
		/** 
		 * The scope to execute the [launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#method-launch) function in. Defaults to the Application instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * Array of stores to require from AppName.store namespace and to generate getter methods for.
		 * For example:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *         stores: ['Users', 'Vehicles']
		 *     });
		 * 
		 * This is equivalent to:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *    
		 *         requires: [
		 *             'MyApp.store.Users',
		 *             'MyApp.store.Vehicles'
		 *         ]
		 *    
		 *         getUsersStore: function() {
		 *             return this.getStore("Users");
		 *         },
		 *    
		 *         getVehiclesStore: function() {
		 *             return this.getStore("Vehicles");
		 *         }
		 *     });
		 * 
		 * **Note:** If the store has a different namespace than that of the
		 * application you will need to specify the full class name as well as define a path
		 * in the [Loader's paths](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#cfg-paths) config or
		 * [setPath](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#method-setPath) method.
		 * @configuration
		 * @optional
		 * @type {string|string[]}
		 */
		stores?: string | string[];
		/** 
		 * Array of views to require from AppName.view namespace and to generate getter methods for.
		 * For example:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *         views: ['List', 'Detail']
		 *     });
		 * 
		 * This is equivalent to:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *         requires: ['MyApp.view.List', 'MyApp.view.Detail'],
		 *    
		 *         getListView: function() {
		 *             return this.getView("List");
		 *         },
		 *    
		 *         getDetailView: function() {
		 *             return this.getView("Detail");
		 *         }
		 *     });
		 * 
		 * **Note:** If the view has a different namespace than that of the
		 * application you will need to specify the full class name as well as define a path
		 * in the [Loader's paths](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#cfg-paths) config or
		 * [setPath](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#method-setPath) method.
		 * @configuration
		 * @optional
		 * @type {string|string[]}
		 */
		views?: string | string[];
		/** 
		 * A template method that is called when your application boots. It is called before the
		 * [Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)'s launch function is executed so gives a hook point
		 * to run any code before your Viewport is created.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.app.Application} application
		 * @returns {void}                            
		 */
		init? (application: Ext.app.Application): void;
		/** 
		 * Called automatically when the page has completely loaded. This is an empty function that should be
		 * overridden by each application that needs to take action on page load.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {string}  profile The detected application profile
		 * @returns {boolean} 
		 * By default, the Application will dispatch to the configured startup controller and
		 * action immediately after running the launch function. Return false to prevent this behavior.
		 */
		launch? (profile: string): boolean;
		/** 
		 * Called automatically when an update to either the Application Cache or the Local Storage Cache is detected.
		 * This is mainly used during production builds.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {object} [updateInfo] updateInfo Update information object contains properties for checking which cache triggered the update
		 * @returns {void}                
		 */
		onAppUpdate? (updateInfo?: object): void;
		/** 
		 * A template method like [init](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-init), but called after the viewport is created.
		 * This is called after the [launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#method-launch) method of Application
		 * is executed.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.app.Application} application
		 * @returns {void}                            
		 */
		onLaunch? (application: Ext.app.Application): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.app.Application.Statics}        this
		 */
		initConfig? (config: object): Ext.app.Application.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.app.Application.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.Application.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.Application.Statics}  
		 */
		statics? (): Ext.app.Application.Statics;
	}
}
declare namespace Ext.app.BaseController {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.app.BaseController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html)
	 * Base class for Controllers.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		before?: object;
		/** 
		 * Adds listeners to components selected via [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html). Accepts an
		 * object containing component paths mapped to a hash of listener functions.<br/>
		 * The function value may also be a string matching the name of a method on the
		 * controller.
		 * 
		 * In the following example the `updateUser` function is mapped to to the `click`
		 * event on a button component, which is a child of the `useredit` component.
		 * 
		 *     Ext.define('MyApp.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         control: {
		 *             'useredit button[action=save]': {
		 *                 click: 'updateUser'
		 *             }
		 *         },
		 *    
		 *         updateUser: function(button) {
		 *             console.log('clicked the Save button');
		 *         }
		 *     });
		 * 
		 * The method you pass to the listener will automatically be resolved on the controller.
		 * In this case, the `updateUser` method that will get executed on the `button` `click`
		 * event will resolve to the `updateUser` method on the controller,
		 * 
		 * See [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) for more information on component selectors.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		control?: object;
		/** 
		 * The id of this controller. You can use this id when dispatching.
		 * 
		 * For an example of dispatching, see the examples under the
		 * [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-listen) config.
		 * 
		 * If an id is not explicitly set, it will default to the controller's full classname.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		id?: string;
		/** 
		 * Adds listeners to different event sources (also called "event domains"). The
		 * primary event domain is that of components, but there are also other event domains:
		 * [Global](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html) domain that intercepts events fired from
		 * [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance,
		 * [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html) domain can be used to listen to events
		 * fired by other Controllers, [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html) domain gives access to
		 * Store events, and [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html) domain can be used with
		 * Ext Direct Providers to listen to their events.
		 * 
		 * To listen to "bar" events fired by a controller with id="foo":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             controller: {
		 *                 '#foo': {
		 *                     bar: 'onFooBar'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * To listen to "bar" events fired by any controller, and "baz" events
		 * fired by Store with storeId="baz":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             controller: {
		 *                 '*': {
		 *                     bar: 'onAnyControllerBar'
		 *                 }
		 *             },
		 *             store: {
		 *                 '#baz': {
		 *                     baz: 'onStoreBaz'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * To listen to "idle" events fired by [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) when other event
		 * processing is complete and Ext JS is about to return control to the browser:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             global: {            // Global events are always fired
		 *                 idle: 'onIdle'   // from the same object, so there
		 *             }                    // are no selectors
		 *         }
		 *     });
		 * 
		 * As this relates to components, the following example:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             component: {
		 *                 'useredit button[action=save]': {
		 *                     click: 'updateUser'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * Is equivalent to:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         control: {
		 *             'useredit button[action=save]': {
		 *                 click: 'updateUser'
		 *             }
		 *         }
		 *     });
		 * 
		 * Of course, these can all be combined in a single call and used instead of
		 * `control`, like so:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             global: {
		 *                 idle: 'onIdle'
		 *             },
		 *             controller: {
		 *                 '*': {
		 *                     foobar: 'onAnyFooBar'
		 *                 },
		 *                 '#foo': {
		 *                     bar: 'onFooBar'
		 *                 }
		 *             },
		 *             component: {
		 *                 'useredit button[action=save]': {
		 *                     click: 'updateUser'
		 *                 }
		 *             },
		 *             store: {
		 *                 '#qux': {
		 *                     load: 'onQuxLoad'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listen?: object;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * An object of routes to handle hash changes. A route can be defined in a simple way:
		 * 
		 *    routes : {
		 *        'foo/bar'  : 'handleFoo',
		 *        'user/:id' : 'showUser'
		 *    }
		 * 
		 * Where the property is the hash (which can accept a parameter defined by a colon) and the value
		 * is the method on the controller to execute. The parameters will get sent in the action method.
		 * 
		 * At the application level, you can define a event that will be executed when no matching
		 * routes are found.
		 * 
		 *    Ext.application({
		 *        name: 'MyApp',
		 *        listen: {
		 *            controller: {
		 *                '#': {
		 *                    unmatchedroute: 'onUnmatchedRoute'
		 *                }
		 *            }
		 *        },
		 *    
		 *        onUnmatchedRoute: function(hash) {
		 *            console.log('Unmatched', hash);
		 *            // Do something...
		 *        }
		 *    });
		 * 
		 * There is also a complex means of defining a route where you can use a before action and even
		 * specify your own RegEx for the parameter:
		 * 
		 *    routes : {
		 *        'foo/bar'  : {
		 *            action  : 'handleFoo',
		 *            before  : 'beforeHandleFoo'
		 *        },
		 *        'user/:id' : {
		 *            action     : 'showUser',
		 *            before     : 'beforeShowUser',
		 *            conditions : {
		 *                ':id' : '([0-9]+)'
		 *            }
		 *        }
		 *    }
		 * 
		 * This will only match if the `id` parameter is a number.
		 * 
		 * The before action allows you to cancel an action. Every before action will get passed an `action` argument with
		 * a `resume` and `stop` methods as the last argument of the method and you _MUST_ execute either method:
		 * 
		 *    beforeHandleFoo : function(action) {
		 *        //some logic here
		 *    
		 *        //this will allow the handleFoo action to be executed
		 *        action.resume();
		 *    },
		 *    handleFoo : function() {
		 *        //will get executed due to true being passed in callback in beforeHandleFoo
		 *    },
		 *    beforeShowUser : function(id, action) {
		 *        //allows for async process like an Ajax
		 *        Ext.Ajax.request({
		 *            url     : 'foo.php',
		 *            success : function() {
		 *                //will not allow the showUser method to be executed but will continue other queued actions.
		 *                action.stop();
		 *            },
		 *            failure : function() {
		 *                //will not allow the showUser method to be executed and will not allow other queued actions to be executed.
		 *                action.stop(true);
		 *            }
		 *        });
		 *    },
		 *    showUser : function(id) {
		 *        //will not get executed due to false being passed in callback in beforeShowUser
		 *    }
		 * 
		 * You _MUST_ execute the `resume` or `stop` method on the `action` argument. Executing `action.resume();` will continue
		 * the action, `action.stop();` will not allow the action to resume but will allow other queued actions to resume,
		 * `action.stop(true);` will not allow the action and any other queued actions to resume.
		 * 
		 * The default RegEx that will be used is `([%a-zA-Z0-9\\-\\_\\s,]+)` but you can specify any
		 * that may suit what you need to accomplish. An example of an advanced condition may be to make
		 * a parameter optional and case-insensitive:
		 * 
		 *    routes : {
		 *        'user:id' : {
		 *            action     : 'showUser',
		 *            before     : 'beforeShowUser',
		 *            conditions : {
		 *                ':id' : '(?:(?:\/){1}([%a-z0-9_,\s\-]+))?'
		 *            }
		 *        }
		 *    }
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		routes?: object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                         config
		 * @returns {Ext.app.BaseController.Statics}        this
		 */
		initConfig? (config: object): Ext.app.BaseController.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                  name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                         [value] The value to set for the name parameter.
		 * @returns {Ext.app.BaseController.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.BaseController.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.BaseController.Statics}  
		 */
		statics? (): Ext.app.BaseController.Statics;
	}
}
declare namespace Ext.app.Controller {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.app.Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html)
	 * Controllers are the glue that binds an application together. That said, their main
	 * purpose is to listen for events (usually from views) and take some action. Here's how
	 * we might create a Controller to manage Users:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         init: function() {
	 *             console.log('Initialized Users! This happens before ' +
	 *                         'the Application launch() function is called');
	 *         }
	 *     });
	 * 
	 * The init function is a special method that is called when your application boots. It is
	 * called before the [Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)'s launch function is executed.
	 * This creates an area you can run code prior to Viewport creation.
	 * 
	 * The controller's [control](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-control) function
	 * makes it easy to listen to events on your view classes and take some action with a
	 * handler function. Let's update our Users controller to tell us when the panel is
	 * rendered:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         control: {
	 *             'viewport &gt; panel': {
	 *                 render: 'onPanelRendered'
	 *             }
	 *         }
	 *    
	 *         onPanelRendered: function() {
	 *             console.log('The panel was rendered');
	 *         }
	 *     });
	 * 
	 * The [control method](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.BaseController.html#method-control) has now set up
	 * listeners on views in our application. The control method uses the ComponentQuery
	 * engine to quickly and easily get references to components on the page. If you are not
	 * familiar with ComponentQuery yet, be sure to check out the
	 * [documentation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html). In brief, it allows us to pass a
	 * CSS-like selector that will find every matching component on the page.
	 * 
	 * In our init function above, we supplied 'viewport > panel', which translates to "find me
	 * every Panel that is a direct child of a Viewport". We then supplied an object that maps
	 * event names (just 'render' in this case) to handler functions. In short, whenever
	 * a component that matches our selector fires a 'render' event, our
	 * onPanelRendered function is called.
	 * 
	 * ## Event domains
	 * 
	 * In Ext JS 4.2, we introduced the concept of event domains. In terms of MVC, an event
	 * domain is one or more base classes that fire events to which a Controller wants to
	 * listen. Besides Component event domain that encompass [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)-descended
	 * Views, Controllers now can listen to events from data Stores, Ext Direct Providers,
	 * other Controllers, and [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html). This feature provides a way to communicate
	 * between parts of the whole application without the need to bind controllers together
	 * tightly, and allows to develop and test application parts in isolation.
	 * 
	 * See usage examples in [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-listen) method documentation.
	 * 
	 * ## Using refs
	 * 
	 * One of the most useful parts of Controllers is the ref system. These use
	 * [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) to make it really easy to get references to Views on your
	 * page. Let's look at an example of this now:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         refs: [{
	 *             ref: 'list',
	 *             selector: 'grid'
	 *         }],
	 *    
	 *         control: {
	 *             'button': {
	 *                 click: 'refreshGrid'
	 *             }
	 *         },
	 *    
	 *         refreshGrid: function() {
	 *             this.getList().store.load();
	 *         }
	 *     });
	 * 
	 * This example assumes the existence of a [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) on the page, which
	 * contains a single button to refresh the Grid when clicked. In our refs array, we set up
	 * a reference to the grid. There are two parts to this - the 'selector', which is a
	 * [ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) selector which finds any grid on the page and
	 * assigns it to the reference 'list'.
	 * 
	 * By giving the reference a name, we get a number of things for free. The first is the
	 * getList function that we use in the refreshGrid method above. This is generated
	 * automatically by the Controller based on the name of our ref, which was capitalized and
	 * prepended with get to go from 'list' to 'getList'.
	 * 
	 * The way this works is that the first time getList is called by your code, the
	 * ComponentQuery selector is run and the first component that matches the selector
	 * ('grid' in this case) will be returned. All future calls to getList will use a cached
	 * reference to that grid. Usually it is advised to use a specific ComponentQuery selector
	 * that will only match a single View in your application (in the case above our selector
	 * will match any grid on the page).
	 * 
	 * Bringing it all together, we configure control
	 * to listen to any click on a [button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) and call our refreshGrid
	 * function (again, this will match any button on the page so we advise a more specific
	 * selector than just 'button', but have left it this way for simplicity). When the button
	 * is clicked we use out getList function to refresh the grid.
	 * 
	 * You can create any number of refs and control any number of components this way, simply
	 * adding more functions to your Controller as you go. For an example of real-world usage
	 * of Controllers see the Feed Viewer example in the examples/app/feed-viewer folder in
	 * the SDK download.
	 * 
	 * ## Generated getter methods
	 * 
	 * Refs aren't the only thing that generate convenient getter methods. Controllers often
	 * have to deal with Models and Stores so the framework offers a couple of easy ways to
	 * get access to those too. Let's look at another example:
	 * 
	 *     Ext.define('MyApp.controller.Users', {
	 *         extend: 'Ext.app.Controller',
	 *    
	 *         models: ['User'],
	 *         stores: ['AllUsers', 'AdminUsers'],
	 *    
	 *         init: function() {
	 *             var User, allUsers, ed;
	 *    
	 *             User = this.getUserModel();
	 *             allUsers = this.getAllUsersStore();
	 *    
	 *             ed = new User({ name: 'Ed' });
	 *             allUsers.add(ed);
	 *         }
	 *     });
	 * 
	 * By specifying Models and Stores that the Controller cares about, it again dynamically
	 * loads them from the appropriate locations (app/model/User.js, app/store/AllUsers.js and
	 * app/store/AdminUsers.js in this case) and creates getter functions for them all. The
	 * example above will create a new User model instance and add it to the AllUsers Store.
	 * Of course, you could do anything in this function but in this case we just did
	 * something simple to demonstrate the functionality.
	 * 
	 * ## Further Reading
	 * 
	 * For more information about writing Ext JS 5 applications, please see the
	 * [Application Architecture](../../../application_architecture/application_architecture.html).
	 * Also see the [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) documentation.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		active?: boolean;
		/** 
		 * The [Ext.app.Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) for this controller accessible via the getApplication method.
		 * @configuration
		 * @optional
		 * @type {Ext.app.Application}
		 */
		application?: Ext.app.Application;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		before?: object;
		/** 
		 * Adds listeners to components selected via [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html). Accepts an
		 * object containing component paths mapped to a hash of listener functions.<br/>
		 * The function value may also be a string matching the name of a method on the
		 * controller.
		 * 
		 * In the following example the `updateUser` function is mapped to to the `click`
		 * event on a button component, which is a child of the `useredit` component.
		 * 
		 *     Ext.define('MyApp.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         control: {
		 *             'useredit button[action=save]': {
		 *                 click: 'updateUser'
		 *             }
		 *         },
		 *    
		 *         updateUser: function(button) {
		 *             console.log('clicked the Save button');
		 *         }
		 *     });
		 * 
		 * The method you pass to the listener will automatically be resolved on the controller.
		 * In this case, the `updateUser` method that will get executed on the `button` `click`
		 * event will resolve to the `updateUser` method on the controller,
		 * 
		 * See [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) for more information on component selectors.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		control?: object;
		/** 
		 * The id of this controller. You can use this id when dispatching.
		 * 
		 * For an example of dispatching, see the examples under the
		 * [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-listen) config.
		 * 
		 * If an id is not explicitly set, it will default to the controller's full classname.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		id?: string;
		/** 
		 * Adds listeners to different event sources (also called "event domains"). The
		 * primary event domain is that of components, but there are also other event domains:
		 * [Global](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html) domain that intercepts events fired from
		 * [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance,
		 * [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html) domain can be used to listen to events
		 * fired by other Controllers, [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html) domain gives access to
		 * Store events, and [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html) domain can be used with
		 * Ext Direct Providers to listen to their events.
		 * 
		 * To listen to "bar" events fired by a controller with id="foo":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             controller: {
		 *                 '#foo': {
		 *                     bar: 'onFooBar'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * To listen to "bar" events fired by any controller, and "baz" events
		 * fired by Store with storeId="baz":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             controller: {
		 *                 '*': {
		 *                     bar: 'onAnyControllerBar'
		 *                 }
		 *             },
		 *             store: {
		 *                 '#baz': {
		 *                     baz: 'onStoreBaz'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * To listen to "idle" events fired by [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) when other event
		 * processing is complete and Ext JS is about to return control to the browser:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             global: {            // Global events are always fired
		 *                 idle: 'onIdle'   // from the same object, so there
		 *             }                    // are no selectors
		 *         }
		 *     });
		 * 
		 * As this relates to components, the following example:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             component: {
		 *                 'useredit button[action=save]': {
		 *                     click: 'updateUser'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * Is equivalent to:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         control: {
		 *             'useredit button[action=save]': {
		 *                 click: 'updateUser'
		 *             }
		 *         }
		 *     });
		 * 
		 * Of course, these can all be combined in a single call and used instead of
		 * `control`, like so:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             global: {
		 *                 idle: 'onIdle'
		 *             },
		 *             controller: {
		 *                 '*': {
		 *                     foobar: 'onAnyFooBar'
		 *                 },
		 *                 '#foo': {
		 *                     bar: 'onFooBar'
		 *                 }
		 *             },
		 *             component: {
		 *                 'useredit button[action=save]': {
		 *                     click: 'updateUser'
		 *                 }
		 *             },
		 *             store: {
		 *                 '#qux': {
		 *                     load: 'onQuxLoad'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listen?: object;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Array of models to require from AppName.model namespace. For example:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *         models: ['User', 'Vehicle']
		 *     });
		 * 
		 * This is equivalent to:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *         requires: ['MyApp.model.User', 'MyApp.model.Vehicle'],
		 *    
		 *         getUserModel: function() {
		 *             return this.getModel("User");
		 *         },
		 *    
		 *         getVehicleModel: function() {
		 *             return this.getModel("Vehicle");
		 *         }
		 *     });
		 * 
		 * **Note:** If the model has a different namespace than that of the
		 * application you will need to specify the full class name as well as define a path
		 * in the [Loader's paths](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#cfg-paths) config or
		 * [setPath](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#method-setPath) method.
		 * @configuration
		 * @optional
		 * @type {string|string[]}
		 */
		models?: string | string[];
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		moduleClassName?: object;
		/** 
		 * The refs config creates a getter method on the controller that internally
		 * uses [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) to fetch the component instance using the configured
		 * selector.  The following example will add the `getList` method to
		 * the controller and will return the first component in the application
		 * hierarchy with an xtype of "grid".  By default, _undefined_ will be returned
		 * when the query does not locate the target component.
		 * 
		 *    Ext.define('MyApp.controller.Foo', {
		 *        extend: 'Ext.app.Controller',
		 *    
		 *        refs: [{
		 *            ref: 'list',
		 *            selector: 'grid'
		 *        }]
		 *    });
		 * 
		 * The following fields may be used in the ref definition:
		 * 
		 * - `ref` - name of the reference.
		 * - `selector` - [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) selector to access the component.
		 * - `autoCreate` - True to create the component automatically if not found on
		 *   page.
		 * - `forceCreate` - True to force the creation of the component every time
		 *   reference is accessed (when `get&lt;REFNAME&gt;` is called).
		 * - `xtype` - Used to create the component by its xtype with `autoCreate` or
		 *   `forceCreate`. If you don't provide `xtype`, an [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) instance will
		 *   be created.
		 * 
		 * The following example will create a `getList` and `getUser` method on the
		 * controller.
		 * 
		 *    Ext.define('MyApp.controller.Foo', {
		 *        extend: 'Ext.app.Controller',
		 *    
		 *        refs: [{
		 *            list: 'grid',
		 *            user: {
		 *                autoCreate: true,
		 *                selector: 'form',
		 *                xtype: 'form'
		 *            }
		 *        }]
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object|object[]}
		 */
		refs?: object | object[];
		/** 
		 * An object of routes to handle hash changes. A route can be defined in a simple way:
		 * 
		 *    routes : {
		 *        'foo/bar'  : 'handleFoo',
		 *        'user/:id' : 'showUser'
		 *    }
		 * 
		 * Where the property is the hash (which can accept a parameter defined by a colon) and the value
		 * is the method on the controller to execute. The parameters will get sent in the action method.
		 * 
		 * At the application level, you can define a event that will be executed when no matching
		 * routes are found.
		 * 
		 *    Ext.application({
		 *        name: 'MyApp',
		 *        listen: {
		 *            controller: {
		 *                '#': {
		 *                    unmatchedroute: 'onUnmatchedRoute'
		 *                }
		 *            }
		 *        },
		 *    
		 *        onUnmatchedRoute: function(hash) {
		 *            console.log('Unmatched', hash);
		 *            // Do something...
		 *        }
		 *    });
		 * 
		 * There is also a complex means of defining a route where you can use a before action and even
		 * specify your own RegEx for the parameter:
		 * 
		 *    routes : {
		 *        'foo/bar'  : {
		 *            action  : 'handleFoo',
		 *            before  : 'beforeHandleFoo'
		 *        },
		 *        'user/:id' : {
		 *            action     : 'showUser',
		 *            before     : 'beforeShowUser',
		 *            conditions : {
		 *                ':id' : '([0-9]+)'
		 *            }
		 *        }
		 *    }
		 * 
		 * This will only match if the `id` parameter is a number.
		 * 
		 * The before action allows you to cancel an action. Every before action will get passed an `action` argument with
		 * a `resume` and `stop` methods as the last argument of the method and you _MUST_ execute either method:
		 * 
		 *    beforeHandleFoo : function(action) {
		 *        //some logic here
		 *    
		 *        //this will allow the handleFoo action to be executed
		 *        action.resume();
		 *    },
		 *    handleFoo : function() {
		 *        //will get executed due to true being passed in callback in beforeHandleFoo
		 *    },
		 *    beforeShowUser : function(id, action) {
		 *        //allows for async process like an Ajax
		 *        Ext.Ajax.request({
		 *            url     : 'foo.php',
		 *            success : function() {
		 *                //will not allow the showUser method to be executed but will continue other queued actions.
		 *                action.stop();
		 *            },
		 *            failure : function() {
		 *                //will not allow the showUser method to be executed and will not allow other queued actions to be executed.
		 *                action.stop(true);
		 *            }
		 *        });
		 *    },
		 *    showUser : function(id) {
		 *        //will not get executed due to false being passed in callback in beforeShowUser
		 *    }
		 * 
		 * You _MUST_ execute the `resume` or `stop` method on the `action` argument. Executing `action.resume();` will continue
		 * the action, `action.stop();` will not allow the action to resume but will allow other queued actions to resume,
		 * `action.stop(true);` will not allow the action and any other queued actions to resume.
		 * 
		 * The default RegEx that will be used is `([%a-zA-Z0-9\\-\\_\\s,]+)` but you can specify any
		 * that may suit what you need to accomplish. An example of an advanced condition may be to make
		 * a parameter optional and case-insensitive:
		 * 
		 *    routes : {
		 *        'user:id' : {
		 *            action     : 'showUser',
		 *            before     : 'beforeShowUser',
		 *            conditions : {
		 *                ':id' : '(?:(?:\/){1}([%a-z0-9_,\s\-]+))?'
		 *            }
		 *        }
		 *    }
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		routes?: object;
		/** 
		 * Array of stores to require from AppName.store namespace and to generate getter methods for.
		 * For example:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *         stores: ['Users', 'Vehicles']
		 *     });
		 * 
		 * This is equivalent to:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *    
		 *         requires: [
		 *             'MyApp.store.Users',
		 *             'MyApp.store.Vehicles'
		 *         ]
		 *    
		 *         getUsersStore: function() {
		 *             return this.getStore("Users");
		 *         },
		 *    
		 *         getVehiclesStore: function() {
		 *             return this.getStore("Vehicles");
		 *         }
		 *     });
		 * 
		 * **Note:** If the store has a different namespace than that of the
		 * application you will need to specify the full class name as well as define a path
		 * in the [Loader's paths](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#cfg-paths) config or
		 * [setPath](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#method-setPath) method.
		 * @configuration
		 * @optional
		 * @type {string|string[]}
		 */
		stores?: string | string[];
		/** 
		 * Array of views to require from AppName.view namespace and to generate getter methods for.
		 * For example:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *         views: ['List', 'Detail']
		 *     });
		 * 
		 * This is equivalent to:
		 * 
		 *     Ext.define("MyApp.controller.Foo", {
		 *         extend: "Ext.app.Controller",
		 *         requires: ['MyApp.view.List', 'MyApp.view.Detail'],
		 *    
		 *         getListView: function() {
		 *             return this.getView("List");
		 *         },
		 *    
		 *         getDetailView: function() {
		 *             return this.getView("Detail");
		 *         }
		 *     });
		 * 
		 * **Note:** If the view has a different namespace than that of the
		 * application you will need to specify the full class name as well as define a path
		 * in the [Loader's paths](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#cfg-paths) config or
		 * [setPath](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html#method-setPath) method.
		 * @configuration
		 * @optional
		 * @type {string|string[]}
		 */
		views?: string | string[];
		/** 
		 * A template method that is called when your application boots. It is called before the
		 * [Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html)'s launch function is executed so gives a hook point
		 * to run any code before your Viewport is created.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.app.Application} application
		 * @returns {void}                            
		 */
		init? (application: Ext.app.Application): void;
		/** 
		 * A template method like [init](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#method-init), but called after the viewport is created.
		 * This is called after the [launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#method-launch) method of Application
		 * is executed.
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.app.Application} application
		 * @returns {void}                            
		 */
		onLaunch? (application: Ext.app.Application): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                     config
		 * @returns {Ext.app.Controller.Statics}        this
		 */
		initConfig? (config: object): Ext.app.Controller.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}              name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                     [value] The value to set for the name parameter.
		 * @returns {Ext.app.Controller.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.Controller.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.Controller.Statics}  
		 */
		statics? (): Ext.app.Controller.Statics;
	}
}
declare namespace Ext.app.EventDomain {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.app.EventDomain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html)
	 * This class is a base class for an event domain. In the context of MVC, an "event domain"
	 * is one or more base classes that fire events to which a Controller wants to listen. A
	 * controller listens to events by describing the selectors for events of interest to it.
	 * 
	 * Matching selectors to the firer of an event is one key aspect that defines an event
	 * domain. All event domain instances must provide a `match` method that tests selectors
	 * against the event firer.
	 * 
	 * When an event domain instance is created (typically as a `singleton`), its `type`
	 * property is used to catalog the domain in the
	 * [Ext.app.EventDomain.instances](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventDomain.html#static-property-instances) map.
	 * 
	 * There are five event domains provided by default:
	 * 
	 * - [Component domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Component.html). This is the primary event domain that
	 *   has been available since Ext JS MVC was introduced. This domain is defined as any class that
	 *   extends [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html), where the selectors use
	 *   [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html#method-query).
	 * - [Global domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html). This domain provides Controllers with access
	 *   to events fired from [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance. These events represent
	 *   the state of the application as a whole, and are always anonymous. Because of this, Global
	 *   domain does not provide selectors at all.
	 * - [Controller domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html). This domain includes all classes
	 *   that extend [Ext.app.Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html). Events fired by Controllers will be available
	 *   within this domain; selectors are either Controller's [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-id) or
	 *   '*' wildcard for any Controller.
	 * - [Store domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html). This domain is for classes extending
	 *   [Ext.data.AbstractStore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.AbstractStore.html). Selectors are either Store's
	 *   [storeId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.AbstractStore.html#cfg-storeId) or '*' wildcard for any Store.
	 * - [Direct domain](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html). This domain includes all classes that extend
	 *   [Ext.direct.Provider](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Provider.html). Selectors are either Provider's [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Provider.html#cfg-id)
	 *   or '*' wildcard for any Provider. This domain is optional and will be loaded only if
	 *   [Ext.direct.Manager](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Manager.html) singleton is required in your application.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * Name of the identifier property for this event domain.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		idProperty?: string;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.app.EventDomain.Statics}        this
		 */
		initConfig? (config: object): Ext.app.EventDomain.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.app.EventDomain.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.EventDomain.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.EventDomain.Statics}  
		 */
		statics? (): Ext.app.EventDomain.Statics;
	}
}
declare namespace Ext.app.Profile {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.app.Profile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html)
	 * A Profile represents a range of devices that fall under a common category. For the vast majority of apps that use
	 * device profiles, the app defines a Phone profile and a Tablet profile. Doing this enables you to easily customize
	 * the experience for the different sized screens offered by those device types.
	 * 
	 * Only one Profile can be active at a time, and each Profile defines a simple [isActive](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#method-isActive) function that should
	 * return either true or false. The first Profile to return true from its isActive function is set as your Application's
	 * [current profile](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-currentProfile).
	 * 
	 * A Profile can define any number of [models](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-models), [views](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-views), [controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-controllers) and [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-stores) which
	 * will be loaded if the Profile is activated. It can also define a [launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#method-launch) function that will be called after
	 * all of its dependencies have been loaded, just before the [application launch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#method-launch)
	 * function is called.
	 * 
	 * ## Sample Usage
	 * 
	 * First you need to tell your Application about your Profile(s):
	 * 
	 *    Ext.application({
	 *        name: 'MyApp',
	 *        profiles: ['Phone', 'Tablet']
	 *    });
	 * 
	 * This will load app/profile/Phone.js and app/profile/Tablet.js. Here's how we might define the Phone profile:
	 * 
	 *    Ext.define('MyApp.profile.Phone', {
	 *        extend: 'Ext.app.Profile',
	 *    
	 *        views: ['Main'],
	 *    
	 *        isActive: function() {
	 *            return Ext.os.is('Phone');
	 *        }
	 *    });
	 * 
	 * The isActive function returns true if we detect that we are running on a phone device. If that is the case the
	 * Application will set this Profile active and load the 'Main' view specified in the Profile's [views](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-views) config.
	 * 
	 * ## Class Specializations
	 * 
	 * Because Profiles are specializations of an application, all of the models, views, controllers and stores defined
	 * in a Profile are expected to be namespaced under the name of the Profile. Here's an expanded form of the example
	 * above:
	 * 
	 *    Ext.define('MyApp.profile.Phone', {
	 *        extend: 'Ext.app.Profile',
	 *    
	 *        views: ['Main'],
	 *        controllers: ['Signup'],
	 *        models: ['MyApp.model.Group'],
	 *    
	 *        isActive: function() {
	 *            return Ext.os.is('Phone');
	 *        }
	 *    });
	 * 
	 * In this case, the Profile is going to load _app/view/phone/Main.js_, _app/controller/phone/Signup.js_ and
	 * _app/model/Group.js_. Notice that in each of the first two cases the name of the profile ('phone' in this case) was
	 * injected into the class names. In the third case we specified the full Model name (for Group) so the Profile name
	 * was not injected.
	 * 
	 * For a fuller understanding of the ideas behind Profiles and how best to use them in your app, we suggest you read
	 * the [device profiles guide](/touch/2.4/core_concepts/device_profiles.html).
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The [Application](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html) instance to which this Profile is
		 * bound. This is set automatically.
		 * @configuration
		 * @optional
		 * @type {Ext.app.Application}
		 */
		application?: Ext.app.Application;
		/** 
		 * Any additional [Controllers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html) to load for this profile.
		 * Note that each item here will be prepended with the Profile namespace when loaded.
		 * 
		 * Example usage:
		 * 
		 *    controllers: [
		 *        'Users',
		 *        'MyApp.controller.Products'
		 *    ]
		 * 
		 * This will load _MyApp.controller.tablet.Users_ and _MyApp.controller.Products_.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {string[]}
		 */
		controllers?: string[];
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * @configuration
		 * @optional
		 * @default {$value: null, lazy: true}
		 * @type {string}
		 */
		mainView?: string;
		/** 
		 * Any additional [Models](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-models) to load for this profile.
		 * Note that each item here will be prepended with the Profile namespace when loaded.
		 * 
		 * Example usage:
		 * 
		 *    models: [
		 *        'Group',
		 *        'MyApp.model.User'
		 *    ]
		 * 
		 * This will load _MyApp.model.tablet.Group_ and _MyApp.model.User_.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {string[]}
		 */
		models?: string[];
		/** 
		 * The name of this Profile. Defaults to the last section of the class name (e.g. a profile
		 * called MyApp.profile.Phone will default the name to 'Phone').
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		name?: string;
		/** 
		 * The namespace that this Profile's classes can be found in. Defaults to the lowercase
		 * Profile [name](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Profile.html#cfg-name), for example a Profile called MyApp.profile.Phone will by default have a 'phone'
		 * namespace, which means that this Profile's additional models, stores, views and controllers will be loaded
		 * from the MyApp.model.phone._, MyApp.store.phone._, MyApp.view.phone._ and MyApp.controller.phone._ namespaces
		 * respectively.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		namespace?: string;
		/** 
		 * Any additional [Stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-stores) to load for this profile.
		 * Note that each item here will be prepended with the Profile namespace when loaded.
		 * 
		 * Example usage:
		 * 
		 *    stores: [
		 *        'Users',
		 *        'MyApp.store.Products'
		 *    ]
		 * 
		 * This will load _MyApp.store.tablet.Users_ and _MyApp.store.Products_.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {string[]}
		 */
		stores?: string[];
		/** 
		 * This config allows the active profile to define a set of `xtypes` and map them
		 * to desired classes and default configurations. Normally an `xtype` is statically
		 * declared by a [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) in its class definition. This
		 * mechanism allows the active profile to control a set of these types.
		 * 
		 * Example:
		 * 
		 *     views: {
		 *         // The "main" xtype maps to MyApp.view.tablet.Main
		 *         //
		 *         main: 'MyApp.view.tablet.Main',
		 *    
		 *         // The "inbox" xtype maps to a subclass of MyApp.view.Inbox (created
		 *         // by this mechanism) that sets the "mode" config to "compact".
		 *         //
		 *         inbox: {
		 *             xclass: 'MyApp.view.Inbox',
		 *             mode: 'compact'
		 *         }
		 *     }
		 * 
		 * Note that class names used in this form must be full class names, unlike the
		 * historical usage of `views`. Further, these views cannot be accessed using the
		 * `getView` method but rather via their assigned `xtype`.
		 * 
		 * The historical usage of this config is enabled when an array is passed. In this
		 * case, these are simply additional [views](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Application.html#cfg-views) to
		 * load for this profile. Note that each item here will be prepended with the
		 * Profile namespace when loaded.
		 * 
		 * Example usage:
		 * 
		 *    views: [
		 *        'Main',
		 *        'MyApp.view.Login'
		 *    ]
		 * 
		 * This will load _MyApp.view.tablet.Main_ and _MyApp.view.Login_. While supported,
		 * this usage is discouraged in favor of `xtype` mapping.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {object|string[]}
		 */
		views?: object | string[];
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                  config
		 * @returns {Ext.app.Profile.Statics}        this
		 */
		initConfig? (config: object): Ext.app.Profile.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}           name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                  [value] The value to set for the name parameter.
		 * @returns {Ext.app.Profile.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.Profile.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.Profile.Statics}  
		 */
		statics? (): Ext.app.Profile.Statics;
	}
}
declare namespace Ext.app.ViewController {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.app.ViewController](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewController.html)
	 * A view controller is a controller that can be attached to a specific view
	 * instance so it can manage the view and its child components. Each instance of the view
	 * will have a new view controller, so the instances are isolated.
	 * 
	 * When a controller is specified on a view, the view automatically becomes a [Ext.container.Container.referenceHolder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-referenceHolder),
	 * so it will receive inline events declared on the view. Sample usage:
	 * 
	 *    Ext.define('User', {
	 *       extend: 'Ext.data.Model',
	 *       fields: ['name', 'phone']    
	 *    });
	 *    
	 *    Ext.define('UserListController', {
	 *        extend : 'Ext.app.ViewController',
	 *        alias: 'controller.userlist',
	 *    
	 *        init: function(view) {
	 *            this.userCount = 0;
	 *            var users = [],
	 *                i;
	 *    
	 *            for (i = 0; i &lt; 5; ++i) {
	 *                users.push(this.getUser());
	 *            }  
	 *            view.getStore().add(users);
	 *        },
	 *    
	 *        onAddClick: function() {
	 *            this.addUser();
	 *        },
	 *    
	 *        onDeleteClick: function() {
	 *            var view = this.getView(),
	 *                selected = view.getSelectionModel().getSelection()[0],
	 *                store = view.getStore();
	 *    
	 *            store.remove(selected);
	 *        },
	 *    
	 *        onSelectionChange: function(selModel, selections) {
	 *            this.lookupReference('delete').setDisabled(selections.length === 0);
	 *        },
	 *    
	 *        getUser: function() {
	 *            ++this.userCount;
	 *            return {
	 *                name: 'User ' + this.userCount,
	 *                phone: this.generatePhone()
	 *            };
	 *        },
	 *    
	 *        addUser: function() {
	 *            this.getView().getStore().add(this.getUser());    
	 *        },
	 *    
	 *        generatePhone: function() {
	 *            var num = '',
	 *                i;
	 *    
	 *            for (i = 0; i &lt; 7; ++i) {
	 *                num += Ext.Number.randomInt(0, 9);
	 *                if (num.length === 3) {
	 *                    num += '-';
	 *                }
	 *            }    
	 *            return num;
	 *        }
	 *    });
	 *    
	 *    Ext.define('UserList', {
	 *        extend: 'Ext.grid.Panel',
	 *        controller: 'userlist',
	 *    
	 *        tbar: [{
	 *            text: 'Add',
	 *            listeners: {
	 *                click: 'onAddClick'
	 *            }    
	 *        }, {
	 *            text: 'Delete',
	 *            reference: 'delete',
	 *            listeners: {
	 *                click: 'onDeleteClick'
	 *            }
	 *        }],
	 *        store: {
	 *            model: 'User'
	 *        },
	 *        selModel: {
	 *            type: 'rowmodel',
	 *            listeners: {
	 *                selectionchange: 'onSelectionChange'
	 *            }    
	 *        },
	 *        columns: [{
	 *            flex: 1,
	 *            dataIndex: 'name',
	 *            text: 'Name'
	 *        }, {
	 *            flex: 1,
	 *            dataIndex: 'phone',
	 *            text: 'Phone'
	 *        }]
	 *    });
	 *    
	 *    Ext.onReady(function() {
	 *        new UserList({
	 *            renderTo: Ext.getBody(),
	 *            width: 400,
	 *            height: 200
	 *        });
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		before?: object;
		/** 
		 * @configuration
		 * @optional
		 * @default 'destroy'
		 * @type {string}
		 */
		closeViewAction?: string;
		/** 
		 * Adds listeners to components selected via [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html). Accepts an
		 * object containing component paths mapped to a hash of listener functions.<br/>
		 * The function value may also be a string matching the name of a method on the
		 * controller.
		 * 
		 * In the following example the `updateUser` function is mapped to to the `click`
		 * event on a button component, which is a child of the `useredit` component.
		 * 
		 *     Ext.define('MyApp.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         control: {
		 *             'useredit button[action=save]': {
		 *                 click: 'updateUser'
		 *             }
		 *         },
		 *    
		 *         updateUser: function(button) {
		 *             console.log('clicked the Save button');
		 *         }
		 *     });
		 * 
		 * The method you pass to the listener will automatically be resolved on the controller.
		 * In this case, the `updateUser` method that will get executed on the `button` `click`
		 * event will resolve to the `updateUser` method on the controller,
		 * 
		 * See [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ComponentQuery.html) for more information on component selectors.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		control?: object;
		/** 
		 * The id of this controller. You can use this id when dispatching.
		 * 
		 * For an example of dispatching, see the examples under the
		 * [listen](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.Controller.html#cfg-listen) config.
		 * 
		 * If an id is not explicitly set, it will default to the controller's full classname.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		id?: string;
		/** 
		 * Adds listeners to different event sources (also called "event domains"). The
		 * primary event domain is that of components, but there are also other event domains:
		 * [Global](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Global.html) domain that intercepts events fired from
		 * [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) Observable instance,
		 * [Controller](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Controller.html) domain can be used to listen to events
		 * fired by other Controllers, [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Store.html) domain gives access to
		 * Store events, and [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.domain.Direct.html) domain can be used with
		 * Ext Direct Providers to listen to their events.
		 * 
		 * To listen to "bar" events fired by a controller with id="foo":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             controller: {
		 *                 '#foo': {
		 *                     bar: 'onFooBar'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * To listen to "bar" events fired by any controller, and "baz" events
		 * fired by Store with storeId="baz":
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             controller: {
		 *                 '*': {
		 *                     bar: 'onAnyControllerBar'
		 *                 }
		 *             },
		 *             store: {
		 *                 '#baz': {
		 *                     baz: 'onStoreBaz'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * To listen to "idle" events fired by [Ext.GlobalEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.GlobalEvents.html) when other event
		 * processing is complete and Ext JS is about to return control to the browser:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             global: {            // Global events are always fired
		 *                 idle: 'onIdle'   // from the same object, so there
		 *             }                    // are no selectors
		 *         }
		 *     });
		 * 
		 * As this relates to components, the following example:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             component: {
		 *                 'useredit button[action=save]': {
		 *                     click: 'updateUser'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * Is equivalent to:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         control: {
		 *             'useredit button[action=save]': {
		 *                 click: 'updateUser'
		 *             }
		 *         }
		 *     });
		 * 
		 * Of course, these can all be combined in a single call and used instead of
		 * `control`, like so:
		 * 
		 *     Ext.define('AM.controller.Users', {
		 *         extend: 'Ext.app.Controller',
		 *    
		 *         listen: {
		 *             global: {
		 *                 idle: 'onIdle'
		 *             },
		 *             controller: {
		 *                 '*': {
		 *                     foobar: 'onAnyFooBar'
		 *                 },
		 *                 '#foo': {
		 *                     bar: 'onFooBar'
		 *                 }
		 *             },
		 *             component: {
		 *                 'useredit button[action=save]': {
		 *                     click: 'updateUser'
		 *                 }
		 *             },
		 *             store: {
		 *                 '#qux': {
		 *                     load: 'onQuxLoad'
		 *                 }
		 *             }
		 *         }
		 *     });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listen?: object;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * An object of routes to handle hash changes. A route can be defined in a simple way:
		 * 
		 *    routes : {
		 *        'foo/bar'  : 'handleFoo',
		 *        'user/:id' : 'showUser'
		 *    }
		 * 
		 * Where the property is the hash (which can accept a parameter defined by a colon) and the value
		 * is the method on the controller to execute. The parameters will get sent in the action method.
		 * 
		 * At the application level, you can define a event that will be executed when no matching
		 * routes are found.
		 * 
		 *    Ext.application({
		 *        name: 'MyApp',
		 *        listen: {
		 *            controller: {
		 *                '#': {
		 *                    unmatchedroute: 'onUnmatchedRoute'
		 *                }
		 *            }
		 *        },
		 *    
		 *        onUnmatchedRoute: function(hash) {
		 *            console.log('Unmatched', hash);
		 *            // Do something...
		 *        }
		 *    });
		 * 
		 * There is also a complex means of defining a route where you can use a before action and even
		 * specify your own RegEx for the parameter:
		 * 
		 *    routes : {
		 *        'foo/bar'  : {
		 *            action  : 'handleFoo',
		 *            before  : 'beforeHandleFoo'
		 *        },
		 *        'user/:id' : {
		 *            action     : 'showUser',
		 *            before     : 'beforeShowUser',
		 *            conditions : {
		 *                ':id' : '([0-9]+)'
		 *            }
		 *        }
		 *    }
		 * 
		 * This will only match if the `id` parameter is a number.
		 * 
		 * The before action allows you to cancel an action. Every before action will get passed an `action` argument with
		 * a `resume` and `stop` methods as the last argument of the method and you _MUST_ execute either method:
		 * 
		 *    beforeHandleFoo : function(action) {
		 *        //some logic here
		 *    
		 *        //this will allow the handleFoo action to be executed
		 *        action.resume();
		 *    },
		 *    handleFoo : function() {
		 *        //will get executed due to true being passed in callback in beforeHandleFoo
		 *    },
		 *    beforeShowUser : function(id, action) {
		 *        //allows for async process like an Ajax
		 *        Ext.Ajax.request({
		 *            url     : 'foo.php',
		 *            success : function() {
		 *                //will not allow the showUser method to be executed but will continue other queued actions.
		 *                action.stop();
		 *            },
		 *            failure : function() {
		 *                //will not allow the showUser method to be executed and will not allow other queued actions to be executed.
		 *                action.stop(true);
		 *            }
		 *        });
		 *    },
		 *    showUser : function(id) {
		 *        //will not get executed due to false being passed in callback in beforeShowUser
		 *    }
		 * 
		 * You _MUST_ execute the `resume` or `stop` method on the `action` argument. Executing `action.resume();` will continue
		 * the action, `action.stop();` will not allow the action to resume but will allow other queued actions to resume,
		 * `action.stop(true);` will not allow the action and any other queued actions to resume.
		 * 
		 * The default RegEx that will be used is `([%a-zA-Z0-9\\-\\_\\s,]+)` but you can specify any
		 * that may suit what you need to accomplish. An example of an advanced condition may be to make
		 * a parameter optional and case-insensitive:
		 * 
		 *    routes : {
		 *        'user:id' : {
		 *            action     : 'showUser',
		 *            before     : 'beforeShowUser',
		 *            conditions : {
		 *                ':id' : '(?:(?:\/){1}([%a-z0-9_,\s\-]+))?'
		 *            }
		 *        }
		 *    }
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		routes?: object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                         config
		 * @returns {Ext.app.ViewController.Statics}        this
		 */
		initConfig? (config: object): Ext.app.ViewController.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                  name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                         [value] The value to set for the name parameter.
		 * @returns {Ext.app.ViewController.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.ViewController.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.ViewController.Statics}  
		 */
		statics? (): Ext.app.ViewController.Statics;
	}
}
declare namespace Ext.app.ViewModel {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.app.ViewModel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html)
	 * This class manages arbitrary data and its relationship to data models. Instances of
	 * `ViewModel` are associated with some `Component` and then used by their child items
	 * for the purposes of Data Binding.
	 * 
	 * # Binding
	 * 
	 * The most commonly used aspect of a `ViewModel` is the `bind` method. This method takes
	 * a "bind descriptor" (see below) and a callback to call when the data indicated by the
	 * bind descriptor either becomes available or changes.
	 * 
	 * The `bind` method, based on the bind descriptor given, will return different types of
	 * "binding" objects. These objects maintain the connection between the requested data and
	 * the callback. Bindings ultimately derive from [`Ext.app.bind.BaseBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.BaseBinding.html)
	 * which provides several methods to help manage the binding.
	 * 
	 * Perhaps the most important method is `destroy`. When the binding is no longer needed
	 * it is important to remember to `destroy` it. Leaking bindings can cause performance
	 * problems or worse when callbacks are called at unexpected times.
	 * 
	 * The types of bindings produced by `bind` are:
	 * 
	 * - [`Ext.app.bind.Binding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Binding.html)
	 * - [`Ext.app.bind.Multi`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Multi.html)
	 * - [`Ext.app.bind.TemplateBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.TemplateBinding.html)
	 * 
	 * ## Bind Descriptors
	 * 
	 * A "bind descriptor" is a value (a String, an Object or an array of these) that describe
	 * the desired data. Any piece of data in the `ViewModel` can be described by a bind
	 * descriptor.
	 * 
	 * ### Textual Bind Descriptors
	 * 
	 * The simplest and most common form of bind descriptors are strings that look like an
	 * [`Ext.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Template.html) containing text and tokens surrounded by "{}" with dot notation inside
	 * to traverse objects and their properties.
	 * 
	 * For example:
	 * 
	 * - `'Hello {user.name}!'`
	 * - `'You have selected "{selectedItem.text}".'`
	 * - `'{user.groups}'`
	 * 
	 * The first two bindings are [`template bindings`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.TemplateBinding.html)
	 * which use the familiar [`Ext.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Template.html) syntax with some slight differences. For more on
	 * templates see [`Ext.app.bind.Template`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Template.html).
	 * 
	 * The third bind descriptor is called a "direct bind descriptor". This special form of
	 * bind maps one-to-one to some piece of data in the `ViewModel` and is managed by the
	 * [`Ext.app.bind.Binding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Binding.html) class.
	 * 
	 * #### Two-Way Descriptors
	 * 
	 * A direct bind descriptor may be able to write back a value to the `ViewModel` as well
	 * as retrieve one. When this is the case, they are said to be "two-way". For example:
	 * 
	 *     var binding = viewModel.bind('{s}', function(x) { console.log('s=' + s); });
	 *    
	 *     binding.setValue('abc');
	 * 
	 * Direct use of `ViewModel` in this way is not commonly needed because [`Ext.Component`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)
	 * automates this process. For example, a `textfield` component understands when it is
	 * given a "two-way" binding and automatically synchronizes its value bidirectionally using
	 * the above technique. For example:
	 * 
	 *     Ext.widget({
	 *         items: [{
	 *             xtype: 'textfield',
	 *             bind: '{s}'  // a two-way / direct bind descriptor
	 *         }]
	 *     });
	 * 
	 * ### Object and Array Descriptors / Multi-Bind
	 * 
	 * With two exceptions (see below) an Object is interpreted as a "shape" to produce by
	 * treating each of its properties as individual bind descriptors. An object of the same
	 * shape is passed as the value of the bind except that each property is populated with
	 * the appropriate value. Of course, this definition is recursive, so these properties
	 * may also be objects.
	 * 
	 * For example:
	 * 
	 *     viewModel.bind({
	 *             x: '{x}',
	 *             foo: {
	 *                 bar: 'Hello {foo.bar}'
	 *             }
	 *         },
	 *         function (obj) {
	 *             //  obj = {
	 *             //      x: 42,
	 *             //      foo: {
	 *             //          bar: 'Hello foobar'
	 *             //      }
	 *             //  }
	 *         });
	 * 
	 * Arrays are handled in the same way. Each element of the array is considered a bind
	 * descriptor (recursively) and the value produced for the binding is an array with each
	 * element set to the bound property.
	 * 
	 * ### Bind Options
	 * 
	 * One exception to the "object is a multi-bind" rule is when that object contains a
	 * `bindTo` property. When an object contains a `bindTo` property the object is understood
	 * to contain bind options and the value of `bindTo` is considered the actual bind
	 * descriptor.
	 * 
	 * For example:
	 * 
	 *     viewModel.bind({
	 *             bindTo: '{x}',
	 *             single: true
	 *         },
	 *         function (x) {
	 *             console.log('x: ' + x); // only called once
	 *         });
	 * 
	 * The available bind options depend on the type of binding, but since all bindings
	 * derive from [`Ext.app.bind.BaseBinding`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.BaseBinding.html) its options are always applicable.
	 * For a list of the other types of bindings, see above.
	 * 
	 * #### Deep Binding
	 * 
	 * When a direct bind is made and the bound property is an object, by default the binding
	 * callback is only called when that reference changes. This is the most efficient way to
	 * understand a bind of this type, but sometimes you may need to be notified if any of the
	 * properties of that object change.
	 * 
	 * To do this, we create a "deep bind":
	 * 
	 *     viewModel.bind({
	 *             bindTo: '{someObject}',
	 *             deep: true
	 *         },
	 *         function (someObject) {
	 *             // called when reference changes or *any* property changes
	 *         });
	 * 
	 * #### Binding Timings
	 * 
	 * The `ViewModel` has a [scheduler](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-scheduler) attached that is used to coordinate the firing of bindings.
	 * It serves 2 main purposes:
	 * 
	 * - To coordinate dependencies between bindings. This means bindings will be fired in an order such that
	 *   the any dependencies for a binding are fired before the binding itself.
	 * - To batch binding firings. The scheduler runs on a short timer, so the following code will only trigger
	 *   a single binding (the last), the changes in between will never be triggered.
	 * 
	 *      viewModel.bind('{val}', function(v) {
	 *          console.log(v);
	 *      });
	 *      viewModel.set('val', 1);
	 *      viewModel.set('val', 2);
	 *      viewModel.set('val', 3);
	 *      viewModel.set('val', 4);
	 * 
	 * The `ViewModel` can be forced to process by calling [`notify`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#method-notify), which will force the
	 * scheduler to run immediately in the current state.
	 * 
	 *    viewModel.bind('{val}', function(v) {
	 *        console.log(v);
	 *    });
	 *    viewModel.set('val', 1);
	 *    viewModel.notify();
	 *    viewModel.set('val', 2);
	 *    viewModel.notify();
	 *    viewModel.set('val', 3);
	 *    viewModel.notify();
	 *    viewModel.set('val', 4);
	 *    viewModel.notify();
	 * 
	 * #### Models, Stores and Associations
	 * 
	 * A [Session](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Session.html) manages model instances and their associations.
	 * The `ViewModel` may be used with or without a `Session`. When a `Session` is attached, the
	 * `ViewModel` will always consult the `Session` to ask about records and stores. The `Session`
	 * ensures that only a single instance of each model Type/Id combination is created. This is
	 * important when tracking changes in models so that we always have the same reference.
	 * 
	 * A `ViewModel` provides functionality to easily consume the built in data package types
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) and [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), as well as their associations.
	 * 
	 * ### Model Links
	 * 
	 * A model can be described declaratively using a [&lt;code&gt;link&lt;/code&gt;](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-links). In the example code below,
	 * We ask the `ViewModel` to construct a record of type `User` with `id: 17`. The model will be loaded
	 * from the server and the bindings will trigger once the load has completed. Similarly, we could also
	 * attach a model instance to the `ViewModel` data directly.
	 * 
	 *    Ext.define('MyApp.model.User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name']
	 *    });
	 *    
	 *    var rec = new MyApp.model.User({
	 *        id: 12,
	 *        name: 'Foo'
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            theUser: {
	 *                type: 'User',
	 *                id: 17
	 *            }
	 *        },
	 *        data: {
	 *            otherUser: rec
	 *        }
	 *    });
	 *    viewModel.bind('{theUser.name}', function(v) {
	 *        console.log(v);
	 *    });
	 *    viewModel.bind('{otherUser.name}', function(v) {
	 *        console.log(v);
	 *    });
	 * 
	 * ### Model Fields
	 * 
	 * Bindings have the functionality to inspect the parent values and resolve the underlying
	 * value dynamically. This behavior allows model fields to be interrogated as part of a binding.
	 * 
	 *    Ext.define('MyApp.model.User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name', 'age']
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            theUser: {
	 *                type: 'User',
	 *                id: 22
	 *            }
	 *        }
	 *    });
	 *    
	 *    // Server responds with:
	 *    {
	 *        "id": 22,
	 *        "name": "Foo",
	 *        "age": 100
	 *    }
	 *    
	 *    viewModel.bind('Hello {name}, you are {age} years old', function(v) {
	 *        console.log(v);
	 *    });
	 * 
	 * ### Associations
	 * 
	 * In the same way as fields, the bindings can also traverse associations in a bind statement.
	 * The `ViewModel` will handle the asynchronous loading of data and only present the value once
	 * the full path has been loaded. For more information on associations see [OneToOne](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.schema.OneToOne.html) and
	 * [ManyToOne](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.schema.ManyToOne.html) associations.
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['name']
	 *    });
	 *    
	 *    Ext.define('Order', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['date', {
	 *            name: 'userId',
	 *            reference: 'User'
	 *        }]
	 *    });
	 *    
	 *    Ext.define('OrderItem', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['price', 'qty', {
	 *            name: 'orderId',
	 *            reference: 'Order'
	 *        }]
	 *    });
	 *    
	 *    var viewModel = new Ext.app.ViewModel({
	 *        links: {
	 *            orderItem: {
	 *                type: 'OrderItem',
	 *                id: 13
	 *            }
	 *        }
	 *    });
	 *    // The viewmodel will handle both ways of loading the data:
	 *    // a) If the data is loaded inline in a nested fashion it will
	 *    //    not make requests for extra data
	 *    // b) Only loading a single model at a time. So the Order will be loaded once
	 *    //    the OrderItem returns. The User will be loaded once the Order loads.
	 *    viewModel.bind('{orderItem.order.user.name}', function(name) {
	 *        console.log(name);
	 *    });
	 * 
	 * ### Stores
	 * 
	 * Stores can be created as part of the `ViewModel` definition. The definitions are processed
	 * like bindings which allows for very powerful dynamic functionality.
	 * 
	 * It is important to ensure that you name viewModel's data keys uniquely. If data is not named<br/>
	 * uniquely, binds and formulas may receive information from an unintended data source.<br/>
	 * This applies to keys in the viewModel's data block, stores, and links configs.
	 * 
	 *    var viewModel = new Ext.app.ViewModel({
	 *        stores: {
	 *            users: {
	 *                model: 'User',
	 *                autoLoad: true,
	 *                filters: [{
	 *                    property: 'createdDate',
	 *                    value: '{createdFilter}',
	 *                    operator: '&gt;'
	 *                }]
	 *            }
	 *        }
	 *    });
	 *    // Later on in our code, we set the date so that the store is created.
	 *    viewModel.set('createdFilter', Ext.Date.subtract(new Date(), Ext.Date.DAY, 7));
	 * 
	 * See [stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-stores) for more detail.
	 * 
	 * #### Formulas
	 * 
	 * Formulas allow for calculated `ViewModel` data values. The dependencies for these formulas
	 * are automatically determined so that the formula will not be processed until the required
	 * data is present.
	 * 
	 *     var viewModel = new Ext.app.ViewModel({
	 *         formulas: {
	 *             fullName: function(get) {
	 *                 return get('firstName') + ' ' + get('lastName');
	 *             }
	 *         },
	 *         data: {firstName: 'John', lastName: 'Smith'}
	 *     });
	 *     viewModel.bind('{fullName}', function(v) {
	 *         console.log(v);
	 *     });
	 * 
	 * See [formulas](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#cfg-formulas) for more detail.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * This object holds the arbitrary data that populates the `ViewModel` and is
		 * then available for binding.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {object}
		 */
		data?: object;
		/** 
		 * An object that defines named values whose value is managed by function calls.
		 * The names of the properties of this object are assigned as values in the
		 * ViewModel.
		 * 
		 * For example:
		 * 
		 *     formulas: {
		 *         xy: function (get) { return get('x') * get('y'); }
		 *     }
		 * 
		 * For more details about defining a formula, see [`Ext.app.bind.Formula`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.bind.Formula.html).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		formulas?: object;
		/** 
		 * Links provide a way to assign a simple name to a more complex bind. The primary
		 * use for this is to assign names to records in the data model.
		 * 
		 *     links: {
		 *         theUser: {
		 *             type: 'User',
		 *             id: 12
		 *         }
		 *     }
		 * 
		 * It is also possible to force a new phantom record to be created by not specifying an
		 * id but passing `create: true` as part of the descriptor. This is often useful when
		 * creating a new record for a child session.
		 * 
		 *    links: {
		 *        newUser: {
		 *            type: 'User',
		 *            create: true
		 *        }
		 *    } 
		 * 
		 * `create` can also be an object containing initial data for the record.
		 * 
		 *    links: {
		 *        newUser: {
		 *            type: 'User',
		 *            create: {
		 *                firstName: 'John',
		 *                lastName: 'Smith'
		 *            }
		 *        }
		 *    } 
		 * 
		 * While that is the typical use, the value of each property in `links` may also be
		 * a bind descriptor (see [`bind`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.ViewModel.html#method-bind) for the various forms of bind
		 * descriptors).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		links?: object;
		/** 
		 * The parent `ViewModel` of this `ViewModel`. Once set, this cannot be changed.
		 * @configuration
		 * @optional
		 * @type {Ext.app.ViewModel}
		 */
		parent?: Ext.app.ViewModel;
		/** 
		 * A reference to the root "stub" (an object that manages bindings).
		 * @configuration
		 * @optional
		 * @default true
		 * @type {Ext.app.bind.RootStub}
		 */
		root?: Ext.app.bind.RootStub;
		/** 
		 * The scheduler used to schedule and manage the delivery of notifications for
		 * all connections to this `ViewModel` and any other attached to it. The normal
		 * process to initialize the `scheduler` is to get the scheduler used by the
		 * `parent` or `session` and failing either of those, create one.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Scheduler}
		 */
		scheduler?: Ext.util.Scheduler;
		/** 
		 * The schema to use for getting information about entities.
		 * @configuration
		 * @optional
		 * @default 'default'
		 * @type {string|Ext.data.schema.Schema}
		 */
		schema?: string | Ext.data.schema.Schema;
		/** 
		 * The session used to manage the data model (records and stores).
		 * @configuration
		 * @optional
		 * @type {Ext.data.Session}
		 */
		session?: Ext.data.Session;
		/** 
		 * A declaration of [`Ext.data.Store`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) configurations that are first processed as
		 * binds to produce an effective store configuration.
		 * 
		 * A simple store definition. We can reference this in our bind statements using the
		 * `{users}` as we would with other data values.
		 * 
		 *    new Ext.app.ViewModel({
		 *        stores: {
		 *            users: {
		 *                model: 'User',
		 *                autoLoad: true
		 *            }
		 *        }
		 *    });
		 * 
		 * This store definition contains a dynamic binding. The store will not be created until
		 * the initial value for groupId is set. Once that occurs, the store is created with the appropriate
		 * filter configuration. Subsequently, once we change the group value, the old filter will be
		 * overwritten with the new value.
		 * 
		 *    var viewModel = new Ext.app.ViewModel({
		 *        stores: {
		 *            users: {
		 *                model: 'User',
		 *                filters: [{
		 *                    property: 'groupId',
		 *                    value: '{groupId}'
		 *                }]
		 *            }
		 *        }
		 *    });
		 *    viewModel.set('groupId', 1); // This will trigger the store creation with the filter.
		 *    viewModel.set('groupId', 2); // The filter value will be changed.
		 * 
		 * This store uses [store chaining](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.ChainedStore.html) to create a store backed by the
		 * data in another store. By specifying a string as the store, it will bind our creation and backing
		 * to the other store. This functionality is especially useful when wanting to display a different "view"
		 * of a store, for example a different sort order or different filters.
		 * 
		 *    var viewModel = new Ext.app.ViewModel({
		 *        stores: {
		 *            allUsers: {
		 *                model: 'User',
		 *                autoLoad: true
		 *            },
		 *            children: {
		 *                source: '{allUsers}',
		 *                filters: [{
		 *                    property: 'age',
		 *                    value: 18,
		 *                    operator: '&lt;'
		 *                }]
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		stores?: object;
		/** 
		 * The Container that owns this `ViewModel` instance.
		 * @configuration
		 * @optional
		 * @type {Ext.container.Container}
		 */
		view?: Ext.container.Container;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                    config
		 * @returns {Ext.app.ViewModel.Statics}        this
		 */
		initConfig? (config: object): Ext.app.ViewModel.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}             name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                    [value] The value to set for the name parameter.
		 * @returns {Ext.app.ViewModel.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.app.ViewModel.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.app.ViewModel.Statics}  
		 */
		statics? (): Ext.app.ViewModel.Statics;
	}
}

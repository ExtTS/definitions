declare namespace Ext.data.proxy {
	/** 
	 * [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html)
	 * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
	 * data from the server, usually to be placed into a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html). Let's take a look at a typical setup.
	 * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html):
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email']
	 *    });
	 *    
	 *    //The Store contains the AjaxProxy as an inline configuration
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'ajax',
	 *            url : 'users.json'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * Our example is going to load user data into a Store, so we start off by defining a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) with
	 * the fields that we expect the server to return. Next we set up the Store itself, along with a
	 * [proxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html#cfg-proxy) configuration. This configuration was automatically turned into an
	 * [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) instance, with the url we specified being passed into AjaxProxy's constructor.
	 * It's as if we'd done this:
	 * 
	 *    new Ext.data.proxy.Ajax({
	 *        url: 'users.json',
	 *        model: 'User',
	 *        reader: 'json'
	 *    });
	 * 
	 * A couple of extra configurations appeared here - [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-model) and [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader). These are set by default when we
	 * create the proxy via the Store - the Store already knows about the Model, and Proxy's default [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) is [JsonReader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Json.html).
	 * 
	 * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
	 * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
	 * [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-actionMethods) to customize this - by default any kind of read will be sent as a GET request and any kind of write
	 * will be sent as a POST request).
	 * 
	 * # Limitations
	 * 
	 * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
	 * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
	 * talking to each other via AJAX.
	 * 
	 * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
	 * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
	 * from http://domainA.com), you can use [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and a technique known as JSON-P (JSON with
	 * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
	 * JSON-P responses. See [JsonPProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html)'s introduction docs for more details.
	 * 
	 * # Readers and Writers
	 * 
	 * AjaxProxy can be configured to use any type of [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to decode the server's response.
	 * If no Reader is supplied, AjaxProxy will default to using a [JsonReader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Json.html). Reader
	 * configuration can be passed in as a simple object, which the Proxy automatically turns into a [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) instance:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        model: 'User',
	 *        reader: {
	 *            type: 'xml',
	 *            rootProperty: 'users'
	 *        }
	 *    });
	 *    
	 *    proxy.getReader(); //returns an XmlReader instance based on the config we supplied
	 * 
	 * # Url generation
	 * 
	 * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
	 * each request. These are controlled with the following configuration options:
	 * 
	 * - [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-pageParam) - controls how the page number is sent to the server (see also [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-startParam) and [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-limitParam))
	 * - [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-sortParam) - controls how sort information is sent to the server
	 * - [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-groupParam) - controls how grouping information is sent to the server
	 * - [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-filterParam) - controls how filter information is sent to the server
	 * 
	 * Each request sent by AjaxProxy is described by an [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html). To see how we can customize
	 * the generated urls, let's say we're loading the Proxy with the following Operation:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    var operation = proxy.createOperation('read', {
	 *        page  : 2
	 *    });
	 * 
	 * Now we'll issue the request for this Operation by calling [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-read):
	 * 
	 *    proxy.read(operation); //GET /users?page=2
	 * 
	 * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
	 * to the server:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users',
	 *        pageParam: 'pageNumber'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?pageNumber=2
	 * 
	 * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    var operation = proxy.createOperation('read', {
	 *        start : 50,
	 *        limit : 25
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?start=50&amp;limit;=25
	 * 
	 * Again we can customize this url:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users',
	 *        startParam: 'startIndex',
	 *        limitParam: 'limitIndex'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?startIndex=50&amp;limitIndex;=25
	 * 
	 * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
	 * expressive Operation object:
	 * 
	 *    var operation = proxy.createOperation('read', {
	 *        sorters: [
	 *            new Ext.util.Sorter({
	 *                property : 'name',
	 *                direction: 'ASC'
	 *            }),
	 *            new Ext.util.Sorter({
	 *                property : 'age',
	 *                direction: 'DESC'
	 *            })
	 *        ],
	 *        filters: [
	 *            new Ext.util.Filter({
	 *                property: 'eyeColor',
	 *                value   : 'brown'
	 *            })
	 *        ]
	 *    });
	 * 
	 * This is the type of object that is generated internally when loading a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) with sorters and
	 * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
	 * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&amp;filter;=[{"property":"eyeColor","value":"brown"}]
	 * 
	 * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
	 * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
	 * that format like this:
	 * 
	 *     var proxy = new Ext.data.proxy.Ajax({
	 *         url: '/users',
	 *         sortParam: 'sortBy',
	 *         filterParam: 'filterBy',
	 *    
	 *         //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
	 *         encodeSorters: function(sorters) {
	 *             var length   = sorters.length,
	 *                 sortStrs = [],
	 *                 sorter, i;
	 *    
	 *             for (i = 0; i &lt; length; i++) {
	 *                 sorter = sorters[i];
	 *    
	 *                 sortStrs[i] = sorter.property + '#' + sorter.direction
	 *             }
	 *    
	 *             return sortStrs.join(",");
	 *         }
	 *     });
	 *    
	 *     proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&amp;filterBy;=[{"property":"eyeColor","value":"brown"}]
	 * 
	 * We can also provide a custom [encodeFilters](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-encodeFilters) function to encode our filters.
	 * 
	 * # Debugging your Ajax Proxy
	 * 
	 * If the data is not being loaded into the store as expected, it could be due to a mismatch between the the way that the [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader)
	 * is configured, and the shape of the incoming data.
	 * 
	 * To debug from the point that your data arrives back from the network, set a breakpoint inside the callback function
	 * created in the `createRequestCallback` method of the Ajax Proxy class, and follow the data to where the [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader) attempts
	 * to consume it.
	 */
	class Ajax extends Ext.data.proxy.Server {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.proxy.Ajax.Statics}
		 */
		self?: Ext.data.proxy.Ajax.Statics | Ext.data.proxy.Server.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * Keep a default copy of the action methods here. Ideally could just null
		 * out actionMethods and just check if it exists &amp; has a property, otherwise
		 * fallback to the default. But at the moment it's defined as a public property,
		 * so we need to be able to maintain the ability to modify/access it.
		 * @property
		 * @private (property)
		 * @default {create: 'POST', read: 'GET', update: 'POST', destroy: 'POST'}
		 * @type {object}
		 */
		defaultActionMethods?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		isAjaxProxy?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                  members    The members to add to this class.
		 * @param   {boolean}                                                                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Ajax;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Server;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                  members
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.proxy.Ajax;
		static addStatics? (members: object): typeof Ext.data.proxy.Server;
		static addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                  members
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Ajax;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Server;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                  name
		 * @param   {object}                                                                  member
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Ajax;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Server;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                  fn
		 * @param   {object}                                                                  scope
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Ajax;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Server;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Creates an [Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object from [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html).
		 * 
		 * This gets called from doRequest methods in subclasses of Server proxy.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The operation to execute
		 * @returns {Ext.data.Request}                       The request object
		 */
		buildRequest? (operation: Ext.data.operation.Operation): Ext.data.Request;
		/** 
		 * Generates a url based on a given [Ext.data.Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object. By default, ServerProxy's buildUrl will add the
		 * cache-buster param to the end of the url. Subclasses may need to perform additional modifications to the url.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Request} request The request object
		 * @returns {string}                   The url
		 */
		buildUrl? (request: Ext.data.Request): string;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * in a ServerProxy all four CRUD operations are executed in the same manner, so we delegate to doRequest in each case
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		create? (): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * In ServerProxy subclasses, the [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-erase) methods all
		 * pass through to doRequest. Each ServerProxy subclass must implement the doRequest method - see [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for examples. This method carries the same signature as
		 * each of the methods that delegate to it.
		 * @method
		 * @public (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		doRequest? (operation: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.proxy.Server.doRequest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-doRequest).
		 * In ServerProxy subclasses, the [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-erase) methods all
		 * pass through to doRequest. Each ServerProxy subclass must implement the doRequest method - see [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for examples. This method carries the same signature as
		 * each of the methods that delegate to it.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) object
		 * @param   {Function}                     callback  The callback function to call when the Operation has completed
		 * @param   {object}                       scope     The scope in which to execute the callback
		 * @returns {void}                                   
		 */
		doRequest? (operation: Ext.data.operation.Operation, callback: ExtGlobalFunction, scope: object): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Encodes the array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Filter.html) objects into a string to be sent in the request url. By default,
		 * this simply JSON-encodes the filter data
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Filter[]} filters The array of [Filter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Filter.html) objects
		 * @returns {string}                    The encoded filters
		 */
		encodeFilters? (filters: Ext.util.Filter[]): string;
		/** 
		 * Encodes the array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Sorter.html) objects into a string to be sent in the request url. By default,
		 * this simply JSON-encodes the sorter data
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Sorter[]} sorters        The array of [Sorter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Sorter.html) objects
		 * @param   {boolean}           [preventArray] Prevents the items from being output as an array.
		 * @returns {string}                           The encoded sorters
		 */
		encodeSorters? (sorters: Ext.util.Sorter[], preventArray?: boolean): string;
		/** 
		 * Performs the given destroy operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		erase? (): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-actionMethods).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getActionMethods? (): object;
		/** 
		 * Returns the value of [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getApi? (): object;
		/** 
		 * Returns the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBatchActions? (): boolean;
		/** 
		 * Returns the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchOrder? (): string;
		/** 
		 * Returns the value of [binary](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-binary).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBinary? (): boolean;
		/** 
		 * Returns the value of [cacheString](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-cacheString).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getCacheString? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDirectionParam? (): string;
		/** 
		 * Returns the value of [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraParams? (): object;
		/** 
		 * Returns the value of [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-filterParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getFilterParam? (): string;
		/** 
		 * Returns the value of [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDirectionParam? (): string;
		/** 
		 * Returns the value of [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupParam? (): string;
		/** 
		 * Returns the value of [headers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-headers).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getHeaders? (): object;
		/** 
		 * Returns the value of [idParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-idParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getIdParam? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-limitParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getLimitParam? (): string;
		/** 
		 * Returns the HTTP method name for a given request. By default this returns based on a lookup on
		 * [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-actionMethods).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Request} request The request object
		 * @returns {string}                   The HTTP method to use (should be one of 'GET', 'POST', 'PUT' or 'DELETE')
		 */
		getMethod? (request: Ext.data.Request): string;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Returns the value of [noCache](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-noCache).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getNoCache? (): boolean;
		/** 
		 * Returns the value of [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-pageParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getPageParam? (): string;
		/** 
		 * Returns the value of [paramsAsJson](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-paramsAsJson).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getParamsAsJson? (): boolean;
		/** 
		 * Returns the value of [password](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-password).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getPassword? (): string;
		/** 
		 * Returns the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.reader.Reader}  
		 */
		getReader? (): object | string | Ext.data.reader.Reader;
		/** 
		 * Returns the value of [simpleGroupMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleGroupMode).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSimpleGroupMode? (): boolean;
		/** 
		 * Returns the value of [simpleSortMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleSortMode).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSimpleSortMode? (): boolean;
		/** 
		 * Returns the value of [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getSortParam? (): string;
		/** 
		 * Returns the value of [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-startParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStartParam? (): string;
		/** 
		 * Returns the value of [timeout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getTimeout? (): number;
		/** 
		 * Returns the value of [useDefaultXhrHeader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-useDefaultXhrHeader).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getUseDefaultXhrHeader? (): boolean;
		/** 
		 * Returns the value of [username](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-username).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getUsername? (): string;
		/** 
		 * Returns the value of [withCredentials](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-withCredentials).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getWithCredentials? (): boolean;
		/** 
		 * Returns the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.writer.Writer}  
		 */
		getWriter? (): object | string | Ext.data.writer.Writer;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given read operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-actionMethods).
		 * @method
		 * @public (method)
		 * @param   {object} actionMethods The new value.
		 * @returns {void}                 
		 */
		setActionMethods? (actionMethods: object): void;
		/** 
		 * Sets the value of [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api).
		 * @method
		 * @public (method)
		 * @param   {object} api The new value.
		 * @returns {void}       
		 */
		setApi? (api: object): void;
		/** 
		 * Sets the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @param   {boolean} batchActions The new value.
		 * @returns {void}                 
		 */
		setBatchActions? (batchActions: boolean): void;
		/** 
		 * Sets the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @param   {string} batchOrder The new value.
		 * @returns {void}              
		 */
		setBatchOrder? (batchOrder: string): void;
		/** 
		 * Sets the value of [binary](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-binary).
		 * @method
		 * @public (method)
		 * @param   {boolean} binary The new value.
		 * @returns {void}           
		 */
		setBinary? (binary: boolean): void;
		/** 
		 * Sets the value of [cacheString](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-cacheString).
		 * @method
		 * @public (method)
		 * @param   {string} cacheString The new value.
		 * @returns {void}               
		 */
		setCacheString? (cacheString: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                           name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                  [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Ajax;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Server;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Proxy;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam).
		 * @method
		 * @public (method)
		 * @param   {string} directionParam The new value.
		 * @returns {void}                  
		 */
		setDirectionParam? (directionParam: string): void;
		/** 
		 * Sets a value in the underlying [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @param   {string} name  The key for the new value
		 * @param   {object} value The value
		 * @returns {void}         
		 */
		setExtraParam? (name: string, value: object): void;
		/** 
		 * Sets the value of [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @param   {object} extraParams The new value.
		 * @returns {void}               
		 */
		setExtraParams? (extraParams: object): void;
		/** 
		 * Sets the value of [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-filterParam).
		 * @method
		 * @public (method)
		 * @param   {string} filterParam The new value.
		 * @returns {void}               
		 */
		setFilterParam? (filterParam: string): void;
		/** 
		 * Sets the value of [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam).
		 * @method
		 * @public (method)
		 * @param   {string} groupDirectionParam The new value.
		 * @returns {void}                       
		 */
		setGroupDirectionParam? (groupDirectionParam: string): void;
		/** 
		 * Sets the value of [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam).
		 * @method
		 * @public (method)
		 * @param   {string} groupParam The new value.
		 * @returns {void}              
		 */
		setGroupParam? (groupParam: string): void;
		/** 
		 * Sets the value of [headers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-headers).
		 * @method
		 * @public (method)
		 * @param   {object} headers The new value.
		 * @returns {void}           
		 */
		setHeaders? (headers: object): void;
		/** 
		 * Sets the value of [idParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-idParam).
		 * @method
		 * @public (method)
		 * @param   {string} idParam The new value.
		 * @returns {void}           
		 */
		setIdParam? (idParam: string): void;
		/** 
		 * Sets the value of [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-limitParam).
		 * @method
		 * @public (method)
		 * @param   {string} limitParam The new value.
		 * @returns {void}              
		 */
		setLimitParam? (limitParam: string): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [noCache](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-noCache).
		 * @method
		 * @public (method)
		 * @param   {boolean} noCache The new value.
		 * @returns {void}            
		 */
		setNoCache? (noCache: boolean): void;
		/** 
		 * Sets the value of [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-pageParam).
		 * @method
		 * @public (method)
		 * @param   {string} pageParam The new value.
		 * @returns {void}             
		 */
		setPageParam? (pageParam: string): void;
		/** 
		 * Sets the value of [paramsAsJson](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-paramsAsJson).
		 * @method
		 * @public (method)
		 * @param   {boolean} paramsAsJson The new value.
		 * @returns {void}                 
		 */
		setParamsAsJson? (paramsAsJson: boolean): void;
		/** 
		 * Sets the value of [password](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-password).
		 * @method
		 * @public (method)
		 * @param   {string} password The new value.
		 * @returns {void}            
		 */
		setPassword? (password: string): void;
		/** 
		 * Sets the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.reader.Reader} reader The new value.
		 * @returns {void}                                        
		 */
		setReader? (reader: object | string | Ext.data.reader.Reader): void;
		/** 
		 * Sets the value of [simpleGroupMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleGroupMode).
		 * @method
		 * @public (method)
		 * @param   {boolean} simpleGroupMode The new value.
		 * @returns {void}                    
		 */
		setSimpleGroupMode? (simpleGroupMode: boolean): void;
		/** 
		 * Sets the value of [simpleSortMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleSortMode).
		 * @method
		 * @public (method)
		 * @param   {boolean} simpleSortMode The new value.
		 * @returns {void}                   
		 */
		setSimpleSortMode? (simpleSortMode: boolean): void;
		/** 
		 * Sets the value of [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam).
		 * @method
		 * @public (method)
		 * @param   {string} sortParam The new value.
		 * @returns {void}             
		 */
		setSortParam? (sortParam: string): void;
		/** 
		 * Sets the value of [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-startParam).
		 * @method
		 * @public (method)
		 * @param   {string} startParam The new value.
		 * @returns {void}              
		 */
		setStartParam? (startParam: string): void;
		/** 
		 * Sets the value of [timeout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @param   {number} timeout The new value.
		 * @returns {void}           
		 */
		setTimeout? (timeout: number): void;
		/** 
		 * Sets the value of [url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * @method
		 * @public (method)
		 * @param   {string} url The new value.
		 * @returns {void}       
		 */
		setUrl? (url: string): void;
		/** 
		 * Sets the value of [useDefaultXhrHeader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-useDefaultXhrHeader).
		 * @method
		 * @public (method)
		 * @param   {boolean} useDefaultXhrHeader The new value.
		 * @returns {void}                        
		 */
		setUseDefaultXhrHeader? (useDefaultXhrHeader: boolean): void;
		/** 
		 * Sets the value of [username](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-username).
		 * @method
		 * @public (method)
		 * @param   {string} username The new value.
		 * @returns {void}            
		 */
		setUsername? (username: string): void;
		/** 
		 * Sets the value of [withCredentials](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-withCredentials).
		 * @method
		 * @public (method)
		 * @param   {boolean} withCredentials The new value.
		 * @returns {void}                    
		 */
		setWithCredentials? (withCredentials: boolean): void;
		/** 
		 * Sets the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.writer.Writer} writer The new value.
		 * @returns {void}                                        
		 */
		setWriter? (writer: object | string | Ext.data.writer.Writer): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given update operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		update? (): void;
		/** 
		 * Encode any values being sent to the server. Can be overridden in subclasses.
		 * @method
		 * @protected (method)
		 * @param   {any[]}  value An array of sorters/filters.
		 * @returns {object}       The encoded value
		 */
		applyEncoding? (value: any[]): object;
		/** 
		 * Template method to allow subclasses to specify how to get the response for the reader.
		 * @method
		 * @private (method)
		 * @template
		 * @param   {object} response The server response
		 * @returns {object}          The response data to be used by the reader
		 */
		extractResponseData? (response: object): object;
		/** 
		 * Get the url for the request taking into account the order of priority,
		 * 
		 * - The request
		 * - The api
		 * - The url
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Request} request The request
		 * @returns {string}                   The url
		 */
		getUrl? (request: Ext.data.Request): string;
		/** 
		 * Sets up an exception on the operation
		 * @method
		 * @private (method)
		 * @param   {Ext.data.operation.Operation} operation The operation
		 * @param   {object}                       response  The response
		 * @returns {void}                                   
		 */
		setException? (operation: Ext.data.operation.Operation, response: object): void;
		/** 
		 * Optional callback function which can be used to clean up after a request has been completed.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.data.Request} request The Request object
		 * @param   {boolean}          success True if the request was successful
		 * @returns {void}                     
		 */
		afterRequest? (request: Ext.data.Request, success: boolean): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                  config
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Ajax;
		initConfig? (config: object): Ext.data.proxy.Server;
		initConfig? (config: object): Ext.data.proxy.Proxy;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Processes response, which may involve updating or committing records, each of which
		 * will inform the owning stores and their interested views. Finally, we may perform
		 * an additional layout if the data shape has changed.
		 * @method
		 * @protected (method)
		 * @param   {object} success
		 * @param   {object} operation
		 * @param   {object} request
		 * @param   {object} response
		 * @returns {void}             
		 */
		processResponse? (success: object, operation: object, request: object, response: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Ajax.Statics|Ext.data.proxy.Server.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.proxy.Ajax.Statics;
		statics? (): Ext.data.proxy.Server.Statics;
		statics? (): Ext.data.proxy.Proxy.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		applyReader? (reader: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} writer
		 * @returns {void}          
		 */
		applyWriter? (writer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clone? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		completeOperation? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} config
		 * @returns {void}          
		 */
		createOperation? (action: object, config: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * TODO: This is currently identical to the JsonPProxy version except for the return function's signature. There is a lot
		 * of code duplication inside the returned function so we need to find a way to DRY this up.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Request}             request   The Request object
		 * @param   {Ext.data.operation.Operation} operation The Operation being executed
		 * @returns {Function}                               The callback function
		 */
		createRequestCallback? (request: Ext.data.Request, operation: Ext.data.operation.Operation): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Copy any sorters, filters etc into the params so they can be sent over the wire
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		getParams? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * The internal callback that the proxy uses to call any specified user callbacks after completion of a batch
		 * @method
		 * @private (method)
		 * @param   {object} batchOptions
		 * @param   {object} batch
		 * @returns {void}                
		 */
		onBatchComplete? (batchOptions: object, batch: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Called each time the reader's onMetaChange is called so that the proxy can fire the metachange event
		 * @method
		 * @private (method)
		 * @param   {object} meta
		 * @returns {void}        
		 */
		onMetaChange? (meta: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Fires a request
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Request} request The request
		 * @returns {Ext.data.Request}         The request
		 */
		sendRequest? (request: Ext.data.Request): Ext.data.Request;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                names The names of the linked objects to destroy.
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.proxy.Ajax;
		unlink? (names: string[]): Ext.data.proxy.Server;
		unlink? (names: string[]): Ext.data.proxy.Proxy;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} newExtraParams
		 * @param   {object} oldExtraParams
		 * @returns {void}                  
		 */
		updateExtraParams? (newExtraParams: object, oldExtraParams: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		updateModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		updateReader? (reader: object): void;
	}
	/** 
	 * Base class for any client-side storage. Used as a superclass for [Memory](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html) and
	 * [Web Storage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html) proxies. Do not use directly, use one of the subclasses instead.
	 * @private (class)
	 */
	class Client extends Ext.data.proxy.Proxy {}
	/** 
	 * [Ext.data.proxy.Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html)
	 * This class is used to send requests to the server using Ext Direct. When a
	 * request is made, the transport mechanism is handed off to the appropriate
	 * [Provider](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.RemotingProvider.html) to complete the call.
	 * 
	 * # Specifying the function
	 * 
	 * This proxy expects a Direct remoting method to be passed in order to be able to complete requests.
	 * This can be done by specifying the [directFn](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-directFn) configuration. This will use the same direct
	 * method for all requests. Alternatively, you can provide an [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-api) configuration. This
	 * allows you to specify a different remoting method for each CRUD action.
	 * 
	 * # Parameters
	 * 
	 * This proxy provides options to help configure which parameters will be sent to the server.
	 * By specifying the [paramsAsHash](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramsAsHash) option, it will send an object literal containing each
	 * of the passed parameters. The [paramOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramOrder) option can be used to specify the order in which
	 * the remoting method parameters are passed.
	 * 
	 * # Example Usage
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['firstName', 'lastName'],
	 *        proxy: {
	 *            type: 'direct',
	 *            directFn: MyApp.getUsers,
	 *            paramOrder: 'id' // Tells the proxy to pass the id as the first parameter to the remoting method.
	 *        }
	 *    });
	 *    User.load(1);
	 * 
	 */
	class Direct extends Ext.data.proxy.Server {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.proxy.Direct.Statics}
		 */
		self?: Ext.data.proxy.Direct.Statics | Ext.data.proxy.Server.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members    The members to add to this class.
		 * @param   {boolean}                                                                   [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                   [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Direct;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Server;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.proxy.Direct;
		static addStatics? (members: object): typeof Ext.data.proxy.Server;
		static addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Direct;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Server;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    name
		 * @param   {object}                                                                    member
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Direct;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Server;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    fn
		 * @param   {object}                                                                    scope
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Direct;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Server;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates the Proxy
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Encode any values being sent to the server. Can be overridden in subclasses.
		 * @method
		 * @public (method)
		 * @param   {any[]}  value An array of sorters/filters.
		 * @returns {object}       The encoded value
		 */
		applyEncoding? (value: any[]): object;
		/** 
		 * Creates an [Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object from [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html).
		 * 
		 * This gets called from doRequest methods in subclasses of Server proxy.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The operation to execute
		 * @returns {Ext.data.Request}                       The request object
		 */
		buildRequest? (operation: Ext.data.operation.Operation): Ext.data.Request;
		/** 
		 * Generates a url based on a given [Ext.data.Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object. By default, ServerProxy's buildUrl will add the
		 * cache-buster param to the end of the url. Subclasses may need to perform additional modifications to the url.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Request} request The request object
		 * @returns {string}                   The url
		 */
		buildUrl? (request: Ext.data.Request): string;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * in a ServerProxy all four CRUD operations are executed in the same manner, so we delegate to doRequest in each case
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		create? (): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * In ServerProxy subclasses, the [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#method-erase) methods all
		 * pass through to doRequest. Each ServerProxy subclass must implement the doRequest method - see [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for examples. This method carries the same signature as
		 * each of the methods that delegate to it.
		 * @method
		 * @public (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		doRequest? (operation: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.proxy.Server.doRequest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-doRequest).
		 * In ServerProxy subclasses, the [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-erase) methods all
		 * pass through to doRequest. Each ServerProxy subclass must implement the doRequest method - see [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for examples. This method carries the same signature as
		 * each of the methods that delegate to it.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) object
		 * @param   {Function}                     callback  The callback function to call when the Operation has completed
		 * @param   {object}                       scope     The scope in which to execute the callback
		 * @returns {void}                                   
		 */
		doRequest? (operation: Ext.data.operation.Operation, callback: ExtGlobalFunction, scope: object): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Encodes the array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Filter.html) objects into a string to be sent in the request url. By default,
		 * this simply JSON-encodes the filter data
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Filter[]} filters The array of [Filter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Filter.html) objects
		 * @returns {string}                    The encoded filters
		 */
		encodeFilters? (filters: Ext.util.Filter[]): string;
		/** 
		 * Encodes the array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Sorter.html) objects into a string to be sent in the request url. By default,
		 * this simply JSON-encodes the sorter data
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Sorter[]} sorters        The array of [Sorter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Sorter.html) objects
		 * @param   {boolean}           [preventArray] Prevents the items from being output as an array.
		 * @returns {string}                           The encoded sorters
		 */
		encodeSorters? (sorters: Ext.util.Sorter[], preventArray?: boolean): string;
		/** 
		 * Performs the given destroy operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		erase? (): void;
		/** 
		 * Template method to allow subclasses to specify how to get the response for the reader.
		 * @method
		 * @public (method)
		 * @param   {object} response The server response
		 * @returns {object}          The response data to be used by the reader
		 */
		extractResponseData? (response: object): object;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-api).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getApi? (): object;
		/** 
		 * Returns the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBatchActions? (): boolean;
		/** 
		 * Returns the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchOrder? (): string;
		/** 
		 * Returns the value of [cacheString](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-cacheString).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getCacheString? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [directFn](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-directFn).
		 * @method
		 * @public (method)
		 * @returns {Function|string}  
		 */
		getDirectFn? (): ExtGlobalFunction | string;
		/** 
		 * Returns the value of [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDirectionParam? (): string;
		/** 
		 * Returns the value of [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraParams? (): object;
		/** 
		 * Returns the value of [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-filterParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getFilterParam? (): string;
		/** 
		 * Returns the value of [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDirectionParam? (): string;
		/** 
		 * Returns the value of [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupParam? (): string;
		/** 
		 * Returns the value of [idParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-idParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getIdParam? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-limitParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getLimitParam? (): string;
		/** 
		 * Returns the value of [metadata](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-metadata).
		 * @method
		 * @public (method)
		 * @returns {object|any[]}  
		 */
		getMetadata? (): object | any[];
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Returns the value of [noCache](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-noCache).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getNoCache? (): boolean;
		/** 
		 * Returns the value of [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-pageParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getPageParam? (): string;
		/** 
		 * Returns the value of [paramOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramOrder).
		 * @method
		 * @public (method)
		 * @returns {string|string[]}  
		 */
		getParamOrder? (): string | string[];
		/** 
		 * Returns the value of [paramsAsHash](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramsAsHash).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getParamsAsHash? (): boolean;
		/** 
		 * Returns the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.reader.Reader}  
		 */
		getReader? (): object | string | Ext.data.reader.Reader;
		/** 
		 * Returns the value of [simpleGroupMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleGroupMode).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSimpleGroupMode? (): boolean;
		/** 
		 * Returns the value of [simpleSortMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleSortMode).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSimpleSortMode? (): boolean;
		/** 
		 * Returns the value of [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getSortParam? (): string;
		/** 
		 * Returns the value of [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-startParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStartParam? (): string;
		/** 
		 * Returns the value of [timeout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getTimeout? (): number;
		/** 
		 * Returns the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.writer.Writer}  
		 */
		getWriter? (): object | string | Ext.data.writer.Writer;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given read operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-api).
		 * @method
		 * @public (method)
		 * @param   {object} api The new value.
		 * @returns {void}       
		 */
		setApi? (api: object): void;
		/** 
		 * Sets the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @param   {boolean} batchActions The new value.
		 * @returns {void}                 
		 */
		setBatchActions? (batchActions: boolean): void;
		/** 
		 * Sets the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @param   {string} batchOrder The new value.
		 * @returns {void}              
		 */
		setBatchOrder? (batchOrder: string): void;
		/** 
		 * Sets the value of [cacheString](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-cacheString).
		 * @method
		 * @public (method)
		 * @param   {string} cacheString The new value.
		 * @returns {void}               
		 */
		setCacheString? (cacheString: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                             name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                    [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Direct;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Server;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Proxy;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [directFn](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-directFn).
		 * @method
		 * @public (method)
		 * @param   {Function|string} directFn The new value.
		 * @returns {void}                     
		 */
		setDirectFn? (directFn: ExtGlobalFunction | string): void;
		/** 
		 * Sets the value of [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam).
		 * @method
		 * @public (method)
		 * @param   {string} directionParam The new value.
		 * @returns {void}                  
		 */
		setDirectionParam? (directionParam: string): void;
		/** 
		 * Sets up an exception on the operation
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The operation
		 * @param   {object}                       response  The response
		 * @returns {void}                                   
		 */
		setException? (operation: Ext.data.operation.Operation, response: object): void;
		/** 
		 * Sets a value in the underlying [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @param   {string} name  The key for the new value
		 * @param   {object} value The value
		 * @returns {void}         
		 */
		setExtraParam? (name: string, value: object): void;
		/** 
		 * Sets the value of [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @param   {object} extraParams The new value.
		 * @returns {void}               
		 */
		setExtraParams? (extraParams: object): void;
		/** 
		 * Sets the value of [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-filterParam).
		 * @method
		 * @public (method)
		 * @param   {string} filterParam The new value.
		 * @returns {void}               
		 */
		setFilterParam? (filterParam: string): void;
		/** 
		 * Sets the value of [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam).
		 * @method
		 * @public (method)
		 * @param   {string} groupDirectionParam The new value.
		 * @returns {void}                       
		 */
		setGroupDirectionParam? (groupDirectionParam: string): void;
		/** 
		 * Sets the value of [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam).
		 * @method
		 * @public (method)
		 * @param   {string} groupParam The new value.
		 * @returns {void}              
		 */
		setGroupParam? (groupParam: string): void;
		/** 
		 * Sets the value of [idParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-idParam).
		 * @method
		 * @public (method)
		 * @param   {string} idParam The new value.
		 * @returns {void}           
		 */
		setIdParam? (idParam: string): void;
		/** 
		 * Sets the value of [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-limitParam).
		 * @method
		 * @public (method)
		 * @param   {string} limitParam The new value.
		 * @returns {void}              
		 */
		setLimitParam? (limitParam: string): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [metadata](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-metadata).
		 * @method
		 * @public (method)
		 * @param   {object|any[]} metadata The new value.
		 * @returns {void}                  
		 */
		setMetadata? (metadata: object | any[]): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [noCache](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-noCache).
		 * @method
		 * @public (method)
		 * @param   {boolean} noCache The new value.
		 * @returns {void}            
		 */
		setNoCache? (noCache: boolean): void;
		/** 
		 * Sets the value of [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-pageParam).
		 * @method
		 * @public (method)
		 * @param   {string} pageParam The new value.
		 * @returns {void}             
		 */
		setPageParam? (pageParam: string): void;
		/** 
		 * Sets the value of [paramOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramOrder).
		 * @method
		 * @public (method)
		 * @param   {string|string[]} paramOrder The new value.
		 * @returns {void}                       
		 */
		setParamOrder? (paramOrder: string | string[]): void;
		/** 
		 * Sets the value of [paramsAsHash](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramsAsHash).
		 * @method
		 * @public (method)
		 * @param   {boolean} paramsAsHash The new value.
		 * @returns {void}                 
		 */
		setParamsAsHash? (paramsAsHash: boolean): void;
		/** 
		 * Sets the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.reader.Reader} reader The new value.
		 * @returns {void}                                        
		 */
		setReader? (reader: object | string | Ext.data.reader.Reader): void;
		/** 
		 * Sets the value of [simpleGroupMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleGroupMode).
		 * @method
		 * @public (method)
		 * @param   {boolean} simpleGroupMode The new value.
		 * @returns {void}                    
		 */
		setSimpleGroupMode? (simpleGroupMode: boolean): void;
		/** 
		 * Sets the value of [simpleSortMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleSortMode).
		 * @method
		 * @public (method)
		 * @param   {boolean} simpleSortMode The new value.
		 * @returns {void}                   
		 */
		setSimpleSortMode? (simpleSortMode: boolean): void;
		/** 
		 * Sets the value of [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam).
		 * @method
		 * @public (method)
		 * @param   {string} sortParam The new value.
		 * @returns {void}             
		 */
		setSortParam? (sortParam: string): void;
		/** 
		 * Sets the value of [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-startParam).
		 * @method
		 * @public (method)
		 * @param   {string} startParam The new value.
		 * @returns {void}              
		 */
		setStartParam? (startParam: string): void;
		/** 
		 * Sets the value of [timeout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @param   {number} timeout The new value.
		 * @returns {void}           
		 */
		setTimeout? (timeout: number): void;
		/** 
		 * Sets the value of [url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * @method
		 * @public (method)
		 * @param   {string} url The new value.
		 * @returns {void}       
		 */
		setUrl? (url: string): void;
		/** 
		 * Sets the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.writer.Writer} writer The new value.
		 * @returns {void}                                        
		 */
		setWriter? (writer: object | string | Ext.data.writer.Writer): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given update operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		update? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		abort? (): void;
		/** 
		 * Get the url for the request taking into account the order of priority,
		 * 
		 * - The request
		 * - The api
		 * - The url
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Request} request The request
		 * @returns {string}                   The url
		 */
		getUrl? (request: Ext.data.Request): string;
		/** 
		 * Optional callback function which can be used to clean up after a request has been completed.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.data.Request} request The Request object
		 * @param   {boolean}          success True if the request was successful
		 * @returns {void}                     
		 */
		afterRequest? (request: Ext.data.Request, success: boolean): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                    config
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Direct;
		initConfig? (config: object): Ext.data.proxy.Server;
		initConfig? (config: object): Ext.data.proxy.Proxy;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Processes response, which may involve updating or committing records, each of which
		 * will inform the owning stores and their interested views. Finally, we may perform
		 * an additional layout if the data shape has changed.
		 * @method
		 * @protected (method)
		 * @param   {object} success
		 * @param   {object} operation
		 * @param   {object} request
		 * @param   {object} response
		 * @returns {void}             
		 */
		processResponse? (success: object, operation: object, request: object, response: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Direct.Statics|Ext.data.proxy.Server.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.proxy.Direct.Statics;
		statics? (): Ext.data.proxy.Server.Statics;
		statics? (): Ext.data.proxy.Proxy.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		applyReader? (reader: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} writer
		 * @returns {void}          
		 */
		applyWriter? (writer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clone? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		completeOperation? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} config
		 * @returns {void}          
		 */
		createOperation? (action: object, config: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Copy any sorters, filters etc into the params so they can be sent over the wire
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		getParams? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * The internal callback that the proxy uses to call any specified user callbacks after completion of a batch
		 * @method
		 * @private (method)
		 * @param   {object} batchOptions
		 * @param   {object} batch
		 * @returns {void}                
		 */
		onBatchComplete? (batchOptions: object, batch: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Called each time the reader's onMetaChange is called so that the proxy can fire the metachange event
		 * @method
		 * @private (method)
		 * @param   {object} meta
		 * @returns {void}        
		 */
		onMetaChange? (meta: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                  names The names of the linked objects to destroy.
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.proxy.Direct;
		unlink? (names: string[]): Ext.data.proxy.Server;
		unlink? (names: string[]): Ext.data.proxy.Proxy;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} newExtraParams
		 * @param   {object} oldExtraParams
		 * @returns {void}                  
		 */
		updateExtraParams? (newExtraParams: object, oldExtraParams: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		updateModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		updateReader? (reader: object): void;
	}
	/** 
	 * [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html)
	 * The JsonP proxy is useful when you need to load data from a domain other than the one your application is running on. If
	 * your application is running on http://domainA.com it cannot use [Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) to load its data
	 * from http://domainB.com because cross-domain ajax requests are prohibited by the browser.
	 * 
	 * We can get around this using a JsonP proxy. JsonP proxy injects a `&lt;script&gt;` tag into the DOM whenever an AJAX request
	 * would usually be made. Let's say we want to load data from http://domainB.com/users - the script tag that would be
	 * injected might look like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?callback=someCallback"&gt;&lt;/script&gt;
	 * 
	 * When we inject the tag above, the browser makes a request to that url and includes the response as if it was any
	 * other type of JavaScript include. By passing a callback in the url above, we're telling domainB's server that we want
	 * to be notified when the result comes in and that it should call our callback function with the data it sends back. So
	 * long as the server formats the response to look like this, everything will work:
	 * 
	 *    someCallback({
	 *        users: [
	 *            {
	 *                id: 1,
	 *                name: "Ed Spencer",
	 *                email: "ed@sencha.com"
	 *            }
	 *        ]
	 *    });
	 * 
	 * As soon as the script finishes loading, the 'someCallback' function that we passed in the url is called with the JSON
	 * object that the server returned.
	 * 
	 * JsonP proxy takes care of all of this automatically. It formats the url you pass, adding the callback parameter
	 * automatically. It even creates a temporary callback function, waits for it to be called and then puts the data into
	 * the Proxy making it look just like you loaded it through a normal [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html). Here's how
	 * we might set that up:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email']
	 *    });
	 *    
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'jsonp',
	 *            url : 'http://domainB.com/users'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * That's all we need to do - JsonP proxy takes care of the rest. In this case the Proxy will have injected a script tag
	 * like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?callback=callback1"&gt;&lt;/script&gt;
	 * 
	 * # Customization
	 * 
	 * This script tag can be customized using the [callbackKey](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-callbackKey) configuration. For example:
	 * 
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'jsonp',
	 *            url : 'http://domainB.com/users',
	 *            callbackKey: 'theCallbackFunction'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * Would inject a script tag like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?theCallbackFunction=callback1"&gt;&lt;/script&gt;
	 * 
	 * # Implementing on the server side
	 * 
	 * The remote server side needs to be configured to return data in this format. Here are suggestions for how you might
	 * achieve this using Java, PHP and ASP.net:
	 * 
	 * Java:
	 * 
	 *    boolean jsonP = false;
	 *    String cb = request.getParameter("callback");
	 *    if (cb != null) {
	 *        jsonP = true;
	 *        response.setContentType("text/javascript");
	 *    } else {
	 *        response.setContentType("application/x-json");
	 *    }
	 *    Writer out = response.getWriter();
	 *    if (jsonP) {
	 *        out.write(cb + "(");
	 *    }
	 *    out.print(dataBlock.toJsonString());
	 *    if (jsonP) {
	 *        out.write(");");
	 *    }
	 * 
	 * PHP:
	 * 
	 *    $callback = $_REQUEST['callback'];
	 *    
	 *    // Create the output object.
	 *    $output = array('a' =&gt; 'Apple', 'b' =&gt; 'Banana');
	 *    
	 *    //start output
	 *    if ($callback) {
	 *        header('Content-Type: text/javascript');
	 *        echo $callback . '(' . json_encode($output) . ');';
	 *    } else {
	 *        header('Content-Type: application/x-json');
	 *        echo json_encode($output);
	 *    }
	 * 
	 * ASP.net:
	 * 
	 *    String jsonString = "{success: true}";
	 *    String cb = Request.Params.Get("callback");
	 *    String responseString = "";
	 *    if (!String.IsNullOrEmpty(cb)) {
	 *        responseString = cb + "(" + jsonString + ")";
	 *    } else {
	 *        responseString = jsonString;
	 *    }
	 *    Response.Write(responseString);
	 * 
	 */
	class JsonP extends Ext.data.proxy.Server {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.proxy.JsonP.Statics}
		 */
		self?: Ext.data.proxy.JsonP.Statics | Ext.data.proxy.Server.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                   members    The members to add to this class.
		 * @param   {boolean}                                                                  [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                  [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.JsonP;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Server;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                   members
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.proxy.JsonP;
		static addStatics? (members: object): typeof Ext.data.proxy.Server;
		static addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                   members
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.JsonP;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Server;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                   name
		 * @param   {object}                                                                   member
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.proxy.JsonP;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Server;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                   fn
		 * @param   {object}                                                                   scope
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.JsonP;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Server;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates the Proxy
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Creates an [Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object from [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html).
		 * 
		 * This gets called from doRequest methods in subclasses of Server proxy.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The operation to execute
		 * @returns {Ext.data.Request}                       The request object
		 */
		buildRequest? (operation: Ext.data.operation.Operation): Ext.data.Request;
		/** 
		 * Generates a url based on a given [Ext.data.Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object. Adds the params and callback function name to the url
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Request} request The request object
		 * @returns {string}                   The url
		 */
		buildUrl? (request: Ext.data.Request): string;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * in a ServerProxy all four CRUD operations are executed in the same manner, so we delegate to doRequest in each case
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		create? (): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Encodes the array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Filter.html) objects into a string to be sent in the request url. By default,
		 * this simply JSON-encodes the filter data
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Filter[]} filters The array of [Filter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Filter.html) objects
		 * @returns {string}                    The encoded filters
		 */
		encodeFilters? (filters: Ext.util.Filter[]): string;
		/** 
		 * Encodes an array of records into a value suitable to be added to the request `params` as the [recordParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-recordParam) parameter.
		 * This is broken out into its own function so that it can be easily overridden.
		 * 
		 * The default implementation
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]} records The records array
		 * @returns {any[]}                    An array of record data objects
		 */
		encodeRecords? (records: Ext.data.Model[]): any[];
		/** 
		 * Encodes the array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Sorter.html) objects into a string to be sent in the request url. By default,
		 * this simply JSON-encodes the sorter data
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Sorter[]} sorters        The array of [Sorter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Sorter.html) objects
		 * @param   {boolean}           [preventArray] Prevents the items from being output as an array.
		 * @returns {string}                           The encoded sorters
		 */
		encodeSorters? (sorters: Ext.util.Sorter[], preventArray?: boolean): string;
		/** 
		 * Performs the given destroy operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		erase? (): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getApi? (): object;
		/** 
		 * Returns the value of [autoAppendParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-autoAppendParams).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoAppendParams? (): boolean;
		/** 
		 * Returns the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBatchActions? (): boolean;
		/** 
		 * Returns the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchOrder? (): string;
		/** 
		 * Returns the value of [cacheString](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-cacheString).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getCacheString? (): string;
		/** 
		 * Returns the value of [callbackKey](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-callbackKey).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getCallbackKey? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDirectionParam? (): string;
		/** 
		 * Returns the value of [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraParams? (): object;
		/** 
		 * Returns the value of [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-filterParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getFilterParam? (): string;
		/** 
		 * Returns the value of [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDirectionParam? (): string;
		/** 
		 * Returns the value of [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupParam? (): string;
		/** 
		 * Returns the value of [idParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-idParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getIdParam? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-limitParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getLimitParam? (): string;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Returns the value of [noCache](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-noCache).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getNoCache? (): boolean;
		/** 
		 * Returns the value of [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-pageParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getPageParam? (): string;
		/** 
		 * Returns the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.reader.Reader}  
		 */
		getReader? (): object | string | Ext.data.reader.Reader;
		/** 
		 * Returns the value of [recordParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-recordParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getRecordParam? (): string;
		/** 
		 * Returns the value of [simpleGroupMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleGroupMode).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSimpleGroupMode? (): boolean;
		/** 
		 * Returns the value of [simpleSortMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleSortMode).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSimpleSortMode? (): boolean;
		/** 
		 * Returns the value of [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getSortParam? (): string;
		/** 
		 * Returns the value of [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-startParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStartParam? (): string;
		/** 
		 * Returns the value of [timeout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getTimeout? (): number;
		/** 
		 * Returns the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.writer.Writer}  
		 */
		getWriter? (): object | string | Ext.data.writer.Writer;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given read operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api).
		 * @method
		 * @public (method)
		 * @param   {object} api The new value.
		 * @returns {void}       
		 */
		setApi? (api: object): void;
		/** 
		 * Sets the value of [autoAppendParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-autoAppendParams).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoAppendParams The new value.
		 * @returns {void}                     
		 */
		setAutoAppendParams? (autoAppendParams: boolean): void;
		/** 
		 * Sets the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @param   {boolean} batchActions The new value.
		 * @returns {void}                 
		 */
		setBatchActions? (batchActions: boolean): void;
		/** 
		 * Sets the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @param   {string} batchOrder The new value.
		 * @returns {void}              
		 */
		setBatchOrder? (batchOrder: string): void;
		/** 
		 * Sets the value of [cacheString](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-cacheString).
		 * @method
		 * @public (method)
		 * @param   {string} cacheString The new value.
		 * @returns {void}               
		 */
		setCacheString? (cacheString: string): void;
		/** 
		 * Sets the value of [callbackKey](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-callbackKey).
		 * @method
		 * @public (method)
		 * @param   {string} callbackKey The new value.
		 * @returns {void}               
		 */
		setCallbackKey? (callbackKey: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                            name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                   [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.JsonP;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Server;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Proxy;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam).
		 * @method
		 * @public (method)
		 * @param   {string} directionParam The new value.
		 * @returns {void}                  
		 */
		setDirectionParam? (directionParam: string): void;
		/** 
		 * Sets a value in the underlying [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @param   {string} name  The key for the new value
		 * @param   {object} value The value
		 * @returns {void}         
		 */
		setExtraParam? (name: string, value: object): void;
		/** 
		 * Sets the value of [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @param   {object} extraParams The new value.
		 * @returns {void}               
		 */
		setExtraParams? (extraParams: object): void;
		/** 
		 * Sets the value of [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-filterParam).
		 * @method
		 * @public (method)
		 * @param   {string} filterParam The new value.
		 * @returns {void}               
		 */
		setFilterParam? (filterParam: string): void;
		/** 
		 * Sets the value of [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam).
		 * @method
		 * @public (method)
		 * @param   {string} groupDirectionParam The new value.
		 * @returns {void}                       
		 */
		setGroupDirectionParam? (groupDirectionParam: string): void;
		/** 
		 * Sets the value of [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam).
		 * @method
		 * @public (method)
		 * @param   {string} groupParam The new value.
		 * @returns {void}              
		 */
		setGroupParam? (groupParam: string): void;
		/** 
		 * Sets the value of [idParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-idParam).
		 * @method
		 * @public (method)
		 * @param   {string} idParam The new value.
		 * @returns {void}           
		 */
		setIdParam? (idParam: string): void;
		/** 
		 * Sets the value of [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-limitParam).
		 * @method
		 * @public (method)
		 * @param   {string} limitParam The new value.
		 * @returns {void}              
		 */
		setLimitParam? (limitParam: string): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [noCache](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-noCache).
		 * @method
		 * @public (method)
		 * @param   {boolean} noCache The new value.
		 * @returns {void}            
		 */
		setNoCache? (noCache: boolean): void;
		/** 
		 * Sets the value of [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-pageParam).
		 * @method
		 * @public (method)
		 * @param   {string} pageParam The new value.
		 * @returns {void}             
		 */
		setPageParam? (pageParam: string): void;
		/** 
		 * Sets the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.reader.Reader} reader The new value.
		 * @returns {void}                                        
		 */
		setReader? (reader: object | string | Ext.data.reader.Reader): void;
		/** 
		 * Sets the value of [recordParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-recordParam).
		 * @method
		 * @public (method)
		 * @param   {string} recordParam The new value.
		 * @returns {void}               
		 */
		setRecordParam? (recordParam: string): void;
		/** 
		 * Sets the value of [simpleGroupMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleGroupMode).
		 * @method
		 * @public (method)
		 * @param   {boolean} simpleGroupMode The new value.
		 * @returns {void}                    
		 */
		setSimpleGroupMode? (simpleGroupMode: boolean): void;
		/** 
		 * Sets the value of [simpleSortMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleSortMode).
		 * @method
		 * @public (method)
		 * @param   {boolean} simpleSortMode The new value.
		 * @returns {void}                   
		 */
		setSimpleSortMode? (simpleSortMode: boolean): void;
		/** 
		 * Sets the value of [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam).
		 * @method
		 * @public (method)
		 * @param   {string} sortParam The new value.
		 * @returns {void}             
		 */
		setSortParam? (sortParam: string): void;
		/** 
		 * Sets the value of [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-startParam).
		 * @method
		 * @public (method)
		 * @param   {string} startParam The new value.
		 * @returns {void}              
		 */
		setStartParam? (startParam: string): void;
		/** 
		 * Sets the value of [timeout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @param   {number} timeout The new value.
		 * @returns {void}           
		 */
		setTimeout? (timeout: number): void;
		/** 
		 * Sets the value of [url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * @method
		 * @public (method)
		 * @param   {string} url The new value.
		 * @returns {void}       
		 */
		setUrl? (url: string): void;
		/** 
		 * Sets the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.writer.Writer} writer The new value.
		 * @returns {void}                                        
		 */
		setWriter? (writer: object | string | Ext.data.writer.Writer): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given update operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		update? (): void;
		/** 
		 * Encode any values being sent to the server. Can be overridden in subclasses.
		 * @method
		 * @protected (method)
		 * @param   {any[]}  value An array of sorters/filters.
		 * @returns {object}       The encoded value
		 */
		applyEncoding? (value: any[]): object;
		/** 
		 * Performs the read request to the remote domain. JsonP proxy does not actually create an Ajax request,
		 * instead we write out a `&lt;script&gt;` tag based on the configuration of the internal [Ext.data.Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object
		 * @method
		 * @private (method)
		 * @param   {Ext.data.operation.Operation} operation The [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) object to execute
		 * @param   {Function}                     callback  A callback function to execute when the Operation has been completed
		 * @param   {object}                       scope     The scope to execute the callback in
		 * @returns {void}                                   
		 */
		doRequest? (operation: Ext.data.operation.Operation, callback: ExtGlobalFunction, scope: object): void;
		/** 
		 * Template method to allow subclasses to specify how to get the response for the reader.
		 * @method
		 * @private (method)
		 * @template
		 * @param   {object} response The server response
		 * @returns {object}          The response data to be used by the reader
		 */
		extractResponseData? (response: object): object;
		/** 
		 * Get the url for the request taking into account the order of priority,
		 * 
		 * - The request
		 * - The api
		 * - The url
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Request} request The request
		 * @returns {string}                   The url
		 */
		getUrl? (request: Ext.data.Request): string;
		/** 
		 * Sets up an exception on the operation
		 * @method
		 * @private (method)
		 * @param   {Ext.data.operation.Operation} operation The operation
		 * @param   {object}                       response  The response
		 * @returns {void}                                   
		 */
		setException? (operation: Ext.data.operation.Operation, response: object): void;
		/** 
		 * Optional callback function which can be used to clean up after a request has been completed.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.data.Request} request The Request object
		 * @param   {boolean}          success True if the request was successful
		 * @returns {void}                     
		 */
		afterRequest? (request: Ext.data.Request, success: boolean): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                   config
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.proxy.JsonP;
		initConfig? (config: object): Ext.data.proxy.Server;
		initConfig? (config: object): Ext.data.proxy.Proxy;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Processes response, which may involve updating or committing records, each of which
		 * will inform the owning stores and their interested views. Finally, we may perform
		 * an additional layout if the data shape has changed.
		 * @method
		 * @protected (method)
		 * @param   {object} success
		 * @param   {object} operation
		 * @param   {object} request
		 * @param   {object} response
		 * @returns {void}             
		 */
		processResponse? (success: object, operation: object, request: object, response: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.JsonP.Statics|Ext.data.proxy.Server.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.proxy.JsonP.Statics;
		statics? (): Ext.data.proxy.Server.Statics;
		statics? (): Ext.data.proxy.Proxy.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		applyReader? (reader: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} writer
		 * @returns {void}          
		 */
		applyWriter? (writer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clone? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		completeOperation? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} config
		 * @returns {void}          
		 */
		createOperation? (action: object, config: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Copy any sorters, filters etc into the params so they can be sent over the wire
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		getParams? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * The internal callback that the proxy uses to call any specified user callbacks after completion of a batch
		 * @method
		 * @private (method)
		 * @param   {object} batchOptions
		 * @param   {object} batch
		 * @returns {void}                
		 */
		onBatchComplete? (batchOptions: object, batch: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Called each time the reader's onMetaChange is called so that the proxy can fire the metachange event
		 * @method
		 * @private (method)
		 * @param   {object} meta
		 * @returns {void}        
		 */
		onMetaChange? (meta: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                 names The names of the linked objects to destroy.
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.proxy.JsonP;
		unlink? (names: string[]): Ext.data.proxy.Server;
		unlink? (names: string[]): Ext.data.proxy.Proxy;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} newExtraParams
		 * @param   {object} oldExtraParams
		 * @returns {void}                  
		 */
		updateExtraParams? (newExtraParams: object, oldExtraParams: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		updateModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		updateReader? (reader: object): void;
	}
	/** 
	 * [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html)
	 * The LocalStorageProxy uses the new HTML5 localStorage API to save [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) data locally on the
	 * client browser. HTML5 localStorage is a key-value store (e.g. cannot save complex objects like JSON), so
	 * LocalStorageProxy automatically serializes and deserializes data when saving and retrieving it.
	 * 
	 * localStorage is extremely useful for saving user-specific information without needing to build server-side
	 * infrastructure to support it. Let's imagine we're writing a Twitter search application and want to save the user's
	 * searches locally so they can easily perform a saved search again later. We'd start by creating a Search model:
	 * 
	 *    Ext.define('Search', {
	 *        fields: ['id', 'query'],
	 *        extend: 'Ext.data.Model',
	 *        proxy: {
	 *            type: 'localstorage',
	 *            id  : 'twitter-Searches'
	 *        }
	 *    });
	 * 
	 * Our Search model contains just two fields - id and query - plus a Proxy definition. The only configuration we need to
	 * pass to the LocalStorage proxy is an [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html#cfg-id). This is important as it separates the Model data in this Proxy from
	 * all others. The localStorage API puts all data into a single shared namespace, so by setting an id we enable
	 * LocalStorageProxy to manage the saved Search data.
	 * 
	 * Saving our data into localStorage is easy and would usually be done with a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html):
	 * 
	 *    //our Store automatically picks up the LocalStorageProxy defined on the Search model
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: "Search"
	 *    });
	 *    
	 *    //loads any existing Search data from localStorage
	 *    store.load();
	 *    
	 *    //now add some Searches
	 *    store.add({query: 'Sencha Touch'});
	 *    store.add({query: 'Ext JS'});
	 *    
	 *    //finally, save our Search data to localStorage
	 *    store.sync();
	 * 
	 * The LocalStorageProxy automatically gives our new Searches an id when we call store.sync(). It encodes the Model data
	 * and places it into localStorage. We can also save directly to localStorage, bypassing the Store altogether:
	 * 
	 *    var search = Ext.create('Search', {query: 'Sencha Animator'});
	 *    
	 *    //uses the configured LocalStorageProxy to save the new Search to localStorage
	 *    search.save();
	 * 
	 * # Limitations
	 * 
	 * If this proxy is used in a browser where local storage is not supported, the constructor will throw an error. A local
	 * storage proxy requires a unique ID which is used as a key in which all record data are stored in the local storage
	 * object.
	 * 
	 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
	 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
	 */
	class LocalStorage extends Ext.data.proxy.WebStorage {
		/** 
		 * `true` in this class to identify that requests made on this proxy are
		 * performed synchronously
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isSynchronous?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.proxy.LocalStorage.Statics}
		 */
		self?: Ext.data.proxy.LocalStorage.Statics | Ext.data.proxy.WebStorage.Statics | Ext.data.proxy.Client.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                    members    The members to add to this class.
		 * @param   {boolean}                                                                                                   [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                                   [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.LocalStorage;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.WebStorage;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Client;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                    members
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.proxy.LocalStorage;
		static addStatics? (members: object): typeof Ext.data.proxy.WebStorage;
		static addStatics? (members: object): typeof Ext.data.proxy.Client;
		static addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                    members
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.LocalStorage;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.WebStorage;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Client;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                    name
		 * @param   {object}                                                                                                    member
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.proxy.LocalStorage;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.WebStorage;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Client;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                    fn
		 * @param   {object}                                                                                                    scope
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.LocalStorage;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.WebStorage;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Client;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates the proxy, throws an error if local storage is not supported in the current browser.
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Destroys all records stored in the proxy and removes all keys and values used to support the proxy from the
		 * storage object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clear? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Performs the given create operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		create? (operation: Ext.data.operation.Operation): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Performs the given destroy operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		erase? (operation: Ext.data.operation.Operation): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBatchActions? (): boolean;
		/** 
		 * Returns the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchOrder? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html#cfg-id).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getId? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Returns the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.reader.Reader}  
		 */
		getReader? (): object | string | Ext.data.reader.Reader;
		/** 
		 * Returns the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.writer.Writer}  
		 */
		getWriter? (): object | string | Ext.data.writer.Writer;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given read operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		read? (operation: Ext.data.operation.Operation): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @param   {boolean} batchActions The new value.
		 * @returns {void}                 
		 */
		setBatchActions? (batchActions: boolean): void;
		/** 
		 * Sets the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @param   {string} batchOrder The new value.
		 * @returns {void}              
		 */
		setBatchOrder? (batchOrder: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                                                             name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                                                    [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.LocalStorage;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.WebStorage;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Client;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Proxy;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html#cfg-id).
		 * @method
		 * @public (method)
		 * @param   {string} id The new value.
		 * @returns {void}      
		 */
		setId? (id: string): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.reader.Reader} reader The new value.
		 * @returns {void}                                        
		 */
		setReader? (reader: object | string | Ext.data.reader.Reader): void;
		/** 
		 * Saves the given record in the Proxy.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The model instance
		 * @param   {string}         [id]   The id to save the record under (defaults to the value of the record's getId() function)
		 * @returns {void}                  
		 */
		setRecord? (record: Ext.data.Model, id?: string): void;
		/** 
		 * Sets the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.writer.Writer} writer The new value.
		 * @returns {void}                                        
		 */
		setWriter? (writer: object | string | Ext.data.writer.Writer): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given update operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		update? (operation: Ext.data.operation.Operation): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		abort? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                                                    config
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.proxy.LocalStorage;
		initConfig? (config: object): Ext.data.proxy.WebStorage;
		initConfig? (config: object): Ext.data.proxy.Client;
		initConfig? (config: object): Ext.data.proxy.Proxy;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.LocalStorage.Statics|Ext.data.proxy.WebStorage.Statics|Ext.data.proxy.Client.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.proxy.LocalStorage.Statics;
		statics? (): Ext.data.proxy.WebStorage.Statics;
		statics? (): Ext.data.proxy.Client.Statics;
		statics? (): Ext.data.proxy.Proxy.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		applyReader? (reader: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} writer
		 * @returns {void}          
		 */
		applyWriter? (writer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clone? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		completeOperation? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} config
		 * @returns {void}          
		 */
		createOperation? (action: object, config: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getIdField? (): void;
		/** 
		 * Returns the array of record IDs stored in this Proxy
		 * @method
		 * @private (method)
		 * @returns {number[]}  The record IDs. Each is cast as a Number
		 */
		getIds? (): number[];
		/** 
		 * Returns the next numerical ID that can be used when realizing a model instance (see getRecordCounterKey).
		 * Increments the counter.
		 * @method
		 * @private (method)
		 * @returns {number}  The id
		 */
		getNextId? (): number;
		/** 
		 * Fetches record data from the Proxy by ID.
		 * @method
		 * @private (method)
		 * @param   {string} id The record's unique ID
		 * @returns {object}    The record data
		 */
		getRecord? (id: string): object;
		/** 
		 * Returns the unique key used to store the current record counter for this proxy. This is used internally when
		 * realizing models (creating them when they used to be phantoms), in order to give each model instance a unique id.
		 * @method
		 * @private (method)
		 * @returns {string}  The counter key
		 */
		getRecordCounterKey? (): string;
		/** 
		 * Given the id of a record, returns a unique string based on that id and the id of this proxy. This is used when
		 * storing data in the local storage object and should prevent naming collisions.
		 * @method
		 * @private (method)
		 * @param   {string|number|Ext.data.Model} id The record id, or a Model instance
		 * @returns {string}                          The unique key for this record
		 */
		getRecordKey? (id: string | number | Ext.data.Model): string;
		/** 
		 * Abstract function which should return the storage object that data will be saved to. This must be implemented
		 * in each subclass.
		 * @method
		 * @private (method)
		 * @returns {object}  The storage object
		 */
		getStorageObject? (): object;
		/** 
		 * Gets tree data and transforms it from key value pairs into a hierarchical structure.
		 * @method
		 * @private (method)
		 * @returns {Ext.data.NodeInterface[]}  
		 */
		getTreeData? (): Ext.data.NodeInterface[];
		/** 
		 * Returns the unique key used to store the tree indicator. This is used internally to determine if the stored data is hierarchical
		 * @method
		 * @private (method)
		 * @returns {string}  The counter key
		 */
		getTreeKey? (): string;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Sets up the Proxy by claiming the key in the storage object that corresponds to the unique id of this Proxy. Called
		 * automatically by the constructor, this should not need to be called again unless [clear](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html#method-clear) has been called.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initialize? (): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * The internal callback that the proxy uses to call any specified user callbacks after completion of a batch
		 * @method
		 * @private (method)
		 * @param   {object} batchOptions
		 * @param   {object} batch
		 * @returns {void}                
		 */
		onBatchComplete? (batchOptions: object, batch: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Called each time the reader's onMetaChange is called so that the proxy can fire the metachange event
		 * @method
		 * @private (method)
		 * @param   {object} meta
		 * @returns {void}        
		 */
		onMetaChange? (meta: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Physically removes a given record from the local storage and recursively removes children if the record is a tree node. Used internally by [destroy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html#method-destroy).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The record to remove
		 * @returns {object}                a hash with the ids of the records that were removed as keys and the records that were removed as values
		 */
		removeRecord? (record: Ext.data.Model): object;
		/** 
		 * Saves the array of ids representing the set of all records in the Proxy
		 * @method
		 * @private (method)
		 * @param   {number[]} ids The ids to set
		 * @returns {void}         
		 */
		setIds? (ids: number[]): void;
		/** 
		 * Sorter function for sorting records by parentId
		 * @method
		 * @private (method)
		 * @param   {object} node1
		 * @param   {object} node2
		 * @returns {number}       
		 */
		sortByParentId? (node1: object, node2: object): number;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                                                  names The names of the linked objects to destroy.
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.proxy.LocalStorage;
		unlink? (names: string[]): Ext.data.proxy.WebStorage;
		unlink? (names: string[]): Ext.data.proxy.Client;
		unlink? (names: string[]): Ext.data.proxy.Proxy;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		updateModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		updateReader? (reader: object): void;
	}
	/** 
	 * [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html)
	 * In-memory proxy. This proxy simply uses a local variable for data storage/retrieval, so its contents are lost on
	 * every page refresh.
	 * 
	 * Usually this Proxy isn't used directly, serving instead as a helper to a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) where a reader
	 * is required to load data. For example, say we have a Store for a User model and have some inline data we want to
	 * load, but this data isn't in quite the right format: we can use a MemoryProxy with a JsonReader to read it into our
	 * Store:
	 * 
	 *    //this is the model we will be using in the store
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            {name: 'id',    type: 'int'},
	 *            {name: 'name',  type: 'string'},
	 *            {name: 'phone', type: 'string', mapping: 'phoneNumber'}
	 *        ]
	 *    });
	 *    
	 *    //this data does not line up to our model fields - the phone field is called phoneNumber
	 *    var data = {
	 *        users: [
	 *            {
	 *                id: 1,
	 *                name: 'Ed Spencer',
	 *                phoneNumber: '555 1234'
	 *            },
	 *            {
	 *                id: 2,
	 *                name: 'Abe Elias',
	 *                phoneNumber: '666 1234'
	 *            }
	 *        ]
	 *    };
	 *    
	 *    //note how we set the 'root' in the reader to match the data structure above
	 *    var store = Ext.create('Ext.data.Store', {
	 *        autoLoad: true,
	 *        model: 'User',
	 *        data : data,
	 *        proxy: {
	 *            type: 'memory',
	 *            reader: {
	 *                type: 'json',
	 *                rootProperty: 'users'
	 *            }
	 *        }
	 *    });
	 * 
	 */
	class Memory extends Ext.data.proxy.Client {
		/** 
		 * `true` in this class to identify that requests made on this proxy are
		 * performed synchronously
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isSynchronous?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.proxy.Memory.Statics}
		 */
		self?: Ext.data.proxy.Memory.Statics | Ext.data.proxy.Client.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members    The members to add to this class.
		 * @param   {boolean}                                                                   [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                   [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Memory;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Client;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.proxy.Memory;
		static addStatics? (members: object): typeof Ext.data.proxy.Client;
		static addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Memory;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Client;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    name
		 * @param   {object}                                                                    member
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Memory;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Client;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    fn
		 * @param   {object}                                                                    scope
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Memory;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Client;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates the Proxy
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Abstract function that must be implemented by each ClientProxy subclass. This should purge all record data
		 * from the client side storage, as well as removing any supporting data (such as lists of record IDs)
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clear? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Currently this is a hard-coded method that simply commits any records and sets the operation to successful,
		 * then calls the callback function, if provided. It is essentially mocking a server call in memory, but since
		 * there is no real back end in this case there's not much else to do. This method can be easily overridden to
		 * implement more complex logic if needed.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		create? (operation: Ext.data.operation.Operation): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Currently this is a hard-coded method that simply commits any records and sets the operation to successful,
		 * then calls the callback function, if provided. It is essentially mocking a server call in memory, but since
		 * there is no real back end in this case there's not much else to do. This method can be easily overridden to
		 * implement more complex logic if needed.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		erase? (operation: Ext.data.operation.Operation): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBatchActions? (): boolean;
		/** 
		 * Returns the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchOrder? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [data](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html#cfg-data).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getData? (): object;
		/** 
		 * Returns the value of [enablePaging](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html#cfg-enablePaging).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getEnablePaging? (): boolean;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Returns the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.reader.Reader}  
		 */
		getReader? (): object | string | Ext.data.reader.Reader;
		/** 
		 * Returns the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.writer.Writer}  
		 */
		getWriter? (): object | string | Ext.data.writer.Writer;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Reads data from the configured [data](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html#cfg-data) object. Uses the Proxy's [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html#cfg-reader), if present.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The read Operation
		 * @returns {void}                                   
		 */
		read? (operation: Ext.data.operation.Operation): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @param   {boolean} batchActions The new value.
		 * @returns {void}                 
		 */
		setBatchActions? (batchActions: boolean): void;
		/** 
		 * Sets the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @param   {string} batchOrder The new value.
		 * @returns {void}              
		 */
		setBatchOrder? (batchOrder: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                             name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                    [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Memory;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Client;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Proxy;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [data](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html#cfg-data).
		 * @method
		 * @public (method)
		 * @param   {object} data The new value.
		 * @returns {void}        
		 */
		setData? (data: object): void;
		/** 
		 * Sets the value of [enablePaging](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html#cfg-enablePaging).
		 * @method
		 * @public (method)
		 * @param   {boolean} enablePaging The new value.
		 * @returns {void}                 
		 */
		setEnablePaging? (enablePaging: boolean): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.reader.Reader} reader The new value.
		 * @returns {void}                                        
		 */
		setReader? (reader: object | string | Ext.data.reader.Reader): void;
		/** 
		 * Sets the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.writer.Writer} writer The new value.
		 * @returns {void}                                        
		 */
		setWriter? (writer: object | string | Ext.data.writer.Writer): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Currently this is a hard-coded method that simply commits any records and sets the operation to successful,
		 * then calls the callback function, if provided. It is essentially mocking a server call in memory, but since
		 * there is no real back end in this case there's not much else to do. This method can be easily overridden to
		 * implement more complex logic if needed.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		update? (operation: Ext.data.operation.Operation): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		abort? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                    config
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Memory;
		initConfig? (config: object): Ext.data.proxy.Client;
		initConfig? (config: object): Ext.data.proxy.Proxy;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Memory.Statics|Ext.data.proxy.Client.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.proxy.Memory.Statics;
		statics? (): Ext.data.proxy.Client.Statics;
		statics? (): Ext.data.proxy.Proxy.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		applyReader? (reader: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} writer
		 * @returns {void}          
		 */
		applyWriter? (writer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clone? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		completeOperation? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} config
		 * @returns {void}          
		 */
		createOperation? (action: object, config: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * The internal callback that the proxy uses to call any specified user callbacks after completion of a batch
		 * @method
		 * @private (method)
		 * @param   {object} batchOptions
		 * @param   {object} batch
		 * @returns {void}                
		 */
		onBatchComplete? (batchOptions: object, batch: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Called each time the reader's onMetaChange is called so that the proxy can fire the metachange event
		 * @method
		 * @private (method)
		 * @param   {object} meta
		 * @returns {void}        
		 */
		onMetaChange? (meta: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                  names The names of the linked objects to destroy.
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.proxy.Memory;
		unlink? (names: string[]): Ext.data.proxy.Client;
		unlink? (names: string[]): Ext.data.proxy.Proxy;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		updateModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		updateReader? (reader: object): void;
	}
	/** 
	 * [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html)
	 * Proxies are used by [Stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) to handle the loading and saving of [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html)
	 * data. Usually developers will not need to create or interact with proxies directly.
	 * 
	 * # Types of Proxy
	 * 
	 * There are two main types of Proxy - [Client](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Client.html) and [Server](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html).
	 * The Client proxies save their data locally and include the following subclasses:
	 * 
	 * - [LocalStorageProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) - saves its data to localStorage if the browser supports it
	 * - [SessionStorageProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html) - saves its data to sessionStorage if the browsers supports it
	 * - [MemoryProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html) - holds data in memory only, any data is lost when the page is refreshed
	 * 
	 * The Server proxies save their data by sending requests to some remote server. These proxies include:
	 * 
	 * - [Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) - sends requests to a server on the same domain
	 * - [JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) - uses JSON-P to send requests to a server on a different domain
	 * - [Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html) - uses RESTful HTTP methods (GET/PUT/POST/DELETE) to communicate with server
	 * - [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html) - uses [Ext.direct.Manager](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Manager.html) to send requests
	 * 
	 * Proxies operate on the principle that all operations performed are either Create, Read, Update or Delete. These four
	 * operations are mapped to the methods [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-erase)
	 * respectively. Each Proxy subclass implements these functions.
	 * 
	 * The CRUD methods each expect an [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) object as the sole argument. The Operation
	 * encapsulates information about the action the Store wishes to perform, the [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) instances
	 * that are to be modified, etc. See the [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) documentation for more details. Each CRUD
	 * method also accepts a callback function to be called asynchronously on completion.
	 * 
	 * Proxies also support batching of Operations via a [batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object, invoked by the [batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-batch)
	 * method.
	 */
	class Proxy extends Ext.Base {
		/** 
		 * If this property is specified by the target class of this mixin its properties are
		 * used to configure the created [`Ext.Factory`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Factory.html).
		 * @property
		 * @public (property)
		 * @type {object}
		 */
		factoryConfig?: object;
		/** 
		 * This object holds a key for any event that has a listener. The listener may be set
		 * directly on the instance, or on its class or a super class (via [observe](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#static-method-observe)) or
		 * on the [MVC EventBus](https://docs.sencha.com/extjs/6.0.1/classic/Ext.app.EventBus.html). The values of this object are truthy
		 * (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
		 * of listeners. The value for an event is truthy if the event must be fired and is
		 * falsy if there is no need to fire the event.
		 * 
		 * The intended use of this property is to avoid the expense of fireEvent calls when
		 * there are no listeners. This can be particularly helpful when one would otherwise
		 * have to call fireEvent hundreds or thousands of times. It is used like this:
		 * 
		 *     if (this.hasListeners.foo) {
		 *         this.fireEvent('foo', this, arg1);
		 *     }
		 * 
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		readonly hasListeners?: object;
		/** 
		 * `true` in this class to identify an object as an instantiated Observable, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isObservable?: boolean;
		/** 
		 * `true` in this class to identify an object as an instantiated Proxy, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isProxy?: boolean;
		/** 
		 * Identifies the proxy as (a)synchronous.
		 * @property
		 * @public (property)
		 * @default false
		 * @type {boolean}
		 */
		isSynchronous?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.proxy.Proxy.Statics}
		 */
		self?: Ext.data.proxy.Proxy.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * Matches options property names within a listeners specification object  - property names which are never used as event names.
		 * @property
		 * @private (property)
		 * @default {scope: 1, delay: 1, buffer: 1, onFrame: 1, single: 1, args: 1, destroyable: 1, priority: 1, order: 1}
		 * @type {object}
		 */
		$eventOptions?: object;
		/** 
		 * Initial suspended call count. Incremented when [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents) is called, decremented when [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) is called.
		 * @property
		 * @private (property)
		 * @default 0
		 * @type {number}
		 */
		eventsSuspended?: number;
		/** 
		 * @property
		 * @private (property)
		 * @default 'factoryable'
		 * @type {string}
		 */
		mixinId?: string;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                        members    The members to add to this class.
		 * @param   {boolean}                       [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                       [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                        members
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                        members
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                        name
		 * @param   {object}                        member
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                        fn
		 * @param   {object}                        scope
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates the Proxy
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                                eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                              [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                                       [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.data.proxy.Proxy.methodParams.addListener.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                                       [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                                       
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addListener? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.data.proxy.Proxy.methodParams.addListener.Options, order?: string): object;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Performs a batch of [Operations](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html), in the order specified by [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder). Used
		 * internally by [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)'s [sync](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html#method-sync) method. Example usage:
		 * 
		 *    myProxy.batch({
		 *        create : [myModel1, myModel2],
		 *        update : [myModel3],
		 *        destroy: [myModel4, myModel5]
		 *    });
		 * 
		 * Where the myModel* above are [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) instances - in this case 1 and 2 are new instances and
		 * have not been saved before, 3 has been saved previously but needs to be updated, and 4 and 5 have already been
		 * saved but should now be destroyed.
		 * 
		 * Note that the previous version of this method took 2 arguments (operations and listeners). While this is still
		 * supported for now, the current signature is now a single `options` argument that can contain both operations and
		 * listeners, in addition to other options. The multi-argument signature will likely be deprecated in a future release.
		 * @method
		 * @public (method)
		 * @param   {object|Ext.data.proxy.Proxy.methodParams.batch.Options} options Object containing one or more properties supported by the batch method:
		 * @returns {Ext.data.Batch}                                                 The newly created Batch
		 */
		batch? (options: object | Ext.data.proxy.Proxy.methodParams.batch.Options): Ext.data.Batch;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Performs the given create operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		create? (operation: Ext.data.operation.Operation): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Performs the given destroy operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		erase? (operation: Ext.data.operation.Operation): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBatchActions? (): boolean;
		/** 
		 * Returns the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchOrder? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Returns the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.reader.Reader}  
		 */
		getReader? (): object | string | Ext.data.reader.Reader;
		/** 
		 * Returns the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.writer.Writer}  
		 */
		getWriter? (): object | string | Ext.data.writer.Writer;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                       eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                     [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                              [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.data.proxy.Proxy.methodParams.on.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                              [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		on? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.data.proxy.Proxy.methodParams.on.Options, order?: string): object;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given read operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		read? (operation: Ext.data.operation.Operation): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @param   {boolean} batchActions The new value.
		 * @returns {void}                 
		 */
		setBatchActions? (batchActions: boolean): void;
		/** 
		 * Sets the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @param   {string} batchOrder The new value.
		 * @returns {void}              
		 */
		setBatchOrder? (batchOrder: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                 name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                        [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Proxy;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.reader.Reader} reader The new value.
		 * @returns {void}                                        
		 */
		setReader? (reader: object | string | Ext.data.reader.Reader): void;
		/** 
		 * Sets the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.writer.Writer} writer The new value.
		 * @returns {void}                                        
		 */
		setWriter? (writer: object | string | Ext.data.writer.Writer): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given update operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		update? (operation: Ext.data.operation.Operation): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		abort? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                        config
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Proxy;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.proxy.Proxy.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		applyReader? (reader: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} writer
		 * @returns {void}          
		 */
		applyWriter? (writer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clone? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		completeOperation? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} config
		 * @returns {void}          
		 */
		createOperation? (action: object, config: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * The internal callback that the proxy uses to call any specified user callbacks after completion of a batch
		 * @method
		 * @private (method)
		 * @param   {object} batchOptions
		 * @param   {object} batch
		 * @returns {void}                
		 */
		onBatchComplete? (batchOptions: object, batch: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Called each time the reader's onMetaChange is called so that the proxy can fire the metachange event
		 * @method
		 * @private (method)
		 * @param   {object} meta
		 * @returns {void}        
		 */
		onMetaChange? (meta: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                      names The names of the linked objects to destroy.
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.proxy.Proxy;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		updateModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		updateReader? (reader: object): void;
	}
	/** 
	 * [Ext.data.proxy.Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html)
	 * The Rest proxy is a specialization of the [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) which simply maps the four actions
	 * (create, read, update and destroy) to RESTful HTTP verbs. For example, let's set up a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html)
	 * with an inline Rest proxy
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email'],
	 *    
	 *        proxy: {
	 *            type: 'rest',
	 *            url : '/users'
	 *        }
	 *    });
	 * 
	 * Now we can create a new User instance and save it via the Rest proxy. Doing this will cause the Proxy to send a POST
	 * request to '/users':
	 * 
	 *    var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
	 *    
	 *    user.save(); //POST /users
	 * 
	 * Let's expand this a little and provide a callback for the [Ext.data.Model.save](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html#method-save) call to update the Model once
	 * it has been created. We'll assume the creation went successfully and that the server gave this user an ID of 123:
	 * 
	 *    user.save({
	 *        success: function(user) {
	 *            user.set('name', 'Khan Noonien Singh');
	 *    
	 *            user.save(); //PUT /users/123
	 *        }
	 *    });
	 * 
	 * Now that we're no longer creating a new Model instance, the request method is changed to an HTTP PUT, targeting the
	 * relevant url for that user. Now let's delete this user, which will use the DELETE method:
	 * 
	 *        user.erase(); //DELETE /users/123
	 * 
	 * Finally, when we perform a load of a Model or Store, Rest proxy will use the GET method:
	 * 
	 *    //1. Load via Store
	 *    
	 *    //the Store automatically picks up the Proxy from the User model
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User'
	 *    });
	 *    
	 *    store.load(); //GET /users
	 *    
	 *    //2. Load directly from the Model
	 *    
	 *    //GET /users/123
	 *    User.load(123, {
	 *        success: function(user) {
	 *            console.log(user.getId()); //outputs 123
	 *        }
	 *    });
	 * 
	 * # Url generation
	 * 
	 * The Rest proxy is able to automatically generate the urls above based on two configuration options - [appendId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-appendId) and
	 * [format](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-format). If appendId is true (it is by default) then Rest proxy will automatically append the ID of the Model
	 * instance in question to the configured url, resulting in the '/users/123' that we saw above.
	 * 
	 * If the request is not for a specific Model instance (e.g. loading a Store), the url is not appended with an id.
	 * The Rest proxy will automatically insert a '/' before the ID if one is not already present.
	 * 
	 *    new Ext.data.proxy.Rest({
	 *        url: '/users',
	 *        appendId: true //default
	 *    });
	 *    
	 *    // Collection url: /users
	 *    // Instance url  : /users/123
	 * 
	 * The Rest proxy can also optionally append a format string to the end of any generated url:
	 * 
	 *    new Ext.data.proxy.Rest({
	 *        url: '/users',
	 *        format: 'json'
	 *    });
	 *    
	 *    // Collection url: /users.json
	 *    // Instance url  : /users/123.json
	 * 
	 * If further customization is needed, simply implement the [buildUrl](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#method-buildUrl) method and add your custom generated url
	 * onto the [Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object that is passed to buildUrl. See [Rest proxy's implementation](source/Rest.html#Ext-data-proxy-Rest-method-buildUrl) for
	 * an example of how to achieve this.
	 * 
	 * Note that Rest proxy inherits from [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html), which already injects all of the sorter,
	 * filter, group and paging options into the generated url. See the [AjaxProxy docs](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for more
	 * details.
	 */
	class Rest extends Ext.data.proxy.Ajax {
		/** 
		 * Mapping of action name to HTTP request method. These default to RESTful conventions for the 'create', 'read',
		 * 'update' and 'destroy' actions (which map to 'POST', 'GET', 'PUT' and 'DELETE' respectively). This object
		 * should not be changed except globally via [Ext.override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-override) - the [getMethod](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#method-getMethod) function
		 * can be overridden instead.
		 * @property
		 * @public (property)
		 * @type {object}
		 */
		actionMethods?: object;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.proxy.Rest.Statics}
		 */
		self?: Ext.data.proxy.Rest.Statics | Ext.data.proxy.Ajax.Statics | Ext.data.proxy.Server.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      members    The members to add to this class.
		 * @param   {boolean}                                                                                     [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                     [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Rest;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Ajax;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Server;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      members
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.proxy.Rest;
		static addStatics? (members: object): typeof Ext.data.proxy.Ajax;
		static addStatics? (members: object): typeof Ext.data.proxy.Server;
		static addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      members
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Rest;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Ajax;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Server;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      name
		 * @param   {object}                                                                                      member
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Rest;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Ajax;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Server;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      fn
		 * @param   {object}                                                                                      scope
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Rest;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Ajax;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Server;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Note that if this HttpProxy is being used by a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), then the Store's call to
		 * [load](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html#method-load) will override any specified callback and params options. In this case, use the
		 * [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)'s events to modify parameters, or react to loading events.
		 * @method
		 * @public (method)
		 * @param   {object} [config]
		 * Config object.
		 * If an options parameter is passed, the singleton [Ext.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Ajax.html) object will be used to make the request.
		 */
		constructor (config?: object);
		/** 
		 * Aborts a running request.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Request} [request]
		 * The request to abort. If not passed, the most recent active
		 * request will be aborted.
		 * @returns {void}                       
		 */
		abort? (request?: Ext.data.Request): void;
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Creates an [Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object from [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html).
		 * 
		 * This gets called from doRequest methods in subclasses of Server proxy.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The operation to execute
		 * @returns {Ext.data.Request}                       The request object
		 */
		buildRequest? (operation: Ext.data.operation.Operation): Ext.data.Request;
		/** 
		 * Specialized version of buildUrl that incorporates the [appendId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-appendId) and [format](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-format) options into the
		 * generated url. Override this to provide further customizations, but remember to call the superclass buildUrl so
		 * that additional parameters like the cache buster string are appended.
		 * @method
		 * @public (method)
		 * @param   {object} request
		 * @returns {void}           
		 */
		buildUrl? (request: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.proxy.Server.buildUrl](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-buildUrl).
		 * Generates a url based on a given [Ext.data.Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object. By default, ServerProxy's buildUrl will add the
		 * cache-buster param to the end of the url. Subclasses may need to perform additional modifications to the url.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Request} request The request object
		 * @returns {void|string}              The url
		 */
		buildUrl? (request: Ext.data.Request): string;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * in a ServerProxy all four CRUD operations are executed in the same manner, so we delegate to doRequest in each case
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		create? (): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * In ServerProxy subclasses, the [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-erase) methods all
		 * pass through to doRequest. Each ServerProxy subclass must implement the doRequest method - see [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for examples. This method carries the same signature as
		 * each of the methods that delegate to it.
		 * @method
		 * @public (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		doRequest? (operation: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.proxy.Server.doRequest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-doRequest).
		 * In ServerProxy subclasses, the [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-erase) methods all
		 * pass through to doRequest. Each ServerProxy subclass must implement the doRequest method - see [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for examples. This method carries the same signature as
		 * each of the methods that delegate to it.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) object
		 * @param   {Function}                     callback  The callback function to call when the Operation has completed
		 * @param   {object}                       scope     The scope in which to execute the callback
		 * @returns {void}                                   
		 */
		doRequest? (operation: Ext.data.operation.Operation, callback: ExtGlobalFunction, scope: object): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Encodes the array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Filter.html) objects into a string to be sent in the request url. By default,
		 * this simply JSON-encodes the filter data
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Filter[]} filters The array of [Filter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Filter.html) objects
		 * @returns {string}                    The encoded filters
		 */
		encodeFilters? (filters: Ext.util.Filter[]): string;
		/** 
		 * Encodes the array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Sorter.html) objects into a string to be sent in the request url. By default,
		 * this simply JSON-encodes the sorter data
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Sorter[]} sorters        The array of [Sorter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Sorter.html) objects
		 * @param   {boolean}           [preventArray] Prevents the items from being output as an array.
		 * @returns {string}                           The encoded sorters
		 */
		encodeSorters? (sorters: Ext.util.Sorter[], preventArray?: boolean): string;
		/** 
		 * Performs the given destroy operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		erase? (): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-actionMethods).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getActionMethods? (): object;
		/** 
		 * Returns the value of [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getApi? (): object;
		/** 
		 * Returns the value of [appendId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-appendId).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAppendId? (): boolean;
		/** 
		 * Returns the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBatchActions? (): boolean;
		/** 
		 * Returns the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchOrder? (): string;
		/** 
		 * Returns the value of [binary](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-binary).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBinary? (): boolean;
		/** 
		 * Returns the value of [cacheString](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-cacheString).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getCacheString? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDirectionParam? (): string;
		/** 
		 * Returns the value of [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraParams? (): object;
		/** 
		 * Returns the value of [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-filterParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getFilterParam? (): string;
		/** 
		 * Returns the value of [format](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-format).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getFormat? (): string;
		/** 
		 * Returns the value of [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDirectionParam? (): string;
		/** 
		 * Returns the value of [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupParam? (): string;
		/** 
		 * Returns the value of [headers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-headers).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getHeaders? (): object;
		/** 
		 * Returns the value of [idParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-idParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getIdParam? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-limitParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getLimitParam? (): string;
		/** 
		 * Returns the HTTP method name for a given request. By default this returns based on a lookup on
		 * [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-actionMethods).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Request} request The request object
		 * @returns {string}                   The HTTP method to use (should be one of 'GET', 'POST', 'PUT' or 'DELETE')
		 */
		getMethod? (request: Ext.data.Request): string;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Returns the value of [noCache](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-noCache).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getNoCache? (): boolean;
		/** 
		 * Returns the value of [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-pageParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getPageParam? (): string;
		/** 
		 * Returns the value of [paramsAsJson](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-paramsAsJson).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getParamsAsJson? (): boolean;
		/** 
		 * Returns the value of [password](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-password).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getPassword? (): string;
		/** 
		 * Returns the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.reader.Reader}  
		 */
		getReader? (): object | string | Ext.data.reader.Reader;
		/** 
		 * Returns the value of [simpleGroupMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleGroupMode).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSimpleGroupMode? (): boolean;
		/** 
		 * Returns the value of [simpleSortMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleSortMode).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSimpleSortMode? (): boolean;
		/** 
		 * Returns the value of [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getSortParam? (): string;
		/** 
		 * Returns the value of [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-startParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStartParam? (): string;
		/** 
		 * Returns the value of [timeout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getTimeout? (): number;
		/** 
		 * Returns the value of [useDefaultXhrHeader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-useDefaultXhrHeader).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getUseDefaultXhrHeader? (): boolean;
		/** 
		 * Returns the value of [username](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-username).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getUsername? (): string;
		/** 
		 * Returns the value of [withCredentials](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-withCredentials).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getWithCredentials? (): boolean;
		/** 
		 * Returns the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.writer.Writer}  
		 */
		getWriter? (): object | string | Ext.data.writer.Writer;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given read operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-actionMethods).
		 * @method
		 * @public (method)
		 * @param   {object} actionMethods The new value.
		 * @returns {void}                 
		 */
		setActionMethods? (actionMethods: object): void;
		/** 
		 * Sets the value of [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api).
		 * @method
		 * @public (method)
		 * @param   {object} api The new value.
		 * @returns {void}       
		 */
		setApi? (api: object): void;
		/** 
		 * Sets the value of [appendId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-appendId).
		 * @method
		 * @public (method)
		 * @param   {boolean} appendId The new value.
		 * @returns {void}             
		 */
		setAppendId? (appendId: boolean): void;
		/** 
		 * Sets the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @param   {boolean} batchActions The new value.
		 * @returns {void}                 
		 */
		setBatchActions? (batchActions: boolean): void;
		/** 
		 * Sets the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @param   {string} batchOrder The new value.
		 * @returns {void}              
		 */
		setBatchOrder? (batchOrder: string): void;
		/** 
		 * Sets the value of [binary](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-binary).
		 * @method
		 * @public (method)
		 * @param   {boolean} binary The new value.
		 * @returns {void}           
		 */
		setBinary? (binary: boolean): void;
		/** 
		 * Sets the value of [cacheString](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-cacheString).
		 * @method
		 * @public (method)
		 * @param   {string} cacheString The new value.
		 * @returns {void}               
		 */
		setCacheString? (cacheString: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                                               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Rest;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Ajax;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Server;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Proxy;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam).
		 * @method
		 * @public (method)
		 * @param   {string} directionParam The new value.
		 * @returns {void}                  
		 */
		setDirectionParam? (directionParam: string): void;
		/** 
		 * Sets a value in the underlying [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @param   {string} name  The key for the new value
		 * @param   {object} value The value
		 * @returns {void}         
		 */
		setExtraParam? (name: string, value: object): void;
		/** 
		 * Sets the value of [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @param   {object} extraParams The new value.
		 * @returns {void}               
		 */
		setExtraParams? (extraParams: object): void;
		/** 
		 * Sets the value of [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-filterParam).
		 * @method
		 * @public (method)
		 * @param   {string} filterParam The new value.
		 * @returns {void}               
		 */
		setFilterParam? (filterParam: string): void;
		/** 
		 * Sets the value of [format](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-format).
		 * @method
		 * @public (method)
		 * @param   {string} format The new value.
		 * @returns {void}          
		 */
		setFormat? (format: string): void;
		/** 
		 * Sets the value of [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam).
		 * @method
		 * @public (method)
		 * @param   {string} groupDirectionParam The new value.
		 * @returns {void}                       
		 */
		setGroupDirectionParam? (groupDirectionParam: string): void;
		/** 
		 * Sets the value of [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam).
		 * @method
		 * @public (method)
		 * @param   {string} groupParam The new value.
		 * @returns {void}              
		 */
		setGroupParam? (groupParam: string): void;
		/** 
		 * Sets the value of [headers](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-headers).
		 * @method
		 * @public (method)
		 * @param   {object} headers The new value.
		 * @returns {void}           
		 */
		setHeaders? (headers: object): void;
		/** 
		 * Sets the value of [idParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-idParam).
		 * @method
		 * @public (method)
		 * @param   {string} idParam The new value.
		 * @returns {void}           
		 */
		setIdParam? (idParam: string): void;
		/** 
		 * Sets the value of [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-limitParam).
		 * @method
		 * @public (method)
		 * @param   {string} limitParam The new value.
		 * @returns {void}              
		 */
		setLimitParam? (limitParam: string): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [noCache](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-noCache).
		 * @method
		 * @public (method)
		 * @param   {boolean} noCache The new value.
		 * @returns {void}            
		 */
		setNoCache? (noCache: boolean): void;
		/** 
		 * Sets the value of [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-pageParam).
		 * @method
		 * @public (method)
		 * @param   {string} pageParam The new value.
		 * @returns {void}             
		 */
		setPageParam? (pageParam: string): void;
		/** 
		 * Sets the value of [paramsAsJson](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-paramsAsJson).
		 * @method
		 * @public (method)
		 * @param   {boolean} paramsAsJson The new value.
		 * @returns {void}                 
		 */
		setParamsAsJson? (paramsAsJson: boolean): void;
		/** 
		 * Sets the value of [password](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-password).
		 * @method
		 * @public (method)
		 * @param   {string} password The new value.
		 * @returns {void}            
		 */
		setPassword? (password: string): void;
		/** 
		 * Sets the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.reader.Reader} reader The new value.
		 * @returns {void}                                        
		 */
		setReader? (reader: object | string | Ext.data.reader.Reader): void;
		/** 
		 * Sets the value of [simpleGroupMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleGroupMode).
		 * @method
		 * @public (method)
		 * @param   {boolean} simpleGroupMode The new value.
		 * @returns {void}                    
		 */
		setSimpleGroupMode? (simpleGroupMode: boolean): void;
		/** 
		 * Sets the value of [simpleSortMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleSortMode).
		 * @method
		 * @public (method)
		 * @param   {boolean} simpleSortMode The new value.
		 * @returns {void}                   
		 */
		setSimpleSortMode? (simpleSortMode: boolean): void;
		/** 
		 * Sets the value of [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam).
		 * @method
		 * @public (method)
		 * @param   {string} sortParam The new value.
		 * @returns {void}             
		 */
		setSortParam? (sortParam: string): void;
		/** 
		 * Sets the value of [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-startParam).
		 * @method
		 * @public (method)
		 * @param   {string} startParam The new value.
		 * @returns {void}              
		 */
		setStartParam? (startParam: string): void;
		/** 
		 * Sets the value of [timeout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @param   {number} timeout The new value.
		 * @returns {void}           
		 */
		setTimeout? (timeout: number): void;
		/** 
		 * Sets the value of [url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * @method
		 * @public (method)
		 * @param   {string} url The new value.
		 * @returns {void}       
		 */
		setUrl? (url: string): void;
		/** 
		 * Sets the value of [useDefaultXhrHeader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-useDefaultXhrHeader).
		 * @method
		 * @public (method)
		 * @param   {boolean} useDefaultXhrHeader The new value.
		 * @returns {void}                        
		 */
		setUseDefaultXhrHeader? (useDefaultXhrHeader: boolean): void;
		/** 
		 * Sets the value of [username](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-username).
		 * @method
		 * @public (method)
		 * @param   {string} username The new value.
		 * @returns {void}            
		 */
		setUsername? (username: string): void;
		/** 
		 * Sets the value of [withCredentials](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-withCredentials).
		 * @method
		 * @public (method)
		 * @param   {boolean} withCredentials The new value.
		 * @returns {void}                    
		 */
		setWithCredentials? (withCredentials: boolean): void;
		/** 
		 * Sets the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.writer.Writer} writer The new value.
		 * @returns {void}                                        
		 */
		setWriter? (writer: object | string | Ext.data.writer.Writer): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given update operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		update? (): void;
		/** 
		 * Encode any values being sent to the server. Can be overridden in subclasses.
		 * @method
		 * @protected (method)
		 * @param   {any[]}  value An array of sorters/filters.
		 * @returns {object}       The encoded value
		 */
		applyEncoding? (value: any[]): object;
		/** 
		 * Template method to allow subclasses to specify how to get the response for the reader.
		 * @method
		 * @private (method)
		 * @template
		 * @param   {object} response The server response
		 * @returns {object}          The response data to be used by the reader
		 */
		extractResponseData? (response: object): object;
		/** 
		 * Get the url for the request taking into account the order of priority,
		 * 
		 * - The request
		 * - The api
		 * - The url
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Request} request The request
		 * @returns {string}                   The url
		 */
		getUrl? (request: Ext.data.Request): string;
		/** 
		 * Sets up an exception on the operation
		 * @method
		 * @private (method)
		 * @param   {Ext.data.operation.Operation} operation The operation
		 * @param   {object}                       response  The response
		 * @returns {void}                                   
		 */
		setException? (operation: Ext.data.operation.Operation, response: object): void;
		/** 
		 * Optional callback function which can be used to clean up after a request has been completed.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.data.Request} request The Request object
		 * @param   {boolean}          success True if the request was successful
		 * @returns {void}                     
		 */
		afterRequest? (request: Ext.data.Request, success: boolean): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                                      config
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Rest;
		initConfig? (config: object): Ext.data.proxy.Ajax;
		initConfig? (config: object): Ext.data.proxy.Server;
		initConfig? (config: object): Ext.data.proxy.Proxy;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Processes response, which may involve updating or committing records, each of which
		 * will inform the owning stores and their interested views. Finally, we may perform
		 * an additional layout if the data shape has changed.
		 * @method
		 * @protected (method)
		 * @param   {object} success
		 * @param   {object} operation
		 * @param   {object} request
		 * @param   {object} response
		 * @returns {void}             
		 */
		processResponse? (success: object, operation: object, request: object, response: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Rest.Statics|Ext.data.proxy.Ajax.Statics|Ext.data.proxy.Server.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.proxy.Rest.Statics;
		statics? (): Ext.data.proxy.Ajax.Statics;
		statics? (): Ext.data.proxy.Server.Statics;
		statics? (): Ext.data.proxy.Proxy.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		applyReader? (reader: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} writer
		 * @returns {void}          
		 */
		applyWriter? (writer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clone? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		completeOperation? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} config
		 * @returns {void}          
		 */
		createOperation? (action: object, config: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * TODO: This is currently identical to the JsonPProxy version except for the return function's signature. There is a lot
		 * of code duplication inside the returned function so we need to find a way to DRY this up.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Request}             request   The Request object
		 * @param   {Ext.data.operation.Operation} operation The Operation being executed
		 * @returns {Function}                               The callback function
		 */
		createRequestCallback? (request: Ext.data.Request, operation: Ext.data.operation.Operation): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Copy any sorters, filters etc into the params so they can be sent over the wire
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		getParams? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * The internal callback that the proxy uses to call any specified user callbacks after completion of a batch
		 * @method
		 * @private (method)
		 * @param   {object} batchOptions
		 * @param   {object} batch
		 * @returns {void}                
		 */
		onBatchComplete? (batchOptions: object, batch: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Called each time the reader's onMetaChange is called so that the proxy can fire the metachange event
		 * @method
		 * @private (method)
		 * @param   {object} meta
		 * @returns {void}        
		 */
		onMetaChange? (meta: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Fires a request
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Request} request The request
		 * @returns {Ext.data.Request}         The request
		 */
		sendRequest? (request: Ext.data.Request): Ext.data.Request;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                                    names The names of the linked objects to destroy.
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.proxy.Rest;
		unlink? (names: string[]): Ext.data.proxy.Ajax;
		unlink? (names: string[]): Ext.data.proxy.Server;
		unlink? (names: string[]): Ext.data.proxy.Proxy;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} newExtraParams
		 * @param   {object} oldExtraParams
		 * @returns {void}                  
		 */
		updateExtraParams? (newExtraParams: object, oldExtraParams: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		updateModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		updateReader? (reader: object): void;
	}
	/** 
	 * [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html)
	 * ServerProxy is a superclass of [JsonPProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html), and
	 * would not usually be used directly.
	 */
	class Server extends Ext.data.proxy.Proxy {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.proxy.Server.Statics}
		 */
		self?: Ext.data.proxy.Server.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		isRemote?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members    The members to add to this class.
		 * @param   {boolean}                                             [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                             [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Server;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.proxy.Server;
		static addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Server;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              name
		 * @param   {object}                                              member
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Server;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              fn
		 * @param   {object}                                              scope
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Server;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates the Proxy
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Creates an [Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object from [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html).
		 * 
		 * This gets called from doRequest methods in subclasses of Server proxy.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The operation to execute
		 * @returns {Ext.data.Request}                       The request object
		 */
		buildRequest? (operation: Ext.data.operation.Operation): Ext.data.Request;
		/** 
		 * Generates a url based on a given [Ext.data.Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object. By default, ServerProxy's buildUrl will add the
		 * cache-buster param to the end of the url. Subclasses may need to perform additional modifications to the url.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Request} request The request object
		 * @returns {string}                   The url
		 */
		buildUrl? (request: Ext.data.Request): string;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * In ServerProxy subclasses, the [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-erase) methods all
		 * pass through to doRequest. Each ServerProxy subclass must implement the doRequest method - see [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for examples. This method carries the same signature as
		 * each of the methods that delegate to it.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) object
		 * @param   {Function}                     callback  The callback function to call when the Operation has completed
		 * @param   {object}                       scope     The scope in which to execute the callback
		 * @returns {void}                                   
		 */
		doRequest? (operation: Ext.data.operation.Operation, callback: ExtGlobalFunction, scope: object): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Encodes the array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Filter.html) objects into a string to be sent in the request url. By default,
		 * this simply JSON-encodes the filter data
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Filter[]} filters The array of [Filter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Filter.html) objects
		 * @returns {string}                    The encoded filters
		 */
		encodeFilters? (filters: Ext.util.Filter[]): string;
		/** 
		 * Encodes the array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Sorter.html) objects into a string to be sent in the request url. By default,
		 * this simply JSON-encodes the sorter data
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Sorter[]} sorters        The array of [Sorter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Sorter.html) objects
		 * @param   {boolean}           [preventArray] Prevents the items from being output as an array.
		 * @returns {string}                           The encoded sorters
		 */
		encodeSorters? (sorters: Ext.util.Sorter[], preventArray?: boolean): string;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getApi? (): object;
		/** 
		 * Returns the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBatchActions? (): boolean;
		/** 
		 * Returns the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchOrder? (): string;
		/** 
		 * Returns the value of [cacheString](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-cacheString).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getCacheString? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDirectionParam? (): string;
		/** 
		 * Returns the value of [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraParams? (): object;
		/** 
		 * Returns the value of [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-filterParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getFilterParam? (): string;
		/** 
		 * Returns the value of [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDirectionParam? (): string;
		/** 
		 * Returns the value of [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupParam? (): string;
		/** 
		 * Returns the value of [idParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-idParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getIdParam? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-limitParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getLimitParam? (): string;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Returns the value of [noCache](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-noCache).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getNoCache? (): boolean;
		/** 
		 * Returns the value of [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-pageParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getPageParam? (): string;
		/** 
		 * Returns the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.reader.Reader}  
		 */
		getReader? (): object | string | Ext.data.reader.Reader;
		/** 
		 * Returns the value of [simpleGroupMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleGroupMode).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSimpleGroupMode? (): boolean;
		/** 
		 * Returns the value of [simpleSortMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleSortMode).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSimpleSortMode? (): boolean;
		/** 
		 * Returns the value of [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getSortParam? (): string;
		/** 
		 * Returns the value of [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-startParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStartParam? (): string;
		/** 
		 * Returns the value of [timeout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getTimeout? (): number;
		/** 
		 * Returns the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.writer.Writer}  
		 */
		getWriter? (): object | string | Ext.data.writer.Writer;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api).
		 * @method
		 * @public (method)
		 * @param   {object} api The new value.
		 * @returns {void}       
		 */
		setApi? (api: object): void;
		/** 
		 * Sets the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @param   {boolean} batchActions The new value.
		 * @returns {void}                 
		 */
		setBatchActions? (batchActions: boolean): void;
		/** 
		 * Sets the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @param   {string} batchOrder The new value.
		 * @returns {void}              
		 */
		setBatchOrder? (batchOrder: string): void;
		/** 
		 * Sets the value of [cacheString](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-cacheString).
		 * @method
		 * @public (method)
		 * @param   {string} cacheString The new value.
		 * @returns {void}               
		 */
		setCacheString? (cacheString: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                       name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                              [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Server;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Proxy;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam).
		 * @method
		 * @public (method)
		 * @param   {string} directionParam The new value.
		 * @returns {void}                  
		 */
		setDirectionParam? (directionParam: string): void;
		/** 
		 * Sets a value in the underlying [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @param   {string} name  The key for the new value
		 * @param   {object} value The value
		 * @returns {void}         
		 */
		setExtraParam? (name: string, value: object): void;
		/** 
		 * Sets the value of [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @param   {object} extraParams The new value.
		 * @returns {void}               
		 */
		setExtraParams? (extraParams: object): void;
		/** 
		 * Sets the value of [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-filterParam).
		 * @method
		 * @public (method)
		 * @param   {string} filterParam The new value.
		 * @returns {void}               
		 */
		setFilterParam? (filterParam: string): void;
		/** 
		 * Sets the value of [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam).
		 * @method
		 * @public (method)
		 * @param   {string} groupDirectionParam The new value.
		 * @returns {void}                       
		 */
		setGroupDirectionParam? (groupDirectionParam: string): void;
		/** 
		 * Sets the value of [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam).
		 * @method
		 * @public (method)
		 * @param   {string} groupParam The new value.
		 * @returns {void}              
		 */
		setGroupParam? (groupParam: string): void;
		/** 
		 * Sets the value of [idParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-idParam).
		 * @method
		 * @public (method)
		 * @param   {string} idParam The new value.
		 * @returns {void}           
		 */
		setIdParam? (idParam: string): void;
		/** 
		 * Sets the value of [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-limitParam).
		 * @method
		 * @public (method)
		 * @param   {string} limitParam The new value.
		 * @returns {void}              
		 */
		setLimitParam? (limitParam: string): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [noCache](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-noCache).
		 * @method
		 * @public (method)
		 * @param   {boolean} noCache The new value.
		 * @returns {void}            
		 */
		setNoCache? (noCache: boolean): void;
		/** 
		 * Sets the value of [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-pageParam).
		 * @method
		 * @public (method)
		 * @param   {string} pageParam The new value.
		 * @returns {void}             
		 */
		setPageParam? (pageParam: string): void;
		/** 
		 * Sets the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.reader.Reader} reader The new value.
		 * @returns {void}                                        
		 */
		setReader? (reader: object | string | Ext.data.reader.Reader): void;
		/** 
		 * Sets the value of [simpleGroupMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleGroupMode).
		 * @method
		 * @public (method)
		 * @param   {boolean} simpleGroupMode The new value.
		 * @returns {void}                    
		 */
		setSimpleGroupMode? (simpleGroupMode: boolean): void;
		/** 
		 * Sets the value of [simpleSortMode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-simpleSortMode).
		 * @method
		 * @public (method)
		 * @param   {boolean} simpleSortMode The new value.
		 * @returns {void}                   
		 */
		setSimpleSortMode? (simpleSortMode: boolean): void;
		/** 
		 * Sets the value of [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam).
		 * @method
		 * @public (method)
		 * @param   {string} sortParam The new value.
		 * @returns {void}             
		 */
		setSortParam? (sortParam: string): void;
		/** 
		 * Sets the value of [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-startParam).
		 * @method
		 * @public (method)
		 * @param   {string} startParam The new value.
		 * @returns {void}              
		 */
		setStartParam? (startParam: string): void;
		/** 
		 * Sets the value of [timeout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @param   {number} timeout The new value.
		 * @returns {void}           
		 */
		setTimeout? (timeout: number): void;
		/** 
		 * Sets the value of [url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * @method
		 * @public (method)
		 * @param   {string} url The new value.
		 * @returns {void}       
		 */
		setUrl? (url: string): void;
		/** 
		 * Sets the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.writer.Writer} writer The new value.
		 * @returns {void}                                        
		 */
		setWriter? (writer: object | string | Ext.data.writer.Writer): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Encode any values being sent to the server. Can be overridden in subclasses.
		 * @method
		 * @protected (method)
		 * @param   {any[]}  value An array of sorters/filters.
		 * @returns {object}       The encoded value
		 */
		applyEncoding? (value: any[]): object;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		abort? (): void;
		/** 
		 * Template method to allow subclasses to specify how to get the response for the reader.
		 * @method
		 * @private (method)
		 * @template
		 * @param   {object} response The server response
		 * @returns {object}          The response data to be used by the reader
		 */
		extractResponseData? (response: object): object;
		/** 
		 * Get the url for the request taking into account the order of priority,
		 * 
		 * - The request
		 * - The api
		 * - The url
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Request} request The request
		 * @returns {string}                   The url
		 */
		getUrl? (request: Ext.data.Request): string;
		/** 
		 * Sets up an exception on the operation
		 * @method
		 * @private (method)
		 * @param   {Ext.data.operation.Operation} operation The operation
		 * @param   {object}                       response  The response
		 * @returns {void}                                   
		 */
		setException? (operation: Ext.data.operation.Operation, response: object): void;
		/** 
		 * Optional callback function which can be used to clean up after a request has been completed.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.data.Request} request The Request object
		 * @param   {boolean}          success True if the request was successful
		 * @returns {void}                     
		 */
		afterRequest? (request: Ext.data.Request, success: boolean): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                              config
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Server;
		initConfig? (config: object): Ext.data.proxy.Proxy;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Processes response, which may involve updating or committing records, each of which
		 * will inform the owning stores and their interested views. Finally, we may perform
		 * an additional layout if the data shape has changed.
		 * @method
		 * @protected (method)
		 * @param   {object} success
		 * @param   {object} operation
		 * @param   {object} request
		 * @param   {object} response
		 * @returns {void}             
		 */
		processResponse? (success: object, operation: object, request: object, response: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Server.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.proxy.Server.Statics;
		statics? (): Ext.data.proxy.Proxy.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		applyReader? (reader: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} writer
		 * @returns {void}          
		 */
		applyWriter? (writer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clone? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		completeOperation? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} config
		 * @returns {void}          
		 */
		createOperation? (action: object, config: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Copy any sorters, filters etc into the params so they can be sent over the wire
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		getParams? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * The internal callback that the proxy uses to call any specified user callbacks after completion of a batch
		 * @method
		 * @private (method)
		 * @param   {object} batchOptions
		 * @param   {object} batch
		 * @returns {void}                
		 */
		onBatchComplete? (batchOptions: object, batch: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Called each time the reader's onMetaChange is called so that the proxy can fire the metachange event
		 * @method
		 * @private (method)
		 * @param   {object} meta
		 * @returns {void}        
		 */
		onMetaChange? (meta: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                            names The names of the linked objects to destroy.
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.proxy.Server;
		unlink? (names: string[]): Ext.data.proxy.Proxy;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} newExtraParams
		 * @param   {object} oldExtraParams
		 * @returns {void}                  
		 */
		updateExtraParams? (newExtraParams: object, oldExtraParams: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		updateModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		updateReader? (reader: object): void;
	}
	/** 
	 * [Ext.data.proxy.SessionStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html)
	 * Proxy which uses HTML5 session storage as its data storage/retrieval mechanism. If this proxy is used in a browser
	 * where session storage is not supported, the constructor will throw an error. A session storage proxy requires a
	 * unique ID which is used as a key in which all record data are stored in the session storage object.
	 * 
	 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
	 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
	 * 
	 * Proxies are almost always used with a [store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html):
	 * 
	 *    new Ext.data.Store({
	 *        proxy: {
	 *            type: 'sessionstorage',
	 *            id  : 'myProxyKey'
	 *        }
	 *    });
	 * 
	 * Alternatively you can instantiate the Proxy directly:
	 * 
	 *    new Ext.data.proxy.SessionStorage({
	 *        id  : 'myOtherProxyKey'
	 *    });
	 * 
	 * Note that session storage is different to local storage (see [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html)) - if a browser
	 * session is ended (e.g. by closing the browser) then all data in a SessionStorageProxy are lost. Browser restarts
	 * don't affect the [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) - the data are preserved.
	 */
	class SessionStorage extends Ext.data.proxy.WebStorage {
		/** 
		 * `true` in this class to identify that requests made on this proxy are
		 * performed synchronously
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isSynchronous?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.proxy.SessionStorage.Statics}
		 */
		self?: Ext.data.proxy.SessionStorage.Statics | Ext.data.proxy.WebStorage.Statics | Ext.data.proxy.Client.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                      members    The members to add to this class.
		 * @param   {boolean}                                                                                                     [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                                     [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.SessionStorage;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.WebStorage;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Client;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                      members
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.proxy.SessionStorage;
		static addStatics? (members: object): typeof Ext.data.proxy.WebStorage;
		static addStatics? (members: object): typeof Ext.data.proxy.Client;
		static addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                      members
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.SessionStorage;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.WebStorage;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Client;
		static addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		static addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                      name
		 * @param   {object}                                                                                                      member
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.proxy.SessionStorage;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.WebStorage;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Client;
		static addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                      fn
		 * @param   {object}                                                                                                      scope
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.SessionStorage;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.WebStorage;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Client;
		static onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates the proxy, throws an error if local storage is not supported in the current browser.
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Destroys all records stored in the proxy and removes all keys and values used to support the proxy from the
		 * storage object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clear? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Performs the given create operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		create? (operation: Ext.data.operation.Operation): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Performs the given destroy operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		erase? (operation: Ext.data.operation.Operation): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBatchActions? (): boolean;
		/** 
		 * Returns the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchOrder? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html#cfg-id).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getId? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Returns the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.reader.Reader}  
		 */
		getReader? (): object | string | Ext.data.reader.Reader;
		/** 
		 * Returns the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @returns {object|string|Ext.data.writer.Writer}  
		 */
		getWriter? (): object | string | Ext.data.writer.Writer;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given read operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		read? (operation: Ext.data.operation.Operation): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [batchActions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchActions).
		 * @method
		 * @public (method)
		 * @param   {boolean} batchActions The new value.
		 * @returns {void}                 
		 */
		setBatchActions? (batchActions: boolean): void;
		/** 
		 * Sets the value of [batchOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-batchOrder).
		 * @method
		 * @public (method)
		 * @param   {string} batchOrder The new value.
		 * @returns {void}              
		 */
		setBatchOrder? (batchOrder: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                                                               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                                                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.SessionStorage;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.WebStorage;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Client;
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Proxy;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html#cfg-id).
		 * @method
		 * @public (method)
		 * @param   {string} id The new value.
		 * @returns {void}      
		 */
		setId? (id: string): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-reader).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.reader.Reader} reader The new value.
		 * @returns {void}                                        
		 */
		setReader? (reader: object | string | Ext.data.reader.Reader): void;
		/** 
		 * Saves the given record in the Proxy.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The model instance
		 * @param   {string}         [id]   The id to save the record under (defaults to the value of the record's getId() function)
		 * @returns {void}                  
		 */
		setRecord? (record: Ext.data.Model, id?: string): void;
		/** 
		 * Sets the value of [writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#cfg-writer).
		 * @method
		 * @public (method)
		 * @param   {object|string|Ext.data.writer.Writer} writer The new value.
		 * @returns {void}                                        
		 */
		setWriter? (writer: object | string | Ext.data.writer.Writer): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Performs the given update operation.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The Operation to perform
		 * @returns {void}                                   
		 */
		update? (operation: Ext.data.operation.Operation): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		abort? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                                                      config
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.proxy.SessionStorage;
		initConfig? (config: object): Ext.data.proxy.WebStorage;
		initConfig? (config: object): Ext.data.proxy.Client;
		initConfig? (config: object): Ext.data.proxy.Proxy;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.SessionStorage.Statics|Ext.data.proxy.WebStorage.Statics|Ext.data.proxy.Client.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.proxy.SessionStorage.Statics;
		statics? (): Ext.data.proxy.WebStorage.Statics;
		statics? (): Ext.data.proxy.Client.Statics;
		statics? (): Ext.data.proxy.Proxy.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		applyReader? (reader: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} writer
		 * @returns {void}          
		 */
		applyWriter? (writer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clone? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		completeOperation? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} config
		 * @returns {void}          
		 */
		createOperation? (action: object, config: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getIdField? (): void;
		/** 
		 * Returns the array of record IDs stored in this Proxy
		 * @method
		 * @private (method)
		 * @returns {number[]}  The record IDs. Each is cast as a Number
		 */
		getIds? (): number[];
		/** 
		 * Returns the next numerical ID that can be used when realizing a model instance (see getRecordCounterKey).
		 * Increments the counter.
		 * @method
		 * @private (method)
		 * @returns {number}  The id
		 */
		getNextId? (): number;
		/** 
		 * Fetches record data from the Proxy by ID.
		 * @method
		 * @private (method)
		 * @param   {string} id The record's unique ID
		 * @returns {object}    The record data
		 */
		getRecord? (id: string): object;
		/** 
		 * Returns the unique key used to store the current record counter for this proxy. This is used internally when
		 * realizing models (creating them when they used to be phantoms), in order to give each model instance a unique id.
		 * @method
		 * @private (method)
		 * @returns {string}  The counter key
		 */
		getRecordCounterKey? (): string;
		/** 
		 * Given the id of a record, returns a unique string based on that id and the id of this proxy. This is used when
		 * storing data in the local storage object and should prevent naming collisions.
		 * @method
		 * @private (method)
		 * @param   {string|number|Ext.data.Model} id The record id, or a Model instance
		 * @returns {string}                          The unique key for this record
		 */
		getRecordKey? (id: string | number | Ext.data.Model): string;
		/** 
		 * Abstract function which should return the storage object that data will be saved to. This must be implemented
		 * in each subclass.
		 * @method
		 * @private (method)
		 * @returns {object}  The storage object
		 */
		getStorageObject? (): object;
		/** 
		 * Gets tree data and transforms it from key value pairs into a hierarchical structure.
		 * @method
		 * @private (method)
		 * @returns {Ext.data.NodeInterface[]}  
		 */
		getTreeData? (): Ext.data.NodeInterface[];
		/** 
		 * Returns the unique key used to store the tree indicator. This is used internally to determine if the stored data is hierarchical
		 * @method
		 * @private (method)
		 * @returns {string}  The counter key
		 */
		getTreeKey? (): string;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Sets up the Proxy by claiming the key in the storage object that corresponds to the unique id of this Proxy. Called
		 * automatically by the constructor, this should not need to be called again unless [clear](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html#method-clear) has been called.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initialize? (): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * The internal callback that the proxy uses to call any specified user callbacks after completion of a batch
		 * @method
		 * @private (method)
		 * @param   {object} batchOptions
		 * @param   {object} batch
		 * @returns {void}                
		 */
		onBatchComplete? (batchOptions: object, batch: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Called each time the reader's onMetaChange is called so that the proxy can fire the metachange event
		 * @method
		 * @private (method)
		 * @param   {object} meta
		 * @returns {void}        
		 */
		onMetaChange? (meta: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Physically removes a given record from the local storage and recursively removes children if the record is a tree node. Used internally by [destroy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html#method-destroy).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The record to remove
		 * @returns {object}                a hash with the ids of the records that were removed as keys and the records that were removed as values
		 */
		removeRecord? (record: Ext.data.Model): object;
		/** 
		 * Saves the array of ids representing the set of all records in the Proxy
		 * @method
		 * @private (method)
		 * @param   {number[]} ids The ids to set
		 * @returns {void}         
		 */
		setIds? (ids: number[]): void;
		/** 
		 * Sorter function for sorting records by parentId
		 * @method
		 * @private (method)
		 * @param   {object} node1
		 * @param   {object} node2
		 * @returns {number}       
		 */
		sortByParentId? (node1: object, node2: object): number;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                                                    names The names of the linked objects to destroy.
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.proxy.SessionStorage;
		unlink? (names: string[]): Ext.data.proxy.WebStorage;
		unlink? (names: string[]): Ext.data.proxy.Client;
		unlink? (names: string[]): Ext.data.proxy.Proxy;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		updateModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} reader
		 * @returns {void}          
		 */
		updateReader? (reader: object): void;
	}
	/** 
	 * WebStorageProxy is simply a superclass for the [LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) and [SessionStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html) proxies. It uses the new HTML5 key/value client-side storage objects to
	 * save [model instances](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) for offline use.
	 * @private (class)
	 */
	class WebStorage extends Ext.data.proxy.Client {}
}
declare namespace Ext.data {
	class AjaxProxy extends Ext.data.proxy.Ajax {}
	class ClientProxy extends Ext.data.proxy.Client {}
	class DataProxy extends Ext.data.proxy.Proxy {}
	class DirectProxy extends Ext.data.proxy.Direct {}
	class HttpProxy extends Ext.data.proxy.Ajax {}
	class LocalStorageProxy extends Ext.data.proxy.LocalStorage {}
	class MemoryProxy extends Ext.data.proxy.Memory {}
	class Proxy extends Ext.data.proxy.Proxy {}
	class RestProxy extends Ext.data.proxy.Rest {}
	class ScriptTagProxy extends Ext.data.proxy.JsonP {}
	class ServerProxy extends Ext.data.proxy.Server {}
	class SessionStorageProxy extends Ext.data.proxy.SessionStorage {}
	class WebStorageProxy extends Ext.data.proxy.WebStorage {}
}
declare namespace Ext.data.proxy.Ajax {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html)
	 * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
	 * data from the server, usually to be placed into a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html). Let's take a look at a typical setup.
	 * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html):
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email']
	 *    });
	 *    
	 *    //The Store contains the AjaxProxy as an inline configuration
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'ajax',
	 *            url : 'users.json'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * Our example is going to load user data into a Store, so we start off by defining a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) with
	 * the fields that we expect the server to return. Next we set up the Store itself, along with a
	 * [proxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html#cfg-proxy) configuration. This configuration was automatically turned into an
	 * [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) instance, with the url we specified being passed into AjaxProxy's constructor.
	 * It's as if we'd done this:
	 * 
	 *    new Ext.data.proxy.Ajax({
	 *        url: 'users.json',
	 *        model: 'User',
	 *        reader: 'json'
	 *    });
	 * 
	 * A couple of extra configurations appeared here - [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-model) and [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader). These are set by default when we
	 * create the proxy via the Store - the Store already knows about the Model, and Proxy's default [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) is [JsonReader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Json.html).
	 * 
	 * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
	 * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
	 * [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-actionMethods) to customize this - by default any kind of read will be sent as a GET request and any kind of write
	 * will be sent as a POST request).
	 * 
	 * # Limitations
	 * 
	 * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
	 * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
	 * talking to each other via AJAX.
	 * 
	 * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
	 * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
	 * from http://domainA.com), you can use [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and a technique known as JSON-P (JSON with
	 * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
	 * JSON-P responses. See [JsonPProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html)'s introduction docs for more details.
	 * 
	 * # Readers and Writers
	 * 
	 * AjaxProxy can be configured to use any type of [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to decode the server's response.
	 * If no Reader is supplied, AjaxProxy will default to using a [JsonReader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Json.html). Reader
	 * configuration can be passed in as a simple object, which the Proxy automatically turns into a [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) instance:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        model: 'User',
	 *        reader: {
	 *            type: 'xml',
	 *            rootProperty: 'users'
	 *        }
	 *    });
	 *    
	 *    proxy.getReader(); //returns an XmlReader instance based on the config we supplied
	 * 
	 * # Url generation
	 * 
	 * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
	 * each request. These are controlled with the following configuration options:
	 * 
	 * - [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-pageParam) - controls how the page number is sent to the server (see also [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-startParam) and [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-limitParam))
	 * - [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-sortParam) - controls how sort information is sent to the server
	 * - [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-groupParam) - controls how grouping information is sent to the server
	 * - [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-filterParam) - controls how filter information is sent to the server
	 * 
	 * Each request sent by AjaxProxy is described by an [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html). To see how we can customize
	 * the generated urls, let's say we're loading the Proxy with the following Operation:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    var operation = proxy.createOperation('read', {
	 *        page  : 2
	 *    });
	 * 
	 * Now we'll issue the request for this Operation by calling [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-read):
	 * 
	 *    proxy.read(operation); //GET /users?page=2
	 * 
	 * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
	 * to the server:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users',
	 *        pageParam: 'pageNumber'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?pageNumber=2
	 * 
	 * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    var operation = proxy.createOperation('read', {
	 *        start : 50,
	 *        limit : 25
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?start=50&amp;limit;=25
	 * 
	 * Again we can customize this url:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users',
	 *        startParam: 'startIndex',
	 *        limitParam: 'limitIndex'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?startIndex=50&amp;limitIndex;=25
	 * 
	 * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
	 * expressive Operation object:
	 * 
	 *    var operation = proxy.createOperation('read', {
	 *        sorters: [
	 *            new Ext.util.Sorter({
	 *                property : 'name',
	 *                direction: 'ASC'
	 *            }),
	 *            new Ext.util.Sorter({
	 *                property : 'age',
	 *                direction: 'DESC'
	 *            })
	 *        ],
	 *        filters: [
	 *            new Ext.util.Filter({
	 *                property: 'eyeColor',
	 *                value   : 'brown'
	 *            })
	 *        ]
	 *    });
	 * 
	 * This is the type of object that is generated internally when loading a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) with sorters and
	 * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
	 * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&amp;filter;=[{"property":"eyeColor","value":"brown"}]
	 * 
	 * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
	 * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
	 * that format like this:
	 * 
	 *     var proxy = new Ext.data.proxy.Ajax({
	 *         url: '/users',
	 *         sortParam: 'sortBy',
	 *         filterParam: 'filterBy',
	 *    
	 *         //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
	 *         encodeSorters: function(sorters) {
	 *             var length   = sorters.length,
	 *                 sortStrs = [],
	 *                 sorter, i;
	 *    
	 *             for (i = 0; i &lt; length; i++) {
	 *                 sorter = sorters[i];
	 *    
	 *                 sortStrs[i] = sorter.property + '#' + sorter.direction
	 *             }
	 *    
	 *             return sortStrs.join(",");
	 *         }
	 *     });
	 *    
	 *     proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&amp;filterBy;=[{"property":"eyeColor","value":"brown"}]
	 * 
	 * We can also provide a custom [encodeFilters](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-encodeFilters) function to encode our filters.
	 * 
	 * # Debugging your Ajax Proxy
	 * 
	 * If the data is not being loaded into the store as expected, it could be due to a mismatch between the the way that the [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader)
	 * is configured, and the shape of the incoming data.
	 * 
	 * To debug from the point that your data arrives back from the network, set a breakpoint inside the callback function
	 * created in the `createRequestCallback` method of the Ajax Proxy class, and follow the data to where the [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader) attempts
	 * to consume it.
	 */
	interface Def extends Ext.data.proxy.Ajax {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.proxy.Ajax.Cfg}
		 */
		config?: Ext.data.proxy.Ajax.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.proxy.Ajax.Statics|Ext.data.proxy.Server.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.proxy.Ajax.Statics}
		 */
		statics?: (() => Ext.data.proxy.Ajax.Statics | Ext.data.proxy.Server.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics) | Ext.data.proxy.Ajax.Statics | any;
	}
}
declare namespace Ext.data.proxy.Direct {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.proxy.Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html)
	 * This class is used to send requests to the server using Ext Direct. When a
	 * request is made, the transport mechanism is handed off to the appropriate
	 * [Provider](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.RemotingProvider.html) to complete the call.
	 * 
	 * # Specifying the function
	 * 
	 * This proxy expects a Direct remoting method to be passed in order to be able to complete requests.
	 * This can be done by specifying the [directFn](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-directFn) configuration. This will use the same direct
	 * method for all requests. Alternatively, you can provide an [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-api) configuration. This
	 * allows you to specify a different remoting method for each CRUD action.
	 * 
	 * # Parameters
	 * 
	 * This proxy provides options to help configure which parameters will be sent to the server.
	 * By specifying the [paramsAsHash](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramsAsHash) option, it will send an object literal containing each
	 * of the passed parameters. The [paramOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramOrder) option can be used to specify the order in which
	 * the remoting method parameters are passed.
	 * 
	 * # Example Usage
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['firstName', 'lastName'],
	 *        proxy: {
	 *            type: 'direct',
	 *            directFn: MyApp.getUsers,
	 *            paramOrder: 'id' // Tells the proxy to pass the id as the first parameter to the remoting method.
	 *        }
	 *    });
	 *    User.load(1);
	 * 
	 */
	interface Def extends Ext.data.proxy.Direct {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.proxy.Direct.Cfg}
		 */
		config?: Ext.data.proxy.Direct.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.proxy.Direct.Statics|Ext.data.proxy.Server.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.proxy.Direct.Statics}
		 */
		statics?: (() => Ext.data.proxy.Direct.Statics | Ext.data.proxy.Server.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics) | Ext.data.proxy.Direct.Statics | any;
	}
}
declare namespace Ext.data.proxy.JsonP {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html)
	 * The JsonP proxy is useful when you need to load data from a domain other than the one your application is running on. If
	 * your application is running on http://domainA.com it cannot use [Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) to load its data
	 * from http://domainB.com because cross-domain ajax requests are prohibited by the browser.
	 * 
	 * We can get around this using a JsonP proxy. JsonP proxy injects a `&lt;script&gt;` tag into the DOM whenever an AJAX request
	 * would usually be made. Let's say we want to load data from http://domainB.com/users - the script tag that would be
	 * injected might look like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?callback=someCallback"&gt;&lt;/script&gt;
	 * 
	 * When we inject the tag above, the browser makes a request to that url and includes the response as if it was any
	 * other type of JavaScript include. By passing a callback in the url above, we're telling domainB's server that we want
	 * to be notified when the result comes in and that it should call our callback function with the data it sends back. So
	 * long as the server formats the response to look like this, everything will work:
	 * 
	 *    someCallback({
	 *        users: [
	 *            {
	 *                id: 1,
	 *                name: "Ed Spencer",
	 *                email: "ed@sencha.com"
	 *            }
	 *        ]
	 *    });
	 * 
	 * As soon as the script finishes loading, the 'someCallback' function that we passed in the url is called with the JSON
	 * object that the server returned.
	 * 
	 * JsonP proxy takes care of all of this automatically. It formats the url you pass, adding the callback parameter
	 * automatically. It even creates a temporary callback function, waits for it to be called and then puts the data into
	 * the Proxy making it look just like you loaded it through a normal [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html). Here's how
	 * we might set that up:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email']
	 *    });
	 *    
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'jsonp',
	 *            url : 'http://domainB.com/users'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * That's all we need to do - JsonP proxy takes care of the rest. In this case the Proxy will have injected a script tag
	 * like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?callback=callback1"&gt;&lt;/script&gt;
	 * 
	 * # Customization
	 * 
	 * This script tag can be customized using the [callbackKey](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-callbackKey) configuration. For example:
	 * 
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'jsonp',
	 *            url : 'http://domainB.com/users',
	 *            callbackKey: 'theCallbackFunction'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * Would inject a script tag like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?theCallbackFunction=callback1"&gt;&lt;/script&gt;
	 * 
	 * # Implementing on the server side
	 * 
	 * The remote server side needs to be configured to return data in this format. Here are suggestions for how you might
	 * achieve this using Java, PHP and ASP.net:
	 * 
	 * Java:
	 * 
	 *    boolean jsonP = false;
	 *    String cb = request.getParameter("callback");
	 *    if (cb != null) {
	 *        jsonP = true;
	 *        response.setContentType("text/javascript");
	 *    } else {
	 *        response.setContentType("application/x-json");
	 *    }
	 *    Writer out = response.getWriter();
	 *    if (jsonP) {
	 *        out.write(cb + "(");
	 *    }
	 *    out.print(dataBlock.toJsonString());
	 *    if (jsonP) {
	 *        out.write(");");
	 *    }
	 * 
	 * PHP:
	 * 
	 *    $callback = $_REQUEST['callback'];
	 *    
	 *    // Create the output object.
	 *    $output = array('a' =&gt; 'Apple', 'b' =&gt; 'Banana');
	 *    
	 *    //start output
	 *    if ($callback) {
	 *        header('Content-Type: text/javascript');
	 *        echo $callback . '(' . json_encode($output) . ');';
	 *    } else {
	 *        header('Content-Type: application/x-json');
	 *        echo json_encode($output);
	 *    }
	 * 
	 * ASP.net:
	 * 
	 *    String jsonString = "{success: true}";
	 *    String cb = Request.Params.Get("callback");
	 *    String responseString = "";
	 *    if (!String.IsNullOrEmpty(cb)) {
	 *        responseString = cb + "(" + jsonString + ")";
	 *    } else {
	 *        responseString = jsonString;
	 *    }
	 *    Response.Write(responseString);
	 * 
	 */
	interface Def extends Ext.data.proxy.JsonP {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.proxy.JsonP.Cfg}
		 */
		config?: Ext.data.proxy.JsonP.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.proxy.JsonP.Statics|Ext.data.proxy.Server.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.proxy.JsonP.Statics}
		 */
		statics?: (() => Ext.data.proxy.JsonP.Statics | Ext.data.proxy.Server.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics) | Ext.data.proxy.JsonP.Statics | any;
	}
}
declare namespace Ext.data.proxy.LocalStorage {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html)
	 * The LocalStorageProxy uses the new HTML5 localStorage API to save [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) data locally on the
	 * client browser. HTML5 localStorage is a key-value store (e.g. cannot save complex objects like JSON), so
	 * LocalStorageProxy automatically serializes and deserializes data when saving and retrieving it.
	 * 
	 * localStorage is extremely useful for saving user-specific information without needing to build server-side
	 * infrastructure to support it. Let's imagine we're writing a Twitter search application and want to save the user's
	 * searches locally so they can easily perform a saved search again later. We'd start by creating a Search model:
	 * 
	 *    Ext.define('Search', {
	 *        fields: ['id', 'query'],
	 *        extend: 'Ext.data.Model',
	 *        proxy: {
	 *            type: 'localstorage',
	 *            id  : 'twitter-Searches'
	 *        }
	 *    });
	 * 
	 * Our Search model contains just two fields - id and query - plus a Proxy definition. The only configuration we need to
	 * pass to the LocalStorage proxy is an [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html#cfg-id). This is important as it separates the Model data in this Proxy from
	 * all others. The localStorage API puts all data into a single shared namespace, so by setting an id we enable
	 * LocalStorageProxy to manage the saved Search data.
	 * 
	 * Saving our data into localStorage is easy and would usually be done with a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html):
	 * 
	 *    //our Store automatically picks up the LocalStorageProxy defined on the Search model
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: "Search"
	 *    });
	 *    
	 *    //loads any existing Search data from localStorage
	 *    store.load();
	 *    
	 *    //now add some Searches
	 *    store.add({query: 'Sencha Touch'});
	 *    store.add({query: 'Ext JS'});
	 *    
	 *    //finally, save our Search data to localStorage
	 *    store.sync();
	 * 
	 * The LocalStorageProxy automatically gives our new Searches an id when we call store.sync(). It encodes the Model data
	 * and places it into localStorage. We can also save directly to localStorage, bypassing the Store altogether:
	 * 
	 *    var search = Ext.create('Search', {query: 'Sencha Animator'});
	 *    
	 *    //uses the configured LocalStorageProxy to save the new Search to localStorage
	 *    search.save();
	 * 
	 * # Limitations
	 * 
	 * If this proxy is used in a browser where local storage is not supported, the constructor will throw an error. A local
	 * storage proxy requires a unique ID which is used as a key in which all record data are stored in the local storage
	 * object.
	 * 
	 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
	 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
	 */
	interface Def extends Ext.data.proxy.LocalStorage {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.proxy.LocalStorage.Cfg}
		 */
		config?: Ext.data.proxy.LocalStorage.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.proxy.LocalStorage.Statics|Ext.data.proxy.WebStorage.Statics|Ext.data.proxy.Client.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.proxy.LocalStorage.Statics}
		 */
		statics?: (() => Ext.data.proxy.LocalStorage.Statics | Ext.data.proxy.WebStorage.Statics | Ext.data.proxy.Client.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics) | Ext.data.proxy.LocalStorage.Statics | any;
	}
}
declare namespace Ext.data.proxy.Memory {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html)
	 * In-memory proxy. This proxy simply uses a local variable for data storage/retrieval, so its contents are lost on
	 * every page refresh.
	 * 
	 * Usually this Proxy isn't used directly, serving instead as a helper to a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) where a reader
	 * is required to load data. For example, say we have a Store for a User model and have some inline data we want to
	 * load, but this data isn't in quite the right format: we can use a MemoryProxy with a JsonReader to read it into our
	 * Store:
	 * 
	 *    //this is the model we will be using in the store
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            {name: 'id',    type: 'int'},
	 *            {name: 'name',  type: 'string'},
	 *            {name: 'phone', type: 'string', mapping: 'phoneNumber'}
	 *        ]
	 *    });
	 *    
	 *    //this data does not line up to our model fields - the phone field is called phoneNumber
	 *    var data = {
	 *        users: [
	 *            {
	 *                id: 1,
	 *                name: 'Ed Spencer',
	 *                phoneNumber: '555 1234'
	 *            },
	 *            {
	 *                id: 2,
	 *                name: 'Abe Elias',
	 *                phoneNumber: '666 1234'
	 *            }
	 *        ]
	 *    };
	 *    
	 *    //note how we set the 'root' in the reader to match the data structure above
	 *    var store = Ext.create('Ext.data.Store', {
	 *        autoLoad: true,
	 *        model: 'User',
	 *        data : data,
	 *        proxy: {
	 *            type: 'memory',
	 *            reader: {
	 *                type: 'json',
	 *                rootProperty: 'users'
	 *            }
	 *        }
	 *    });
	 * 
	 */
	interface Def extends Ext.data.proxy.Memory {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.proxy.Memory.Cfg}
		 */
		config?: Ext.data.proxy.Memory.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.proxy.Memory.Statics|Ext.data.proxy.Client.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.proxy.Memory.Statics}
		 */
		statics?: (() => Ext.data.proxy.Memory.Statics | Ext.data.proxy.Client.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics) | Ext.data.proxy.Memory.Statics | any;
	}
}
declare namespace Ext.data.proxy.Proxy {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html)
	 * Proxies are used by [Stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) to handle the loading and saving of [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html)
	 * data. Usually developers will not need to create or interact with proxies directly.
	 * 
	 * # Types of Proxy
	 * 
	 * There are two main types of Proxy - [Client](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Client.html) and [Server](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html).
	 * The Client proxies save their data locally and include the following subclasses:
	 * 
	 * - [LocalStorageProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) - saves its data to localStorage if the browser supports it
	 * - [SessionStorageProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html) - saves its data to sessionStorage if the browsers supports it
	 * - [MemoryProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html) - holds data in memory only, any data is lost when the page is refreshed
	 * 
	 * The Server proxies save their data by sending requests to some remote server. These proxies include:
	 * 
	 * - [Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) - sends requests to a server on the same domain
	 * - [JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) - uses JSON-P to send requests to a server on a different domain
	 * - [Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html) - uses RESTful HTTP methods (GET/PUT/POST/DELETE) to communicate with server
	 * - [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html) - uses [Ext.direct.Manager](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Manager.html) to send requests
	 * 
	 * Proxies operate on the principle that all operations performed are either Create, Read, Update or Delete. These four
	 * operations are mapped to the methods [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-erase)
	 * respectively. Each Proxy subclass implements these functions.
	 * 
	 * The CRUD methods each expect an [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) object as the sole argument. The Operation
	 * encapsulates information about the action the Store wishes to perform, the [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) instances
	 * that are to be modified, etc. See the [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) documentation for more details. Each CRUD
	 * method also accepts a callback function to be called asynchronously on completion.
	 * 
	 * Proxies also support batching of Operations via a [batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object, invoked by the [batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-batch)
	 * method.
	 */
	interface Def extends Ext.data.proxy.Proxy {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.proxy.Proxy.Cfg}
		 */
		config?: Ext.data.proxy.Proxy.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.proxy.Proxy.Statics}
		 */
		statics?: (() => Ext.data.proxy.Proxy.Statics | Ext.Base.Statics) | Ext.data.proxy.Proxy.Statics | any;
	}
}
declare namespace Ext.data.proxy.Rest {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.proxy.Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html)
	 * The Rest proxy is a specialization of the [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) which simply maps the four actions
	 * (create, read, update and destroy) to RESTful HTTP verbs. For example, let's set up a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html)
	 * with an inline Rest proxy
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email'],
	 *    
	 *        proxy: {
	 *            type: 'rest',
	 *            url : '/users'
	 *        }
	 *    });
	 * 
	 * Now we can create a new User instance and save it via the Rest proxy. Doing this will cause the Proxy to send a POST
	 * request to '/users':
	 * 
	 *    var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
	 *    
	 *    user.save(); //POST /users
	 * 
	 * Let's expand this a little and provide a callback for the [Ext.data.Model.save](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html#method-save) call to update the Model once
	 * it has been created. We'll assume the creation went successfully and that the server gave this user an ID of 123:
	 * 
	 *    user.save({
	 *        success: function(user) {
	 *            user.set('name', 'Khan Noonien Singh');
	 *    
	 *            user.save(); //PUT /users/123
	 *        }
	 *    });
	 * 
	 * Now that we're no longer creating a new Model instance, the request method is changed to an HTTP PUT, targeting the
	 * relevant url for that user. Now let's delete this user, which will use the DELETE method:
	 * 
	 *        user.erase(); //DELETE /users/123
	 * 
	 * Finally, when we perform a load of a Model or Store, Rest proxy will use the GET method:
	 * 
	 *    //1. Load via Store
	 *    
	 *    //the Store automatically picks up the Proxy from the User model
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User'
	 *    });
	 *    
	 *    store.load(); //GET /users
	 *    
	 *    //2. Load directly from the Model
	 *    
	 *    //GET /users/123
	 *    User.load(123, {
	 *        success: function(user) {
	 *            console.log(user.getId()); //outputs 123
	 *        }
	 *    });
	 * 
	 * # Url generation
	 * 
	 * The Rest proxy is able to automatically generate the urls above based on two configuration options - [appendId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-appendId) and
	 * [format](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-format). If appendId is true (it is by default) then Rest proxy will automatically append the ID of the Model
	 * instance in question to the configured url, resulting in the '/users/123' that we saw above.
	 * 
	 * If the request is not for a specific Model instance (e.g. loading a Store), the url is not appended with an id.
	 * The Rest proxy will automatically insert a '/' before the ID if one is not already present.
	 * 
	 *    new Ext.data.proxy.Rest({
	 *        url: '/users',
	 *        appendId: true //default
	 *    });
	 *    
	 *    // Collection url: /users
	 *    // Instance url  : /users/123
	 * 
	 * The Rest proxy can also optionally append a format string to the end of any generated url:
	 * 
	 *    new Ext.data.proxy.Rest({
	 *        url: '/users',
	 *        format: 'json'
	 *    });
	 *    
	 *    // Collection url: /users.json
	 *    // Instance url  : /users/123.json
	 * 
	 * If further customization is needed, simply implement the [buildUrl](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#method-buildUrl) method and add your custom generated url
	 * onto the [Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object that is passed to buildUrl. See [Rest proxy's implementation](source/Rest.html#Ext-data-proxy-Rest-method-buildUrl) for
	 * an example of how to achieve this.
	 * 
	 * Note that Rest proxy inherits from [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html), which already injects all of the sorter,
	 * filter, group and paging options into the generated url. See the [AjaxProxy docs](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for more
	 * details.
	 */
	interface Def extends Ext.data.proxy.Rest {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.proxy.Rest.Cfg}
		 */
		config?: Ext.data.proxy.Rest.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.proxy.Rest.Statics|Ext.data.proxy.Ajax.Statics|Ext.data.proxy.Server.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.proxy.Rest.Statics}
		 */
		statics?: (() => Ext.data.proxy.Rest.Statics | Ext.data.proxy.Ajax.Statics | Ext.data.proxy.Server.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics) | Ext.data.proxy.Rest.Statics | any;
	}
}
declare namespace Ext.data.proxy.Server {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html)
	 * ServerProxy is a superclass of [JsonPProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html), and
	 * would not usually be used directly.
	 */
	interface Def extends Ext.data.proxy.Server {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.proxy.Server.Cfg}
		 */
		config?: Ext.data.proxy.Server.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.proxy.Server.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.proxy.Server.Statics}
		 */
		statics?: (() => Ext.data.proxy.Server.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics) | Ext.data.proxy.Server.Statics | any;
	}
}
declare namespace Ext.data.proxy.SessionStorage {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.proxy.SessionStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html)
	 * Proxy which uses HTML5 session storage as its data storage/retrieval mechanism. If this proxy is used in a browser
	 * where session storage is not supported, the constructor will throw an error. A session storage proxy requires a
	 * unique ID which is used as a key in which all record data are stored in the session storage object.
	 * 
	 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
	 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
	 * 
	 * Proxies are almost always used with a [store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html):
	 * 
	 *    new Ext.data.Store({
	 *        proxy: {
	 *            type: 'sessionstorage',
	 *            id  : 'myProxyKey'
	 *        }
	 *    });
	 * 
	 * Alternatively you can instantiate the Proxy directly:
	 * 
	 *    new Ext.data.proxy.SessionStorage({
	 *        id  : 'myOtherProxyKey'
	 *    });
	 * 
	 * Note that session storage is different to local storage (see [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html)) - if a browser
	 * session is ended (e.g. by closing the browser) then all data in a SessionStorageProxy are lost. Browser restarts
	 * don't affect the [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) - the data are preserved.
	 */
	interface Def extends Ext.data.proxy.SessionStorage {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.proxy.SessionStorage.Cfg}
		 */
		config?: Ext.data.proxy.SessionStorage.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.proxy.SessionStorage.Statics|Ext.data.proxy.WebStorage.Statics|Ext.data.proxy.Client.Statics|Ext.data.proxy.Proxy.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.proxy.SessionStorage.Statics}
		 */
		statics?: (() => Ext.data.proxy.SessionStorage.Statics | Ext.data.proxy.WebStorage.Statics | Ext.data.proxy.Client.Statics | Ext.data.proxy.Proxy.Statics | Ext.Base.Statics) | Ext.data.proxy.SessionStorage.Statics | any;
	}
}
declare namespace Ext.data.proxy.Ajax {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html)
	 * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
	 * data from the server, usually to be placed into a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html). Let's take a look at a typical setup.
	 * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html):
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email']
	 *    });
	 *    
	 *    //The Store contains the AjaxProxy as an inline configuration
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'ajax',
	 *            url : 'users.json'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * Our example is going to load user data into a Store, so we start off by defining a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) with
	 * the fields that we expect the server to return. Next we set up the Store itself, along with a
	 * [proxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html#cfg-proxy) configuration. This configuration was automatically turned into an
	 * [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) instance, with the url we specified being passed into AjaxProxy's constructor.
	 * It's as if we'd done this:
	 * 
	 *    new Ext.data.proxy.Ajax({
	 *        url: 'users.json',
	 *        model: 'User',
	 *        reader: 'json'
	 *    });
	 * 
	 * A couple of extra configurations appeared here - [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-model) and [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader). These are set by default when we
	 * create the proxy via the Store - the Store already knows about the Model, and Proxy's default [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) is [JsonReader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Json.html).
	 * 
	 * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
	 * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
	 * [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-actionMethods) to customize this - by default any kind of read will be sent as a GET request and any kind of write
	 * will be sent as a POST request).
	 * 
	 * # Limitations
	 * 
	 * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
	 * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
	 * talking to each other via AJAX.
	 * 
	 * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
	 * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
	 * from http://domainA.com), you can use [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and a technique known as JSON-P (JSON with
	 * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
	 * JSON-P responses. See [JsonPProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html)'s introduction docs for more details.
	 * 
	 * # Readers and Writers
	 * 
	 * AjaxProxy can be configured to use any type of [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to decode the server's response.
	 * If no Reader is supplied, AjaxProxy will default to using a [JsonReader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Json.html). Reader
	 * configuration can be passed in as a simple object, which the Proxy automatically turns into a [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) instance:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        model: 'User',
	 *        reader: {
	 *            type: 'xml',
	 *            rootProperty: 'users'
	 *        }
	 *    });
	 *    
	 *    proxy.getReader(); //returns an XmlReader instance based on the config we supplied
	 * 
	 * # Url generation
	 * 
	 * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
	 * each request. These are controlled with the following configuration options:
	 * 
	 * - [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-pageParam) - controls how the page number is sent to the server (see also [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-startParam) and [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-limitParam))
	 * - [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-sortParam) - controls how sort information is sent to the server
	 * - [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-groupParam) - controls how grouping information is sent to the server
	 * - [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-filterParam) - controls how filter information is sent to the server
	 * 
	 * Each request sent by AjaxProxy is described by an [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html). To see how we can customize
	 * the generated urls, let's say we're loading the Proxy with the following Operation:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    var operation = proxy.createOperation('read', {
	 *        page  : 2
	 *    });
	 * 
	 * Now we'll issue the request for this Operation by calling [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-read):
	 * 
	 *    proxy.read(operation); //GET /users?page=2
	 * 
	 * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
	 * to the server:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users',
	 *        pageParam: 'pageNumber'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?pageNumber=2
	 * 
	 * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    var operation = proxy.createOperation('read', {
	 *        start : 50,
	 *        limit : 25
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?start=50&amp;limit;=25
	 * 
	 * Again we can customize this url:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users',
	 *        startParam: 'startIndex',
	 *        limitParam: 'limitIndex'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?startIndex=50&amp;limitIndex;=25
	 * 
	 * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
	 * expressive Operation object:
	 * 
	 *    var operation = proxy.createOperation('read', {
	 *        sorters: [
	 *            new Ext.util.Sorter({
	 *                property : 'name',
	 *                direction: 'ASC'
	 *            }),
	 *            new Ext.util.Sorter({
	 *                property : 'age',
	 *                direction: 'DESC'
	 *            })
	 *        ],
	 *        filters: [
	 *            new Ext.util.Filter({
	 *                property: 'eyeColor',
	 *                value   : 'brown'
	 *            })
	 *        ]
	 *    });
	 * 
	 * This is the type of object that is generated internally when loading a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) with sorters and
	 * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
	 * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&amp;filter;=[{"property":"eyeColor","value":"brown"}]
	 * 
	 * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
	 * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
	 * that format like this:
	 * 
	 *     var proxy = new Ext.data.proxy.Ajax({
	 *         url: '/users',
	 *         sortParam: 'sortBy',
	 *         filterParam: 'filterBy',
	 *    
	 *         //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
	 *         encodeSorters: function(sorters) {
	 *             var length   = sorters.length,
	 *                 sortStrs = [],
	 *                 sorter, i;
	 *    
	 *             for (i = 0; i &lt; length; i++) {
	 *                 sorter = sorters[i];
	 *    
	 *                 sortStrs[i] = sorter.property + '#' + sorter.direction
	 *             }
	 *    
	 *             return sortStrs.join(",");
	 *         }
	 *     });
	 *    
	 *     proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&amp;filterBy;=[{"property":"eyeColor","value":"brown"}]
	 * 
	 * We can also provide a custom [encodeFilters](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-encodeFilters) function to encode our filters.
	 * 
	 * # Debugging your Ajax Proxy
	 * 
	 * If the data is not being loaded into the store as expected, it could be due to a mismatch between the the way that the [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader)
	 * is configured, and the shape of the incoming data.
	 * 
	 * To debug from the point that your data arrives back from the network, set a breakpoint inside the callback function
	 * created in the `createRequestCallback` method of the Ajax Proxy class, and follow the data to where the [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader) attempts
	 * to consume it.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                  members    The members to add to this class.
		 * @param   {boolean}                                                                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Ajax;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Server;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                  members
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.proxy.Ajax;
		addStatics? (members: object): typeof Ext.data.proxy.Server;
		addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                  members
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Ajax;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Server;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                  name
		 * @param   {object}                                                                  member
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.proxy.Ajax;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Server;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                  fn
		 * @param   {object}                                                                  scope
		 * @returns {Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Ajax;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Server;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.proxy.Client {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.proxy.Client](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Client.html)
	 * Base class for any client-side storage. Used as a superclass for [Memory](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html) and
	 * [Web Storage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html) proxies. Do not use directly, use one of the subclasses instead.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members    The members to add to this class.
		 * @param   {boolean}                                             [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                             [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Client;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members
		 * @returns {Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.proxy.Client;
		addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members
		 * @returns {Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Client;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              name
		 * @param   {object}                                              member
		 * @returns {Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.proxy.Client;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              fn
		 * @param   {object}                                              scope
		 * @returns {Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Client;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.proxy.Direct {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.proxy.Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html)
	 * This class is used to send requests to the server using Ext Direct. When a
	 * request is made, the transport mechanism is handed off to the appropriate
	 * [Provider](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.RemotingProvider.html) to complete the call.
	 * 
	 * # Specifying the function
	 * 
	 * This proxy expects a Direct remoting method to be passed in order to be able to complete requests.
	 * This can be done by specifying the [directFn](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-directFn) configuration. This will use the same direct
	 * method for all requests. Alternatively, you can provide an [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-api) configuration. This
	 * allows you to specify a different remoting method for each CRUD action.
	 * 
	 * # Parameters
	 * 
	 * This proxy provides options to help configure which parameters will be sent to the server.
	 * By specifying the [paramsAsHash](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramsAsHash) option, it will send an object literal containing each
	 * of the passed parameters. The [paramOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramOrder) option can be used to specify the order in which
	 * the remoting method parameters are passed.
	 * 
	 * # Example Usage
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['firstName', 'lastName'],
	 *        proxy: {
	 *            type: 'direct',
	 *            directFn: MyApp.getUsers,
	 *            paramOrder: 'id' // Tells the proxy to pass the id as the first parameter to the remoting method.
	 *        }
	 *    });
	 *    User.load(1);
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members    The members to add to this class.
		 * @param   {boolean}                                                                   [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                   [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Direct;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Server;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.proxy.Direct;
		addStatics? (members: object): typeof Ext.data.proxy.Server;
		addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Direct;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Server;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    name
		 * @param   {object}                                                                    member
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.proxy.Direct;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Server;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    fn
		 * @param   {object}                                                                    scope
		 * @returns {Ext.data.proxy.Direct|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Direct;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Server;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.proxy.JsonP {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html)
	 * The JsonP proxy is useful when you need to load data from a domain other than the one your application is running on. If
	 * your application is running on http://domainA.com it cannot use [Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) to load its data
	 * from http://domainB.com because cross-domain ajax requests are prohibited by the browser.
	 * 
	 * We can get around this using a JsonP proxy. JsonP proxy injects a `&lt;script&gt;` tag into the DOM whenever an AJAX request
	 * would usually be made. Let's say we want to load data from http://domainB.com/users - the script tag that would be
	 * injected might look like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?callback=someCallback"&gt;&lt;/script&gt;
	 * 
	 * When we inject the tag above, the browser makes a request to that url and includes the response as if it was any
	 * other type of JavaScript include. By passing a callback in the url above, we're telling domainB's server that we want
	 * to be notified when the result comes in and that it should call our callback function with the data it sends back. So
	 * long as the server formats the response to look like this, everything will work:
	 * 
	 *    someCallback({
	 *        users: [
	 *            {
	 *                id: 1,
	 *                name: "Ed Spencer",
	 *                email: "ed@sencha.com"
	 *            }
	 *        ]
	 *    });
	 * 
	 * As soon as the script finishes loading, the 'someCallback' function that we passed in the url is called with the JSON
	 * object that the server returned.
	 * 
	 * JsonP proxy takes care of all of this automatically. It formats the url you pass, adding the callback parameter
	 * automatically. It even creates a temporary callback function, waits for it to be called and then puts the data into
	 * the Proxy making it look just like you loaded it through a normal [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html). Here's how
	 * we might set that up:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email']
	 *    });
	 *    
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'jsonp',
	 *            url : 'http://domainB.com/users'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * That's all we need to do - JsonP proxy takes care of the rest. In this case the Proxy will have injected a script tag
	 * like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?callback=callback1"&gt;&lt;/script&gt;
	 * 
	 * # Customization
	 * 
	 * This script tag can be customized using the [callbackKey](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-callbackKey) configuration. For example:
	 * 
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'jsonp',
	 *            url : 'http://domainB.com/users',
	 *            callbackKey: 'theCallbackFunction'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * Would inject a script tag like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?theCallbackFunction=callback1"&gt;&lt;/script&gt;
	 * 
	 * # Implementing on the server side
	 * 
	 * The remote server side needs to be configured to return data in this format. Here are suggestions for how you might
	 * achieve this using Java, PHP and ASP.net:
	 * 
	 * Java:
	 * 
	 *    boolean jsonP = false;
	 *    String cb = request.getParameter("callback");
	 *    if (cb != null) {
	 *        jsonP = true;
	 *        response.setContentType("text/javascript");
	 *    } else {
	 *        response.setContentType("application/x-json");
	 *    }
	 *    Writer out = response.getWriter();
	 *    if (jsonP) {
	 *        out.write(cb + "(");
	 *    }
	 *    out.print(dataBlock.toJsonString());
	 *    if (jsonP) {
	 *        out.write(");");
	 *    }
	 * 
	 * PHP:
	 * 
	 *    $callback = $_REQUEST['callback'];
	 *    
	 *    // Create the output object.
	 *    $output = array('a' =&gt; 'Apple', 'b' =&gt; 'Banana');
	 *    
	 *    //start output
	 *    if ($callback) {
	 *        header('Content-Type: text/javascript');
	 *        echo $callback . '(' . json_encode($output) . ');';
	 *    } else {
	 *        header('Content-Type: application/x-json');
	 *        echo json_encode($output);
	 *    }
	 * 
	 * ASP.net:
	 * 
	 *    String jsonString = "{success: true}";
	 *    String cb = Request.Params.Get("callback");
	 *    String responseString = "";
	 *    if (!String.IsNullOrEmpty(cb)) {
	 *        responseString = cb + "(" + jsonString + ")";
	 *    } else {
	 *        responseString = jsonString;
	 *    }
	 *    Response.Write(responseString);
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                   members    The members to add to this class.
		 * @param   {boolean}                                                                  [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                  [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.JsonP;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Server;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                   members
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.proxy.JsonP;
		addStatics? (members: object): typeof Ext.data.proxy.Server;
		addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                   members
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.data.proxy.JsonP;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Server;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                   name
		 * @param   {object}                                                                   member
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.proxy.JsonP;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Server;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                   fn
		 * @param   {object}                                                                   scope
		 * @returns {Ext.data.proxy.JsonP|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.JsonP;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Server;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.proxy.LocalStorage {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html)
	 * The LocalStorageProxy uses the new HTML5 localStorage API to save [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) data locally on the
	 * client browser. HTML5 localStorage is a key-value store (e.g. cannot save complex objects like JSON), so
	 * LocalStorageProxy automatically serializes and deserializes data when saving and retrieving it.
	 * 
	 * localStorage is extremely useful for saving user-specific information without needing to build server-side
	 * infrastructure to support it. Let's imagine we're writing a Twitter search application and want to save the user's
	 * searches locally so they can easily perform a saved search again later. We'd start by creating a Search model:
	 * 
	 *    Ext.define('Search', {
	 *        fields: ['id', 'query'],
	 *        extend: 'Ext.data.Model',
	 *        proxy: {
	 *            type: 'localstorage',
	 *            id  : 'twitter-Searches'
	 *        }
	 *    });
	 * 
	 * Our Search model contains just two fields - id and query - plus a Proxy definition. The only configuration we need to
	 * pass to the LocalStorage proxy is an [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html#cfg-id). This is important as it separates the Model data in this Proxy from
	 * all others. The localStorage API puts all data into a single shared namespace, so by setting an id we enable
	 * LocalStorageProxy to manage the saved Search data.
	 * 
	 * Saving our data into localStorage is easy and would usually be done with a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html):
	 * 
	 *    //our Store automatically picks up the LocalStorageProxy defined on the Search model
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: "Search"
	 *    });
	 *    
	 *    //loads any existing Search data from localStorage
	 *    store.load();
	 *    
	 *    //now add some Searches
	 *    store.add({query: 'Sencha Touch'});
	 *    store.add({query: 'Ext JS'});
	 *    
	 *    //finally, save our Search data to localStorage
	 *    store.sync();
	 * 
	 * The LocalStorageProxy automatically gives our new Searches an id when we call store.sync(). It encodes the Model data
	 * and places it into localStorage. We can also save directly to localStorage, bypassing the Store altogether:
	 * 
	 *    var search = Ext.create('Search', {query: 'Sencha Animator'});
	 *    
	 *    //uses the configured LocalStorageProxy to save the new Search to localStorage
	 *    search.save();
	 * 
	 * # Limitations
	 * 
	 * If this proxy is used in a browser where local storage is not supported, the constructor will throw an error. A local
	 * storage proxy requires a unique ID which is used as a key in which all record data are stored in the local storage
	 * object.
	 * 
	 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
	 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                    members    The members to add to this class.
		 * @param   {boolean}                                                                                                   [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                                   [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.LocalStorage;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.WebStorage;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Client;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                    members
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.proxy.LocalStorage;
		addStatics? (members: object): typeof Ext.data.proxy.WebStorage;
		addStatics? (members: object): typeof Ext.data.proxy.Client;
		addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                    members
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.data.proxy.LocalStorage;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.WebStorage;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Client;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                    name
		 * @param   {object}                                                                                                    member
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.proxy.LocalStorage;
		addMember? (name: object, member: object): typeof Ext.data.proxy.WebStorage;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Client;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                    fn
		 * @param   {object}                                                                                                    scope
		 * @returns {Ext.data.proxy.LocalStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.LocalStorage;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.WebStorage;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Client;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.proxy.Memory {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html)
	 * In-memory proxy. This proxy simply uses a local variable for data storage/retrieval, so its contents are lost on
	 * every page refresh.
	 * 
	 * Usually this Proxy isn't used directly, serving instead as a helper to a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) where a reader
	 * is required to load data. For example, say we have a Store for a User model and have some inline data we want to
	 * load, but this data isn't in quite the right format: we can use a MemoryProxy with a JsonReader to read it into our
	 * Store:
	 * 
	 *    //this is the model we will be using in the store
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            {name: 'id',    type: 'int'},
	 *            {name: 'name',  type: 'string'},
	 *            {name: 'phone', type: 'string', mapping: 'phoneNumber'}
	 *        ]
	 *    });
	 *    
	 *    //this data does not line up to our model fields - the phone field is called phoneNumber
	 *    var data = {
	 *        users: [
	 *            {
	 *                id: 1,
	 *                name: 'Ed Spencer',
	 *                phoneNumber: '555 1234'
	 *            },
	 *            {
	 *                id: 2,
	 *                name: 'Abe Elias',
	 *                phoneNumber: '666 1234'
	 *            }
	 *        ]
	 *    };
	 *    
	 *    //note how we set the 'root' in the reader to match the data structure above
	 *    var store = Ext.create('Ext.data.Store', {
	 *        autoLoad: true,
	 *        model: 'User',
	 *        data : data,
	 *        proxy: {
	 *            type: 'memory',
	 *            reader: {
	 *                type: 'json',
	 *                rootProperty: 'users'
	 *            }
	 *        }
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members    The members to add to this class.
		 * @param   {boolean}                                                                   [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                   [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Memory;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Client;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.proxy.Memory;
		addStatics? (members: object): typeof Ext.data.proxy.Client;
		addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    members
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Memory;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Client;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    name
		 * @param   {object}                                                                    member
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.proxy.Memory;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Client;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                    fn
		 * @param   {object}                                                                    scope
		 * @returns {Ext.data.proxy.Memory|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Memory;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Client;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.proxy.Proxy {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html)
	 * Proxies are used by [Stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) to handle the loading and saving of [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html)
	 * data. Usually developers will not need to create or interact with proxies directly.
	 * 
	 * # Types of Proxy
	 * 
	 * There are two main types of Proxy - [Client](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Client.html) and [Server](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html).
	 * The Client proxies save their data locally and include the following subclasses:
	 * 
	 * - [LocalStorageProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) - saves its data to localStorage if the browser supports it
	 * - [SessionStorageProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html) - saves its data to sessionStorage if the browsers supports it
	 * - [MemoryProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html) - holds data in memory only, any data is lost when the page is refreshed
	 * 
	 * The Server proxies save their data by sending requests to some remote server. These proxies include:
	 * 
	 * - [Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) - sends requests to a server on the same domain
	 * - [JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) - uses JSON-P to send requests to a server on a different domain
	 * - [Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html) - uses RESTful HTTP methods (GET/PUT/POST/DELETE) to communicate with server
	 * - [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html) - uses [Ext.direct.Manager](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Manager.html) to send requests
	 * 
	 * Proxies operate on the principle that all operations performed are either Create, Read, Update or Delete. These four
	 * operations are mapped to the methods [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-erase)
	 * respectively. Each Proxy subclass implements these functions.
	 * 
	 * The CRUD methods each expect an [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) object as the sole argument. The Operation
	 * encapsulates information about the action the Store wishes to perform, the [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) instances
	 * that are to be modified, etc. See the [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) documentation for more details. Each CRUD
	 * method also accepts a callback function to be called asynchronously on completion.
	 * 
	 * Proxies also support batching of Operations via a [batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object, invoked by the [batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-batch)
	 * method.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                        members    The members to add to this class.
		 * @param   {boolean}                       [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                       [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                        members
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                        members
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                        name
		 * @param   {object}                        member
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                        fn
		 * @param   {object}                        scope
		 * @returns {Ext.data.proxy.Proxy|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.proxy.Rest {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.proxy.Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html)
	 * The Rest proxy is a specialization of the [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) which simply maps the four actions
	 * (create, read, update and destroy) to RESTful HTTP verbs. For example, let's set up a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html)
	 * with an inline Rest proxy
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email'],
	 *    
	 *        proxy: {
	 *            type: 'rest',
	 *            url : '/users'
	 *        }
	 *    });
	 * 
	 * Now we can create a new User instance and save it via the Rest proxy. Doing this will cause the Proxy to send a POST
	 * request to '/users':
	 * 
	 *    var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
	 *    
	 *    user.save(); //POST /users
	 * 
	 * Let's expand this a little and provide a callback for the [Ext.data.Model.save](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html#method-save) call to update the Model once
	 * it has been created. We'll assume the creation went successfully and that the server gave this user an ID of 123:
	 * 
	 *    user.save({
	 *        success: function(user) {
	 *            user.set('name', 'Khan Noonien Singh');
	 *    
	 *            user.save(); //PUT /users/123
	 *        }
	 *    });
	 * 
	 * Now that we're no longer creating a new Model instance, the request method is changed to an HTTP PUT, targeting the
	 * relevant url for that user. Now let's delete this user, which will use the DELETE method:
	 * 
	 *        user.erase(); //DELETE /users/123
	 * 
	 * Finally, when we perform a load of a Model or Store, Rest proxy will use the GET method:
	 * 
	 *    //1. Load via Store
	 *    
	 *    //the Store automatically picks up the Proxy from the User model
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User'
	 *    });
	 *    
	 *    store.load(); //GET /users
	 *    
	 *    //2. Load directly from the Model
	 *    
	 *    //GET /users/123
	 *    User.load(123, {
	 *        success: function(user) {
	 *            console.log(user.getId()); //outputs 123
	 *        }
	 *    });
	 * 
	 * # Url generation
	 * 
	 * The Rest proxy is able to automatically generate the urls above based on two configuration options - [appendId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-appendId) and
	 * [format](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-format). If appendId is true (it is by default) then Rest proxy will automatically append the ID of the Model
	 * instance in question to the configured url, resulting in the '/users/123' that we saw above.
	 * 
	 * If the request is not for a specific Model instance (e.g. loading a Store), the url is not appended with an id.
	 * The Rest proxy will automatically insert a '/' before the ID if one is not already present.
	 * 
	 *    new Ext.data.proxy.Rest({
	 *        url: '/users',
	 *        appendId: true //default
	 *    });
	 *    
	 *    // Collection url: /users
	 *    // Instance url  : /users/123
	 * 
	 * The Rest proxy can also optionally append a format string to the end of any generated url:
	 * 
	 *    new Ext.data.proxy.Rest({
	 *        url: '/users',
	 *        format: 'json'
	 *    });
	 *    
	 *    // Collection url: /users.json
	 *    // Instance url  : /users/123.json
	 * 
	 * If further customization is needed, simply implement the [buildUrl](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#method-buildUrl) method and add your custom generated url
	 * onto the [Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object that is passed to buildUrl. See [Rest proxy's implementation](source/Rest.html#Ext-data-proxy-Rest-method-buildUrl) for
	 * an example of how to achieve this.
	 * 
	 * Note that Rest proxy inherits from [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html), which already injects all of the sorter,
	 * filter, group and paging options into the generated url. See the [AjaxProxy docs](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for more
	 * details.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      members    The members to add to this class.
		 * @param   {boolean}                                                                                     [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                     [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Rest;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Ajax;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Server;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      members
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.proxy.Rest;
		addStatics? (members: object): typeof Ext.data.proxy.Ajax;
		addStatics? (members: object): typeof Ext.data.proxy.Server;
		addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      members
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Rest;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Ajax;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Server;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      name
		 * @param   {object}                                                                                      member
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.proxy.Rest;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Ajax;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Server;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      fn
		 * @param   {object}                                                                                      scope
		 * @returns {Ext.data.proxy.Rest|Ext.data.proxy.Ajax|Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Rest;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Ajax;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Server;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.proxy.Server {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html)
	 * ServerProxy is a superclass of [JsonPProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html), and
	 * would not usually be used directly.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members    The members to add to this class.
		 * @param   {boolean}                                             [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                             [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Server;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.proxy.Server;
		addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Server;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              name
		 * @param   {object}                                              member
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.proxy.Server;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              fn
		 * @param   {object}                                              scope
		 * @returns {Ext.data.proxy.Server|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Server;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.proxy.SessionStorage {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.proxy.SessionStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html)
	 * Proxy which uses HTML5 session storage as its data storage/retrieval mechanism. If this proxy is used in a browser
	 * where session storage is not supported, the constructor will throw an error. A session storage proxy requires a
	 * unique ID which is used as a key in which all record data are stored in the session storage object.
	 * 
	 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
	 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
	 * 
	 * Proxies are almost always used with a [store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html):
	 * 
	 *    new Ext.data.Store({
	 *        proxy: {
	 *            type: 'sessionstorage',
	 *            id  : 'myProxyKey'
	 *        }
	 *    });
	 * 
	 * Alternatively you can instantiate the Proxy directly:
	 * 
	 *    new Ext.data.proxy.SessionStorage({
	 *        id  : 'myOtherProxyKey'
	 *    });
	 * 
	 * Note that session storage is different to local storage (see [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html)) - if a browser
	 * session is ended (e.g. by closing the browser) then all data in a SessionStorageProxy are lost. Browser restarts
	 * don't affect the [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) - the data are preserved.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                      members    The members to add to this class.
		 * @param   {boolean}                                                                                                     [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                                     [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.SessionStorage;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.WebStorage;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Client;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                      members
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.proxy.SessionStorage;
		addStatics? (members: object): typeof Ext.data.proxy.WebStorage;
		addStatics? (members: object): typeof Ext.data.proxy.Client;
		addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                      members
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.data.proxy.SessionStorage;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.WebStorage;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Client;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                      name
		 * @param   {object}                                                                                                      member
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.proxy.SessionStorage;
		addMember? (name: object, member: object): typeof Ext.data.proxy.WebStorage;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Client;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                                      fn
		 * @param   {object}                                                                                                      scope
		 * @returns {Ext.data.proxy.SessionStorage|Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.SessionStorage;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.WebStorage;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Client;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.proxy.WebStorage {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.proxy.WebStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html)
	 * WebStorageProxy is simply a superclass for the [LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) and [SessionStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html) proxies. It uses the new HTML5 key/value client-side storage objects to
	 * save [model instances](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) for offline use.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                        members    The members to add to this class.
		 * @param   {boolean}                                                                       [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                       [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.WebStorage;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Client;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.proxy.Proxy;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                        members
		 * @returns {Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.proxy.WebStorage;
		addStatics? (members: object): typeof Ext.data.proxy.Client;
		addStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                        members
		 * @returns {Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}         
		 */
		addInheritableStatics? (members: object): typeof Ext.data.proxy.WebStorage;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Client;
		addInheritableStatics? (members: object): typeof Ext.data.proxy.Proxy;
		addInheritableStatics? (members: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                        name
		 * @param   {object}                                                                        member
		 * @returns {Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.proxy.WebStorage;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Client;
		addMember? (name: object, member: object): typeof Ext.data.proxy.Proxy;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                        fn
		 * @param   {object}                                                                        scope
		 * @returns {Ext.data.proxy.WebStorage|Ext.data.proxy.Client|Ext.data.proxy.Proxy|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.WebStorage;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Client;
		onExtended? (fn: object, scope: object): typeof Ext.data.proxy.Proxy;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.proxy.Ajax.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Ajax.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Ajax.methodParams.batch {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Ajax.batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-batch)
	 * Object containing one or more properties supported by the batch method:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Object containing the Model instances to act upon, keyed by action name
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		operations?: object;
		/** 
		 * Event listeners object passed straight through to the Batch -
		 * see [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) for details
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of processing the batch.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Ajax.methodParams.batch.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the batch. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the `failure` function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Ajax.methodParams.batch.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the batch. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Ajax.methodParams.batch.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.proxy.Ajax.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Ajax.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Client.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Client.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Client.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Client.methodParams.batch {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Client.batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Client.html#method-batch)
	 * Object containing one or more properties supported by the batch method:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Object containing the Model instances to act upon, keyed by action name
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		operations?: object;
		/** 
		 * Event listeners object passed straight through to the Batch -
		 * see [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) for details
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of processing the batch.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Client.methodParams.batch.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the batch. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the `failure` function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Client.methodParams.batch.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the batch. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Client.methodParams.batch.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.proxy.Client.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Client.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Client.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Direct.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Direct.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Direct.methodParams.batch {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Direct.batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#method-batch)
	 * Object containing one or more properties supported by the batch method:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Object containing the Model instances to act upon, keyed by action name
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		operations?: object;
		/** 
		 * Event listeners object passed straight through to the Batch -
		 * see [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) for details
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of processing the batch.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Direct.methodParams.batch.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the batch. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the `failure` function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Direct.methodParams.batch.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the batch. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Direct.methodParams.batch.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.proxy.Direct.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Direct.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.JsonP.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.JsonP.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.JsonP.methodParams.batch {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.JsonP.batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#method-batch)
	 * Object containing one or more properties supported by the batch method:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Object containing the Model instances to act upon, keyed by action name
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		operations?: object;
		/** 
		 * Event listeners object passed straight through to the Batch -
		 * see [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) for details
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of processing the batch.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.JsonP.methodParams.batch.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the batch. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the `failure` function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.JsonP.methodParams.batch.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the batch. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.JsonP.methodParams.batch.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.proxy.JsonP.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.JsonP.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.LocalStorage.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.LocalStorage.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.LocalStorage.methodParams.batch {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.LocalStorage.batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html#method-batch)
	 * Object containing one or more properties supported by the batch method:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Object containing the Model instances to act upon, keyed by action name
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		operations?: object;
		/** 
		 * Event listeners object passed straight through to the Batch -
		 * see [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) for details
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of processing the batch.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.LocalStorage.methodParams.batch.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the batch. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the `failure` function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.LocalStorage.methodParams.batch.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the batch. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.LocalStorage.methodParams.batch.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.proxy.LocalStorage.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.LocalStorage.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Memory.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Memory.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Memory.methodParams.batch {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Memory.batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html#method-batch)
	 * Object containing one or more properties supported by the batch method:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Object containing the Model instances to act upon, keyed by action name
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		operations?: object;
		/** 
		 * Event listeners object passed straight through to the Batch -
		 * see [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) for details
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of processing the batch.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Memory.methodParams.batch.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the batch. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the `failure` function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Memory.methodParams.batch.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the batch. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Memory.methodParams.batch.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.proxy.Memory.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Memory.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Proxy.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Proxy.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Proxy.methodParams.batch {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Proxy.batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-batch)
	 * Object containing one or more properties supported by the batch method:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Object containing the Model instances to act upon, keyed by action name
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		operations?: object;
		/** 
		 * Event listeners object passed straight through to the Batch -
		 * see [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) for details
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of processing the batch.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Proxy.methodParams.batch.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the batch. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the `failure` function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Proxy.methodParams.batch.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the batch. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Proxy.methodParams.batch.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.proxy.Proxy.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Proxy.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Rest.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Rest.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Rest.methodParams.batch {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Rest.batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#method-batch)
	 * Object containing one or more properties supported by the batch method:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Object containing the Model instances to act upon, keyed by action name
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		operations?: object;
		/** 
		 * Event listeners object passed straight through to the Batch -
		 * see [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) for details
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of processing the batch.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Rest.methodParams.batch.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the batch. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the `failure` function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Rest.methodParams.batch.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the batch. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Rest.methodParams.batch.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.proxy.Rest.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Rest.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Server.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Server.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Server.methodParams.batch {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Server.batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-batch)
	 * Object containing one or more properties supported by the batch method:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Object containing the Model instances to act upon, keyed by action name
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		operations?: object;
		/** 
		 * Event listeners object passed straight through to the Batch -
		 * see [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) for details
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of processing the batch.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Server.methodParams.batch.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the batch. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the `failure` function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Server.methodParams.batch.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the batch. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.Server.methodParams.batch.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.proxy.Server.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.Server.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.SessionStorage.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.SessionStorage.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.SessionStorage.methodParams.batch {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.SessionStorage.batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html#method-batch)
	 * Object containing one or more properties supported by the batch method:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Object containing the Model instances to act upon, keyed by action name
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		operations?: object;
		/** 
		 * Event listeners object passed straight through to the Batch -
		 * see [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) for details
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of processing the batch.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.SessionStorage.methodParams.batch.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the batch. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the `failure` function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.SessionStorage.methodParams.batch.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the batch. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.SessionStorage.methodParams.batch.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.proxy.SessionStorage.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.SessionStorage.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.WebStorage.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.WebStorage.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.WebStorage.methodParams.batch {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.WebStorage.batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html#method-batch)
	 * Object containing one or more properties supported by the batch method:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Object containing the Model instances to act upon, keyed by action name
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		operations?: object;
		/** 
		 * Event listeners object passed straight through to the Batch -
		 * see [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) for details
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of processing the batch.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.WebStorage.methodParams.batch.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the batch. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the `failure` function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.WebStorage.methodParams.batch.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the batch. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.proxy.WebStorage.methodParams.batch.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.proxy.WebStorage.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.proxy.WebStorage.on](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.proxy.Ajax {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html)
	 * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
	 * data from the server, usually to be placed into a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html). Let's take a look at a typical setup.
	 * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html):
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email']
	 *    });
	 *    
	 *    //The Store contains the AjaxProxy as an inline configuration
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'ajax',
	 *            url : 'users.json'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * Our example is going to load user data into a Store, so we start off by defining a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) with
	 * the fields that we expect the server to return. Next we set up the Store itself, along with a
	 * [proxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html#cfg-proxy) configuration. This configuration was automatically turned into an
	 * [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) instance, with the url we specified being passed into AjaxProxy's constructor.
	 * It's as if we'd done this:
	 * 
	 *    new Ext.data.proxy.Ajax({
	 *        url: 'users.json',
	 *        model: 'User',
	 *        reader: 'json'
	 *    });
	 * 
	 * A couple of extra configurations appeared here - [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-model) and [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader). These are set by default when we
	 * create the proxy via the Store - the Store already knows about the Model, and Proxy's default [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) is [JsonReader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Json.html).
	 * 
	 * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
	 * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
	 * [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-actionMethods) to customize this - by default any kind of read will be sent as a GET request and any kind of write
	 * will be sent as a POST request).
	 * 
	 * # Limitations
	 * 
	 * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
	 * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
	 * talking to each other via AJAX.
	 * 
	 * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
	 * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
	 * from http://domainA.com), you can use [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and a technique known as JSON-P (JSON with
	 * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
	 * JSON-P responses. See [JsonPProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html)'s introduction docs for more details.
	 * 
	 * # Readers and Writers
	 * 
	 * AjaxProxy can be configured to use any type of [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to decode the server's response.
	 * If no Reader is supplied, AjaxProxy will default to using a [JsonReader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Json.html). Reader
	 * configuration can be passed in as a simple object, which the Proxy automatically turns into a [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) instance:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        model: 'User',
	 *        reader: {
	 *            type: 'xml',
	 *            rootProperty: 'users'
	 *        }
	 *    });
	 *    
	 *    proxy.getReader(); //returns an XmlReader instance based on the config we supplied
	 * 
	 * # Url generation
	 * 
	 * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
	 * each request. These are controlled with the following configuration options:
	 * 
	 * - [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-pageParam) - controls how the page number is sent to the server (see also [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-startParam) and [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-limitParam))
	 * - [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-sortParam) - controls how sort information is sent to the server
	 * - [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-groupParam) - controls how grouping information is sent to the server
	 * - [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-filterParam) - controls how filter information is sent to the server
	 * 
	 * Each request sent by AjaxProxy is described by an [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html). To see how we can customize
	 * the generated urls, let's say we're loading the Proxy with the following Operation:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    var operation = proxy.createOperation('read', {
	 *        page  : 2
	 *    });
	 * 
	 * Now we'll issue the request for this Operation by calling [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-read):
	 * 
	 *    proxy.read(operation); //GET /users?page=2
	 * 
	 * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
	 * to the server:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users',
	 *        pageParam: 'pageNumber'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?pageNumber=2
	 * 
	 * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    var operation = proxy.createOperation('read', {
	 *        start : 50,
	 *        limit : 25
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?start=50&amp;limit;=25
	 * 
	 * Again we can customize this url:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users',
	 *        startParam: 'startIndex',
	 *        limitParam: 'limitIndex'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?startIndex=50&amp;limitIndex;=25
	 * 
	 * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
	 * expressive Operation object:
	 * 
	 *    var operation = proxy.createOperation('read', {
	 *        sorters: [
	 *            new Ext.util.Sorter({
	 *                property : 'name',
	 *                direction: 'ASC'
	 *            }),
	 *            new Ext.util.Sorter({
	 *                property : 'age',
	 *                direction: 'DESC'
	 *            })
	 *        ],
	 *        filters: [
	 *            new Ext.util.Filter({
	 *                property: 'eyeColor',
	 *                value   : 'brown'
	 *            })
	 *        ]
	 *    });
	 * 
	 * This is the type of object that is generated internally when loading a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) with sorters and
	 * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
	 * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&amp;filter;=[{"property":"eyeColor","value":"brown"}]
	 * 
	 * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
	 * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
	 * that format like this:
	 * 
	 *     var proxy = new Ext.data.proxy.Ajax({
	 *         url: '/users',
	 *         sortParam: 'sortBy',
	 *         filterParam: 'filterBy',
	 *    
	 *         //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
	 *         encodeSorters: function(sorters) {
	 *             var length   = sorters.length,
	 *                 sortStrs = [],
	 *                 sorter, i;
	 *    
	 *             for (i = 0; i &lt; length; i++) {
	 *                 sorter = sorters[i];
	 *    
	 *                 sortStrs[i] = sorter.property + '#' + sorter.direction
	 *             }
	 *    
	 *             return sortStrs.join(",");
	 *         }
	 *     });
	 *    
	 *     proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&amp;filterBy;=[{"property":"eyeColor","value":"brown"}]
	 * 
	 * We can also provide a custom [encodeFilters](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-encodeFilters) function to encode our filters.
	 * 
	 * # Debugging your Ajax Proxy
	 * 
	 * If the data is not being loaded into the store as expected, it could be due to a mismatch between the the way that the [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader)
	 * is configured, and the shape of the incoming data.
	 * 
	 * To debug from the point that your data arrives back from the network, set a breakpoint inside the callback function
	 * created in the `createRequestCallback` method of the Ajax Proxy class, and follow the data to where the [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader) attempts
	 * to consume it.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * Mapping of action name to HTTP request method. In the basic AjaxProxy these are set to 'GET' for 'read' actions
		 * and 'POST' for 'create', 'update' and 'destroy' actions. The [Ext.data.proxy.Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html) maps these to the
		 * correct RESTful methods.
		 * @configuration
		 * @optional
		 * @default {create: 'POST', read: 'GET', update: 'POST', destroy: 'POST'}
		 * @type {object}
		 */
		actionMethods?: object;
		/** 
		 * Specific urls to call on CRUD action methods "create", "read", "update" and "destroy". Defaults to:
		 * 
		 *    api: {
		 *        create  : undefined,
		 *        read    : undefined,
		 *        update  : undefined,
		 *        destroy : undefined
		 *    }
		 * 
		 * The url is built based upon the action being executed [create|read|update|destroy] using the commensurate
		 * [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api) property, or if undefined default to the configured
		 * [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html).[url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * 
		 * For example:
		 * 
		 *    api: {
		 *        create  : '/controller/new',
		 *        read    : '/controller/load',
		 *        update  : '/controller/update',
		 *        destroy : '/controller/destroy_action'
		 *    }
		 * 
		 * If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the
		 * configured [url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		api?: object;
		/** 
		 * True to batch actions of a particular type when synchronizing the store. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		batchActions?: boolean;
		/** 
		 * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
		 * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
		 * @configuration
		 * @optional
		 * @default 'create,update,destroy'
		 * @type {string}
		 */
		batchOrder?: string;
		/** 
		 * True to request binary data from the server.  This feature requires
		 * the use of a binary reader such as AMF Reader
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		binary?: boolean;
		/** 
		 * The name of the cache param added to the url when using noCache. Defaults to "_dc".
		 * @configuration
		 * @optional
		 * @default "_dc"
		 * @type {string}
		 */
		cacheString?: string;
		/** 
		 * The name of the direction parameter to send in a request. **This is only used when simpleSortMode is set to
		 * true.**
		 * @configuration
		 * @optional
		 * @default "dir"
		 * @type {string}
		 */
		directionParam?: string;
		/** 
		 * Extra parameters that will be included on every request. Individual requests with params of the same name
		 * will override these params when they are in conflict.
		 * @configuration
		 * @optional
		 * @default {}
		 * @type {object}
		 */
		extraParams?: object;
		/** 
		 * The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to `''` if you don't
		 * want to send a filter parameter.
		 * @configuration
		 * @optional
		 * @default "filter"
		 * @type {string}
		 */
		filterParam?: string;
		/** 
		 * The name of the direction parameter to send in a request. **This is only used when simpleGroupMode is set to
		 * true.**
		 * @configuration
		 * @optional
		 * @default "groupDir"
		 * @type {string}
		 */
		groupDirectionParam?: string;
		/** 
		 * The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to `''` if you don't
		 * want to send a group parameter.
		 * @configuration
		 * @optional
		 * @default "group"
		 * @type {string}
		 */
		groupParam?: string;
		/** 
		 * Any headers to add to the Ajax request.
		 * 
		 * example:
		 * 
		 *    proxy: {
		 *        headers: {'Content-Type': "text/plain" }
		 *        ...
		 *    }
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		headers?: object;
		/** 
		 * The name of the parameter which carries the id of the entity being operated upon.
		 * @configuration
		 * @optional
		 * @default "id"
		 * @type {string}
		 */
		idParam?: string;
		/** 
		 * The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to `''` if you don't
		 * want to send a limit parameter.
		 * @configuration
		 * @optional
		 * @default "limit"
		 * @type {string}
		 */
		limitParam?: string;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
		 * Model constructor. Required.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * Disable caching by adding a unique parameter name to the request. Set to false to allow caching. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		noCache?: boolean;
		/** 
		 * The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to `''` if you don't
		 * want to send a page parameter.
		 * @configuration
		 * @optional
		 * @default "page"
		 * @type {string}
		 */
		pageParam?: string;
		/** 
		 * `true` to have any request parameters sent as [jsonData](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Connection.html#method-request)
		 * where they can be parsed from the raw request. By default, parameters are sent via the
		 * [params](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Connection.html#method-request) property. **Note**: This setting does not apply when the
		 * request is sent as a 'GET' request. See [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-actionMethods) for controlling the HTTP verb
		 * that is used when sending requests.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		paramsAsJson?: boolean;
		/** 
		 * Most oData feeds require basic HTTP authentication. This configuration allows
		 * you to specify the password.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		password?: string;
		/** 
		 * The [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to use to decode the server's response or data read
		 * from client. This can either be a Reader instance, a config object or just a
		 * valid Reader type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.reader.Reader}
		 */
		reader?: object | string | Ext.data.reader.Reader;
		/** 
		 * Enabling simpleGroupMode in conjunction with remoteGroup will only send one group property and a direction when a
		 * remote group is requested. The [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam) and [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam) will be sent with the property name and either 'ASC'
		 * or 'DESC'.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		simpleGroupMode?: boolean;
		/** 
		 * Enabling simpleSortMode in conjunction with remoteSort will only send one sort property and a direction when a
		 * remote sort is requested. The [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam) and [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam) will be sent with the property name
		 * and either 'ASC' or 'DESC'.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		simpleSortMode?: boolean;
		/** 
		 * The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to `''` if you don't
		 * want to send a sort parameter.
		 * @configuration
		 * @optional
		 * @default "sort"
		 * @type {string}
		 */
		sortParam?: string;
		/** 
		 * The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to `''` if you don't
		 * want to send a start parameter.
		 * @configuration
		 * @optional
		 * @default "start"
		 * @type {string}
		 */
		startParam?: string;
		/** 
		 * The number of milliseconds to wait for a response. Defaults to 30000 milliseconds (30 seconds).
		 * @configuration
		 * @optional
		 * @default 30000
		 * @type {number}
		 */
		timeout?: number;
		/** 
		 * The URL from which to request the data object.
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		url?: string;
		/** 
		 * Set this to false to not send the default Xhr header (X-Requested-With) with every request.
		 * This should be set to false when making CORS (cross-domain) requests.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		useDefaultXhrHeader?: boolean;
		/** 
		 * Most oData feeds require basic HTTP authentication. This configuration allows
		 * you to specify the username.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		username?: string;
		/** 
		 * This configuration is sometimes necessary when using cross-origin resource sharing.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		withCredentials?: boolean;
		/** 
		 * The [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.writer.Writer.html) to use to encode any request sent to the server or
		 * saved to client. This can either be a Writer instance, a config object or just
		 * a valid Writer type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.writer.Writer}
		 */
		writer?: object | string | Ext.data.writer.Writer;
		/** 
		 * Optional callback function which can be used to clean up after a request has been completed.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.data.Request} request The Request object
		 * @param   {boolean}          success True if the request was successful
		 * @returns {void}                     
		 */
		afterRequest? (request: Ext.data.Request, success: boolean): void;
		/** 
		 * Template method to allow subclasses to specify how to get the response for the reader.
		 * @method
		 * @private (method)
		 * @template
		 * @param   {object} response The server response
		 * @returns {object}          The response data to be used by the reader
		 */
		extractResponseData? (response: object): object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.data.proxy.Ajax.Statics}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Ajax.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Ajax.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Ajax.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Ajax.Statics}  
		 */
		statics? (): Ext.data.proxy.Ajax.Statics;
	}
}
declare namespace Ext.data.proxy.Client {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.proxy.Client](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Client.html)
	 * Base class for any client-side storage. Used as a superclass for [Memory](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html) and
	 * [Web Storage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html) proxies. Do not use directly, use one of the subclasses instead.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * True to batch actions of a particular type when synchronizing the store. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		batchActions?: boolean;
		/** 
		 * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
		 * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
		 * @configuration
		 * @optional
		 * @default 'create,update,destroy'
		 * @type {string}
		 */
		batchOrder?: string;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
		 * Model constructor. Required.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to use to decode the server's response or data read
		 * from client. This can either be a Reader instance, a config object or just a
		 * valid Reader type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.reader.Reader}
		 */
		reader?: object | string | Ext.data.reader.Reader;
		/** 
		 * The [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.writer.Writer.html) to use to encode any request sent to the server or
		 * saved to client. This can either be a Writer instance, a config object or just
		 * a valid Writer type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.writer.Writer}
		 */
		writer?: object | string | Ext.data.writer.Writer;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                        config
		 * @returns {Ext.data.proxy.Client.Statics}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Client.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                 name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                        [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Client.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Client.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Client.Statics}  
		 */
		statics? (): Ext.data.proxy.Client.Statics;
	}
}
declare namespace Ext.data.proxy.Direct {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.proxy.Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html)
	 * This class is used to send requests to the server using Ext Direct. When a
	 * request is made, the transport mechanism is handed off to the appropriate
	 * [Provider](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.RemotingProvider.html) to complete the call.
	 * 
	 * # Specifying the function
	 * 
	 * This proxy expects a Direct remoting method to be passed in order to be able to complete requests.
	 * This can be done by specifying the [directFn](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-directFn) configuration. This will use the same direct
	 * method for all requests. Alternatively, you can provide an [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-api) configuration. This
	 * allows you to specify a different remoting method for each CRUD action.
	 * 
	 * # Parameters
	 * 
	 * This proxy provides options to help configure which parameters will be sent to the server.
	 * By specifying the [paramsAsHash](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramsAsHash) option, it will send an object literal containing each
	 * of the passed parameters. The [paramOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramOrder) option can be used to specify the order in which
	 * the remoting method parameters are passed.
	 * 
	 * # Example Usage
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['firstName', 'lastName'],
	 *        proxy: {
	 *            type: 'direct',
	 *            directFn: MyApp.getUsers,
	 *            paramOrder: 'id' // Tells the proxy to pass the id as the first parameter to the remoting method.
	 *        }
	 *    });
	 *    User.load(1);
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The same as [Ext.data.proxy.Server.api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api), however instead of providing urls, you should provide a direct
		 * function call. See [directFn](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-directFn).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		api?: object;
		/** 
		 * True to batch actions of a particular type when synchronizing the store. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		batchActions?: boolean;
		/** 
		 * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
		 * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
		 * @configuration
		 * @optional
		 * @default 'create,update,destroy'
		 * @type {string}
		 */
		batchOrder?: string;
		/** 
		 * The name of the cache param added to the url when using noCache. Defaults to "_dc".
		 * @configuration
		 * @optional
		 * @default "_dc"
		 * @type {string}
		 */
		cacheString?: string;
		/** 
		 * Function to call when executing a request. directFn is a simple alternative to defining the api configuration-parameter
		 * for Store's which will not implement a full CRUD api. The directFn may also be a string reference to the fully qualified
		 * name of the function, for example: 'MyApp.company.GetProfile'. This can be useful when using dynamic loading. The string
		 * will be looked up when the proxy is created.
		 * @configuration
		 * @optional
		 * @type {ExtGlobalFunction|string}
		 */
		directFn?: ExtGlobalFunction | string;
		/** 
		 * The name of the direction parameter to send in a request. **This is only used when simpleSortMode is set to
		 * true.**
		 * @configuration
		 * @optional
		 * @default "dir"
		 * @type {string}
		 */
		directionParam?: string;
		/** 
		 * Extra parameters that will be included on every request. Individual requests with params of the same name
		 * will override these params when they are in conflict.
		 * @configuration
		 * @optional
		 * @default {}
		 * @type {object}
		 */
		extraParams?: object;
		/** 
		 * The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to `''` if you don't
		 * want to send a filter parameter.
		 * @configuration
		 * @optional
		 * @default "filter"
		 * @type {string}
		 */
		filterParam?: string;
		/** 
		 * The name of the direction parameter to send in a request. **This is only used when simpleGroupMode is set to
		 * true.**
		 * @configuration
		 * @optional
		 * @default "groupDir"
		 * @type {string}
		 */
		groupDirectionParam?: string;
		/** 
		 * The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to `''` if you don't
		 * want to send a group parameter.
		 * @configuration
		 * @optional
		 * @default "group"
		 * @type {string}
		 */
		groupParam?: string;
		/** 
		 * The name of the parameter which carries the id of the entity being operated upon.
		 * @configuration
		 * @optional
		 * @default "id"
		 * @type {string}
		 */
		idParam?: string;
		/** 
		 * The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to `''` if you don't
		 * want to send a limit parameter.
		 * @configuration
		 * @optional
		 * @default "limit"
		 * @type {string}
		 */
		limitParam?: string;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Optional set of fixed parameters to send with every Proxy request, similar to
		 * [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-extraParams) but available with all CRUD requests. Also unlike
		 * [extraParams](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-extraParams), metadata is not mixed with the ordinary data but sent
		 * separately in the data packet.
		 * You may need to update your server side Ext Direct stack to use this feature.
		 * @configuration
		 * @optional
		 * @type {object|any[]}
		 */
		metadata?: object | any[];
		/** 
		 * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
		 * Model constructor. Required.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * Disable caching by adding a unique parameter name to the request. Set to false to allow caching. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		noCache?: boolean;
		/** 
		 * The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to `''` if you don't
		 * want to send a page parameter.
		 * @configuration
		 * @optional
		 * @default "page"
		 * @type {string}
		 */
		pageParam?: string;
		/** 
		 * Defaults to undefined. A list of params to be executed server side.  Specify the params in the order in
		 * which they must be executed on the server-side as either (1) an Array of String values, or (2) a String
		 * of params delimited by either whitespace, comma, or pipe. For example, any of the following would be
		 * acceptable:
		 * 
		 *    paramOrder: ['param1','param2','param3']
		 *    paramOrder: 'param1 param2 param3'
		 *    paramOrder: 'param1,param2,param3'
		 *    paramOrder: 'param1|param2|param'
		 * 
		 * @configuration
		 * @optional
		 * @type {string|string[]}
		 */
		paramOrder?: string | string[];
		/** 
		 * Send parameters as a collection of named arguments.
		 * Providing a [paramOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramOrder) nullifies this configuration.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		paramsAsHash?: boolean;
		/** 
		 * The [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to use to decode the server's response or data read
		 * from client. This can either be a Reader instance, a config object or just a
		 * valid Reader type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.reader.Reader}
		 */
		reader?: object | string | Ext.data.reader.Reader;
		/** 
		 * Enabling simpleGroupMode in conjunction with remoteGroup will only send one group property and a direction when a
		 * remote group is requested. The [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam) and [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam) will be sent with the property name and either 'ASC'
		 * or 'DESC'.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		simpleGroupMode?: boolean;
		/** 
		 * Enabling simpleSortMode in conjunction with remoteSort will only send one sort property and a direction when a
		 * remote sort is requested. The [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam) and [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam) will be sent with the property name
		 * and either 'ASC' or 'DESC'.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		simpleSortMode?: boolean;
		/** 
		 * The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to `''` if you don't
		 * want to send a sort parameter.
		 * @configuration
		 * @optional
		 * @default "sort"
		 * @type {string}
		 */
		sortParam?: string;
		/** 
		 * The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to `''` if you don't
		 * want to send a start parameter.
		 * @configuration
		 * @optional
		 * @default "start"
		 * @type {string}
		 */
		startParam?: string;
		/** 
		 * The number of milliseconds to wait for a response. Defaults to 30000 milliseconds (30 seconds).
		 * @configuration
		 * @optional
		 * @default 30000
		 * @type {number}
		 */
		timeout?: number;
		/** 
		 * The [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.writer.Writer.html) to use to encode any request sent to the server or
		 * saved to client. This can either be a Writer instance, a config object or just
		 * a valid Writer type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.writer.Writer}
		 */
		writer?: object | string | Ext.data.writer.Writer;
		/** 
		 * Optional callback function which can be used to clean up after a request has been completed.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.data.Request} request The Request object
		 * @param   {boolean}          success True if the request was successful
		 * @returns {void}                     
		 */
		afterRequest? (request: Ext.data.Request, success: boolean): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                        config
		 * @returns {Ext.data.proxy.Direct.Statics}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Direct.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                 name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                        [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Direct.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Direct.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Direct.Statics}  
		 */
		statics? (): Ext.data.proxy.Direct.Statics;
	}
}
declare namespace Ext.data.proxy.JsonP {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html)
	 * The JsonP proxy is useful when you need to load data from a domain other than the one your application is running on. If
	 * your application is running on http://domainA.com it cannot use [Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) to load its data
	 * from http://domainB.com because cross-domain ajax requests are prohibited by the browser.
	 * 
	 * We can get around this using a JsonP proxy. JsonP proxy injects a `&lt;script&gt;` tag into the DOM whenever an AJAX request
	 * would usually be made. Let's say we want to load data from http://domainB.com/users - the script tag that would be
	 * injected might look like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?callback=someCallback"&gt;&lt;/script&gt;
	 * 
	 * When we inject the tag above, the browser makes a request to that url and includes the response as if it was any
	 * other type of JavaScript include. By passing a callback in the url above, we're telling domainB's server that we want
	 * to be notified when the result comes in and that it should call our callback function with the data it sends back. So
	 * long as the server formats the response to look like this, everything will work:
	 * 
	 *    someCallback({
	 *        users: [
	 *            {
	 *                id: 1,
	 *                name: "Ed Spencer",
	 *                email: "ed@sencha.com"
	 *            }
	 *        ]
	 *    });
	 * 
	 * As soon as the script finishes loading, the 'someCallback' function that we passed in the url is called with the JSON
	 * object that the server returned.
	 * 
	 * JsonP proxy takes care of all of this automatically. It formats the url you pass, adding the callback parameter
	 * automatically. It even creates a temporary callback function, waits for it to be called and then puts the data into
	 * the Proxy making it look just like you loaded it through a normal [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html). Here's how
	 * we might set that up:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email']
	 *    });
	 *    
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'jsonp',
	 *            url : 'http://domainB.com/users'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * That's all we need to do - JsonP proxy takes care of the rest. In this case the Proxy will have injected a script tag
	 * like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?callback=callback1"&gt;&lt;/script&gt;
	 * 
	 * # Customization
	 * 
	 * This script tag can be customized using the [callbackKey](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-callbackKey) configuration. For example:
	 * 
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'jsonp',
	 *            url : 'http://domainB.com/users',
	 *            callbackKey: 'theCallbackFunction'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * Would inject a script tag like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?theCallbackFunction=callback1"&gt;&lt;/script&gt;
	 * 
	 * # Implementing on the server side
	 * 
	 * The remote server side needs to be configured to return data in this format. Here are suggestions for how you might
	 * achieve this using Java, PHP and ASP.net:
	 * 
	 * Java:
	 * 
	 *    boolean jsonP = false;
	 *    String cb = request.getParameter("callback");
	 *    if (cb != null) {
	 *        jsonP = true;
	 *        response.setContentType("text/javascript");
	 *    } else {
	 *        response.setContentType("application/x-json");
	 *    }
	 *    Writer out = response.getWriter();
	 *    if (jsonP) {
	 *        out.write(cb + "(");
	 *    }
	 *    out.print(dataBlock.toJsonString());
	 *    if (jsonP) {
	 *        out.write(");");
	 *    }
	 * 
	 * PHP:
	 * 
	 *    $callback = $_REQUEST['callback'];
	 *    
	 *    // Create the output object.
	 *    $output = array('a' =&gt; 'Apple', 'b' =&gt; 'Banana');
	 *    
	 *    //start output
	 *    if ($callback) {
	 *        header('Content-Type: text/javascript');
	 *        echo $callback . '(' . json_encode($output) . ');';
	 *    } else {
	 *        header('Content-Type: application/x-json');
	 *        echo json_encode($output);
	 *    }
	 * 
	 * ASP.net:
	 * 
	 *    String jsonString = "{success: true}";
	 *    String cb = Request.Params.Get("callback");
	 *    String responseString = "";
	 *    if (!String.IsNullOrEmpty(cb)) {
	 *        responseString = cb + "(" + jsonString + ")";
	 *    } else {
	 *        responseString = jsonString;
	 *    }
	 *    Response.Write(responseString);
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * Specific urls to call on CRUD action methods "create", "read", "update" and "destroy". Defaults to:
		 * 
		 *    api: {
		 *        create  : undefined,
		 *        read    : undefined,
		 *        update  : undefined,
		 *        destroy : undefined
		 *    }
		 * 
		 * The url is built based upon the action being executed [create|read|update|destroy] using the commensurate
		 * [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api) property, or if undefined default to the configured
		 * [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html).[url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * 
		 * For example:
		 * 
		 *    api: {
		 *        create  : '/controller/new',
		 *        read    : '/controller/load',
		 *        update  : '/controller/update',
		 *        destroy : '/controller/destroy_action'
		 *    }
		 * 
		 * If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the
		 * configured [url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		api?: object;
		/** 
		 * True to automatically append the request's params to the generated url. Defaults to true
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoAppendParams?: boolean;
		/** 
		 * True to batch actions of a particular type when synchronizing the store. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		batchActions?: boolean;
		/** 
		 * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
		 * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
		 * @configuration
		 * @optional
		 * @default 'create,update,destroy'
		 * @type {string}
		 */
		batchOrder?: string;
		/** 
		 * The name of the cache param added to the url when using noCache. Defaults to "_dc".
		 * @configuration
		 * @optional
		 * @default "_dc"
		 * @type {string}
		 */
		cacheString?: string;
		/** 
		 * See [Ext.data.JsonP.callbackKey](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.JsonP.html#property-callbackKey).
		 * @configuration
		 * @optional
		 * @default 'callback'
		 * @type {string}
		 */
		callbackKey?: string;
		/** 
		 * The name of the direction parameter to send in a request. **This is only used when simpleSortMode is set to
		 * true.**
		 * @configuration
		 * @optional
		 * @default "dir"
		 * @type {string}
		 */
		directionParam?: string;
		/** 
		 * Extra parameters that will be included on every request. Individual requests with params of the same name
		 * will override these params when they are in conflict.
		 * @configuration
		 * @optional
		 * @default {}
		 * @type {object}
		 */
		extraParams?: object;
		/** 
		 * The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to `''` if you don't
		 * want to send a filter parameter.
		 * @configuration
		 * @optional
		 * @default "filter"
		 * @type {string}
		 */
		filterParam?: string;
		/** 
		 * The name of the direction parameter to send in a request. **This is only used when simpleGroupMode is set to
		 * true.**
		 * @configuration
		 * @optional
		 * @default "groupDir"
		 * @type {string}
		 */
		groupDirectionParam?: string;
		/** 
		 * The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to `''` if you don't
		 * want to send a group parameter.
		 * @configuration
		 * @optional
		 * @default "group"
		 * @type {string}
		 */
		groupParam?: string;
		/** 
		 * The name of the parameter which carries the id of the entity being operated upon.
		 * @configuration
		 * @optional
		 * @default "id"
		 * @type {string}
		 */
		idParam?: string;
		/** 
		 * The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to `''` if you don't
		 * want to send a limit parameter.
		 * @configuration
		 * @optional
		 * @default "limit"
		 * @type {string}
		 */
		limitParam?: string;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
		 * Model constructor. Required.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * Disable caching by adding a unique parameter name to the request. Set to false to allow caching. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		noCache?: boolean;
		/** 
		 * The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to `''` if you don't
		 * want to send a page parameter.
		 * @configuration
		 * @optional
		 * @default "page"
		 * @type {string}
		 */
		pageParam?: string;
		/** 
		 * The [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to use to decode the server's response or data read
		 * from client. This can either be a Reader instance, a config object or just a
		 * valid Reader type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.reader.Reader}
		 */
		reader?: object | string | Ext.data.reader.Reader;
		/** 
		 * The HTTP parameter name to use when passing records to the server and the [Json writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-writer) is not configured
		 * to [encode](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.writer.Json.html#cfg-encode) records into a parameter.
		 * 
		 * The [encodeRecords](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#method-encodeRecords) method is used to encode the records to create this parameter's value.
		 * @configuration
		 * @optional
		 * @default 'records'
		 * @type {string}
		 */
		recordParam?: string;
		/** 
		 * Enabling simpleGroupMode in conjunction with remoteGroup will only send one group property and a direction when a
		 * remote group is requested. The [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam) and [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam) will be sent with the property name and either 'ASC'
		 * or 'DESC'.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		simpleGroupMode?: boolean;
		/** 
		 * Enabling simpleSortMode in conjunction with remoteSort will only send one sort property and a direction when a
		 * remote sort is requested. The [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam) and [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam) will be sent with the property name
		 * and either 'ASC' or 'DESC'.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		simpleSortMode?: boolean;
		/** 
		 * The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to `''` if you don't
		 * want to send a sort parameter.
		 * @configuration
		 * @optional
		 * @default "sort"
		 * @type {string}
		 */
		sortParam?: string;
		/** 
		 * The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to `''` if you don't
		 * want to send a start parameter.
		 * @configuration
		 * @optional
		 * @default "start"
		 * @type {string}
		 */
		startParam?: string;
		/** 
		 * The number of milliseconds to wait for a response. Defaults to 30000 milliseconds (30 seconds).
		 * @configuration
		 * @optional
		 * @default 30000
		 * @type {number}
		 */
		timeout?: number;
		/** 
		 * The URL from which to request the data object.
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		url?: string;
		/** 
		 * The [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.writer.Writer.html) to use to encode any request sent to the server or
		 * saved to client. This can either be a Writer instance, a config object or just
		 * a valid Writer type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.writer.Writer}
		 */
		writer?: object | string | Ext.data.writer.Writer;
		/** 
		 * Optional callback function which can be used to clean up after a request has been completed.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.data.Request} request The Request object
		 * @param   {boolean}          success True if the request was successful
		 * @returns {void}                     
		 */
		afterRequest? (request: Ext.data.Request, success: boolean): void;
		/** 
		 * Template method to allow subclasses to specify how to get the response for the reader.
		 * @method
		 * @private (method)
		 * @template
		 * @param   {object} response The server response
		 * @returns {object}          The response data to be used by the reader
		 */
		extractResponseData? (response: object): object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.data.proxy.JsonP.Statics}        this
		 */
		initConfig? (config: object): Ext.data.proxy.JsonP.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.JsonP.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.JsonP.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.JsonP.Statics}  
		 */
		statics? (): Ext.data.proxy.JsonP.Statics;
	}
}
declare namespace Ext.data.proxy.LocalStorage {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html)
	 * The LocalStorageProxy uses the new HTML5 localStorage API to save [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) data locally on the
	 * client browser. HTML5 localStorage is a key-value store (e.g. cannot save complex objects like JSON), so
	 * LocalStorageProxy automatically serializes and deserializes data when saving and retrieving it.
	 * 
	 * localStorage is extremely useful for saving user-specific information without needing to build server-side
	 * infrastructure to support it. Let's imagine we're writing a Twitter search application and want to save the user's
	 * searches locally so they can easily perform a saved search again later. We'd start by creating a Search model:
	 * 
	 *    Ext.define('Search', {
	 *        fields: ['id', 'query'],
	 *        extend: 'Ext.data.Model',
	 *        proxy: {
	 *            type: 'localstorage',
	 *            id  : 'twitter-Searches'
	 *        }
	 *    });
	 * 
	 * Our Search model contains just two fields - id and query - plus a Proxy definition. The only configuration we need to
	 * pass to the LocalStorage proxy is an [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html#cfg-id). This is important as it separates the Model data in this Proxy from
	 * all others. The localStorage API puts all data into a single shared namespace, so by setting an id we enable
	 * LocalStorageProxy to manage the saved Search data.
	 * 
	 * Saving our data into localStorage is easy and would usually be done with a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html):
	 * 
	 *    //our Store automatically picks up the LocalStorageProxy defined on the Search model
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: "Search"
	 *    });
	 *    
	 *    //loads any existing Search data from localStorage
	 *    store.load();
	 *    
	 *    //now add some Searches
	 *    store.add({query: 'Sencha Touch'});
	 *    store.add({query: 'Ext JS'});
	 *    
	 *    //finally, save our Search data to localStorage
	 *    store.sync();
	 * 
	 * The LocalStorageProxy automatically gives our new Searches an id when we call store.sync(). It encodes the Model data
	 * and places it into localStorage. We can also save directly to localStorage, bypassing the Store altogether:
	 * 
	 *    var search = Ext.create('Search', {query: 'Sencha Animator'});
	 *    
	 *    //uses the configured LocalStorageProxy to save the new Search to localStorage
	 *    search.save();
	 * 
	 * # Limitations
	 * 
	 * If this proxy is used in a browser where local storage is not supported, the constructor will throw an error. A local
	 * storage proxy requires a unique ID which is used as a key in which all record data are stored in the local storage
	 * object.
	 * 
	 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
	 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * True to batch actions of a particular type when synchronizing the store. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		batchActions?: boolean;
		/** 
		 * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
		 * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
		 * @configuration
		 * @optional
		 * @default 'create,update,destroy'
		 * @type {string}
		 */
		batchOrder?: string;
		/** 
		 * The unique ID used as the key in which all record data are stored in the local storage object.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		id?: string;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
		 * Model constructor. Required.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                              config
		 * @returns {Ext.data.proxy.LocalStorage.Statics}        this
		 */
		initConfig? (config: object): Ext.data.proxy.LocalStorage.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                       name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                              [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.LocalStorage.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.LocalStorage.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.LocalStorage.Statics}  
		 */
		statics? (): Ext.data.proxy.LocalStorage.Statics;
	}
}
declare namespace Ext.data.proxy.Memory {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html)
	 * In-memory proxy. This proxy simply uses a local variable for data storage/retrieval, so its contents are lost on
	 * every page refresh.
	 * 
	 * Usually this Proxy isn't used directly, serving instead as a helper to a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) where a reader
	 * is required to load data. For example, say we have a Store for a User model and have some inline data we want to
	 * load, but this data isn't in quite the right format: we can use a MemoryProxy with a JsonReader to read it into our
	 * Store:
	 * 
	 *    //this is the model we will be using in the store
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            {name: 'id',    type: 'int'},
	 *            {name: 'name',  type: 'string'},
	 *            {name: 'phone', type: 'string', mapping: 'phoneNumber'}
	 *        ]
	 *    });
	 *    
	 *    //this data does not line up to our model fields - the phone field is called phoneNumber
	 *    var data = {
	 *        users: [
	 *            {
	 *                id: 1,
	 *                name: 'Ed Spencer',
	 *                phoneNumber: '555 1234'
	 *            },
	 *            {
	 *                id: 2,
	 *                name: 'Abe Elias',
	 *                phoneNumber: '666 1234'
	 *            }
	 *        ]
	 *    };
	 *    
	 *    //note how we set the 'root' in the reader to match the data structure above
	 *    var store = Ext.create('Ext.data.Store', {
	 *        autoLoad: true,
	 *        model: 'User',
	 *        data : data,
	 *        proxy: {
	 *            type: 'memory',
	 *            reader: {
	 *                type: 'json',
	 *                rootProperty: 'users'
	 *            }
	 *        }
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * True to batch actions of a particular type when synchronizing the store. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		batchActions?: boolean;
		/** 
		 * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
		 * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
		 * @configuration
		 * @optional
		 * @default 'create,update,destroy'
		 * @type {string}
		 */
		batchOrder?: string;
		/** 
		 * Optional data to pass to configured Reader.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		data?: object;
		/** 
		 * Configure as `true` to enable this MemoryProxy to honour a read operation's `start` and `limit` options.
		 * 
		 * When `true`, read operations will be able to read _pages_ of records from the data object.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		enablePaging?: boolean;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
		 * Model constructor. Required.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to use to decode the server's response or data read
		 * from client. This can either be a Reader instance, a config object or just a
		 * valid Reader type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.reader.Reader}
		 */
		reader?: object | string | Ext.data.reader.Reader;
		/** 
		 * The [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.writer.Writer.html) to use to encode any request sent to the server or
		 * saved to client. This can either be a Writer instance, a config object or just
		 * a valid Writer type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.writer.Writer}
		 */
		writer?: object | string | Ext.data.writer.Writer;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                        config
		 * @returns {Ext.data.proxy.Memory.Statics}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Memory.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                 name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                        [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Memory.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Memory.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Memory.Statics}  
		 */
		statics? (): Ext.data.proxy.Memory.Statics;
	}
}
declare namespace Ext.data.proxy.Proxy {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html)
	 * Proxies are used by [Stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) to handle the loading and saving of [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html)
	 * data. Usually developers will not need to create or interact with proxies directly.
	 * 
	 * # Types of Proxy
	 * 
	 * There are two main types of Proxy - [Client](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Client.html) and [Server](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html).
	 * The Client proxies save their data locally and include the following subclasses:
	 * 
	 * - [LocalStorageProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) - saves its data to localStorage if the browser supports it
	 * - [SessionStorageProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html) - saves its data to sessionStorage if the browsers supports it
	 * - [MemoryProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html) - holds data in memory only, any data is lost when the page is refreshed
	 * 
	 * The Server proxies save their data by sending requests to some remote server. These proxies include:
	 * 
	 * - [Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) - sends requests to a server on the same domain
	 * - [JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) - uses JSON-P to send requests to a server on a different domain
	 * - [Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html) - uses RESTful HTTP methods (GET/PUT/POST/DELETE) to communicate with server
	 * - [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html) - uses [Ext.direct.Manager](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Manager.html) to send requests
	 * 
	 * Proxies operate on the principle that all operations performed are either Create, Read, Update or Delete. These four
	 * operations are mapped to the methods [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-erase)
	 * respectively. Each Proxy subclass implements these functions.
	 * 
	 * The CRUD methods each expect an [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) object as the sole argument. The Operation
	 * encapsulates information about the action the Store wishes to perform, the [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) instances
	 * that are to be modified, etc. See the [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) documentation for more details. Each CRUD
	 * method also accepts a callback function to be called asynchronously on completion.
	 * 
	 * Proxies also support batching of Operations via a [batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object, invoked by the [batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-batch)
	 * method.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * True to batch actions of a particular type when synchronizing the store. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		batchActions?: boolean;
		/** 
		 * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
		 * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
		 * @configuration
		 * @optional
		 * @default 'create,update,destroy'
		 * @type {string}
		 */
		batchOrder?: string;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
		 * Model constructor. Required.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to use to decode the server's response or data read
		 * from client. This can either be a Reader instance, a config object or just a
		 * valid Reader type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.reader.Reader}
		 */
		reader?: object | string | Ext.data.reader.Reader;
		/** 
		 * The [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.writer.Writer.html) to use to encode any request sent to the server or
		 * saved to client. This can either be a Writer instance, a config object or just
		 * a valid Writer type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.writer.Writer}
		 */
		writer?: object | string | Ext.data.writer.Writer;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.data.proxy.Proxy.Statics}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Proxy.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Proxy.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Proxy.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Proxy.Statics}  
		 */
		statics? (): Ext.data.proxy.Proxy.Statics;
	}
}
declare namespace Ext.data.proxy.Rest {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.proxy.Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html)
	 * The Rest proxy is a specialization of the [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) which simply maps the four actions
	 * (create, read, update and destroy) to RESTful HTTP verbs. For example, let's set up a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html)
	 * with an inline Rest proxy
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email'],
	 *    
	 *        proxy: {
	 *            type: 'rest',
	 *            url : '/users'
	 *        }
	 *    });
	 * 
	 * Now we can create a new User instance and save it via the Rest proxy. Doing this will cause the Proxy to send a POST
	 * request to '/users':
	 * 
	 *    var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
	 *    
	 *    user.save(); //POST /users
	 * 
	 * Let's expand this a little and provide a callback for the [Ext.data.Model.save](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html#method-save) call to update the Model once
	 * it has been created. We'll assume the creation went successfully and that the server gave this user an ID of 123:
	 * 
	 *    user.save({
	 *        success: function(user) {
	 *            user.set('name', 'Khan Noonien Singh');
	 *    
	 *            user.save(); //PUT /users/123
	 *        }
	 *    });
	 * 
	 * Now that we're no longer creating a new Model instance, the request method is changed to an HTTP PUT, targeting the
	 * relevant url for that user. Now let's delete this user, which will use the DELETE method:
	 * 
	 *        user.erase(); //DELETE /users/123
	 * 
	 * Finally, when we perform a load of a Model or Store, Rest proxy will use the GET method:
	 * 
	 *    //1. Load via Store
	 *    
	 *    //the Store automatically picks up the Proxy from the User model
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User'
	 *    });
	 *    
	 *    store.load(); //GET /users
	 *    
	 *    //2. Load directly from the Model
	 *    
	 *    //GET /users/123
	 *    User.load(123, {
	 *        success: function(user) {
	 *            console.log(user.getId()); //outputs 123
	 *        }
	 *    });
	 * 
	 * # Url generation
	 * 
	 * The Rest proxy is able to automatically generate the urls above based on two configuration options - [appendId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-appendId) and
	 * [format](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-format). If appendId is true (it is by default) then Rest proxy will automatically append the ID of the Model
	 * instance in question to the configured url, resulting in the '/users/123' that we saw above.
	 * 
	 * If the request is not for a specific Model instance (e.g. loading a Store), the url is not appended with an id.
	 * The Rest proxy will automatically insert a '/' before the ID if one is not already present.
	 * 
	 *    new Ext.data.proxy.Rest({
	 *        url: '/users',
	 *        appendId: true //default
	 *    });
	 *    
	 *    // Collection url: /users
	 *    // Instance url  : /users/123
	 * 
	 * The Rest proxy can also optionally append a format string to the end of any generated url:
	 * 
	 *    new Ext.data.proxy.Rest({
	 *        url: '/users',
	 *        format: 'json'
	 *    });
	 *    
	 *    // Collection url: /users.json
	 *    // Instance url  : /users/123.json
	 * 
	 * If further customization is needed, simply implement the [buildUrl](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#method-buildUrl) method and add your custom generated url
	 * onto the [Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object that is passed to buildUrl. See [Rest proxy's implementation](source/Rest.html#Ext-data-proxy-Rest-method-buildUrl) for
	 * an example of how to achieve this.
	 * 
	 * Note that Rest proxy inherits from [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html), which already injects all of the sorter,
	 * filter, group and paging options into the generated url. See the [AjaxProxy docs](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for more
	 * details.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * Mapping of action name to HTTP request method. In the basic AjaxProxy these are set to 'GET' for 'read' actions
		 * and 'POST' for 'create', 'update' and 'destroy' actions. The [Ext.data.proxy.Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html) maps these to the
		 * correct RESTful methods.
		 * @configuration
		 * @optional
		 * @default {create: 'POST', read: 'GET', update: 'PUT', destroy: 'DELETE'}
		 * @type {object}
		 */
		actionMethods?: object;
		/** 
		 * Specific urls to call on CRUD action methods "create", "read", "update" and "destroy". Defaults to:
		 * 
		 *    api: {
		 *        create  : undefined,
		 *        read    : undefined,
		 *        update  : undefined,
		 *        destroy : undefined
		 *    }
		 * 
		 * The url is built based upon the action being executed [create|read|update|destroy] using the commensurate
		 * [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api) property, or if undefined default to the configured
		 * [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html).[url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * 
		 * For example:
		 * 
		 *    api: {
		 *        create  : '/controller/new',
		 *        read    : '/controller/load',
		 *        update  : '/controller/update',
		 *        destroy : '/controller/destroy_action'
		 *    }
		 * 
		 * If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the
		 * configured [url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		api?: object;
		/** 
		 * True to automatically append the ID of a Model instance when performing a request based on that single instance.
		 * See Rest proxy intro docs for more details. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		appendId?: boolean;
		/** 
		 * True to batch actions of a particular type when synchronizing the store. Defaults to false.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		batchActions?: boolean;
		/** 
		 * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
		 * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
		 * @configuration
		 * @optional
		 * @default 'create,update,destroy'
		 * @type {string}
		 */
		batchOrder?: string;
		/** 
		 * True to request binary data from the server.  This feature requires
		 * the use of a binary reader such as AMF Reader
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		binary?: boolean;
		/** 
		 * The name of the cache param added to the url when using noCache. Defaults to "_dc".
		 * @configuration
		 * @optional
		 * @default "_dc"
		 * @type {string}
		 */
		cacheString?: string;
		/** 
		 * The name of the direction parameter to send in a request. **This is only used when simpleSortMode is set to
		 * true.**
		 * @configuration
		 * @optional
		 * @default "dir"
		 * @type {string}
		 */
		directionParam?: string;
		/** 
		 * Extra parameters that will be included on every request. Individual requests with params of the same name
		 * will override these params when they are in conflict.
		 * @configuration
		 * @optional
		 * @default {}
		 * @type {object}
		 */
		extraParams?: object;
		/** 
		 * The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to `''` if you don't
		 * want to send a filter parameter.
		 * @configuration
		 * @optional
		 * @default "filter"
		 * @type {string}
		 */
		filterParam?: string;
		/** 
		 * Optional data format to send to the server when making any request (e.g. 'json'). See the Rest proxy intro docs
		 * for full details. Defaults to undefined.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		format?: string;
		/** 
		 * The name of the direction parameter to send in a request. **This is only used when simpleGroupMode is set to
		 * true.**
		 * @configuration
		 * @optional
		 * @default "groupDir"
		 * @type {string}
		 */
		groupDirectionParam?: string;
		/** 
		 * The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to `''` if you don't
		 * want to send a group parameter.
		 * @configuration
		 * @optional
		 * @default "group"
		 * @type {string}
		 */
		groupParam?: string;
		/** 
		 * Any headers to add to the Ajax request.
		 * 
		 * example:
		 * 
		 *    proxy: {
		 *        headers: {'Content-Type': "text/plain" }
		 *        ...
		 *    }
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		headers?: object;
		/** 
		 * The name of the parameter which carries the id of the entity being operated upon.
		 * @configuration
		 * @optional
		 * @default "id"
		 * @type {string}
		 */
		idParam?: string;
		/** 
		 * The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to `''` if you don't
		 * want to send a limit parameter.
		 * @configuration
		 * @optional
		 * @default "limit"
		 * @type {string}
		 */
		limitParam?: string;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
		 * Model constructor. Required.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * Disable caching by adding a unique parameter name to the request. Set to false to allow caching. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		noCache?: boolean;
		/** 
		 * The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to `''` if you don't
		 * want to send a page parameter.
		 * @configuration
		 * @optional
		 * @default "page"
		 * @type {string}
		 */
		pageParam?: string;
		/** 
		 * `true` to have any request parameters sent as [jsonData](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Connection.html#method-request)
		 * where they can be parsed from the raw request. By default, parameters are sent via the
		 * [params](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Connection.html#method-request) property. **Note**: This setting does not apply when the
		 * request is sent as a 'GET' request. See [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-actionMethods) for controlling the HTTP verb
		 * that is used when sending requests.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		paramsAsJson?: boolean;
		/** 
		 * Most oData feeds require basic HTTP authentication. This configuration allows
		 * you to specify the password.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		password?: string;
		/** 
		 * The [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to use to decode the server's response or data read
		 * from client. This can either be a Reader instance, a config object or just a
		 * valid Reader type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.reader.Reader}
		 */
		reader?: object | string | Ext.data.reader.Reader;
		/** 
		 * Enabling simpleGroupMode in conjunction with remoteGroup will only send one group property and a direction when a
		 * remote group is requested. The [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam) and [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam) will be sent with the property name and either 'ASC'
		 * or 'DESC'.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		simpleGroupMode?: boolean;
		/** 
		 * Enabling simpleSortMode in conjunction with remoteSort will only send one sort property and a direction when a
		 * remote sort is requested. The [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam) and [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam) will be sent with the property name
		 * and either 'ASC' or 'DESC'.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		simpleSortMode?: boolean;
		/** 
		 * The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to `''` if you don't
		 * want to send a sort parameter.
		 * @configuration
		 * @optional
		 * @default "sort"
		 * @type {string}
		 */
		sortParam?: string;
		/** 
		 * The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to `''` if you don't
		 * want to send a start parameter.
		 * @configuration
		 * @optional
		 * @default "start"
		 * @type {string}
		 */
		startParam?: string;
		/** 
		 * The number of milliseconds to wait for a response. Defaults to 30000 milliseconds (30 seconds).
		 * @configuration
		 * @optional
		 * @default 30000
		 * @type {number}
		 */
		timeout?: number;
		/** 
		 * The URL from which to request the data object.
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		url?: string;
		/** 
		 * Set this to false to not send the default Xhr header (X-Requested-With) with every request.
		 * This should be set to false when making CORS (cross-domain) requests.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		useDefaultXhrHeader?: boolean;
		/** 
		 * Most oData feeds require basic HTTP authentication. This configuration allows
		 * you to specify the username.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		username?: string;
		/** 
		 * This configuration is sometimes necessary when using cross-origin resource sharing.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		withCredentials?: boolean;
		/** 
		 * The [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.writer.Writer.html) to use to encode any request sent to the server or
		 * saved to client. This can either be a Writer instance, a config object or just
		 * a valid Writer type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.writer.Writer}
		 */
		writer?: object | string | Ext.data.writer.Writer;
		/** 
		 * Optional callback function which can be used to clean up after a request has been completed.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.data.Request} request The Request object
		 * @param   {boolean}          success True if the request was successful
		 * @returns {void}                     
		 */
		afterRequest? (request: Ext.data.Request, success: boolean): void;
		/** 
		 * Template method to allow subclasses to specify how to get the response for the reader.
		 * @method
		 * @private (method)
		 * @template
		 * @param   {object} response The server response
		 * @returns {object}          The response data to be used by the reader
		 */
		extractResponseData? (response: object): object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.data.proxy.Rest.Statics}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Rest.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Rest.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Rest.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Rest.Statics}  
		 */
		statics? (): Ext.data.proxy.Rest.Statics;
	}
}
declare namespace Ext.data.proxy.Server {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html)
	 * ServerProxy is a superclass of [JsonPProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html), and
	 * would not usually be used directly.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * Specific urls to call on CRUD action methods "create", "read", "update" and "destroy". Defaults to:
		 * 
		 *    api: {
		 *        create  : undefined,
		 *        read    : undefined,
		 *        update  : undefined,
		 *        destroy : undefined
		 *    }
		 * 
		 * The url is built based upon the action being executed [create|read|update|destroy] using the commensurate
		 * [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-api) property, or if undefined default to the configured
		 * [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html).[url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * 
		 * For example:
		 * 
		 *    api: {
		 *        create  : '/controller/new',
		 *        read    : '/controller/load',
		 *        update  : '/controller/update',
		 *        destroy : '/controller/destroy_action'
		 *    }
		 * 
		 * If the specific URL for a given CRUD action is undefined, the CRUD action request will be directed to the
		 * configured [url](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-url).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		api?: object;
		/** 
		 * True to batch actions of a particular type when synchronizing the store. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		batchActions?: boolean;
		/** 
		 * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
		 * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
		 * @configuration
		 * @optional
		 * @default 'create,update,destroy'
		 * @type {string}
		 */
		batchOrder?: string;
		/** 
		 * The name of the cache param added to the url when using noCache. Defaults to "_dc".
		 * @configuration
		 * @optional
		 * @default "_dc"
		 * @type {string}
		 */
		cacheString?: string;
		/** 
		 * The name of the direction parameter to send in a request. **This is only used when simpleSortMode is set to
		 * true.**
		 * @configuration
		 * @optional
		 * @default "dir"
		 * @type {string}
		 */
		directionParam?: string;
		/** 
		 * Extra parameters that will be included on every request. Individual requests with params of the same name
		 * will override these params when they are in conflict.
		 * @configuration
		 * @optional
		 * @default {}
		 * @type {object}
		 */
		extraParams?: object;
		/** 
		 * The name of the 'filter' parameter to send in a request. Defaults to 'filter'. Set this to `''` if you don't
		 * want to send a filter parameter.
		 * @configuration
		 * @optional
		 * @default "filter"
		 * @type {string}
		 */
		filterParam?: string;
		/** 
		 * The name of the direction parameter to send in a request. **This is only used when simpleGroupMode is set to
		 * true.**
		 * @configuration
		 * @optional
		 * @default "groupDir"
		 * @type {string}
		 */
		groupDirectionParam?: string;
		/** 
		 * The name of the 'group' parameter to send in a request. Defaults to 'group'. Set this to `''` if you don't
		 * want to send a group parameter.
		 * @configuration
		 * @optional
		 * @default "group"
		 * @type {string}
		 */
		groupParam?: string;
		/** 
		 * The name of the parameter which carries the id of the entity being operated upon.
		 * @configuration
		 * @optional
		 * @default "id"
		 * @type {string}
		 */
		idParam?: string;
		/** 
		 * The name of the 'limit' parameter to send in a request. Defaults to 'limit'. Set this to `''` if you don't
		 * want to send a limit parameter.
		 * @configuration
		 * @optional
		 * @default "limit"
		 * @type {string}
		 */
		limitParam?: string;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
		 * Model constructor. Required.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * Disable caching by adding a unique parameter name to the request. Set to false to allow caching. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		noCache?: boolean;
		/** 
		 * The name of the 'page' parameter to send in a request. Defaults to 'page'. Set this to `''` if you don't
		 * want to send a page parameter.
		 * @configuration
		 * @optional
		 * @default "page"
		 * @type {string}
		 */
		pageParam?: string;
		/** 
		 * The [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to use to decode the server's response or data read
		 * from client. This can either be a Reader instance, a config object or just a
		 * valid Reader type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.reader.Reader}
		 */
		reader?: object | string | Ext.data.reader.Reader;
		/** 
		 * Enabling simpleGroupMode in conjunction with remoteGroup will only send one group property and a direction when a
		 * remote group is requested. The [groupDirectionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupDirectionParam) and [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-groupParam) will be sent with the property name and either 'ASC'
		 * or 'DESC'.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		simpleGroupMode?: boolean;
		/** 
		 * Enabling simpleSortMode in conjunction with remoteSort will only send one sort property and a direction when a
		 * remote sort is requested. The [directionParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-directionParam) and [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html#cfg-sortParam) will be sent with the property name
		 * and either 'ASC' or 'DESC'.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		simpleSortMode?: boolean;
		/** 
		 * The name of the 'sort' parameter to send in a request. Defaults to 'sort'. Set this to `''` if you don't
		 * want to send a sort parameter.
		 * @configuration
		 * @optional
		 * @default "sort"
		 * @type {string}
		 */
		sortParam?: string;
		/** 
		 * The name of the 'start' parameter to send in a request. Defaults to 'start'. Set this to `''` if you don't
		 * want to send a start parameter.
		 * @configuration
		 * @optional
		 * @default "start"
		 * @type {string}
		 */
		startParam?: string;
		/** 
		 * The number of milliseconds to wait for a response. Defaults to 30000 milliseconds (30 seconds).
		 * @configuration
		 * @optional
		 * @default 30000
		 * @type {number}
		 */
		timeout?: number;
		/** 
		 * The URL from which to request the data object.
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		url?: string;
		/** 
		 * The [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.writer.Writer.html) to use to encode any request sent to the server or
		 * saved to client. This can either be a Writer instance, a config object or just
		 * a valid Writer type name (e.g. 'json', 'xml').
		 * @configuration
		 * @optional
		 * @default {type: 'json'}
		 * @type {object|string|Ext.data.writer.Writer}
		 */
		writer?: object | string | Ext.data.writer.Writer;
		/** 
		 * Optional callback function which can be used to clean up after a request has been completed.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.data.Request} request The Request object
		 * @param   {boolean}          success True if the request was successful
		 * @returns {void}                     
		 */
		afterRequest? (request: Ext.data.Request, success: boolean): void;
		/** 
		 * Template method to allow subclasses to specify how to get the response for the reader.
		 * @method
		 * @private (method)
		 * @template
		 * @param   {object} response The server response
		 * @returns {object}          The response data to be used by the reader
		 */
		extractResponseData? (response: object): object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                        config
		 * @returns {Ext.data.proxy.Server.Statics}        this
		 */
		initConfig? (config: object): Ext.data.proxy.Server.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                 name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                        [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.Server.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.Server.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.Server.Statics}  
		 */
		statics? (): Ext.data.proxy.Server.Statics;
	}
}
declare namespace Ext.data.proxy.SessionStorage {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.proxy.SessionStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html)
	 * Proxy which uses HTML5 session storage as its data storage/retrieval mechanism. If this proxy is used in a browser
	 * where session storage is not supported, the constructor will throw an error. A session storage proxy requires a
	 * unique ID which is used as a key in which all record data are stored in the session storage object.
	 * 
	 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
	 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
	 * 
	 * Proxies are almost always used with a [store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html):
	 * 
	 *    new Ext.data.Store({
	 *        proxy: {
	 *            type: 'sessionstorage',
	 *            id  : 'myProxyKey'
	 *        }
	 *    });
	 * 
	 * Alternatively you can instantiate the Proxy directly:
	 * 
	 *    new Ext.data.proxy.SessionStorage({
	 *        id  : 'myOtherProxyKey'
	 *    });
	 * 
	 * Note that session storage is different to local storage (see [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html)) - if a browser
	 * session is ended (e.g. by closing the browser) then all data in a SessionStorageProxy are lost. Browser restarts
	 * don't affect the [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) - the data are preserved.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * True to batch actions of a particular type when synchronizing the store. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		batchActions?: boolean;
		/** 
		 * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
		 * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
		 * @configuration
		 * @optional
		 * @default 'create,update,destroy'
		 * @type {string}
		 */
		batchOrder?: string;
		/** 
		 * The unique ID used as the key in which all record data are stored in the local storage object.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		id?: string;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
		 * Model constructor. Required.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                config
		 * @returns {Ext.data.proxy.SessionStorage.Statics}        this
		 */
		initConfig? (config: object): Ext.data.proxy.SessionStorage.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                         name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.SessionStorage.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.SessionStorage.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.SessionStorage.Statics}  
		 */
		statics? (): Ext.data.proxy.SessionStorage.Statics;
	}
}
declare namespace Ext.data.proxy.WebStorage {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.proxy.WebStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.WebStorage.html)
	 * WebStorageProxy is simply a superclass for the [LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) and [SessionStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html) proxies. It uses the new HTML5 key/value client-side storage objects to
	 * save [model instances](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) for offline use.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * True to batch actions of a particular type when synchronizing the store. Defaults to true.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		batchActions?: boolean;
		/** 
		 * Comma-separated ordering 'create', 'update' and 'destroy' actions when batching. Override this to set a different
		 * order for the batched CRUD actions to be executed in. Defaults to 'create,update,destroy'.
		 * @configuration
		 * @optional
		 * @default 'create,update,destroy'
		 * @type {string}
		 */
		batchOrder?: string;
		/** 
		 * The unique ID used as the key in which all record data are stored in the local storage object.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		id?: string;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the [DataView](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html)'s **[`itemclick`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html#event-itemclick)** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The name of the Model to tie to this Proxy. Can be either the string name of the Model, or a reference to the
		 * Model constructor. Required.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                            config
		 * @returns {Ext.data.proxy.WebStorage.Statics}        this
		 */
		initConfig? (config: object): Ext.data.proxy.WebStorage.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                     name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                            [value] The value to set for the name parameter.
		 * @returns {Ext.data.proxy.WebStorage.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.proxy.WebStorage.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.proxy.WebStorage.Statics}  
		 */
		statics? (): Ext.data.proxy.WebStorage.Statics;
	}
}
declare namespace Ext.data.proxy.Ajax {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html)
	 * AjaxProxy is one of the most widely-used ways of getting data into your application. It uses AJAX requests to load
	 * data from the server, usually to be placed into a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html). Let's take a look at a typical setup.
	 * Here we're going to set up a Store that has an AjaxProxy. To prepare, we'll also set up a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html):
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email']
	 *    });
	 *    
	 *    //The Store contains the AjaxProxy as an inline configuration
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'ajax',
	 *            url : 'users.json'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * Our example is going to load user data into a Store, so we start off by defining a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) with
	 * the fields that we expect the server to return. Next we set up the Store itself, along with a
	 * [proxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html#cfg-proxy) configuration. This configuration was automatically turned into an
	 * [Ext.data.proxy.Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) instance, with the url we specified being passed into AjaxProxy's constructor.
	 * It's as if we'd done this:
	 * 
	 *    new Ext.data.proxy.Ajax({
	 *        url: 'users.json',
	 *        model: 'User',
	 *        reader: 'json'
	 *    });
	 * 
	 * A couple of extra configurations appeared here - [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-model) and [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader). These are set by default when we
	 * create the proxy via the Store - the Store already knows about the Model, and Proxy's default [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) is [JsonReader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Json.html).
	 * 
	 * Now when we call store.load(), the AjaxProxy springs into action, making a request to the url we configured
	 * ('users.json' in this case). As we're performing a read, it sends a GET request to that url (see
	 * [actionMethods](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-actionMethods) to customize this - by default any kind of read will be sent as a GET request and any kind of write
	 * will be sent as a POST request).
	 * 
	 * # Limitations
	 * 
	 * AjaxProxy cannot be used to retrieve data from other domains. If your application is running on http://domainA.com it
	 * cannot load data from http://domainB.com because browsers have a built-in security policy that prohibits domains
	 * talking to each other via AJAX.
	 * 
	 * If you need to read data from another domain and can't set up a proxy server (some software that runs on your own
	 * domain's web server and transparently forwards requests to http://domainB.com, making it look like they actually came
	 * from http://domainA.com), you can use [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and a technique known as JSON-P (JSON with
	 * Padding), which can help you get around the problem so long as the server on http://domainB.com is set up to support
	 * JSON-P responses. See [JsonPProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html)'s introduction docs for more details.
	 * 
	 * # Readers and Writers
	 * 
	 * AjaxProxy can be configured to use any type of [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) to decode the server's response.
	 * If no Reader is supplied, AjaxProxy will default to using a [JsonReader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Json.html). Reader
	 * configuration can be passed in as a simple object, which the Proxy automatically turns into a [Reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.reader.Reader.html) instance:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        model: 'User',
	 *        reader: {
	 *            type: 'xml',
	 *            rootProperty: 'users'
	 *        }
	 *    });
	 *    
	 *    proxy.getReader(); //returns an XmlReader instance based on the config we supplied
	 * 
	 * # Url generation
	 * 
	 * AjaxProxy automatically inserts any sorting, filtering, paging and grouping options into the url it generates for
	 * each request. These are controlled with the following configuration options:
	 * 
	 * - [pageParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-pageParam) - controls how the page number is sent to the server (see also [startParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-startParam) and [limitParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-limitParam))
	 * - [sortParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-sortParam) - controls how sort information is sent to the server
	 * - [groupParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-groupParam) - controls how grouping information is sent to the server
	 * - [filterParam](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-filterParam) - controls how filter information is sent to the server
	 * 
	 * Each request sent by AjaxProxy is described by an [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html). To see how we can customize
	 * the generated urls, let's say we're loading the Proxy with the following Operation:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    var operation = proxy.createOperation('read', {
	 *        page  : 2
	 *    });
	 * 
	 * Now we'll issue the request for this Operation by calling [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-read):
	 * 
	 *    proxy.read(operation); //GET /users?page=2
	 * 
	 * Easy enough - the Proxy just copied the page property from the Operation. We can customize how this page data is sent
	 * to the server:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users',
	 *        pageParam: 'pageNumber'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?pageNumber=2
	 * 
	 * Alternatively, our Operation could have been configured to send start and limit parameters instead of page:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    var operation = proxy.createOperation('read', {
	 *        start : 50,
	 *        limit : 25
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?start=50&amp;limit;=25
	 * 
	 * Again we can customize this url:
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users',
	 *        startParam: 'startIndex',
	 *        limitParam: 'limitIndex'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?startIndex=50&amp;limitIndex;=25
	 * 
	 * AjaxProxy will also send sort and filter information to the server. Let's take a look at how this looks with a more
	 * expressive Operation object:
	 * 
	 *    var operation = proxy.createOperation('read', {
	 *        sorters: [
	 *            new Ext.util.Sorter({
	 *                property : 'name',
	 *                direction: 'ASC'
	 *            }),
	 *            new Ext.util.Sorter({
	 *                property : 'age',
	 *                direction: 'DESC'
	 *            })
	 *        ],
	 *        filters: [
	 *            new Ext.util.Filter({
	 *                property: 'eyeColor',
	 *                value   : 'brown'
	 *            })
	 *        ]
	 *    });
	 * 
	 * This is the type of object that is generated internally when loading a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) with sorters and
	 * filters defined. By default the AjaxProxy will JSON encode the sorters and filters, resulting in something like this
	 * (note that the url is escaped before sending the request, but is left unescaped here for clarity):
	 * 
	 *    var proxy = new Ext.data.proxy.Ajax({
	 *        url: '/users'
	 *    });
	 *    
	 *    proxy.read(operation); //GET /users?sort=[{"property":"name","direction":"ASC"},{"property":"age","direction":"DESC"}]&amp;filter;=[{"property":"eyeColor","value":"brown"}]
	 * 
	 * We can again customize how this is created by supplying a few configuration options. Let's say our server is set up
	 * to receive sorting information is a format like "sortBy=name#ASC,age#DESC". We can configure AjaxProxy to provide
	 * that format like this:
	 * 
	 *     var proxy = new Ext.data.proxy.Ajax({
	 *         url: '/users',
	 *         sortParam: 'sortBy',
	 *         filterParam: 'filterBy',
	 *    
	 *         //our custom implementation of sorter encoding - turns our sorters into "name#ASC,age#DESC"
	 *         encodeSorters: function(sorters) {
	 *             var length   = sorters.length,
	 *                 sortStrs = [],
	 *                 sorter, i;
	 *    
	 *             for (i = 0; i &lt; length; i++) {
	 *                 sorter = sorters[i];
	 *    
	 *                 sortStrs[i] = sorter.property + '#' + sorter.direction
	 *             }
	 *    
	 *             return sortStrs.join(",");
	 *         }
	 *     });
	 *    
	 *     proxy.read(operation); //GET /users?sortBy=name#ASC,age#DESC&amp;filterBy;=[{"property":"eyeColor","value":"brown"}]
	 * 
	 * We can also provide a custom [encodeFilters](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#method-encodeFilters) function to encode our filters.
	 * 
	 * # Debugging your Ajax Proxy
	 * 
	 * If the data is not being loaded into the store as expected, it could be due to a mismatch between the the way that the [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader)
	 * is configured, and the shape of the incoming data.
	 * 
	 * To debug from the point that your data arrives back from the network, set a breakpoint inside the callback function
	 * created in the `createRequestCallback` method of the Ajax Proxy class, and follow the data to where the [reader](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html#cfg-reader) attempts
	 * to consume it.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when the server returns an exception. This event may also be listened
		 * to in the event that a request has timed out or has been aborted.
		 * @event
		 * @param   {Ext.data.proxy.Proxy}         _this
		 * @param   {Ext.data.Request}             request   The request that was sent
		 * @param   {Ext.data.operation.Operation} operation The operation that triggered the request
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		exception? (_this: Ext.data.proxy.Proxy, request: Ext.data.Request, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when this proxy's reader provides new metadata. Metadata usually consists
		 * of new field definitions, but can include any configuration data required by an
		 * application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders. Note that this event is also
		 * propagated by [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), which is typically where it would be handled.
		 * @event
		 * @param   {Ext.data.proxy.Proxy} _this
		 * @param   {object}               meta  The JSON metadata
		 * @param   {object}               eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                 
		 */
		metachange? (_this: Ext.data.proxy.Proxy, meta: object, eOpts: object): void;
	}
}
declare namespace Ext.data.proxy.Direct {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.proxy.Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html)
	 * This class is used to send requests to the server using Ext Direct. When a
	 * request is made, the transport mechanism is handed off to the appropriate
	 * [Provider](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.RemotingProvider.html) to complete the call.
	 * 
	 * # Specifying the function
	 * 
	 * This proxy expects a Direct remoting method to be passed in order to be able to complete requests.
	 * This can be done by specifying the [directFn](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-directFn) configuration. This will use the same direct
	 * method for all requests. Alternatively, you can provide an [api](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-api) configuration. This
	 * allows you to specify a different remoting method for each CRUD action.
	 * 
	 * # Parameters
	 * 
	 * This proxy provides options to help configure which parameters will be sent to the server.
	 * By specifying the [paramsAsHash](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramsAsHash) option, it will send an object literal containing each
	 * of the passed parameters. The [paramOrder](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html#cfg-paramOrder) option can be used to specify the order in which
	 * the remoting method parameters are passed.
	 * 
	 * # Example Usage
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['firstName', 'lastName'],
	 *        proxy: {
	 *            type: 'direct',
	 *            directFn: MyApp.getUsers,
	 *            paramOrder: 'id' // Tells the proxy to pass the id as the first parameter to the remoting method.
	 *        }
	 *    });
	 *    User.load(1);
	 * 
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when the server returns an exception. This event may also be listened
		 * to in the event that a request has timed out or has been aborted.
		 * @event
		 * @param   {Ext.data.proxy.Proxy}         _this
		 * @param   {Ext.data.Request}             request   The request that was sent
		 * @param   {Ext.data.operation.Operation} operation The operation that triggered the request
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		exception? (_this: Ext.data.proxy.Proxy, request: Ext.data.Request, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when this proxy's reader provides new metadata. Metadata usually consists
		 * of new field definitions, but can include any configuration data required by an
		 * application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders. Note that this event is also
		 * propagated by [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), which is typically where it would be handled.
		 * @event
		 * @param   {Ext.data.proxy.Proxy} _this
		 * @param   {object}               meta  The JSON metadata
		 * @param   {object}               eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                 
		 */
		metachange? (_this: Ext.data.proxy.Proxy, meta: object, eOpts: object): void;
	}
}
declare namespace Ext.data.proxy.JsonP {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.proxy.JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html)
	 * The JsonP proxy is useful when you need to load data from a domain other than the one your application is running on. If
	 * your application is running on http://domainA.com it cannot use [Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) to load its data
	 * from http://domainB.com because cross-domain ajax requests are prohibited by the browser.
	 * 
	 * We can get around this using a JsonP proxy. JsonP proxy injects a `&lt;script&gt;` tag into the DOM whenever an AJAX request
	 * would usually be made. Let's say we want to load data from http://domainB.com/users - the script tag that would be
	 * injected might look like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?callback=someCallback"&gt;&lt;/script&gt;
	 * 
	 * When we inject the tag above, the browser makes a request to that url and includes the response as if it was any
	 * other type of JavaScript include. By passing a callback in the url above, we're telling domainB's server that we want
	 * to be notified when the result comes in and that it should call our callback function with the data it sends back. So
	 * long as the server formats the response to look like this, everything will work:
	 * 
	 *    someCallback({
	 *        users: [
	 *            {
	 *                id: 1,
	 *                name: "Ed Spencer",
	 *                email: "ed@sencha.com"
	 *            }
	 *        ]
	 *    });
	 * 
	 * As soon as the script finishes loading, the 'someCallback' function that we passed in the url is called with the JSON
	 * object that the server returned.
	 * 
	 * JsonP proxy takes care of all of this automatically. It formats the url you pass, adding the callback parameter
	 * automatically. It even creates a temporary callback function, waits for it to be called and then puts the data into
	 * the Proxy making it look just like you loaded it through a normal [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html). Here's how
	 * we might set that up:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email']
	 *    });
	 *    
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'jsonp',
	 *            url : 'http://domainB.com/users'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * That's all we need to do - JsonP proxy takes care of the rest. In this case the Proxy will have injected a script tag
	 * like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?callback=callback1"&gt;&lt;/script&gt;
	 * 
	 * # Customization
	 * 
	 * This script tag can be customized using the [callbackKey](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html#cfg-callbackKey) configuration. For example:
	 * 
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        proxy: {
	 *            type: 'jsonp',
	 *            url : 'http://domainB.com/users',
	 *            callbackKey: 'theCallbackFunction'
	 *        }
	 *    });
	 *    
	 *    store.load();
	 * 
	 * Would inject a script tag like this:
	 * 
	 *    &lt;script src="http://domainB.com/users?theCallbackFunction=callback1"&gt;&lt;/script&gt;
	 * 
	 * # Implementing on the server side
	 * 
	 * The remote server side needs to be configured to return data in this format. Here are suggestions for how you might
	 * achieve this using Java, PHP and ASP.net:
	 * 
	 * Java:
	 * 
	 *    boolean jsonP = false;
	 *    String cb = request.getParameter("callback");
	 *    if (cb != null) {
	 *        jsonP = true;
	 *        response.setContentType("text/javascript");
	 *    } else {
	 *        response.setContentType("application/x-json");
	 *    }
	 *    Writer out = response.getWriter();
	 *    if (jsonP) {
	 *        out.write(cb + "(");
	 *    }
	 *    out.print(dataBlock.toJsonString());
	 *    if (jsonP) {
	 *        out.write(");");
	 *    }
	 * 
	 * PHP:
	 * 
	 *    $callback = $_REQUEST['callback'];
	 *    
	 *    // Create the output object.
	 *    $output = array('a' =&gt; 'Apple', 'b' =&gt; 'Banana');
	 *    
	 *    //start output
	 *    if ($callback) {
	 *        header('Content-Type: text/javascript');
	 *        echo $callback . '(' . json_encode($output) . ');';
	 *    } else {
	 *        header('Content-Type: application/x-json');
	 *        echo json_encode($output);
	 *    }
	 * 
	 * ASP.net:
	 * 
	 *    String jsonString = "{success: true}";
	 *    String cb = Request.Params.Get("callback");
	 *    String responseString = "";
	 *    if (!String.IsNullOrEmpty(cb)) {
	 *        responseString = cb + "(" + jsonString + ")";
	 *    } else {
	 *        responseString = jsonString;
	 *    }
	 *    Response.Write(responseString);
	 * 
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when the server returns an exception. This event may also be listened
		 * to in the event that a request has timed out or has been aborted.
		 * @event
		 * @param   {Ext.data.proxy.Proxy}         _this
		 * @param   {Ext.data.Request}             request   The request that was sent
		 * @param   {Ext.data.operation.Operation} operation The operation that triggered the request
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		exception? (_this: Ext.data.proxy.Proxy, request: Ext.data.Request, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when this proxy's reader provides new metadata. Metadata usually consists
		 * of new field definitions, but can include any configuration data required by an
		 * application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders. Note that this event is also
		 * propagated by [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), which is typically where it would be handled.
		 * @event
		 * @param   {Ext.data.proxy.Proxy} _this
		 * @param   {object}               meta  The JSON metadata
		 * @param   {object}               eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                 
		 */
		metachange? (_this: Ext.data.proxy.Proxy, meta: object, eOpts: object): void;
	}
}
declare namespace Ext.data.proxy.LocalStorage {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html)
	 * The LocalStorageProxy uses the new HTML5 localStorage API to save [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) data locally on the
	 * client browser. HTML5 localStorage is a key-value store (e.g. cannot save complex objects like JSON), so
	 * LocalStorageProxy automatically serializes and deserializes data when saving and retrieving it.
	 * 
	 * localStorage is extremely useful for saving user-specific information without needing to build server-side
	 * infrastructure to support it. Let's imagine we're writing a Twitter search application and want to save the user's
	 * searches locally so they can easily perform a saved search again later. We'd start by creating a Search model:
	 * 
	 *    Ext.define('Search', {
	 *        fields: ['id', 'query'],
	 *        extend: 'Ext.data.Model',
	 *        proxy: {
	 *            type: 'localstorage',
	 *            id  : 'twitter-Searches'
	 *        }
	 *    });
	 * 
	 * Our Search model contains just two fields - id and query - plus a Proxy definition. The only configuration we need to
	 * pass to the LocalStorage proxy is an [id](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html#cfg-id). This is important as it separates the Model data in this Proxy from
	 * all others. The localStorage API puts all data into a single shared namespace, so by setting an id we enable
	 * LocalStorageProxy to manage the saved Search data.
	 * 
	 * Saving our data into localStorage is easy and would usually be done with a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html):
	 * 
	 *    //our Store automatically picks up the LocalStorageProxy defined on the Search model
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: "Search"
	 *    });
	 *    
	 *    //loads any existing Search data from localStorage
	 *    store.load();
	 *    
	 *    //now add some Searches
	 *    store.add({query: 'Sencha Touch'});
	 *    store.add({query: 'Ext JS'});
	 *    
	 *    //finally, save our Search data to localStorage
	 *    store.sync();
	 * 
	 * The LocalStorageProxy automatically gives our new Searches an id when we call store.sync(). It encodes the Model data
	 * and places it into localStorage. We can also save directly to localStorage, bypassing the Store altogether:
	 * 
	 *    var search = Ext.create('Search', {query: 'Sencha Animator'});
	 *    
	 *    //uses the configured LocalStorageProxy to save the new Search to localStorage
	 *    search.save();
	 * 
	 * # Limitations
	 * 
	 * If this proxy is used in a browser where local storage is not supported, the constructor will throw an error. A local
	 * storage proxy requires a unique ID which is used as a key in which all record data are stored in the local storage
	 * object.
	 * 
	 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
	 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when this proxy's reader provides new metadata. Metadata usually consists
		 * of new field definitions, but can include any configuration data required by an
		 * application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders. Note that this event is also
		 * propagated by [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), which is typically where it would be handled.
		 * @event
		 * @param   {Ext.data.proxy.Proxy} _this
		 * @param   {object}               meta  The JSON metadata
		 * @param   {object}               eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                 
		 */
		metachange? (_this: Ext.data.proxy.Proxy, meta: object, eOpts: object): void;
	}
}
declare namespace Ext.data.proxy.Memory {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html)
	 * In-memory proxy. This proxy simply uses a local variable for data storage/retrieval, so its contents are lost on
	 * every page refresh.
	 * 
	 * Usually this Proxy isn't used directly, serving instead as a helper to a [Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) where a reader
	 * is required to load data. For example, say we have a Store for a User model and have some inline data we want to
	 * load, but this data isn't in quite the right format: we can use a MemoryProxy with a JsonReader to read it into our
	 * Store:
	 * 
	 *    //this is the model we will be using in the store
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            {name: 'id',    type: 'int'},
	 *            {name: 'name',  type: 'string'},
	 *            {name: 'phone', type: 'string', mapping: 'phoneNumber'}
	 *        ]
	 *    });
	 *    
	 *    //this data does not line up to our model fields - the phone field is called phoneNumber
	 *    var data = {
	 *        users: [
	 *            {
	 *                id: 1,
	 *                name: 'Ed Spencer',
	 *                phoneNumber: '555 1234'
	 *            },
	 *            {
	 *                id: 2,
	 *                name: 'Abe Elias',
	 *                phoneNumber: '666 1234'
	 *            }
	 *        ]
	 *    };
	 *    
	 *    //note how we set the 'root' in the reader to match the data structure above
	 *    var store = Ext.create('Ext.data.Store', {
	 *        autoLoad: true,
	 *        model: 'User',
	 *        data : data,
	 *        proxy: {
	 *            type: 'memory',
	 *            reader: {
	 *                type: 'json',
	 *                rootProperty: 'users'
	 *            }
	 *        }
	 *    });
	 * 
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when this proxy's reader provides new metadata. Metadata usually consists
		 * of new field definitions, but can include any configuration data required by an
		 * application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders. Note that this event is also
		 * propagated by [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), which is typically where it would be handled.
		 * @event
		 * @param   {Ext.data.proxy.Proxy} _this
		 * @param   {object}               meta  The JSON metadata
		 * @param   {object}               eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                 
		 */
		metachange? (_this: Ext.data.proxy.Proxy, meta: object, eOpts: object): void;
	}
}
declare namespace Ext.data.proxy.Proxy {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html)
	 * Proxies are used by [Stores](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html) to handle the loading and saving of [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html)
	 * data. Usually developers will not need to create or interact with proxies directly.
	 * 
	 * # Types of Proxy
	 * 
	 * There are two main types of Proxy - [Client](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Client.html) and [Server](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html).
	 * The Client proxies save their data locally and include the following subclasses:
	 * 
	 * - [LocalStorageProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) - saves its data to localStorage if the browser supports it
	 * - [SessionStorageProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html) - saves its data to sessionStorage if the browsers supports it
	 * - [MemoryProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Memory.html) - holds data in memory only, any data is lost when the page is refreshed
	 * 
	 * The Server proxies save their data by sending requests to some remote server. These proxies include:
	 * 
	 * - [Ajax](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) - sends requests to a server on the same domain
	 * - [JsonP](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) - uses JSON-P to send requests to a server on a different domain
	 * - [Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html) - uses RESTful HTTP methods (GET/PUT/POST/DELETE) to communicate with server
	 * - [Direct](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Direct.html) - uses [Ext.direct.Manager](https://docs.sencha.com/extjs/6.0.1/classic/Ext.direct.Manager.html) to send requests
	 * 
	 * Proxies operate on the principle that all operations performed are either Create, Read, Update or Delete. These four
	 * operations are mapped to the methods [create](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-create), [read](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-read), [update](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-update) and [erase](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-erase)
	 * respectively. Each Proxy subclass implements these functions.
	 * 
	 * The CRUD methods each expect an [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) object as the sole argument. The Operation
	 * encapsulates information about the action the Store wishes to perform, the [model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html) instances
	 * that are to be modified, etc. See the [Operation](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.operation.Operation.html) documentation for more details. Each CRUD
	 * method also accepts a callback function to be called asynchronously on completion.
	 * 
	 * Proxies also support batching of Operations via a [batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Batch.html) object, invoked by the [batch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Proxy.html#method-batch)
	 * method.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when this proxy's reader provides new metadata. Metadata usually consists
		 * of new field definitions, but can include any configuration data required by an
		 * application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders. Note that this event is also
		 * propagated by [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), which is typically where it would be handled.
		 * @event
		 * @param   {Ext.data.proxy.Proxy} _this
		 * @param   {object}               meta  The JSON metadata
		 * @param   {object}               eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                 
		 */
		metachange? (_this: Ext.data.proxy.Proxy, meta: object, eOpts: object): void;
	}
}
declare namespace Ext.data.proxy.Rest {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.proxy.Rest](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html)
	 * The Rest proxy is a specialization of the [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) which simply maps the four actions
	 * (create, read, update and destroy) to RESTful HTTP verbs. For example, let's set up a [Model](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html)
	 * with an inline Rest proxy
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email'],
	 *    
	 *        proxy: {
	 *            type: 'rest',
	 *            url : '/users'
	 *        }
	 *    });
	 * 
	 * Now we can create a new User instance and save it via the Rest proxy. Doing this will cause the Proxy to send a POST
	 * request to '/users':
	 * 
	 *    var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
	 *    
	 *    user.save(); //POST /users
	 * 
	 * Let's expand this a little and provide a callback for the [Ext.data.Model.save](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Model.html#method-save) call to update the Model once
	 * it has been created. We'll assume the creation went successfully and that the server gave this user an ID of 123:
	 * 
	 *    user.save({
	 *        success: function(user) {
	 *            user.set('name', 'Khan Noonien Singh');
	 *    
	 *            user.save(); //PUT /users/123
	 *        }
	 *    });
	 * 
	 * Now that we're no longer creating a new Model instance, the request method is changed to an HTTP PUT, targeting the
	 * relevant url for that user. Now let's delete this user, which will use the DELETE method:
	 * 
	 *        user.erase(); //DELETE /users/123
	 * 
	 * Finally, when we perform a load of a Model or Store, Rest proxy will use the GET method:
	 * 
	 *    //1. Load via Store
	 *    
	 *    //the Store automatically picks up the Proxy from the User model
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User'
	 *    });
	 *    
	 *    store.load(); //GET /users
	 *    
	 *    //2. Load directly from the Model
	 *    
	 *    //GET /users/123
	 *    User.load(123, {
	 *        success: function(user) {
	 *            console.log(user.getId()); //outputs 123
	 *        }
	 *    });
	 * 
	 * # Url generation
	 * 
	 * The Rest proxy is able to automatically generate the urls above based on two configuration options - [appendId](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-appendId) and
	 * [format](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#cfg-format). If appendId is true (it is by default) then Rest proxy will automatically append the ID of the Model
	 * instance in question to the configured url, resulting in the '/users/123' that we saw above.
	 * 
	 * If the request is not for a specific Model instance (e.g. loading a Store), the url is not appended with an id.
	 * The Rest proxy will automatically insert a '/' before the ID if one is not already present.
	 * 
	 *    new Ext.data.proxy.Rest({
	 *        url: '/users',
	 *        appendId: true //default
	 *    });
	 *    
	 *    // Collection url: /users
	 *    // Instance url  : /users/123
	 * 
	 * The Rest proxy can also optionally append a format string to the end of any generated url:
	 * 
	 *    new Ext.data.proxy.Rest({
	 *        url: '/users',
	 *        format: 'json'
	 *    });
	 *    
	 *    // Collection url: /users.json
	 *    // Instance url  : /users/123.json
	 * 
	 * If further customization is needed, simply implement the [buildUrl](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Rest.html#method-buildUrl) method and add your custom generated url
	 * onto the [Request](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Request.html) object that is passed to buildUrl. See [Rest proxy's implementation](source/Rest.html#Ext-data-proxy-Rest-method-buildUrl) for
	 * an example of how to achieve this.
	 * 
	 * Note that Rest proxy inherits from [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html), which already injects all of the sorter,
	 * filter, group and paging options into the generated url. See the [AjaxProxy docs](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html) for more
	 * details.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when the server returns an exception. This event may also be listened
		 * to in the event that a request has timed out or has been aborted.
		 * @event
		 * @param   {Ext.data.proxy.Proxy}         _this
		 * @param   {Ext.data.Request}             request   The request that was sent
		 * @param   {Ext.data.operation.Operation} operation The operation that triggered the request
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		exception? (_this: Ext.data.proxy.Proxy, request: Ext.data.Request, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when this proxy's reader provides new metadata. Metadata usually consists
		 * of new field definitions, but can include any configuration data required by an
		 * application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders. Note that this event is also
		 * propagated by [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), which is typically where it would be handled.
		 * @event
		 * @param   {Ext.data.proxy.Proxy} _this
		 * @param   {object}               meta  The JSON metadata
		 * @param   {object}               eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                 
		 */
		metachange? (_this: Ext.data.proxy.Proxy, meta: object, eOpts: object): void;
	}
}
declare namespace Ext.data.proxy.Server {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Server.html)
	 * ServerProxy is a superclass of [JsonPProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.JsonP.html) and [AjaxProxy](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.Ajax.html), and
	 * would not usually be used directly.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when the server returns an exception. This event may also be listened
		 * to in the event that a request has timed out or has been aborted.
		 * @event
		 * @param   {Ext.data.proxy.Proxy}         _this
		 * @param   {Ext.data.Request}             request   The request that was sent
		 * @param   {Ext.data.operation.Operation} operation The operation that triggered the request
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		exception? (_this: Ext.data.proxy.Proxy, request: Ext.data.Request, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when this proxy's reader provides new metadata. Metadata usually consists
		 * of new field definitions, but can include any configuration data required by an
		 * application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders. Note that this event is also
		 * propagated by [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), which is typically where it would be handled.
		 * @event
		 * @param   {Ext.data.proxy.Proxy} _this
		 * @param   {object}               meta  The JSON metadata
		 * @param   {object}               eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                 
		 */
		metachange? (_this: Ext.data.proxy.Proxy, meta: object, eOpts: object): void;
	}
}
declare namespace Ext.data.proxy.SessionStorage {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.proxy.SessionStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.SessionStorage.html)
	 * Proxy which uses HTML5 session storage as its data storage/retrieval mechanism. If this proxy is used in a browser
	 * where session storage is not supported, the constructor will throw an error. A session storage proxy requires a
	 * unique ID which is used as a key in which all record data are stored in the session storage object.
	 * 
	 * It's important to supply this unique ID as it cannot be reliably determined otherwise. If no id is provided but the
	 * attached store has a storeId, the storeId will be used. If neither option is presented the proxy will throw an error.
	 * 
	 * Proxies are almost always used with a [store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html):
	 * 
	 *    new Ext.data.Store({
	 *        proxy: {
	 *            type: 'sessionstorage',
	 *            id  : 'myProxyKey'
	 *        }
	 *    });
	 * 
	 * Alternatively you can instantiate the Proxy directly:
	 * 
	 *    new Ext.data.proxy.SessionStorage({
	 *        id  : 'myOtherProxyKey'
	 *    });
	 * 
	 * Note that session storage is different to local storage (see [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html)) - if a browser
	 * session is ended (e.g. by closing the browser) then all data in a SessionStorageProxy are lost. Browser restarts
	 * don't affect the [Ext.data.proxy.LocalStorage](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.proxy.LocalStorage.html) - the data are preserved.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when this proxy's reader provides new metadata. Metadata usually consists
		 * of new field definitions, but can include any configuration data required by an
		 * application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders. Note that this event is also
		 * propagated by [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html), which is typically where it would be handled.
		 * @event
		 * @param   {Ext.data.proxy.Proxy} _this
		 * @param   {object}               meta  The JSON metadata
		 * @param   {object}               eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                 
		 */
		metachange? (_this: Ext.data.proxy.Proxy, meta: object, eOpts: object): void;
	}
}

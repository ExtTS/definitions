declare namespace Ext.enums {
	/** 
	 * [Ext.enums.Feature](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Feature.html)
	 * Enumeration of all ftypes.
	 */
	class Feature {
		/** 
		 * Alias for [Ext.grid.feature.AbstractSummary](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.feature.AbstractSummary.html).
		 * @property
		 * @public (property)
		 * @default 'abstractsummary'
		 * @type {string}
		 */
		abstractsummary?: string;
		/** 
		 * Alias for [Ext.grid.feature.Feature](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.feature.Feature.html).
		 * @property
		 * @public (property)
		 * @default 'feature'
		 * @type {string}
		 */
		feature?: string;
		/** 
		 * Alias for [Ext.grid.feature.Grouping](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.feature.Grouping.html).
		 * @property
		 * @public (property)
		 * @default 'grouping'
		 * @type {string}
		 */
		grouping?: string;
		/** 
		 * Alias for [Ext.grid.feature.GroupingSummary](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.feature.GroupingSummary.html).
		 * @property
		 * @public (property)
		 * @default 'groupingsummary'
		 * @type {string}
		 */
		groupingsummary?: string;
		/** 
		 * Alias for [Ext.grid.feature.RowBody](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.feature.RowBody.html).
		 * @property
		 * @public (property)
		 * @default 'rowbody'
		 * @type {string}
		 */
		rowbody?: string;
		/** 
		 * Alias for [Ext.grid.feature.Summary](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.feature.Summary.html).
		 * @property
		 * @public (property)
		 * @default 'summary'
		 * @type {string}
		 */
		summary?: string;
	}
	/** 
	 * [Ext.enums.Layout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Layout.html)
	 * Enumeration of all layout types.
	 */
	class Layout {
		/** 
		 * Alias for [Ext.layout.container.Absolute](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Absolute.html).
		 * @property
		 * @public (property)
		 * @default 'absolute'
		 * @type {string}
		 */
		absolute?: string;
		/** 
		 * Alias for [Ext.layout.container.Accordion](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Accordion.html).
		 * @property
		 * @public (property)
		 * @default 'accordion'
		 * @type {string}
		 */
		accordion?: string;
		/** 
		 * Alias for [Ext.layout.container.Anchor](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Anchor.html).
		 * @property
		 * @public (property)
		 * @default 'anchor'
		 * @type {string}
		 */
		anchor?: string;
		/** 
		 * Alias for [Ext.layout.container.Auto](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Auto.html).
		 * @property
		 * @public (property)
		 * @default 'auto'
		 * @type {string}
		 */
		auto?: string;
		/** 
		 * Alias for [Ext.layout.component.Auto](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.component.Auto.html).
		 * @property
		 * @public (property)
		 * @default 'autocomponent'
		 * @type {string}
		 */
		autocomponent?: string;
		/** 
		 * Alias for [Ext.layout.container.Auto](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Auto.html).
		 * @property
		 * @public (property)
		 * @default 'autocontainer'
		 * @type {string}
		 */
		autocontainer?: string;
		/** 
		 * Alias for [Ext.layout.container.Border](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Border.html).
		 * @property
		 * @public (property)
		 * @default 'border'
		 * @type {string}
		 */
		border?: string;
		/** 
		 * Alias for [Ext.layout.container.Box](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Box.html).
		 * @property
		 * @public (property)
		 * @default 'box'
		 * @type {string}
		 */
		box?: string;
		/** 
		 * Alias for [Ext.layout.container.Card](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Card.html).
		 * @property
		 * @public (property)
		 * @default 'card'
		 * @type {string}
		 */
		card?: string;
		/** 
		 * Alias for [Ext.layout.container.Center](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Center.html).
		 * @property
		 * @public (property)
		 * @default 'center'
		 * @type {string}
		 */
		center?: string;
		/** 
		 * Alias for [Ext.layout.container.CheckboxGroup](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.CheckboxGroup.html).
		 * @property
		 * @public (property)
		 * @default 'checkboxgroup'
		 * @type {string}
		 */
		checkboxgroup?: string;
		/** 
		 * Alias for [Ext.layout.container.Column](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Column.html).
		 * @property
		 * @public (property)
		 * @default 'column'
		 * @type {string}
		 */
		column?: string;
		/** 
		 * Alias for [Ext.layout.container.Container](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Container.html).
		 * @property
		 * @public (property)
		 * @default 'container'
		 * @type {string}
		 */
		container?: string;
		/** 
		 * Alias for [Ext.layout.container.Fit](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Fit.html).
		 * @property
		 * @public (property)
		 * @default 'fit'
		 * @type {string}
		 */
		fit?: string;
		/** 
		 * Alias for [Ext.layout.container.Form](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Form.html).
		 * @property
		 * @public (property)
		 * @default 'form'
		 * @type {string}
		 */
		form?: string;
		/** 
		 * Alias for [Ext.layout.container.HBox](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.HBox.html).
		 * @property
		 * @public (property)
		 * @default 'hbox'
		 * @type {string}
		 */
		hbox?: string;
		/** 
		 * Alias for [Ext.layout.container.Table](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.Table.html).
		 * @property
		 * @public (property)
		 * @default 'table'
		 * @type {string}
		 */
		table?: string;
		/** 
		 * Alias for [Ext.layout.container.VBox](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.VBox.html).
		 * @property
		 * @public (property)
		 * @default 'vbox'
		 * @type {string}
		 */
		vbox?: string;
	}
	/** 
	 * [Ext.enums.Plugin](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Plugin.html)
	 * Enumeration of all ptypes.
	 */
	class Plugin {
		/** 
		 * Alias for [Ext.grid.plugin.CellEditing](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.plugin.CellEditing.html).
		 * @property
		 * @public (property)
		 * @default 'cellediting'
		 * @type {string}
		 */
		cellediting?: string;
		/** 
		 * Alias for [Ext.grid.plugin.Clipboard](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.plugin.Clipboard.html).
		 * @property
		 * @public (property)
		 * @default 'clipboard'
		 * @type {string}
		 */
		clipboard?: string;
		/** 
		 * Alias for [Ext.grid.filters.Filters](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.filters.Filters.html).
		 * @property
		 * @public (property)
		 * @default 'gridfilters'
		 * @type {string}
		 */
		gridfilters?: string;
		/** 
		 * Alias for [Ext.grid.plugin.HeaderResizer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.plugin.HeaderResizer.html).
		 * @property
		 * @public (property)
		 * @default 'gridheaderresizer'
		 * @type {string}
		 */
		gridheaderresizer?: string;
		/** 
		 * Alias for [Ext.grid.plugin.DragDrop](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.plugin.DragDrop.html).
		 * @property
		 * @public (property)
		 * @default 'gridviewdragdrop'
		 * @type {string}
		 */
		gridviewdragdrop?: string;
		/** 
		 * Alias for [Ext.plugin.LazyItems](https://docs.sencha.com/extjs/6.0.1/classic/Ext.plugin.LazyItems.html).
		 * @property
		 * @public (property)
		 * @default 'lazyitems'
		 * @type {string}
		 */
		lazyitems?: string;
		/** 
		 * Alias for [Ext.plugin.Responsive](https://docs.sencha.com/extjs/6.0.1/classic/Ext.plugin.Responsive.html).
		 * @property
		 * @public (property)
		 * @default 'responsive'
		 * @type {string}
		 */
		responsive?: string;
		/** 
		 * Alias for [Ext.grid.plugin.RowEditing](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.plugin.RowEditing.html).
		 * @property
		 * @public (property)
		 * @default 'rowediting'
		 * @type {string}
		 */
		rowediting?: string;
		/** 
		 * Alias for [Ext.grid.plugin.RowExpander](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.plugin.RowExpander.html).
		 * @property
		 * @public (property)
		 * @default 'rowexpander'
		 * @type {string}
		 */
		rowexpander?: string;
		/** 
		 * Alias for [Ext.grid.selection.Replicator](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.selection.Replicator.html).
		 * @property
		 * @public (property)
		 * @default 'selectionreplicator'
		 * @type {string}
		 */
		selectionreplicator?: string;
		/** 
		 * Alias for [Ext.tree.plugin.TreeViewDragDrop](https://docs.sencha.com/extjs/6.0.1/classic/Ext.tree.plugin.TreeViewDragDrop.html).
		 * @property
		 * @public (property)
		 * @default 'treeviewdragdrop'
		 * @type {string}
		 */
		treeviewdragdrop?: string;
		/** 
		 * Alias for [Ext.plugin.Viewport](https://docs.sencha.com/extjs/6.0.1/classic/Ext.plugin.Viewport.html).
		 * @property
		 * @public (property)
		 * @default 'viewport'
		 * @type {string}
		 */
		viewport?: string;
	}
	/** 
	 * [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html)
	 * Enumeration of all xtypes.
	 */
	class Widget {
		/** 
		 * Alias for [Ext.grid.column.Action](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.column.Action.html).
		 * @property
		 * @public (property)
		 * @default 'actioncolumn'
		 * @type {string}
		 */
		actioncolumn?: string;
		/** 
		 * Alias for [Ext.grid.column.Boolean](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.column.Boolean.html).
		 * @property
		 * @public (property)
		 * @default 'booleancolumn'
		 * @type {string}
		 */
		booleancolumn?: string;
		/** 
		 * Alias for [Ext.view.BoundList](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.BoundList.html).
		 * @property
		 * @public (property)
		 * @default 'boundlist'
		 * @type {string}
		 */
		boundlist?: string;
		/** 
		 * Alias for [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).
		 * @property
		 * @public (property)
		 * @default 'box'
		 * @type {string}
		 */
		box?: string;
		/** 
		 * Alias for [Ext.toolbar.Breadcrumb](https://docs.sencha.com/extjs/6.0.1/classic/Ext.toolbar.Breadcrumb.html).
		 * @property
		 * @public (property)
		 * @default 'breadcrumb'
		 * @type {string}
		 */
		breadcrumb?: string;
		/** 
		 * Alias for [Ext.button.Button](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Button.html).
		 * @property
		 * @public (property)
		 * @default 'button'
		 * @type {string}
		 */
		button?: string;
		/** 
		 * Alias for [Ext.container.ButtonGroup](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.ButtonGroup.html).
		 * @property
		 * @public (property)
		 * @default 'buttongroup'
		 * @type {string}
		 */
		buttongroup?: string;
		/** 
		 * Alias for [Ext.form.field.Checkbox](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Checkbox.html).
		 * @property
		 * @public (property)
		 * @default 'checkbox'
		 * @type {string}
		 */
		checkbox?: string;
		/** 
		 * Alias for [Ext.form.field.Checkbox](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Checkbox.html).
		 * @property
		 * @public (property)
		 * @default 'checkboxfield'
		 * @type {string}
		 */
		checkboxfield?: string;
		/** 
		 * Alias for [Ext.form.CheckboxGroup](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.CheckboxGroup.html).
		 * @property
		 * @public (property)
		 * @default 'checkboxgroup'
		 * @type {string}
		 */
		checkboxgroup?: string;
		/** 
		 * Alias for [Ext.grid.column.Check](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.column.Check.html).
		 * @property
		 * @public (property)
		 * @default 'checkcolumn'
		 * @type {string}
		 */
		checkcolumn?: string;
		/** 
		 * Alias for [Ext.menu.ColorPicker](https://docs.sencha.com/extjs/6.0.1/classic/Ext.menu.ColorPicker.html).
		 * @property
		 * @public (property)
		 * @default 'colormenu'
		 * @type {string}
		 */
		colormenu?: string;
		/** 
		 * Alias for [Ext.picker.Color](https://docs.sencha.com/extjs/6.0.1/classic/Ext.picker.Color.html).
		 * @property
		 * @public (property)
		 * @default 'colorpicker'
		 * @type {string}
		 */
		colorpicker?: string;
		/** 
		 * Alias for [Ext.layout.container.ColumnSplitter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.layout.container.ColumnSplitter.html).
		 * @property
		 * @public (property)
		 * @default 'columnsplitter'
		 * @type {string}
		 */
		columnsplitter?: string;
		/** 
		 * Alias for [Ext.form.field.ComboBox](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.ComboBox.html).
		 * @property
		 * @public (property)
		 * @default 'combo'
		 * @type {string}
		 */
		combo?: string;
		/** 
		 * Alias for [Ext.form.field.ComboBox](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.ComboBox.html).
		 * @property
		 * @public (property)
		 * @default 'combobox'
		 * @type {string}
		 */
		combobox?: string;
		/** 
		 * Alias for [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html).
		 * @property
		 * @public (property)
		 * @default 'component'
		 * @type {string}
		 */
		component?: string;
		/** 
		 * Alias for [Ext.container.Container](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html).
		 * @property
		 * @public (property)
		 * @default 'container'
		 * @type {string}
		 */
		container?: string;
		/** 
		 * Alias for [Ext.button.Cycle](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Cycle.html).
		 * @property
		 * @public (property)
		 * @default 'cycle'
		 * @type {string}
		 */
		cycle?: string;
		/** 
		 * Alias for [Ext.dashboard.Dashboard](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dashboard.Dashboard.html).
		 * @property
		 * @public (property)
		 * @default 'dashboard'
		 * @type {string}
		 */
		dashboard?: string;
		/** 
		 * Alias for [Ext.dashboard.Column](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dashboard.Column.html).
		 * @property
		 * @public (property)
		 * @default 'dashboard-column'
		 * @type {string}
		 */
		dashboard_column?: string;
		/** 
		 * Alias for [Ext.dashboard.Panel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.dashboard.Panel.html).
		 * @property
		 * @public (property)
		 * @default 'dashboard-panel'
		 * @type {string}
		 */
		dashboard_panel?: string;
		/** 
		 * Alias for [Ext.view.View](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.View.html).
		 * @property
		 * @public (property)
		 * @default 'dataview'
		 * @type {string}
		 */
		dataview?: string;
		/** 
		 * Alias for [Ext.grid.column.Date](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.column.Date.html).
		 * @property
		 * @public (property)
		 * @default 'datecolumn'
		 * @type {string}
		 */
		datecolumn?: string;
		/** 
		 * Alias for [Ext.form.field.Date](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Date.html).
		 * @property
		 * @public (property)
		 * @default 'datefield'
		 * @type {string}
		 */
		datefield?: string;
		/** 
		 * Alias for [Ext.menu.DatePicker](https://docs.sencha.com/extjs/6.0.1/classic/Ext.menu.DatePicker.html).
		 * @property
		 * @public (property)
		 * @default 'datemenu'
		 * @type {string}
		 */
		datemenu?: string;
		/** 
		 * Alias for [Ext.picker.Date](https://docs.sencha.com/extjs/6.0.1/classic/Ext.picker.Date.html).
		 * @property
		 * @public (property)
		 * @default 'datepicker'
		 * @type {string}
		 */
		datepicker?: string;
		/** 
		 * Alias for [Ext.form.field.Display](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Display.html).
		 * @property
		 * @public (property)
		 * @default 'displayfield'
		 * @type {string}
		 */
		displayfield?: string;
		/** 
		 * Alias for [Ext.Editor](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Editor.html).
		 * @property
		 * @public (property)
		 * @default 'editor'
		 * @type {string}
		 */
		editor?: string;
		/** 
		 * Alias for [Ext.form.field.Base](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Base.html).
		 * @property
		 * @public (property)
		 * @default 'field'
		 * @type {string}
		 */
		field?: string;
		/** 
		 * Alias for [Ext.form.FieldContainer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.FieldContainer.html).
		 * @property
		 * @public (property)
		 * @default 'fieldcontainer'
		 * @type {string}
		 */
		fieldcontainer?: string;
		/** 
		 * Alias for [Ext.form.FieldSet](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.FieldSet.html).
		 * @property
		 * @public (property)
		 * @default 'fieldset'
		 * @type {string}
		 */
		fieldset?: string;
		/** 
		 * Alias for [Ext.form.field.FileButton](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.FileButton.html).
		 * @property
		 * @public (property)
		 * @default 'filebutton'
		 * @type {string}
		 */
		filebutton?: string;
		/** 
		 * Alias for [Ext.form.field.File](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.File.html).
		 * @property
		 * @public (property)
		 * @default 'filefield'
		 * @type {string}
		 */
		filefield?: string;
		/** 
		 * Alias for [Ext.form.field.File](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.File.html).
		 * @property
		 * @public (property)
		 * @default 'fileuploadfield'
		 * @type {string}
		 */
		fileuploadfield?: string;
		/** 
		 * Alias for [Ext.flash.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.flash.Component.html).
		 * @property
		 * @public (property)
		 * @default 'flash'
		 * @type {string}
		 */
		flash?: string;
		/** 
		 * Alias for [Ext.form.Panel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.Panel.html).
		 * @property
		 * @public (property)
		 * @default 'form'
		 * @type {string}
		 */
		form?: string;
		/** 
		 * Alias for [Ext.grid.Panel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html).
		 * @property
		 * @public (property)
		 * @default 'grid'
		 * @type {string}
		 */
		grid?: string;
		/** 
		 * Alias for [Ext.grid.column.Column](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.column.Column.html).
		 * @property
		 * @public (property)
		 * @default 'gridcolumn'
		 * @type {string}
		 */
		gridcolumn?: string;
		/** 
		 * Alias for [Ext.grid.Panel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html).
		 * @property
		 * @public (property)
		 * @default 'gridpanel'
		 * @type {string}
		 */
		gridpanel?: string;
		/** 
		 * Alias for [Ext.view.Table](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.Table.html).
		 * @property
		 * @public (property)
		 * @default 'gridview'
		 * @type {string}
		 */
		gridview?: string;
		/** 
		 * Alias for [Ext.panel.Header](https://docs.sencha.com/extjs/6.0.1/classic/Ext.panel.Header.html).
		 * @property
		 * @public (property)
		 * @default 'header'
		 * @type {string}
		 */
		header?: string;
		/** 
		 * Alias for [Ext.grid.header.Container](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.header.Container.html).
		 * @property
		 * @public (property)
		 * @default 'headercontainer'
		 * @type {string}
		 */
		headercontainer?: string;
		/** 
		 * Alias for [Ext.form.field.Hidden](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Hidden.html).
		 * @property
		 * @public (property)
		 * @default 'hidden'
		 * @type {string}
		 */
		hidden?: string;
		/** 
		 * Alias for [Ext.form.field.Hidden](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Hidden.html).
		 * @property
		 * @public (property)
		 * @default 'hiddenfield'
		 * @type {string}
		 */
		hiddenfield?: string;
		/** 
		 * Alias for [Ext.form.field.HtmlEditor](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.HtmlEditor.html).
		 * @property
		 * @public (property)
		 * @default 'htmleditor'
		 * @type {string}
		 */
		htmleditor?: string;
		/** 
		 * Alias for [Ext.Img](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Img.html).
		 * @property
		 * @public (property)
		 * @default 'image'
		 * @type {string}
		 */
		image?: string;
		/** 
		 * Alias for [Ext.Img](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Img.html).
		 * @property
		 * @public (property)
		 * @default 'imagecomponent'
		 * @type {string}
		 */
		imagecomponent?: string;
		/** 
		 * Alias for [Ext.data.JsonPStore](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.JsonPStore.html).
		 * @property
		 * @public (property)
		 * @default 'jsonpstore'
		 * @type {string}
		 */
		jsonpstore?: string;
		/** 
		 * Alias for [Ext.form.Label](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.Label.html).
		 * @property
		 * @public (property)
		 * @default 'label'
		 * @type {string}
		 */
		label?: string;
		/** 
		 * Alias for [Ext.LoadMask](https://docs.sencha.com/extjs/6.0.1/classic/Ext.LoadMask.html).
		 * @property
		 * @public (property)
		 * @default 'loadmask'
		 * @type {string}
		 */
		loadmask?: string;
		/** 
		 * Alias for [Ext.menu.Menu](https://docs.sencha.com/extjs/6.0.1/classic/Ext.menu.Menu.html).
		 * @property
		 * @public (property)
		 * @default 'menu'
		 * @type {string}
		 */
		menu?: string;
		/** 
		 * Alias for [Ext.menu.CheckItem](https://docs.sencha.com/extjs/6.0.1/classic/Ext.menu.CheckItem.html).
		 * @property
		 * @public (property)
		 * @default 'menucheckitem'
		 * @type {string}
		 */
		menucheckitem?: string;
		/** 
		 * Alias for [Ext.menu.Item](https://docs.sencha.com/extjs/6.0.1/classic/Ext.menu.Item.html).
		 * @property
		 * @public (property)
		 * @default 'menuitem'
		 * @type {string}
		 */
		menuitem?: string;
		/** 
		 * Alias for [Ext.menu.Separator](https://docs.sencha.com/extjs/6.0.1/classic/Ext.menu.Separator.html).
		 * @property
		 * @public (property)
		 * @default 'menuseparator'
		 * @type {string}
		 */
		menuseparator?: string;
		/** 
		 * Alias for [Ext.window.MessageBox](https://docs.sencha.com/extjs/6.0.1/classic/Ext.window.MessageBox.html).
		 * @property
		 * @public (property)
		 * @default 'messagebox'
		 * @type {string}
		 */
		messagebox?: string;
		/** 
		 * Alias for [Ext.picker.Month](https://docs.sencha.com/extjs/6.0.1/classic/Ext.picker.Month.html).
		 * @property
		 * @public (property)
		 * @default 'monthpicker'
		 * @type {string}
		 */
		monthpicker?: string;
		/** 
		 * Alias for [Ext.view.MultiSelector](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.MultiSelector.html).
		 * @property
		 * @public (property)
		 * @default 'multiselector'
		 * @type {string}
		 */
		multiselector?: string;
		/** 
		 * Alias for [Ext.view.MultiSelectorSearch](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.MultiSelectorSearch.html).
		 * @property
		 * @public (property)
		 * @default 'multiselector-search'
		 * @type {string}
		 */
		multiselector_search?: string;
		/** 
		 * Alias for [Ext.slider.Multi](https://docs.sencha.com/extjs/6.0.1/classic/Ext.slider.Multi.html).
		 * @property
		 * @public (property)
		 * @default 'multislider'
		 * @type {string}
		 */
		multislider?: string;
		/** 
		 * Alias for [Ext.grid.column.Number](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.column.Number.html).
		 * @property
		 * @public (property)
		 * @default 'numbercolumn'
		 * @type {string}
		 */
		numbercolumn?: string;
		/** 
		 * Alias for [Ext.form.field.Number](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Number.html).
		 * @property
		 * @public (property)
		 * @default 'numberfield'
		 * @type {string}
		 */
		numberfield?: string;
		/** 
		 * Alias for [Ext.toolbar.Paging](https://docs.sencha.com/extjs/6.0.1/classic/Ext.toolbar.Paging.html).
		 * @property
		 * @public (property)
		 * @default 'pagingtoolbar'
		 * @type {string}
		 */
		pagingtoolbar?: string;
		/** 
		 * Alias for [Ext.panel.Panel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.panel.Panel.html).
		 * @property
		 * @public (property)
		 * @default 'panel'
		 * @type {string}
		 */
		panel?: string;
		/** 
		 * Alias for [Ext.form.field.Picker](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Picker.html).
		 * @property
		 * @public (property)
		 * @default 'pickerfield'
		 * @type {string}
		 */
		pickerfield?: string;
		/** 
		 * Alias for [Ext.Progress](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Progress.html).
		 * @property
		 * @public (property)
		 * @default 'progress'
		 * @type {string}
		 */
		progress?: string;
		/** 
		 * Alias for [Ext.ProgressBar](https://docs.sencha.com/extjs/6.0.1/classic/Ext.ProgressBar.html).
		 * @property
		 * @public (property)
		 * @default 'progressbar'
		 * @type {string}
		 */
		progressbar?: string;
		/** 
		 * Alias for [Ext.Progress](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Progress.html).
		 * @property
		 * @public (property)
		 * @default 'progressbarwidget'
		 * @type {string}
		 */
		progressbarwidget?: string;
		/** 
		 * Alias for [Ext.grid.property.Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.property.Grid.html).
		 * @property
		 * @public (property)
		 * @default 'propertygrid'
		 * @type {string}
		 */
		propertygrid?: string;
		/** 
		 * Alias for [Ext.tip.QuickTip](https://docs.sencha.com/extjs/6.0.1/classic/Ext.tip.QuickTip.html).
		 * @property
		 * @public (property)
		 * @default 'quicktip'
		 * @type {string}
		 */
		quicktip?: string;
		/** 
		 * Alias for [Ext.form.field.Radio](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Radio.html).
		 * @property
		 * @public (property)
		 * @default 'radio'
		 * @type {string}
		 */
		radio?: string;
		/** 
		 * Alias for [Ext.form.field.Radio](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Radio.html).
		 * @property
		 * @public (property)
		 * @default 'radiofield'
		 * @type {string}
		 */
		radiofield?: string;
		/** 
		 * Alias for [Ext.form.RadioGroup](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.RadioGroup.html).
		 * @property
		 * @public (property)
		 * @default 'radiogroup'
		 * @type {string}
		 */
		radiogroup?: string;
		/** 
		 * Alias for [Ext.grid.column.RowNumberer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.column.RowNumberer.html).
		 * @property
		 * @public (property)
		 * @default 'rownumberer'
		 * @type {string}
		 */
		rownumberer?: string;
		/** 
		 * Alias for [Ext.scroll.Indicator](https://docs.sencha.com/extjs/6.0.1/classic/Ext.scroll.Indicator.html).
		 * @property
		 * @public (property)
		 * @default 'scrollindicator'
		 * @type {string}
		 */
		scrollindicator?: string;
		/** 
		 * Alias for [Ext.button.Segmented](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Segmented.html).
		 * @property
		 * @public (property)
		 * @default 'segmentedbutton'
		 * @type {string}
		 */
		segmentedbutton?: string;
		/** 
		 * Alias for [Ext.slider.Single](https://docs.sencha.com/extjs/6.0.1/classic/Ext.slider.Single.html).
		 * @property
		 * @public (property)
		 * @default 'slider'
		 * @type {string}
		 */
		slider?: string;
		/** 
		 * Alias for [Ext.slider.Single](https://docs.sencha.com/extjs/6.0.1/classic/Ext.slider.Single.html).
		 * @property
		 * @public (property)
		 * @default 'sliderfield'
		 * @type {string}
		 */
		sliderfield?: string;
		/** 
		 * Alias for [Ext.slider.Tip](https://docs.sencha.com/extjs/6.0.1/classic/Ext.slider.Tip.html).
		 * @property
		 * @public (property)
		 * @default 'slidertip'
		 * @type {string}
		 */
		slidertip?: string;
		/** 
		 * Alias for [Ext.slider.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.slider.Widget.html).
		 * @property
		 * @public (property)
		 * @default 'sliderwidget'
		 * @type {string}
		 */
		sliderwidget?: string;
		/** 
		 * Alias for [Ext.sparkline.Bar](https://docs.sencha.com/extjs/6.0.1/classic/Ext.sparkline.Bar.html).
		 * @property
		 * @public (property)
		 * @default 'sparklinebar'
		 * @type {string}
		 */
		sparklinebar?: string;
		/** 
		 * Alias for [Ext.sparkline.Box](https://docs.sencha.com/extjs/6.0.1/classic/Ext.sparkline.Box.html).
		 * @property
		 * @public (property)
		 * @default 'sparklinebox'
		 * @type {string}
		 */
		sparklinebox?: string;
		/** 
		 * Alias for [Ext.sparkline.Bullet](https://docs.sencha.com/extjs/6.0.1/classic/Ext.sparkline.Bullet.html).
		 * @property
		 * @public (property)
		 * @default 'sparklinebullet'
		 * @type {string}
		 */
		sparklinebullet?: string;
		/** 
		 * Alias for [Ext.sparkline.Discrete](https://docs.sencha.com/extjs/6.0.1/classic/Ext.sparkline.Discrete.html).
		 * @property
		 * @public (property)
		 * @default 'sparklinediscrete'
		 * @type {string}
		 */
		sparklinediscrete?: string;
		/** 
		 * Alias for [Ext.sparkline.Line](https://docs.sencha.com/extjs/6.0.1/classic/Ext.sparkline.Line.html).
		 * @property
		 * @public (property)
		 * @default 'sparklineline'
		 * @type {string}
		 */
		sparklineline?: string;
		/** 
		 * Alias for [Ext.sparkline.Pie](https://docs.sencha.com/extjs/6.0.1/classic/Ext.sparkline.Pie.html).
		 * @property
		 * @public (property)
		 * @default 'sparklinepie'
		 * @type {string}
		 */
		sparklinepie?: string;
		/** 
		 * Alias for [Ext.sparkline.TriState](https://docs.sencha.com/extjs/6.0.1/classic/Ext.sparkline.TriState.html).
		 * @property
		 * @public (property)
		 * @default 'sparklinetristate'
		 * @type {string}
		 */
		sparklinetristate?: string;
		/** 
		 * Alias for [Ext.form.field.Spinner](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Spinner.html).
		 * @property
		 * @public (property)
		 * @default 'spinnerfield'
		 * @type {string}
		 */
		spinnerfield?: string;
		/** 
		 * Alias for [Ext.button.Split](https://docs.sencha.com/extjs/6.0.1/classic/Ext.button.Split.html).
		 * @property
		 * @public (property)
		 * @default 'splitbutton'
		 * @type {string}
		 */
		splitbutton?: string;
		/** 
		 * Alias for [Ext.resizer.Splitter](https://docs.sencha.com/extjs/6.0.1/classic/Ext.resizer.Splitter.html).
		 * @property
		 * @public (property)
		 * @default 'splitter'
		 * @type {string}
		 */
		splitter?: string;
		/** 
		 * Alias for [Ext.tab.Tab](https://docs.sencha.com/extjs/6.0.1/classic/Ext.tab.Tab.html).
		 * @property
		 * @public (property)
		 * @default 'tab'
		 * @type {string}
		 */
		tab?: string;
		/** 
		 * Alias for [Ext.tab.Bar](https://docs.sencha.com/extjs/6.0.1/classic/Ext.tab.Bar.html).
		 * @property
		 * @public (property)
		 * @default 'tabbar'
		 * @type {string}
		 */
		tabbar?: string;
		/** 
		 * Alias for [Ext.panel.Table](https://docs.sencha.com/extjs/6.0.1/classic/Ext.panel.Table.html).
		 * @property
		 * @public (property)
		 * @default 'tablepanel'
		 * @type {string}
		 */
		tablepanel?: string;
		/** 
		 * Alias for [Ext.view.Table](https://docs.sencha.com/extjs/6.0.1/classic/Ext.view.Table.html).
		 * @property
		 * @public (property)
		 * @default 'tableview'
		 * @type {string}
		 */
		tableview?: string;
		/** 
		 * Alias for [Ext.tab.Panel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.tab.Panel.html).
		 * @property
		 * @public (property)
		 * @default 'tabpanel'
		 * @type {string}
		 */
		tabpanel?: string;
		/** 
		 * Alias for [Ext.form.field.Tag](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Tag.html).
		 * @property
		 * @public (property)
		 * @default 'tagfield'
		 * @type {string}
		 */
		tagfield?: string;
		/** 
		 * Alias for [Ext.toolbar.Fill](https://docs.sencha.com/extjs/6.0.1/classic/Ext.toolbar.Fill.html).
		 * @property
		 * @public (property)
		 * @default 'tbfill'
		 * @type {string}
		 */
		tbfill?: string;
		/** 
		 * Alias for [Ext.toolbar.Item](https://docs.sencha.com/extjs/6.0.1/classic/Ext.toolbar.Item.html).
		 * @property
		 * @public (property)
		 * @default 'tbitem'
		 * @type {string}
		 */
		tbitem?: string;
		/** 
		 * Alias for [Ext.toolbar.Separator](https://docs.sencha.com/extjs/6.0.1/classic/Ext.toolbar.Separator.html).
		 * @property
		 * @public (property)
		 * @default 'tbseparator'
		 * @type {string}
		 */
		tbseparator?: string;
		/** 
		 * Alias for [Ext.toolbar.Spacer](https://docs.sencha.com/extjs/6.0.1/classic/Ext.toolbar.Spacer.html).
		 * @property
		 * @public (property)
		 * @default 'tbspacer'
		 * @type {string}
		 */
		tbspacer?: string;
		/** 
		 * Alias for [Ext.toolbar.TextItem](https://docs.sencha.com/extjs/6.0.1/classic/Ext.toolbar.TextItem.html).
		 * @property
		 * @public (property)
		 * @default 'tbtext'
		 * @type {string}
		 */
		tbtext?: string;
		/** 
		 * Alias for [Ext.grid.column.Template](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.column.Template.html).
		 * @property
		 * @public (property)
		 * @default 'templatecolumn'
		 * @type {string}
		 */
		templatecolumn?: string;
		/** 
		 * Alias for [Ext.form.field.TextArea](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.TextArea.html).
		 * @property
		 * @public (property)
		 * @default 'textarea'
		 * @type {string}
		 */
		textarea?: string;
		/** 
		 * Alias for [Ext.form.field.TextArea](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.TextArea.html).
		 * @property
		 * @public (property)
		 * @default 'textareafield'
		 * @type {string}
		 */
		textareafield?: string;
		/** 
		 * Alias for [Ext.form.field.Text](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Text.html).
		 * @property
		 * @public (property)
		 * @default 'textfield'
		 * @type {string}
		 */
		textfield?: string;
		/** 
		 * Alias for [Ext.form.field.Time](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Time.html).
		 * @property
		 * @public (property)
		 * @default 'timefield'
		 * @type {string}
		 */
		timefield?: string;
		/** 
		 * Alias for [Ext.picker.Time](https://docs.sencha.com/extjs/6.0.1/classic/Ext.picker.Time.html).
		 * @property
		 * @public (property)
		 * @default 'timepicker'
		 * @type {string}
		 */
		timepicker?: string;
		/** 
		 * Alias for [Ext.tip.Tip](https://docs.sencha.com/extjs/6.0.1/classic/Ext.tip.Tip.html).
		 * @property
		 * @public (property)
		 * @default 'tip'
		 * @type {string}
		 */
		tip?: string;
		/** 
		 * Alias for [Ext.panel.Title](https://docs.sencha.com/extjs/6.0.1/classic/Ext.panel.Title.html).
		 * @property
		 * @public (property)
		 * @default 'title'
		 * @type {string}
		 */
		title?: string;
		/** 
		 * Alias for [Ext.window.Toast](https://docs.sencha.com/extjs/6.0.1/classic/Ext.window.Toast.html).
		 * @property
		 * @public (property)
		 * @default 'toast'
		 * @type {string}
		 */
		toast?: string;
		/** 
		 * Alias for [Ext.panel.Tool](https://docs.sencha.com/extjs/6.0.1/classic/Ext.panel.Tool.html).
		 * @property
		 * @public (property)
		 * @default 'tool'
		 * @type {string}
		 */
		tool?: string;
		/** 
		 * Alias for [Ext.toolbar.Toolbar](https://docs.sencha.com/extjs/6.0.1/classic/Ext.toolbar.Toolbar.html).
		 * @property
		 * @public (property)
		 * @default 'toolbar'
		 * @type {string}
		 */
		toolbar?: string;
		/** 
		 * Alias for [Ext.tip.ToolTip](https://docs.sencha.com/extjs/6.0.1/classic/Ext.tip.ToolTip.html).
		 * @property
		 * @public (property)
		 * @default 'tooltip'
		 * @type {string}
		 */
		tooltip?: string;
		/** 
		 * Alias for [Ext.tree.Column](https://docs.sencha.com/extjs/6.0.1/classic/Ext.tree.Column.html).
		 * @property
		 * @public (property)
		 * @default 'treecolumn'
		 * @type {string}
		 */
		treecolumn?: string;
		/** 
		 * Alias for [Ext.list.Tree](https://docs.sencha.com/extjs/6.0.1/classic/Ext.list.Tree.html).
		 * @property
		 * @public (property)
		 * @default 'treelist'
		 * @type {string}
		 */
		treelist?: string;
		/** 
		 * Alias for [Ext.list.TreeItem](https://docs.sencha.com/extjs/6.0.1/classic/Ext.list.TreeItem.html).
		 * @property
		 * @public (property)
		 * @default 'treelistitem'
		 * @type {string}
		 */
		treelistitem?: string;
		/** 
		 * Alias for [Ext.tree.Panel](https://docs.sencha.com/extjs/6.0.1/classic/Ext.tree.Panel.html).
		 * @property
		 * @public (property)
		 * @default 'treepanel'
		 * @type {string}
		 */
		treepanel?: string;
		/** 
		 * Alias for [Ext.tree.View](https://docs.sencha.com/extjs/6.0.1/classic/Ext.tree.View.html).
		 * @property
		 * @public (property)
		 * @default 'treeview'
		 * @type {string}
		 */
		treeview?: string;
		/** 
		 * Alias for [Ext.form.field.Trigger](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Trigger.html).
		 * @property
		 * @public (property)
		 * @default 'trigger'
		 * @type {string}
		 */
		trigger?: string;
		/** 
		 * Alias for [Ext.form.field.Trigger](https://docs.sencha.com/extjs/6.0.1/classic/Ext.form.field.Trigger.html).
		 * @property
		 * @public (property)
		 * @default 'triggerfield'
		 * @type {string}
		 */
		triggerfield?: string;
		/** 
		 * Alias for [Ext.container.Viewport](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Viewport.html).
		 * @property
		 * @public (property)
		 * @default 'viewport'
		 * @type {string}
		 */
		viewport?: string;
		/** 
		 * Alias for [Ext.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Widget.html).
		 * @property
		 * @public (property)
		 * @default 'widget'
		 * @type {string}
		 */
		widget?: string;
		/** 
		 * Alias for [Ext.grid.column.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.column.Widget.html).
		 * @property
		 * @public (property)
		 * @default 'widgetcolumn'
		 * @type {string}
		 */
		widgetcolumn?: string;
		/** 
		 * Alias for [Ext.window.Window](https://docs.sencha.com/extjs/6.0.1/classic/Ext.window.Window.html).
		 * @property
		 * @public (property)
		 * @default 'window'
		 * @type {string}
		 */
		window?: string;
	}
}
declare namespace Ext.enums.Feature {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.enums.Feature](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Feature.html)
	 * Enumeration of all ftypes.
	 */
	interface Def extends Ext.enums.Feature {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		config?: object;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		statics?: object;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
	}
}
declare namespace Ext.enums.Layout {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.enums.Layout](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Layout.html)
	 * Enumeration of all layout types.
	 */
	interface Def extends Ext.enums.Layout {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		config?: object;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		statics?: object;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
	}
}
declare namespace Ext.enums.Plugin {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.enums.Plugin](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Plugin.html)
	 * Enumeration of all ptypes.
	 */
	interface Def extends Ext.enums.Plugin {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		config?: object;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		statics?: object;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
	}
}
declare namespace Ext.enums.Widget {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html)
	 * Enumeration of all xtypes.
	 */
	interface Def extends Ext.enums.Widget {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.0.1/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.0.1/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		config?: object;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * not cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.0.1/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		statics?: object;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.0.1/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.0.1/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.0.1/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.0.1/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.0.1/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
	}
}

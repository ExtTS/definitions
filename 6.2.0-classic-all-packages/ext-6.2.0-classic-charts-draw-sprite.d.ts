declare namespace Ext.draw.sprite {
	/** 
	 * Computes an intermidiate value between two values of the same type for use in animations.
	 * Can have pre- and post- processor functions if the values need to be processed
	 * before an intermidiate value can be computed (parseInitial), or the computed value
	 * needs to be processed before it can be used as a valid attribute value (serve).
	 * @private (class)
	 */
	class AnimationParser extends Ext.Base {}
	/** 
	 * [Ext.draw.sprite.Arc](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Arc.html)
	 * A sprite that represents a circular arc.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'arc',
	 *           cx: 100,
	 *           cy: 100,
	 *           r: 80,
	 *           fillStyle: '#1F6D91',
	 *           startAngle: 0,
	 *           endAngle: Math.PI,
	 *           anticlockwise: true
	 *       }]
	 *    });
	 * 
	 */
	class Arc extends Ext.draw.sprite.Circle {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default 'arc'
		 * @type {string}
		 */
		type?: string;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Arc|Ext.draw.sprite.Circle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Arc;
		hide? (): Ext.draw.sprite.Circle;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                                                [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Arc|Ext.draw.sprite.Circle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Arc;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Circle;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                                               matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                                                [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Arc|Ext.draw.sprite.Circle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Arc;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Circle;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Arc|Ext.draw.sprite.Circle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Arc;
		show? (): Ext.draw.sprite.Circle;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                                               matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                                                [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Arc|Ext.draw.sprite.Circle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Arc;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Circle;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Arrow](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Arrow.html)
	 * A sprite that represents an arrow.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'arrow',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#30BDA7'
	 *       }]
	 *    });
	 * 
	 */
	class Arrow extends Ext.draw.sprite.Path {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'path'}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Arrow|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Arrow;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                           [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Arrow|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Arrow;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                          matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                           [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Arrow|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Arrow;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Arrow|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Arrow;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                          matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                           [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Arrow|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Arrow;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * Flyweight object to process the attributes of a sprite.
	 * A single instance of the AttributeDefinition is created per sprite class.
	 * See `onClassCreated` and `onClassExtended` callbacks
	 * of the [Ext.draw.sprite.Sprite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html) for more info.
	 * @private (class)
	 */
	class AttributeDefinition extends Ext.Base {}
	/** 
	 * Parsers used for sprite attributes if they are [normalized](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.AttributeDefinition.html#method-normalize)
	 * (default) when being [set](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributes).
	 * 
	 * Methods of the singleton correpond either to the processor functions themselves or processor factories.
	 * @private (class)
	 * @singleton (definition)
	 */
	interface AttributeParser extends Ext.Base {}
	/** 
	 * [Ext.draw.sprite.Circle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Circle.html)
	 * A sprite that represents a circle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'circle',
	 *           cx: 100,
	 *           cy: 100,
	 *           r: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	class Circle extends Ext.draw.sprite.Path {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {cx: 'number', cy: 'number', r: 'number'}, aliases: {radius: 'r', x: 'cx', y: 'cy', centerX: 'cx', centerY: 'cy'}, defaults: {cx: 0, cy: 0, r: 4}, triggers: {cx: 'path', cy: 'path', r: 'path'}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default 'circle'
		 * @type {string}
		 */
		type?: string;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Circle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Circle;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                            [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Circle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Circle;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                           matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                            [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Circle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Circle;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Circle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Circle;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                           matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                            [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Circle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Circle;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Composite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Composite.html)
	 * Represents a group of sprites.
	 */
	class Composite extends Ext.draw.sprite.Sprite {
		/** 
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		isComposite?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @default 'composite'
		 * @type {string}
		 */
		type?: string;
		/** 
		 * Adds a sprite to the composite.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.sprite.Sprite|object} sprite
		 * @returns {void}                                 
		 */
		add? (sprite: Ext.draw.sprite.Sprite | object): void;
		/** 
		 * Adds a list of sprites to the composite.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.sprite.Sprite[]|object[]|Ext.draw.sprite.Sprite|object} sprites
		 * @returns {void}                                                                    
		 */
		addAll? (sprites: Ext.draw.sprite.Sprite[] | object[] | Ext.draw.sprite.Sprite | object): void;
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns the value of [sprites](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Composite.html#cfg-sprites).
		 * @method
		 * @public (method)
		 * @returns {any[]}  
		 */
		getSprites? (): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Composite|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Composite;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * Performs a hit test on the sprite.
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Renders all sprites contained in the composite to the surface.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}           
		 */
		render? (surface: object, ctx: object, rect: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {void|any}         
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                          [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Composite|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Composite;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Sets the value of [sprites](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Composite.html#cfg-sprites).
		 * @method
		 * @public (method)
		 * @param   {any[]} sprites The new value.
		 * @returns {void}          
		 */
		setSprites? (sprites: any[]): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                         matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                          [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Composite|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Composite;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Composite|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Composite;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                         matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                          [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Composite|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Composite;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Updates the bounding box of the composite, which contains the bounding box of all sprites in the composite.
		 * @method
		 * @public (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform Target object (transformed bounding box) to populate.
		 * @param   {object} plain     Untransformed bounding box.
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object, plain: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sprite
		 * @param   {object} isDestroy
		 * @returns {void}             
		 */
		removeSprite? (sprite: object, isDestroy: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @returns {void}           
		 */
		updateSurface? (surface: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Cross](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Cross.html)
	 * A sprite that represents a cross.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'cross',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	class Cross extends Ext.draw.sprite.Path {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'path'}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Cross|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Cross;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                           [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Cross|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Cross;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                          matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                           [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Cross|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Cross;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Cross|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Cross;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                          matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                           [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Cross|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Cross;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Diamond](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Diamond.html)
	 * A sprite that represents a diamond.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'diamond',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	class Diamond extends Ext.draw.sprite.Path {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'path'}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Diamond|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Diamond;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                             [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Diamond|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Diamond;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                            matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                             [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Diamond|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Diamond;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Diamond|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Diamond;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                            matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                             [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Diamond|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Diamond;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Ellipse](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Ellipse.html)
	 * A sprite that represents an ellipse.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'ellipse',
	 *           cx: 100,
	 *           cy: 100,
	 *           rx: 80,
	 *           ry: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	class Ellipse extends Ext.draw.sprite.Path {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {cx: "number", cy: "number", rx: "number", ry: "number", axisRotation: "number"}, aliases: {radius: "r", x: "cx", y: "cy", centerX: "cx", centerY: "cy", radiusX: "rx", radiusY: "ry"}, defaults: {cx: 0, cy: 0, rx: 1, ry: 1, axisRotation: 0}, triggers: {cx: 'path', cy: 'path', rx: 'path', ry: 'path', axisRotation: 'path'}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default 'ellipse'
		 * @type {string}
		 */
		type?: string;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Ellipse|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Ellipse;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                             [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Ellipse|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Ellipse;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                            matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                             [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Ellipse|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Ellipse;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Ellipse|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Ellipse;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                            matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                             [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Ellipse|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Ellipse;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.EllipticalArc](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.EllipticalArc.html)
	 * A sprite that represents an elliptical arc.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'ellipticalArc',
	 *           cx: 100,
	 *           cy: 100,
	 *           rx: 80,
	 *           ry: 50,
	 *           fillStyle: '#1F6D91',
	 *           startAngle: 0,
	 *           endAngle: Math.PI,
	 *           anticlockwise: true
	 *       }]
	 *    });
	 * 
	 */
	class EllipticalArc extends Ext.draw.sprite.Ellipse {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default 'ellipticalArc'
		 * @type {string}
		 */
		type?: string;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.EllipticalArc|Ext.draw.sprite.Ellipse|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.EllipticalArc;
		hide? (): Ext.draw.sprite.Ellipse;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                                                           [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.EllipticalArc|Ext.draw.sprite.Ellipse|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.EllipticalArc;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Ellipse;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                                                          matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                                                           [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.EllipticalArc|Ext.draw.sprite.Ellipse|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.EllipticalArc;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Ellipse;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.EllipticalArc|Ext.draw.sprite.Ellipse|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.EllipticalArc;
		show? (): Ext.draw.sprite.Ellipse;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                                                          matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                                                           [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.EllipticalArc|Ext.draw.sprite.Ellipse|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.EllipticalArc;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Ellipse;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Image](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Image.html)
	 * A sprite that represents an image.
	 */
	class Image extends Ext.draw.sprite.Rect {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {src: 'string'}, triggers: {src: 'src'}, updaters: {src: 'updateSource'}, defaults: {src: '', width: null, height: null}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default 'image'
		 * @type {string}
		 */
		type?: string;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Image|Ext.draw.sprite.Rect|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Image;
		hide? (): Ext.draw.sprite.Rect;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                                                [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Image|Ext.draw.sprite.Rect|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Image;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Rect;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                                               matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                                                [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Image|Ext.draw.sprite.Rect|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Image;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Rect;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Image|Ext.draw.sprite.Rect|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Image;
		show? (): Ext.draw.sprite.Rect;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                                               matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                                                [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Image|Ext.draw.sprite.Rect|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Image;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Rect;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @param   {object} plain
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object, plain: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updateTransformedBBox](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updateTransformedBBox).
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void|boolean}  
		 */
		isVisible? (): void;
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Instancing](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Instancing.html)
	 * Sprite that represents multiple instances based on the given template.
	 * 
	 * **From override Ext.draw.overrides.hittest.sprite.Instancing:** Adds hit testing methods to the [Ext.draw.sprite.Instancing](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Instancing.html).
	 * Included by the [Ext.draw.plugin.SpriteEvents](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.plugin.SpriteEvents.html).
	 */
	class Instancing extends Ext.draw.sprite.Sprite {
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		instances?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		isInstancing?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @default 'instancing'
		 * @type {string}
		 */
		type?: string;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Creates a new sprite instance.
		 * @method
		 * @public (method)
		 * @param   {object}  config                The configuration of the instance.
		 * @param   {boolean} [bypassNormalization] 'true' to bypass attribute normalization.
		 * @param   {boolean} [avoidCopy]           'true' to avoid copying the `config` object.
		 * @returns {object}                        The attributes of the instance.
		 */
		add? (config: object, bypassNormalization?: boolean, avoidCopy?: boolean): object;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * @param   {object} bypassNormalization
		 * @param   {object} avoidCopy
		 * @returns {void}                       
		 */
		createInstance? (config: object, bypassNormalization: object, avoidCopy: object): void;
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Not supported.
		 * @method
		 * @public (method)
		 * @returns {null}  
		 */
		getBBox? (): null;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.getBBox](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-getBBox).
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean}   [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {null|void}                      
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns the bounding box for the instance at the given index.
		 * @method
		 * @public (method)
		 * @param   {number}  index                The index of the instance.
		 * @param   {boolean} [isWithoutTransform] 'true' to not apply sprite transforms to the bounding box.
		 * @returns {object}                       The bounding box for the instance.
		 */
		getBBoxFor? (index: number, isWithoutTransform?: boolean): object;
		/** 
		 * Returns the value of [instances](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Instancing.html#cfg-instances).
		 * @method
		 * @public (method)
		 * @returns {any[]}  
		 */
		getInstances? (): any[];
		/** 
		 * Returns the value of [template](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Instancing.html#cfg-template).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getTemplate? (): object;
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Instancing|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Instancing;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * Performs a hit test on the instances of an instancing sprite.
		 * 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Instancing.**
		 * @method
		 * @public (method)
		 * @param   {object} point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: object, options: object): object;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.hitTest](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-hitTest).
		 * Performs a hit test on the sprite.
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object, rect: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                           [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Instancing|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Instancing;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Sets the attributes for the instance at the given index.
		 * @method
		 * @public (method)
		 * @param   {number}  index                 the index of the instance
		 * @param   {object}  changes               the attributes to change
		 * @param   {boolean} [bypassNormalization] 'true' to avoid attribute normalization
		 * @returns {void}                          
		 */
		setAttributesFor? (index: number, changes: object, bypassNormalization?: boolean): void;
		/** 
		 * Sets the value of [instances](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Instancing.html#cfg-instances).
		 * @method
		 * @public (method)
		 * @param   {any[]} instances The new value.
		 * @returns {void}            
		 */
		setInstances? (instances: any[]): void;
		/** 
		 * Sets the value of [template](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Instancing.html#cfg-template).
		 * @method
		 * @public (method)
		 * @param   {object} template The new value.
		 * @returns {void}            
		 */
		setTemplate? (template: object): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                          matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                           [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Instancing|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Instancing;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Instancing|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Instancing;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                          matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                           [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Instancing|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Instancing;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain Target object.
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform Target object (transformed bounding box) to populate.
		 * @param   {object} plain     Untransformed bounding box.
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object, plain: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} template
		 * @returns {void}            
		 */
		applyTemplate? (template: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearAll? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} index
		 * @returns {void}         
		 */
		get? (index: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCount? (): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the instance of an instancing sprite can be seen.
		 * @method
		 * @private (method)
		 * @param   {number} index The index of the instance.
		 * @returns {void}         
		 */
		isInstanceVisible? (index: number): void;
		/** 
		 * Checks if the instancing sprite can be seen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} instances
		 * @returns {void}             
		 */
		updateInstances? (instances: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @returns {void}           
		 */
		updateSurface? (surface: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} template
		 * @param   {object} oldTemplate
		 * @returns {void}               
		 */
		updateTemplate? (template: object, oldTemplate: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Line](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Line.html)
	 * A sprite that represents a line.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'line',
	 *           fromX: 20,
	 *           fromY: 20,
	 *           toX: 120,
	 *           toY: 120,
	 *           strokeStyle: '#1F6D91',
	 *           lineWidth: 3
	 *       }]
	 *    });
	 * 
	 */
	class Line extends Ext.draw.sprite.Sprite {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {fromX: 'number', fromY: 'number', toX: 'number', toY: 'number'}, defaults: {fromX: 0, fromY: 0, toX: 1, toY: 1, strokeStyle: 'black'}, aliases: {x1: 'fromX', y1: 'fromY', x2: 'toX', y2: 'toY'}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default 'line'
		 * @type {string}
		 */
		type?: string;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Line|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Line;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * Performs a hit test on the sprite.
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                     [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Line|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Line;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                    matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                     [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Line|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Line;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Line|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Line;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                    matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                     [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Line|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Line;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @param   {object} plain
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object, plain: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} bbox
		 * @param   {object} isTransform
		 * @param   {object} x1
		 * @param   {object} y1
		 * @param   {object} x2
		 * @param   {object} y2
		 * @returns {void}               
		 */
		updateLineBBox? (bbox: object, isTransform: object, x1: object, y1: object, x2: object, y2: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html)
	 * A sprite that represents a path.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'path',
	 *           path: 'M20,30 c0,-50 75,50 75,0 c0,-50 -75,50 -75,0',
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 * ### Drawing with SVG Paths
	 * 
	 * You may use special SVG Path syntax to "describe" the drawing path.  Here are the SVG path commands:
	 * 
	 * - M = moveto
	 * - L = lineto
	 * - H = horizontal lineto
	 * - V = vertical lineto
	 * - C = curveto
	 * - S = smooth curveto
	 * - Q = quadratic Bézier curve
	 * - T = smooth quadratic Bézier curveto
	 * - A = elliptical Arc
	 * - Z = closepath
	 * 
	 * **Note:** Capital letters indicate that the item should be absolutely positioned.
	 * Use lower case letters for relative positioning.
	 * 
	 * **From override Ext.draw.overrides.hittest.sprite.Path:** Adds hit testing methods to the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) sprite.
	 * Included by the [Ext.draw.PathUtil](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.PathUtil.html).
	 */
	class Path extends Ext.draw.sprite.Sprite {
		/** 
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		isPath?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @default 'path'
		 * @type {string}
		 */
		type?: string;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                     [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                    matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                     [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                    matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                     [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Plus](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Plus.html)
	 * A sprite that represents a plus.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'plus',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	class Plus extends Ext.draw.sprite.Path {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'path'}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Plus|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Plus;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                          [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Plus|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Plus;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                         matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                          [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Plus|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Plus;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Plus|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Plus;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                         matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                          [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Plus|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Plus;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Rect](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Rect.html)
	 * A sprite that represents a rectangle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'rect',
	 *           x: 50,
	 *           y: 50,
	 *           width: 100,
	 *           height: 100,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	class Rect extends Ext.draw.sprite.Path {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', width: 'number', height: 'number', radius: 'number'}, aliases: {}, triggers: {x: 'path', y: 'path', width: 'path', height: 'path', radius: 'path'}, defaults: {x: 0, y: 0, width: 8, height: 8, radius: 0}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default 'rect'
		 * @type {string}
		 */
		type?: string;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Rect|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Rect;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                          [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Rect|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Rect;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                         matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                          [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Rect|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Rect;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Rect|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Rect;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                         matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                          [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Rect|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Rect;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @param   {object} plain
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object, plain: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updateTransformedBBox](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updateTransformedBBox).
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Sector](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sector.html)
	 * A sprite representing a pie slice.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'sector',
	 *           centerX: 100,
	 *           centerY: 100,
	 *           startAngle: -2.355,
	 *           endAngle: -.785,
	 *           endRho: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	class Sector extends Ext.draw.sprite.Path {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {centerX: 'number', centerY: 'number', startAngle: 'number', endAngle: 'number', startRho: 'number', endRho: 'number', margin: 'number'}, aliases: {rho: 'endRho'}, triggers: {centerX: 'path,bbox', centerY: 'path,bbox', startAngle: 'path,bbox', endAngle: 'path,bbox', startRho: 'path,bbox', endRho: 'path,bbox', margin: 'path,bbox'}, defaults: {centerX: 0, centerY: 0, startAngle: 0, endAngle: 0, startRho: 0, endRho: 150, margin: 0, path: 'M 0,0'}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default 'sector'
		 * @type {string}
		 */
		type?: string;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Sector|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Sector;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                            [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Sector|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sector;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                           matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                            [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Sector|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sector;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Sector|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Sector;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                           matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                            [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Sector|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sector;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getMidAngle? (): void;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Sprite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html)
	 * A sprite is a basic primitive from the charts package which represents a graphical
	 * object that can be drawn. Sprites are used extensively in the charts package to
	 * create the visual elements of each chart.  You can also create a desired image by
	 * adding one or more sprites to a [draw container](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Container.html).
	 * 
	 * The Sprite class itself is an abstract class and is not meant to be used directly.<br/>
	 * There are many different kinds of sprites available in the charts package that extend
	 * [Ext.draw.sprite.Sprite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html). Each sprite type has various attributes that define how that
	 * sprite should look. For example, this is a [rect](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Rect.html) sprite:
	 * 
	 *    Ext.create({
	 *        xtype: 'draw', 
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400,
	 *        sprites: [{
	 *            type: 'rect',
	 *            x: 50,
	 *            y: 50,
	 *            width: 100,
	 *            height: 100,
	 *            fillStyle: '#1F6D91'
	 *        }]
	 *    });
	 * 
	 * By default, sprites are added to the default 'main' [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html)
	 * of the draw container.  However, sprites may also be configured with a reference to a
	 * specific [Ext.draw.Surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html) when set in the draw container's
	 * [sprites](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Container.html#cfg-sprites) config.  Specifying a surface
	 * other than 'main' will create a surface by that name if it does not already exist.
	 * 
	 *    Ext.create({
	 *        xtype: 'draw', 
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400,
	 *        sprites: [{
	 *            type: 'rect',
	 *            surface: 'anim',  // a surface with id "anim" will be created automatically
	 *            x: 50,
	 *            y: 50,
	 *            width: 100,
	 *            height: 100,
	 *            fillStyle: '#1F6D91'
	 *        }]
	 *    });
	 * 
	 * The ability to have multiple surfaces is useful for performance (and battery life)
	 * reasons. Because changes to sprite attributes cause the whole surface (and all
	 * sprites in it) to re-render, it makes sense to group sprites by surface, so changes
	 * to one group of sprites will only trigger the surface they are in to re-render.
	 * 
	 * You can add a sprite to an existing drawing by adding the sprite to a draw surface.
	 * 
	 *    var drawCt = Ext.create({
	 *        xtype: 'draw',
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400
	 *    });
	 *    
	 *    // If the surface name is not specified then 'main' will be used
	 *    var surface = drawCt.getSurface();
	 *    
	 *    surface.add({
	 *        type: 'rect',
	 *        x: 50,
	 *        y: 50,
	 *        width: 100,
	 *        height: 100,
	 *        fillStyle: '#1F6D91'
	 *    });
	 *    
	 *    surface.renderFrame();
	 * 
	 * **Note:** Changes to the sprites on a surface will be not be reflected in the DOM
	 * until you call the surface's [renderFrame](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-renderFrame)
	 * method.  This must be done after adding, removing, or modifying sprites in order to
	 * see the changes on-screen.
	 * 
	 * For information on configuring a sprite with an initial transformation see
	 * [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), rotation, and translation.
	 * 
	 * For information on applying a transformation to an existing sprite see the
	 * [Ext.draw.Matrix](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Matrix.html) class.
	 */
	class Sprite extends Ext.Base {
		/** 
		 * Debug rendering options:
		 * 
		 * debug: {
		 * 
		 *      bbox: true, // renders the bounding box of the sprite
		 *      xray: true  // renders control points of the path (for Ext.draw.sprite.Path and descendants only)
		 * 
		 * }
		 * @property
		 * @public (property)
		 * @static
		 * @default false
		 * @type {boolean}
		 */
		static debug?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * The visual attributes of the sprite, e.g. strokeStyle, fillStyle, lineWidth...
		 * @property
		 * @public (property)
		 * @type {object}
		 */
		attr?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		isSprite?: boolean;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * Performs a hit test on the sprite.
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]} matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                  [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Sprite}             This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]} matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                  [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Sprite}             This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain Target object.
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform Target object (transformed bounding box) to populate.
		 * @param   {object} plain     Untransformed bounding box.
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object, plain: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Square](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Square.html)
	 * A sprite that represents a square.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'square',
	 *           x: 100,
	 *           y: 100,
	 *           size: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	class Square extends Ext.draw.sprite.Path {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'size'}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Square|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Square;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                            [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Square|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Square;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                           matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                            [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Square|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Square;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Square|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Square;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                           matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                            [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Square|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Square;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Text](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Text.html)
	 * A sprite that represents text.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw',
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'text',
	 *           x: 50,
	 *           y: 50,
	 *           text: 'Sencha',
	 *           fontSize: 30,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	class Text extends Ext.draw.sprite.Sprite {
		/** 
		 * Debug rendering options:
		 * 
		 * debug: {
		 *     bbox: true // renders the bounding box of the text sprite
		 * }
		 * @property
		 * @public (property)
		 * @default false
		 * @type {boolean}
		 */
		debug?: boolean;
		/** 
		 * If the value is boolean, it overrides the TextMeasurer's 'precise' config
		 * (for the given sprite only).
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		preciseMeasurement?: object;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Text|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Text;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * Performs a hit test on the sprite.
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                     [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Text|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Text;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                    matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                     [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Text|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Text;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Text|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Text;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                    matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                     [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Text|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Text;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain Target object.
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform Target object (transformed bounding box) to populate.
		 * @param   {object} plain     Untransformed bounding box.
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object, plain: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Tick](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Tick.html)
	 * A veritical line sprite. The x and y configs set the center of the line with the size
	 * value determining the height of the line (the line will be twice the height of 'size'
	 * since 'size' is added to above and below 'y' to set the line endpoints).
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'tick',
	 *           x: 20,
	 *           y: 40,
	 *           size: 10,
	 *           strokeStyle: '#388FAD',
	 *           lineWidth: 2
	 *       }]
	 *    });
	 * 
	 */
	class Tick extends Ext.draw.sprite.Line {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Tick|Ext.draw.sprite.Line|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Tick;
		hide? (): Ext.draw.sprite.Line;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * Performs a hit test on the sprite.
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                          [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Tick|Ext.draw.sprite.Line|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Tick;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Line;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                         matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                          [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Tick|Ext.draw.sprite.Line|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Tick;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Line;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Tick|Ext.draw.sprite.Line|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Tick;
		show? (): Ext.draw.sprite.Line;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                         matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                          [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Tick|Ext.draw.sprite.Line|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Tick;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Line;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @param   {object} plain
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object, plain: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} bbox
		 * @param   {object} isTransform
		 * @param   {object} x1
		 * @param   {object} y1
		 * @param   {object} x2
		 * @param   {object} y2
		 * @returns {void}               
		 */
		updateLineBBox? (bbox: object, isTransform: object, x1: object, y1: object, x2: object, y2: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
	/** 
	 * [Ext.draw.sprite.Triangle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Triangle.html)
	 * A sprite that represents a triangle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'triangle',
	 *           size: 50,
	 *           translationX: 100,
	 *           translationY: 100,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	class Triangle extends Ext.draw.sprite.Path {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'path'}}
		 * @type {object}
		 */
		static def?: object;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Removes the sprite and clears all listeners.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the current animation instance.
		 * return {[Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html)} The animation modifier used to animate the
		 * sprite
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		getAnimation? (): void;
		/** 
		 * Returns the bounding box for the given Sprite as calculated with the Canvas engine.
		 * @method
		 * @public (method)
		 * @param   {boolean} [isWithoutTransform] Whether to calculate the bounding box with the current transforms or not.
		 * @returns {void}                         
		 */
		getBBox? (isWithoutTransform?: boolean): void;
		/** 
		 * Subclass can rewrite this function to gain better performance.
		 * @method
		 * @public (method)
		 * @param   {boolean} isWithoutTransform
		 * @returns {any[]}                      
		 */
		getBBoxCenter? (isWithoutTransform: boolean): any[];
		/** 
		 * Returns all points where this sprite intersects the given sprite.
		 * The given sprite must be an instance of the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) class
		 * or its subclass.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @returns {any[]}       
		 */
		getIntersections? (path: object): any[];
		/** 
		 * Hide the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Triangle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		hide? (): Ext.draw.sprite.Triangle;
		hide? (): Ext.draw.sprite.Path;
		hide? (): Ext.draw.sprite.Sprite;
		/** 
		 * **Defined in override Ext.draw.overrides.hittest.sprite.Path.**
		 * @method
		 * @public (method)
		 * @param   {any[]}  point   A two-item array containing x and y coordinates of the point.
		 * @param   {object} options Hit testing options.
		 * @returns {object} 
		 * A hit result object that contains more information about what
		 * exactly was hit or null if nothing was hit.
		 */
		hitTest? (point: any[], options: object): object;
		/** 
		 * Tests whether the given point is inside the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointInPath? (x: object, y: object): boolean;
		/** 
		 * Tests whether the given point is on the path.
		 * @method
		 * @public (method)
		 * @param   {object}  x
		 * @param   {object}  y
		 * @returns {boolean}   
		 */
		isPointOnPath? (x: object, y: object): boolean;
		/** 
		 * Called before rendering.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		preRender? (): void;
		/** 
		 * Removes this sprite from its surface.
		 * The sprite itself is not destroyed.
		 * @method
		 * @public (method)
		 * @returns {Ext.draw.sprite.Sprite}  Returns the removed sprite or `null` otherwise.
		 */
		remove? (): Ext.draw.sprite.Sprite;
		/** 
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {any}    
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: object, ctx: object): any;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Sprite.render](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-render).
		 * Render method.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Surface} surface The surface.
		 * @param   {object}           ctx     A context object compatible with CanvasRenderingContext2D.
		 * @param   {any[]}            rect
		 * The clip rect (or called dirty rect) of the current rendering. Not to be confused
		 * with `surface.getRect()`.
		 * @returns {any}              
		 * returns `false` to stop rendering in this frame.
		 * All the sprites that haven't been rendered will have their dirty flag untouched.
		 */
		render? (surface: Ext.draw.Surface, ctx: object, rect: any[]): any;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                                                              [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Triangle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Triangle;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Path;
		resetTransform? (isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Sets the animation config used by the sprite when animating the sprite's
		 * attributes and transformation properties.
		 * 
		 *    var drawCt = Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: document.body,
		 *        width: 400,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91'
		 *        }]
		 *    });
		 *    
		 *    var rect = drawCt.getSurface().getItems()[0];
		 *    
		 *    rect.setAnimation({
		 *        duration: 1000,
		 *        easing: 'elasticOut'
		 *    });
		 *    
		 *    Ext.defer(function () {
		 *        rect.setAttributes({
		 *            width: 250
		 *        });
		 *    }, 500);
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 * The [Ext.draw.modifier.Animation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.modifier.Animation.html) config for this sprite's
		 * animations.
		 * @returns {void}          
		 */
		setAnimation? (config: object): void;
		/** 
		 * Set attributes of the sprite.
		 * By default only the attributes that have processors will be set
		 * and all other attributes will be filtered out as a result of the
		 * normalization process.
		 * The normalization process can be skipped. In that case all the given
		 * attributes will be set unprocessed. This will result in better
		 * performance, but might also pollute the sprite's attributes with
		 * unwanted attributes or attributes with invalid values, if one is not
		 * careful. See also [setAttributesBypassingNormalization](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributesBypassingNormalization).
		 * If normalization is skipped, one may also chose to avoid copying
		 * the given object. This may result in even better performance, but
		 * only in cases where most of the attributes have values that are
		 * different from the old values, because copying additionally checks
		 * if the value has changed.
		 * @method
		 * @public (method)
		 * @param   {object}  changes               The content of the change.
		 * @param   {boolean} [bypassNormalization] `true` to avoid normalization of the given changes.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * `bypassNormalization` should also be `true`. The content of object may be destroyed.
		 * @returns {void}                          
		 */
		setAttributes? (changes: object, bypassNormalization?: boolean, avoidCopy?: boolean): void;
		/** 
		 * Set attributes of the sprite, assuming the names and values have already been
		 * normalized.
		 * @method
		 * @public (method)
		 * @param   {object}  changes     The content of the change.
		 * @param   {boolean} [avoidCopy]
		 * `true` to avoid copying the `changes` object.
		 * The content of object may be destroyed.
		 * @returns {void}                
		 */
		setAttributesBypassingNormalization? (changes: object, avoidCopy?: boolean): void;
		/** 
		 * Resets current transformation matrix of a sprite to the identify matrix
		 * and pre-multiplies it with the given matrix.
		 * This is effectively the same as calling [resetTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-resetTransform),
		 * followed by [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform) with the same arguments.
		 * 
		 * See also: [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-transform)
		 * 
		 *    var drawContainer = new Ext.draw.Container({
		 *        renderTo: Ext.getBody(),
		 *        width: 380,
		 *        height: 380,
		 *        sprites: [{
		 *            type: 'rect',
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: 'red'
		 *        }]
		 *    });
		 *    
		 *    var main = drawContainer.getSurface();
		 *    var rect = main.getItems()[0];
		 *    
		 *    var m = new Ext.draw.Matrix().rotate(Math.PI, 100, 100);
		 *    
		 *    rect.setTransform(m);
		 *    main.renderFrame();
		 * 
		 * There may be times where the transformation you need to apply cannot easily be
		 * accomplished using the sprite’s convenience transform methods.  Or, you may want
		 * to pass a matrix directly to the sprite in order to set a transformation.  The
		 * `setTransform` method allows for this sort of advanced usage as well.  The
		 * following tables show each transformation matrix used when applying
		 * transformations to a sprite.
		 * 
		 * ### Translate
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">tx</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>ty</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Rotate (θ is the angle of rotation)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">cos(θ)</td>
		 *          <td style="font-weight: normal;">-sin(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Scale
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">sx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>cos(θ)</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear X _(λ is the distance on the x axis to shear by)_
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">λx</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Shear Y (λ is the distance on the y axis to shear by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>λy</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew X (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">tan(θ)</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * 
		 * ### Skew Y (θ is the angle to skew by)
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">1</td>
		 *          <td style="font-weight: normal;">0</td>
		 *          <td style="font-weight: normal;">0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>tan(θ)</td>
		 *          <td>1</td>
		 *          <td>0</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 *  
		 *  
		 *  
		 *  
		 *  Multiplying matrices for translation, rotation, scaling, and shearing / skewing
		 *  any number of times in the desired order produces a single matrix for a composite
		 *  transformation.  You can use the product as a value for the `setTransform`method
		 *  of a sprite:
		 * 
		 *    mySprite.setTransform([a, b, c, d, e, f]);
		 * 
		 * Where `a`, `b`, `c`, `d`, `e`, `f` are numeric values that correspond to the
		 * following transformation matrix components:
		 * 
		 * <table style="text-align: center;">
		 * 
		 *      <tr>
		 *          <td style="font-weight: normal;">a</td>
		 *          <td style="font-weight: normal;">c</td>
		 *          <td style="font-weight: normal;">e</td>
		 *      </tr>
		 *      <tr>
		 *          <td>b</td>
		 *          <td>d</td>
		 *          <td>f</td>
		 *      </tr>
		 *      <tr>
		 *          <td>0</td>
		 *          <td>0</td>
		 *          <td>1</td>
		 *      </tr>
		 * 
		 * </table>
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                             matrix
		 * The transformation matrix to apply or its
		 * raw elements as an array.
		 * @param   {boolean}                                                              [isSplit] If `true`, transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Triangle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Triangle;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		setTransform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Show the sprite.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.draw.sprite.Triangle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}  this
		 */
		show? (): Ext.draw.sprite.Triangle;
		show? (): Ext.draw.sprite.Path;
		show? (): Ext.draw.sprite.Sprite;
		/** 
		 * Pre-multiplies the current transformation matrix of a sprite with the given matrix.
		 * If `isSplit` parameter is `true`, the resulting matrix is also split into
		 * individual components (scaling, rotation, translation) and corresponding sprite
		 * attributes are updated. The shearing component is not extracted.
		 * Note, that transformation attributes work as if transformations are applied to the
		 * local coordinate system of a sprite, while matrix transformations transform
		 * the global coordinate space or the surface grid.
		 * Since the `transform` method returns the sprite itself, calls to the method
		 * can be chained. And if updating sprite transformation attributes is desired,
		 * it can be achieved by setting the `isSplit` parameter of the last call to `true`.
		 * For example:
		 * 
		 *    sprite.transform(matrixA).transform(matrixB).transform(matrixC, true);
		 * 
		 * See also: [setTransform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setTransform)
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.draw.Matrix|number[]}                                             matrix    A transformation matrix or array of its elements.
		 * @param   {boolean}                                                              [isSplit] If 'true', transformation attributes are updated.
		 * @returns {Ext.draw.sprite.Triangle|Ext.draw.sprite.Path|Ext.draw.sprite.Sprite}           This sprite.
		 */
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Triangle;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Path;
		transform? (matrix: Ext.draw.Matrix | number[], isSplit?: boolean): Ext.draw.sprite.Sprite;
		/** 
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {object} path
		 * @param   {object} attr
		 * @returns {void}        
		 */
		updatePath? (path: object, attr: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.draw.sprite.Path.updatePath](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html#method-updatePath).
		 * Update the path.
		 * @method
		 * @public (method)
		 * @param   {Ext.draw.Path} path An empty path to draw on using path API.
		 * @param   {object}        attr
		 * The attribute object. Note: DO NOT use the `sprite.attr` instead of this
		 * if you want to work with instancing.
		 * @returns {void}               
		 */
		updatePath? (path: Ext.draw.Path, attr: object): void;
		/** 
		 * Applies sprite's attributes to the given context.
		 * @method
		 * @public (method)
		 * @param   {object} ctx  Context to apply sprite's attributes to.
		 * @param   {any[]}  rect The rect of the context to be affected by gradients.
		 * @returns {void}        
		 */
		useAttributes? (ctx: object, rect: any[]): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the plain bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} plain
		 * @returns {void}         
		 */
		updatePlainBBox? (plain: object): void;
		/** 
		 * Subclass will fill the plain object with `x`, `y`, `width`, `height` information
		 * of the transformed bounding box of this sprite.
		 * @method
		 * @protected (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		updateTransformedBBox? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} modifier
		 * @param   {object} reinitializeAttributes
		 * @returns {void}                          
		 */
		addModifier? (modifier: object, reinitializeAttributes: object): void;
		/** 
		 * Calculates forward and inverse transform matrices from sprite's attributes.
		 * Transformations are applied in the following order: Scaling, Rotation, Translation.
		 * @method
		 * @private (method)
		 * @param   {boolean} [force]
		 * Forces recalculation of transform matrices even when
		 * sprite's transform attributes supposedly haven't changed.
		 * @returns {void}            
		 */
		applyTransformations? (force?: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @returns {void}        
		 */
		bboxUpdater? (attr: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} attr
		 * @param   {object} updater
		 * @param   {object} triggers
		 * @returns {void}            
		 */
		callUpdater? (attr: object, updater: object, triggers: object): void;
		/** 
		 * Calls updaters triggered by changes to sprite attributes.
		 * @method
		 * @private (method)
		 * @param   {object} attr The attributes of a sprite or its instance.
		 * @returns {void}        
		 */
		callUpdaters? (attr: object): void;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-dirty).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}  
		 */
		getParent? (): Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Returns the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @returns {Ext.draw.Surface}  
		 */
		getSurface? (): Ext.draw.Surface;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		initializeAttributes? (): void;
		/** 
		 * Checks if the sprite can be seen.
		 * This includes the `hidden` attribute check, alpha/opacity checks,
		 * fill/stroke color checks and surface/parent checks.
		 * The method doesn't check if the sprite is off-screen.
		 * @method
		 * @private (method)
		 * @returns {boolean}  Returns `true`, if the sprite can be seen.
		 */
		isVisible? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} subClass
		 * @param   {object} data
		 * @returns {void}            
		 */
		onClassExtended? (subClass: object, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} additionalModifiers
		 * @returns {void}                       
		 */
		prepareModifiers? (additionalModifiers: object): void;
		/** 
		 * Renders the bounding box of transformed sprite.
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderBBox? (surface: object, ctx: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} surface
		 * @param   {object} ctx
		 * @returns {void}           
		 */
		renderXRay? (surface: object, ctx: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		repaint? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object}   attr       {Object} The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object}   updater    {String} Updater to be called.
		 * @param   {string[]} [triggers] Attributes that triggered the update.
		 * @returns {void}                
		 */
		scheduleUpdater? (attr: object, updater: object, triggers?: string[]): void;
		/** 
		 * Schedules specified updaters to be called.
		 * Updaters are called implicitly as a result of a change to sprite attributes.
		 * But sometimes it may be required to call an updater without setting an attribute,
		 * and without messing up the updater call order (by calling the updater immediately).
		 * For example:
		 * 
		 *    updaters: {
		 *         onDataX: function (attr) {
		 *             this.processDataX();
		 *             // Process data Y every time data X is processed.
		 *             // Call the onDataY updater as if changes to dataY attribute itself
		 *             // triggered the update.
		 *             this.scheduleUpdaters(attr, {onDataY: ['dataY']});
		 *             // Alternatively:
		 *             // this.scheduleUpdaters(attr, ['onDataY'], ['dataY']);
		 *         }
		 *    }
		 * 
		 * @method
		 * @private (method)
		 * @param   {object}          attr       The attributes object (not necesseraly of a sprite, but of its instance).
		 * @param   {object|string[]} updaters   A map of updaters to be called to attributes that triggered the update.
		 * @param   {string[]}        [triggers]
		 * Attributes that triggered the update. An optional parameter.
		 * If used, the `updaters` parameter will be treated as an array of updaters to be called.
		 * @returns {void}                       
		 */
		scheduleUpdaters? (attr: object, updaters: object | string[], triggers?: string[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} dirty
		 * @returns {void}         
		 */
		setDirty? (dirty: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} ctx
		 * @param   {object} rect
		 * @returns {void}        
		 */
		setGradientBBox? (ctx: object, rect: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-parent).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite} parent The new value.
		 * @returns {void}                                                                         
		 */
		setParent? (parent: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite): void;
		/** 
		 * Sets the value of [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-surface).
		 * @method
		 * @private (method)
		 * @param   {Ext.draw.Surface} surface The new value.
		 * @returns {void}                     
		 */
		setSurface? (surface: Ext.draw.Surface): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		updateTransformAttributes? (): void;
	}
}
declare namespace Ext.draw {
	class sprite {
		/** 
		 * Parsers used for sprite attributes if they are [normalized](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.AttributeDefinition.html#method-normalize)
		 * (default) when being [set](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributes).
		 * 
		 * Methods of the singleton correpond either to the processor functions themselves or processor factories.
		 * @private (class)
		 * @singleton (instance)
		 */
		static readonly AttributeParser?: Ext.draw.sprite.AttributeParser;
	}
}
declare namespace Ext.draw.sprite.Arc {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Arc](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Arc.html)
	 * A sprite that represents a circular arc.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'arc',
	 *           cx: 100,
	 *           cy: 100,
	 *           r: 80,
	 *           fillStyle: '#1F6D91',
	 *           startAngle: 0,
	 *           endAngle: Math.PI,
	 *           anticlockwise: true
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Arc {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Arc.Cfg}
		 */
		config?: Ext.draw.sprite.Arc.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Arc.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Arc.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Arrow {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Arrow](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Arrow.html)
	 * A sprite that represents an arrow.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'arrow',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#30BDA7'
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Arrow {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Arrow.Cfg}
		 */
		config?: Ext.draw.sprite.Arrow.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Arrow.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Arrow.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Circle {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Circle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Circle.html)
	 * A sprite that represents a circle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'circle',
	 *           cx: 100,
	 *           cy: 100,
	 *           r: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Circle {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Circle.Cfg}
		 */
		config?: Ext.draw.sprite.Circle.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Circle.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Circle.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Composite {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Composite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Composite.html)
	 * Represents a group of sprites.
	 */
	interface Def extends Ext.draw.sprite.Composite {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Composite.Cfg}
		 */
		config?: Ext.draw.sprite.Composite.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Composite.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Composite.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Cross {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Cross](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Cross.html)
	 * A sprite that represents a cross.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'cross',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Cross {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Cross.Cfg}
		 */
		config?: Ext.draw.sprite.Cross.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Cross.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Cross.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Diamond {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Diamond](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Diamond.html)
	 * A sprite that represents a diamond.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'diamond',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Diamond {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Diamond.Cfg}
		 */
		config?: Ext.draw.sprite.Diamond.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Diamond.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Diamond.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Ellipse {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Ellipse](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Ellipse.html)
	 * A sprite that represents an ellipse.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'ellipse',
	 *           cx: 100,
	 *           cy: 100,
	 *           rx: 80,
	 *           ry: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Ellipse {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Ellipse.Cfg}
		 */
		config?: Ext.draw.sprite.Ellipse.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Ellipse.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Ellipse.Statics | any;
	}
}
declare namespace Ext.draw.sprite.EllipticalArc {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.EllipticalArc](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.EllipticalArc.html)
	 * A sprite that represents an elliptical arc.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'ellipticalArc',
	 *           cx: 100,
	 *           cy: 100,
	 *           rx: 80,
	 *           ry: 50,
	 *           fillStyle: '#1F6D91',
	 *           startAngle: 0,
	 *           endAngle: Math.PI,
	 *           anticlockwise: true
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.EllipticalArc {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.EllipticalArc.Cfg}
		 */
		config?: Ext.draw.sprite.EllipticalArc.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.EllipticalArc.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.EllipticalArc.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Image {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Image](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Image.html)
	 * A sprite that represents an image.
	 */
	interface Def extends Ext.draw.sprite.Image {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Image.Cfg}
		 */
		config?: Ext.draw.sprite.Image.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Image.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Image.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Instancing {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Instancing](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Instancing.html)
	 * Sprite that represents multiple instances based on the given template.
	 * 
	 * **From override Ext.draw.overrides.hittest.sprite.Instancing:** Adds hit testing methods to the [Ext.draw.sprite.Instancing](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Instancing.html).
	 * Included by the [Ext.draw.plugin.SpriteEvents](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.plugin.SpriteEvents.html).
	 */
	interface Def extends Ext.draw.sprite.Instancing {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Instancing.Cfg}
		 */
		config?: Ext.draw.sprite.Instancing.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Instancing.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Instancing.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Line {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Line](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Line.html)
	 * A sprite that represents a line.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'line',
	 *           fromX: 20,
	 *           fromY: 20,
	 *           toX: 120,
	 *           toY: 120,
	 *           strokeStyle: '#1F6D91',
	 *           lineWidth: 3
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Line {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Line.Cfg}
		 */
		config?: Ext.draw.sprite.Line.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Line.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Line.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Path {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html)
	 * A sprite that represents a path.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'path',
	 *           path: 'M20,30 c0,-50 75,50 75,0 c0,-50 -75,50 -75,0',
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 * ### Drawing with SVG Paths
	 * 
	 * You may use special SVG Path syntax to "describe" the drawing path.  Here are the SVG path commands:
	 * 
	 * - M = moveto
	 * - L = lineto
	 * - H = horizontal lineto
	 * - V = vertical lineto
	 * - C = curveto
	 * - S = smooth curveto
	 * - Q = quadratic Bézier curve
	 * - T = smooth quadratic Bézier curveto
	 * - A = elliptical Arc
	 * - Z = closepath
	 * 
	 * **Note:** Capital letters indicate that the item should be absolutely positioned.
	 * Use lower case letters for relative positioning.
	 * 
	 * **From override Ext.draw.overrides.hittest.sprite.Path:** Adds hit testing methods to the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) sprite.
	 * Included by the [Ext.draw.PathUtil](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.PathUtil.html).
	 */
	interface Def extends Ext.draw.sprite.Path {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Path.Cfg}
		 */
		config?: Ext.draw.sprite.Path.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Path.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Path.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Plus {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Plus](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Plus.html)
	 * A sprite that represents a plus.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'plus',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Plus {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Plus.Cfg}
		 */
		config?: Ext.draw.sprite.Plus.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Plus.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Plus.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Rect {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Rect](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Rect.html)
	 * A sprite that represents a rectangle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'rect',
	 *           x: 50,
	 *           y: 50,
	 *           width: 100,
	 *           height: 100,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Rect {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Rect.Cfg}
		 */
		config?: Ext.draw.sprite.Rect.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Rect.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Rect.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Sector {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Sector](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sector.html)
	 * A sprite representing a pie slice.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'sector',
	 *           centerX: 100,
	 *           centerY: 100,
	 *           startAngle: -2.355,
	 *           endAngle: -.785,
	 *           endRho: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Sector {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Sector.Cfg}
		 */
		config?: Ext.draw.sprite.Sector.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Sector.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Sector.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Sprite {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Sprite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html)
	 * A sprite is a basic primitive from the charts package which represents a graphical
	 * object that can be drawn. Sprites are used extensively in the charts package to
	 * create the visual elements of each chart.  You can also create a desired image by
	 * adding one or more sprites to a [draw container](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Container.html).
	 * 
	 * The Sprite class itself is an abstract class and is not meant to be used directly.<br/>
	 * There are many different kinds of sprites available in the charts package that extend
	 * [Ext.draw.sprite.Sprite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html). Each sprite type has various attributes that define how that
	 * sprite should look. For example, this is a [rect](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Rect.html) sprite:
	 * 
	 *    Ext.create({
	 *        xtype: 'draw', 
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400,
	 *        sprites: [{
	 *            type: 'rect',
	 *            x: 50,
	 *            y: 50,
	 *            width: 100,
	 *            height: 100,
	 *            fillStyle: '#1F6D91'
	 *        }]
	 *    });
	 * 
	 * By default, sprites are added to the default 'main' [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html)
	 * of the draw container.  However, sprites may also be configured with a reference to a
	 * specific [Ext.draw.Surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html) when set in the draw container's
	 * [sprites](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Container.html#cfg-sprites) config.  Specifying a surface
	 * other than 'main' will create a surface by that name if it does not already exist.
	 * 
	 *    Ext.create({
	 *        xtype: 'draw', 
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400,
	 *        sprites: [{
	 *            type: 'rect',
	 *            surface: 'anim',  // a surface with id "anim" will be created automatically
	 *            x: 50,
	 *            y: 50,
	 *            width: 100,
	 *            height: 100,
	 *            fillStyle: '#1F6D91'
	 *        }]
	 *    });
	 * 
	 * The ability to have multiple surfaces is useful for performance (and battery life)
	 * reasons. Because changes to sprite attributes cause the whole surface (and all
	 * sprites in it) to re-render, it makes sense to group sprites by surface, so changes
	 * to one group of sprites will only trigger the surface they are in to re-render.
	 * 
	 * You can add a sprite to an existing drawing by adding the sprite to a draw surface.
	 * 
	 *    var drawCt = Ext.create({
	 *        xtype: 'draw',
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400
	 *    });
	 *    
	 *    // If the surface name is not specified then 'main' will be used
	 *    var surface = drawCt.getSurface();
	 *    
	 *    surface.add({
	 *        type: 'rect',
	 *        x: 50,
	 *        y: 50,
	 *        width: 100,
	 *        height: 100,
	 *        fillStyle: '#1F6D91'
	 *    });
	 *    
	 *    surface.renderFrame();
	 * 
	 * **Note:** Changes to the sprites on a surface will be not be reflected in the DOM
	 * until you call the surface's [renderFrame](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-renderFrame)
	 * method.  This must be done after adding, removing, or modifying sprites in order to
	 * see the changes on-screen.
	 * 
	 * For information on configuring a sprite with an initial transformation see
	 * [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), rotation, and translation.
	 * 
	 * For information on applying a transformation to an existing sprite see the
	 * [Ext.draw.Matrix](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Matrix.html) class.
	 */
	interface Def extends Ext.draw.sprite.Sprite {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Sprite.Cfg}
		 */
		config?: Ext.draw.sprite.Sprite.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Sprite.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Sprite.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Square {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Square](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Square.html)
	 * A sprite that represents a square.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'square',
	 *           x: 100,
	 *           y: 100,
	 *           size: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Square {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Square.Cfg}
		 */
		config?: Ext.draw.sprite.Square.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Square.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Square.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Text {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Text](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Text.html)
	 * A sprite that represents text.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw',
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'text',
	 *           x: 50,
	 *           y: 50,
	 *           text: 'Sencha',
	 *           fontSize: 30,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Text {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Text.Cfg}
		 */
		config?: Ext.draw.sprite.Text.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Text.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Text.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Tick {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Tick](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Tick.html)
	 * A veritical line sprite. The x and y configs set the center of the line with the size
	 * value determining the height of the line (the line will be twice the height of 'size'
	 * since 'size' is added to above and below 'y' to set the line endpoints).
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'tick',
	 *           x: 20,
	 *           y: 40,
	 *           size: 10,
	 *           strokeStyle: '#388FAD',
	 *           lineWidth: 2
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Tick {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Tick.Cfg}
		 */
		config?: Ext.draw.sprite.Tick.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Tick.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Tick.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Triangle {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.draw.sprite.Triangle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Triangle.html)
	 * A sprite that represents a triangle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'triangle',
	 *           size: 50,
	 *           translationX: 100,
	 *           translationY: 100,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Def extends Ext.draw.sprite.Triangle {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.draw.sprite.Triangle.Cfg}
		 */
		config?: Ext.draw.sprite.Triangle.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.Base.Statics}  
		 * @type {Ext.draw.sprite.Triangle.Statics}
		 */
		statics?: (() => Ext.Base.Statics) | Ext.draw.sprite.Triangle.Statics | any;
	}
}
declare namespace Ext.draw.sprite.Arc {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Arc](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Arc.html)
	 * A sprite that represents a circular arc.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'arc',
	 *           cx: 100,
	 *           cy: 100,
	 *           r: 80,
	 *           fillStyle: '#1F6D91',
	 *           startAngle: 0,
	 *           endAngle: Math.PI,
	 *           anticlockwise: true
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Arrow {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Arrow](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Arrow.html)
	 * A sprite that represents an arrow.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'arrow',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#30BDA7'
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'path'}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.AttributeDefinition {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.AttributeDefinition](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.AttributeDefinition.html)
	 * Flyweight object to process the attributes of a sprite.
	 * A single instance of the AttributeDefinition is created per sprite class.
	 * See `onClassCreated` and `onClassExtended` callbacks
	 * of the [Ext.draw.sprite.Sprite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html) for more info.
	 */
	interface Statics extends Ext.base.Statics {
	}
}
declare namespace Ext.draw.sprite.Circle {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Circle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Circle.html)
	 * A sprite that represents a circle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'circle',
	 *           cx: 100,
	 *           cy: 100,
	 *           r: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {cx: 'number', cy: 'number', r: 'number'}, aliases: {radius: 'r', x: 'cx', y: 'cy', centerX: 'cx', centerY: 'cy'}, defaults: {cx: 0, cy: 0, r: 4}, triggers: {cx: 'path', cy: 'path', r: 'path'}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Cross {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Cross](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Cross.html)
	 * A sprite that represents a cross.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'cross',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'path'}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Diamond {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Diamond](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Diamond.html)
	 * A sprite that represents a diamond.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'diamond',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'path'}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Ellipse {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Ellipse](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Ellipse.html)
	 * A sprite that represents an ellipse.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'ellipse',
	 *           cx: 100,
	 *           cy: 100,
	 *           rx: 80,
	 *           ry: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {cx: "number", cy: "number", rx: "number", ry: "number", axisRotation: "number"}, aliases: {radius: "r", x: "cx", y: "cy", centerX: "cx", centerY: "cy", radiusX: "rx", radiusY: "ry"}, defaults: {cx: 0, cy: 0, rx: 1, ry: 1, axisRotation: 0}, triggers: {cx: 'path', cy: 'path', rx: 'path', ry: 'path', axisRotation: 'path'}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.EllipticalArc {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.EllipticalArc](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.EllipticalArc.html)
	 * A sprite that represents an elliptical arc.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'ellipticalArc',
	 *           cx: 100,
	 *           cy: 100,
	 *           rx: 80,
	 *           ry: 50,
	 *           fillStyle: '#1F6D91',
	 *           startAngle: 0,
	 *           endAngle: Math.PI,
	 *           anticlockwise: true
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Image {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Image](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Image.html)
	 * A sprite that represents an image.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {src: 'string'}, triggers: {src: 'src'}, updaters: {src: 'updateSource'}, defaults: {src: '', width: null, height: null}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Line {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Line](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Line.html)
	 * A sprite that represents a line.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'line',
	 *           fromX: 20,
	 *           fromY: 20,
	 *           toX: 120,
	 *           toY: 120,
	 *           strokeStyle: '#1F6D91',
	 *           lineWidth: 3
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {fromX: 'number', fromY: 'number', toX: 'number', toY: 'number'}, defaults: {fromX: 0, fromY: 0, toX: 1, toY: 1, strokeStyle: 'black'}, aliases: {x1: 'fromX', y1: 'fromY', x2: 'toX', y2: 'toY'}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Plus {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Plus](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Plus.html)
	 * A sprite that represents a plus.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'plus',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'path'}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Rect {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Rect](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Rect.html)
	 * A sprite that represents a rectangle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'rect',
	 *           x: 50,
	 *           y: 50,
	 *           width: 100,
	 *           height: 100,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', width: 'number', height: 'number', radius: 'number'}, aliases: {}, triggers: {x: 'path', y: 'path', width: 'path', height: 'path', radius: 'path'}, defaults: {x: 0, y: 0, width: 8, height: 8, radius: 0}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Sector {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Sector](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sector.html)
	 * A sprite representing a pie slice.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'sector',
	 *           centerX: 100,
	 *           centerY: 100,
	 *           startAngle: -2.355,
	 *           endAngle: -.785,
	 *           endRho: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {centerX: 'number', centerY: 'number', startAngle: 'number', endAngle: 'number', startRho: 'number', endRho: 'number', margin: 'number'}, aliases: {rho: 'endRho'}, triggers: {centerX: 'path,bbox', centerY: 'path,bbox', startAngle: 'path,bbox', endAngle: 'path,bbox', startRho: 'path,bbox', endRho: 'path,bbox', margin: 'path,bbox'}, defaults: {centerX: 0, centerY: 0, startAngle: 0, endAngle: 0, startRho: 0, endRho: 150, margin: 0, path: 'M 0,0'}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Sprite {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Sprite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html)
	 * A sprite is a basic primitive from the charts package which represents a graphical
	 * object that can be drawn. Sprites are used extensively in the charts package to
	 * create the visual elements of each chart.  You can also create a desired image by
	 * adding one or more sprites to a [draw container](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Container.html).
	 * 
	 * The Sprite class itself is an abstract class and is not meant to be used directly.<br/>
	 * There are many different kinds of sprites available in the charts package that extend
	 * [Ext.draw.sprite.Sprite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html). Each sprite type has various attributes that define how that
	 * sprite should look. For example, this is a [rect](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Rect.html) sprite:
	 * 
	 *    Ext.create({
	 *        xtype: 'draw', 
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400,
	 *        sprites: [{
	 *            type: 'rect',
	 *            x: 50,
	 *            y: 50,
	 *            width: 100,
	 *            height: 100,
	 *            fillStyle: '#1F6D91'
	 *        }]
	 *    });
	 * 
	 * By default, sprites are added to the default 'main' [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html)
	 * of the draw container.  However, sprites may also be configured with a reference to a
	 * specific [Ext.draw.Surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html) when set in the draw container's
	 * [sprites](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Container.html#cfg-sprites) config.  Specifying a surface
	 * other than 'main' will create a surface by that name if it does not already exist.
	 * 
	 *    Ext.create({
	 *        xtype: 'draw', 
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400,
	 *        sprites: [{
	 *            type: 'rect',
	 *            surface: 'anim',  // a surface with id "anim" will be created automatically
	 *            x: 50,
	 *            y: 50,
	 *            width: 100,
	 *            height: 100,
	 *            fillStyle: '#1F6D91'
	 *        }]
	 *    });
	 * 
	 * The ability to have multiple surfaces is useful for performance (and battery life)
	 * reasons. Because changes to sprite attributes cause the whole surface (and all
	 * sprites in it) to re-render, it makes sense to group sprites by surface, so changes
	 * to one group of sprites will only trigger the surface they are in to re-render.
	 * 
	 * You can add a sprite to an existing drawing by adding the sprite to a draw surface.
	 * 
	 *    var drawCt = Ext.create({
	 *        xtype: 'draw',
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400
	 *    });
	 *    
	 *    // If the surface name is not specified then 'main' will be used
	 *    var surface = drawCt.getSurface();
	 *    
	 *    surface.add({
	 *        type: 'rect',
	 *        x: 50,
	 *        y: 50,
	 *        width: 100,
	 *        height: 100,
	 *        fillStyle: '#1F6D91'
	 *    });
	 *    
	 *    surface.renderFrame();
	 * 
	 * **Note:** Changes to the sprites on a surface will be not be reflected in the DOM
	 * until you call the surface's [renderFrame](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-renderFrame)
	 * method.  This must be done after adding, removing, or modifying sprites in order to
	 * see the changes on-screen.
	 * 
	 * For information on configuring a sprite with an initial transformation see
	 * [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), rotation, and translation.
	 * 
	 * For information on applying a transformation to an existing sprite see the
	 * [Ext.draw.Matrix](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Matrix.html) class.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Debug rendering options:
		 * 
		 * debug: {
		 * 
		 *      bbox: true, // renders the bounding box of the sprite
		 *      xray: true  // renders control points of the path (for Ext.draw.sprite.Path and descendants only)
		 * 
		 * }
		 * @property
		 * @public (property)
		 * @static
		 * @default false
		 * @type {boolean}
		 */
		debug?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Square {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Square](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Square.html)
	 * A sprite that represents a square.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'square',
	 *           x: 100,
	 *           y: 100,
	 *           size: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'size'}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Tick {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Tick](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Tick.html)
	 * A veritical line sprite. The x and y configs set the center of the line with the size
	 * value determining the height of the line (the line will be twice the height of 'size'
	 * since 'size' is added to above and below 'y' to set the line endpoints).
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'tick',
	 *           x: 20,
	 *           y: 40,
	 *           size: 10,
	 *           strokeStyle: '#388FAD',
	 *           lineWidth: 2
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Triangle {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.draw.sprite.Triangle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Triangle.html)
	 * A sprite that represents a triangle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'triangle',
	 *           size: 50,
	 *           translationX: 100,
	 *           translationY: 100,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default {processors: {x: 'number', y: 'number', size: 'number'}, defaults: {x: 0, y: 0, size: 4}, triggers: {x: 'path', y: 'path', size: 'path'}}
		 * @type {object}
		 */
		def?: object;
	}
}
declare namespace Ext.draw.sprite.Arc {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Arc](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Arc.html)
	 * A sprite that represents a circular arc.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'arc',
	 *           cx: 100,
	 *           cy: 100,
	 *           r: 80,
	 *           fillStyle: '#1F6D91',
	 *           startAngle: 0,
	 *           endAngle: Math.PI,
	 *           anticlockwise: true
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Determines whether or not the arc is drawn clockwise.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		anticlockwise?: boolean;
		/** 
		 * The center coordinate of the sprite on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		cx?: number;
		/** 
		 * The center coordinate of the sprite on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		cy?: number;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The ending angle of the arc.
		 * @configuration
		 * @optional
		 * @default Math.PI*2
		 * @type {number}
		 */
		endAngle?: number;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * The radius of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		r?: number;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The beginning angle of the arc.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		startAngle?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.draw.sprite.Arc.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Arc.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Arc.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Arc.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Arc.Statics}  
		 */
		statics? (): Ext.draw.sprite.Arc.Statics;
	}
}
declare namespace Ext.draw.sprite.Arrow {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Arrow](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Arrow.html)
	 * A sprite that represents an arrow.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'arrow',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#30BDA7'
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The size of the sprite.
		 * Meant to be comparable to the size of a circle sprite with the same radius.
		 * @configuration
		 * @optional
		 * @default 4
		 * @type {number}
		 */
		size?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                        config
		 * @returns {Ext.draw.sprite.Arrow.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Arrow.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                 name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                        [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Arrow.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Arrow.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Arrow.Statics}  
		 */
		statics? (): Ext.draw.sprite.Arrow.Statics;
	}
}
declare namespace Ext.draw.sprite.AttributeDefinition {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.AttributeDefinition](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.AttributeDefinition.html)
	 * Flyweight object to process the attributes of a sprite.
	 * A single instance of the AttributeDefinition is created per sprite class.
	 * See `onClassCreated` and `onClassExtended` callbacks
	 * of the [Ext.draw.sprite.Sprite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html) for more info.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * Defines the alternative names for attributes.
		 * @configuration
		 * @optional
		 * @default {}
		 * @type {object}
		 */
		aliases?: object;
		/** 
		 * Defines the process used to animate between attributes.
		 * One doesn't have to define animation processors for sprite attributes that use
		 * predefined [processors](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.AttributeDefinition.html#cfg-processors) from the [Ext.draw.sprite.AttributeParser](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.AttributeParser.html) singleton.
		 * For such attributes matching animation processors from the [Ext.draw.sprite.AnimationParser](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.AnimationParser.html)
		 * singleton will be used automatically.
		 * However, if you have a custom processor for an attribute that should support
		 * animation, you must provide a corresponding animation processor for it here.
		 * For more information on animation processors please see [Ext.draw.sprite.AnimationParser](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.AnimationParser.html)
		 * documentation.
		 * @configuration
		 * @optional
		 * @default {}
		 * @type {object}
		 */
		animationProcessors?: object;
		/** 
		 * Defines the default values of attributes.
		 * @configuration
		 * @optional
		 * @default {$value: {}, lazy: true}
		 * @type {object}
		 */
		defaults?: object;
		/** 
		 * @configuration
		 * @optional
		 * @default {}
		 * @type {object}
		 */
		dirtyTriggers?: object;
		/** 
		 * Defines the preprocessing used on the attributes.
		 * One can define a custom processor function here or use the name of a predefined
		 * processor from the [Ext.draw.sprite.AttributeParser](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.AttributeParser.html) singleton.
		 * @configuration
		 * @optional
		 * @default {$value: {}, lazy: true}
		 * @type {object}
		 */
		processors?: object;
		/** 
		 * Defines which updaters have to be called when an attribute is changed.
		 * For example, the config below indicates that the 'size' updater
		 * of a [square](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Square.html) sprite has to be called
		 * when the 'size' attribute changes.
		 * 
		 *    triggers: {
		 *        size: 'size'   // Use comma-separated values here if multiple updaters have to be called.
		 *    }                  // Note that the order is _not_ guaranteed.
		 * 
		 * If any of the updaters to be called (triggered by the [call)
		 * set attributes themselves and those attributes have triggers defined for them,
		 * then their updaters will be called after all current updaters finish execution.&lt;/p&gt;
		 * 
		 * &lt;p&gt;The updater functions themselves are defined in the {@link #updaters](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#method-setAttributes) config,
		 * aside from the 'canvas' updater, which doesn't have to be defined and acts as a flag,
		 * indicating that this attribute should be applied to a Canvas context (or whatever emulates it).
		 * @configuration
		 * @optional
		 * @default {}
		 * @type {object}
		 */
		triggers?: object;
		/** 
		 * Defines the postprocessing used by the attribute.
		 * Inside the updater function 'this' refers to the sprite that the attributes belong to.
		 * In case of an instancing sprite 'this' will refer to the instancing template.
		 * The two parameters passed to the updater function are the attributes object
		 * of the sprite or instance, and the names of attributes that triggered this updater call.
		 * 
		 * The example below shows how the 'size' updater changes other attributes
		 * of a [square](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Square.html) sprite sprite when its 'size' attribute changes.
		 * 
		 *    updaters: {
		 *        size: function (attr) {
		 *            var size = attr.size;
		 *            this.setAttributes({   // Changes to these attributes will trigger the 'path' updater.
		 *                x: attr.x - size,
		 *                y: attr.y - size,
		 *                height: 2 * size,
		 *                width: 2 * size
		 *            });
		 *        }
		 *    }
		 * 
		 * @configuration
		 * @optional
		 * @default {}
		 * @type {object}
		 */
		updaters?: object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                      config
		 * @returns {Ext.draw.sprite.AttributeDefinition.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.AttributeDefinition.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                      [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.AttributeDefinition.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.AttributeDefinition.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.AttributeDefinition.Statics}  
		 */
		statics? (): Ext.draw.sprite.AttributeDefinition.Statics;
	}
}
declare namespace Ext.draw.sprite.Circle {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Circle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Circle.html)
	 * A sprite that represents a circle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'circle',
	 *           cx: 100,
	 *           cy: 100,
	 *           r: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * The center coordinate of the sprite on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		cx?: number;
		/** 
		 * The center coordinate of the sprite on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		cy?: number;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * The radius of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		r?: number;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                         config
		 * @returns {Ext.draw.sprite.Circle.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Circle.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                  name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                         [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Circle.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Circle.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Circle.Statics}  
		 */
		statics? (): Ext.draw.sprite.Circle.Statics;
	}
}
declare namespace Ext.draw.sprite.Composite {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Composite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Composite.html)
	 * Represents a group of sprites.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		sprites?: any[];
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                            config
		 * @returns {Ext.draw.sprite.Composite.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Composite.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                     name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                            [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Composite.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Composite.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Composite.Statics}  
		 */
		statics? (): Ext.draw.sprite.Composite.Statics;
	}
}
declare namespace Ext.draw.sprite.Cross {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Cross](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Cross.html)
	 * A sprite that represents a cross.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'cross',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The size of the sprite.
		 * Meant to be comparable to the size of a circle sprite with the same radius.
		 * @configuration
		 * @optional
		 * @default 4
		 * @type {number}
		 */
		size?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                        config
		 * @returns {Ext.draw.sprite.Cross.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Cross.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                 name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                        [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Cross.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Cross.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Cross.Statics}  
		 */
		statics? (): Ext.draw.sprite.Cross.Statics;
	}
}
declare namespace Ext.draw.sprite.Diamond {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Diamond](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Diamond.html)
	 * A sprite that represents a diamond.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'diamond',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The size of the sprite.
		 * Meant to be comparable to the size of a circle sprite with the same radius.
		 * @configuration
		 * @optional
		 * @default 4
		 * @type {number}
		 */
		size?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                          config
		 * @returns {Ext.draw.sprite.Diamond.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Diamond.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                   name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                          [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Diamond.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Diamond.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Diamond.Statics}  
		 */
		statics? (): Ext.draw.sprite.Diamond.Statics;
	}
}
declare namespace Ext.draw.sprite.Ellipse {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Ellipse](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Ellipse.html)
	 * A sprite that represents an ellipse.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'ellipse',
	 *           cx: 100,
	 *           cy: 100,
	 *           rx: 80,
	 *           ry: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * The rotation of the sprite about its axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		axisRotation?: number;
		/** 
		 * The center coordinate of the sprite on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		cx?: number;
		/** 
		 * The center coordinate of the sprite on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		cy?: number;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * The radius of the sprite on the x-axis.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		rx?: number;
		/** 
		 * The radius of the sprite on the y-axis.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		ry?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                          config
		 * @returns {Ext.draw.sprite.Ellipse.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Ellipse.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                   name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                          [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Ellipse.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Ellipse.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Ellipse.Statics}  
		 */
		statics? (): Ext.draw.sprite.Ellipse.Statics;
	}
}
declare namespace Ext.draw.sprite.EllipticalArc {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.EllipticalArc](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.EllipticalArc.html)
	 * A sprite that represents an elliptical arc.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'ellipticalArc',
	 *           cx: 100,
	 *           cy: 100,
	 *           rx: 80,
	 *           ry: 50,
	 *           fillStyle: '#1F6D91',
	 *           startAngle: 0,
	 *           endAngle: Math.PI,
	 *           anticlockwise: true
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Determines whether or not the arc is drawn clockwise.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		anticlockwise?: boolean;
		/** 
		 * The rotation of the sprite about its axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		axisRotation?: number;
		/** 
		 * The center coordinate of the sprite on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		cx?: number;
		/** 
		 * The center coordinate of the sprite on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		cy?: number;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The ending angle of the arc.
		 * @configuration
		 * @optional
		 * @default Math.PI*2
		 * @type {number}
		 */
		endAngle?: number;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * The radius of the sprite on the x-axis.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		rx?: number;
		/** 
		 * The radius of the sprite on the y-axis.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		ry?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The beginning angle of the arc.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		startAngle?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                config
		 * @returns {Ext.draw.sprite.EllipticalArc.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.EllipticalArc.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                         name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.EllipticalArc.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.EllipticalArc.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.EllipticalArc.Statics}  
		 */
		statics? (): Ext.draw.sprite.EllipticalArc.Statics;
	}
}
declare namespace Ext.draw.sprite.Image {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Image](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Image.html)
	 * A sprite that represents an image.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * The height of the image.
		 * For consistent image size on all devices the height must be explicitly set.
		 * Otherwise the natural image height devided by the device pixel ratio
		 * (for a crisp looking image) will be used as the height of the sprite.
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		height?: number;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		radius?: number;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The image source of the sprite.
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		src?: string;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The width of the image.
		 * For consistent image size on all devices the width must be explicitly set.
		 * Otherwise the natural image width devided by the device pixel ratio
		 * (for a crisp looking image) will be used as the width of the sprite.
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		width?: number;
		/** 
		 * The position of the sprite on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		x?: number;
		/** 
		 * The position of the sprite on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		y?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                        config
		 * @returns {Ext.draw.sprite.Image.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Image.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                 name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                        [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Image.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Image.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Image.Statics}  
		 */
		statics? (): Ext.draw.sprite.Image.Statics;
	}
}
declare namespace Ext.draw.sprite.Instancing {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Instancing](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Instancing.html)
	 * Sprite that represents multiple instances based on the given template.
	 * 
	 * **From override Ext.draw.overrides.hittest.sprite.Instancing:** Adds hit testing methods to the [Ext.draw.sprite.Instancing](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Instancing.html).
	 * Included by the [Ext.draw.plugin.SpriteEvents](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.plugin.SpriteEvents.html).
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The instances of the [template](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Instancing.html#cfg-template) sprite as configs of attributes.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		instances?: any[];
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * The sprite template used by all instances.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		template?: object;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                             config
		 * @returns {Ext.draw.sprite.Instancing.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Instancing.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                      name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                             [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Instancing.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Instancing.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Instancing.Statics}  
		 */
		statics? (): Ext.draw.sprite.Instancing.Statics;
	}
}
declare namespace Ext.draw.sprite.Line {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Line](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Line.html)
	 * A sprite that represents a line.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'line',
	 *           fromX: 20,
	 *           fromY: 20,
	 *           toX: 120,
	 *           toY: 120,
	 *           strokeStyle: '#1F6D91',
	 *           lineWidth: 3
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.draw.sprite.Line.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Line.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Line.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Line.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Line.Statics}  
		 */
		statics? (): Ext.draw.sprite.Line.Statics;
	}
}
declare namespace Ext.draw.sprite.Path {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html)
	 * A sprite that represents a path.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'path',
	 *           path: 'M20,30 c0,-50 75,50 75,0 c0,-50 -75,50 -75,0',
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 * ### Drawing with SVG Paths
	 * 
	 * You may use special SVG Path syntax to "describe" the drawing path.  Here are the SVG path commands:
	 * 
	 * - M = moveto
	 * - L = lineto
	 * - H = horizontal lineto
	 * - V = vertical lineto
	 * - C = curveto
	 * - S = smooth curveto
	 * - Q = quadratic Bézier curve
	 * - T = smooth quadratic Bézier curveto
	 * - A = elliptical Arc
	 * - Z = closepath
	 * 
	 * **Note:** Capital letters indicate that the item should be absolutely positioned.
	 * Use lower case letters for relative positioning.
	 * 
	 * **From override Ext.draw.overrides.hittest.sprite.Path:** Adds hit testing methods to the [Ext.draw.sprite.Path](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Path.html) sprite.
	 * Included by the [Ext.draw.PathUtil](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.PathUtil.html).
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.draw.sprite.Path.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Path.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Path.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Path.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Path.Statics}  
		 */
		statics? (): Ext.draw.sprite.Path.Statics;
	}
}
declare namespace Ext.draw.sprite.Plus {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Plus](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Plus.html)
	 * A sprite that represents a plus.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'plus',
	 *           translationX: 100,
	 *           translationY: 100,
	 *           size: 40,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The size of the sprite.
		 * Meant to be comparable to the size of a circle sprite with the same radius.
		 * @configuration
		 * @optional
		 * @default 4
		 * @type {number}
		 */
		size?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.draw.sprite.Plus.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Plus.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Plus.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Plus.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Plus.Statics}  
		 */
		statics? (): Ext.draw.sprite.Plus.Statics;
	}
}
declare namespace Ext.draw.sprite.Rect {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Rect](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Rect.html)
	 * A sprite that represents a rectangle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'rect',
	 *           x: 50,
	 *           y: 50,
	 *           width: 100,
	 *           height: 100,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * The height of the sprite.
		 * @configuration
		 * @optional
		 * @default 8
		 * @type {number}
		 */
		height?: number;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * The radius of the rounded corners.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		radius?: number;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The width of the sprite.
		 * @configuration
		 * @optional
		 * @default 8
		 * @type {number}
		 */
		width?: number;
		/** 
		 * The position of the sprite on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		x?: number;
		/** 
		 * The position of the sprite on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		y?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.draw.sprite.Rect.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Rect.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Rect.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Rect.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Rect.Statics}  
		 */
		statics? (): Ext.draw.sprite.Rect.Statics;
	}
}
declare namespace Ext.draw.sprite.Sector {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Sector](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sector.html)
	 * A sprite representing a pie slice.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'sector',
	 *           centerX: 100,
	 *           centerY: 100,
	 *           startAngle: -2.355,
	 *           endAngle: -.785,
	 *           endRho: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * The center coordinate of the sprite on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		centerX?: number;
		/** 
		 * The center coordinate of the sprite on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		centerY?: number;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The ending angle of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		endAngle?: number;
		/** 
		 * The ending point of the radius of the sprite.
		 * @configuration
		 * @optional
		 * @default 150
		 * @type {number}
		 */
		endRho?: number;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * The margin of the sprite from the center of pie.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		margin?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The starting angle of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		startAngle?: number;
		/** 
		 * The starting point of the radius of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		startRho?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                         config
		 * @returns {Ext.draw.sprite.Sector.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Sector.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                  name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                         [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Sector.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Sector.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Sector.Statics}  
		 */
		statics? (): Ext.draw.sprite.Sector.Statics;
	}
}
declare namespace Ext.draw.sprite.Sprite {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Sprite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html)
	 * A sprite is a basic primitive from the charts package which represents a graphical
	 * object that can be drawn. Sprites are used extensively in the charts package to
	 * create the visual elements of each chart.  You can also create a desired image by
	 * adding one or more sprites to a [draw container](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Container.html).
	 * 
	 * The Sprite class itself is an abstract class and is not meant to be used directly.<br/>
	 * There are many different kinds of sprites available in the charts package that extend
	 * [Ext.draw.sprite.Sprite](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html). Each sprite type has various attributes that define how that
	 * sprite should look. For example, this is a [rect](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Rect.html) sprite:
	 * 
	 *    Ext.create({
	 *        xtype: 'draw', 
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400,
	 *        sprites: [{
	 *            type: 'rect',
	 *            x: 50,
	 *            y: 50,
	 *            width: 100,
	 *            height: 100,
	 *            fillStyle: '#1F6D91'
	 *        }]
	 *    });
	 * 
	 * By default, sprites are added to the default 'main' [surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html)
	 * of the draw container.  However, sprites may also be configured with a reference to a
	 * specific [Ext.draw.Surface](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html) when set in the draw container's
	 * [sprites](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Container.html#cfg-sprites) config.  Specifying a surface
	 * other than 'main' will create a surface by that name if it does not already exist.
	 * 
	 *    Ext.create({
	 *        xtype: 'draw', 
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400,
	 *        sprites: [{
	 *            type: 'rect',
	 *            surface: 'anim',  // a surface with id "anim" will be created automatically
	 *            x: 50,
	 *            y: 50,
	 *            width: 100,
	 *            height: 100,
	 *            fillStyle: '#1F6D91'
	 *        }]
	 *    });
	 * 
	 * The ability to have multiple surfaces is useful for performance (and battery life)
	 * reasons. Because changes to sprite attributes cause the whole surface (and all
	 * sprites in it) to re-render, it makes sense to group sprites by surface, so changes
	 * to one group of sprites will only trigger the surface they are in to re-render.
	 * 
	 * You can add a sprite to an existing drawing by adding the sprite to a draw surface.
	 * 
	 *    var drawCt = Ext.create({
	 *        xtype: 'draw',
	 *        renderTo: document.body,
	 *        width: 400,
	 *        height: 400
	 *    });
	 *    
	 *    // If the surface name is not specified then 'main' will be used
	 *    var surface = drawCt.getSurface();
	 *    
	 *    surface.add({
	 *        type: 'rect',
	 *        x: 50,
	 *        y: 50,
	 *        width: 100,
	 *        height: 100,
	 *        fillStyle: '#1F6D91'
	 *    });
	 *    
	 *    surface.renderFrame();
	 * 
	 * **Note:** Changes to the sprites on a surface will be not be reflected in the DOM
	 * until you call the surface's [renderFrame](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-renderFrame)
	 * method.  This must be done after adding, removing, or modifying sprites in order to
	 * see the changes on-screen.
	 * 
	 * For information on configuring a sprite with an initial transformation see
	 * [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), rotation, and translation.
	 * 
	 * For information on applying a transformation to an existing sprite see the
	 * [Ext.draw.Matrix](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Matrix.html) class.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                         config
		 * @returns {Ext.draw.sprite.Sprite.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Sprite.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                  name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                         [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Sprite.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Sprite.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Sprite.Statics}  
		 */
		statics? (): Ext.draw.sprite.Sprite.Statics;
	}
}
declare namespace Ext.draw.sprite.Square {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Square](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Square.html)
	 * A sprite that represents a square.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'square',
	 *           x: 100,
	 *           y: 100,
	 *           size: 50,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The size of the sprite.
		 * Meant to be comparable to the size of a circle sprite with the same radius.
		 * @configuration
		 * @optional
		 * @default 4
		 * @type {number}
		 */
		size?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                         config
		 * @returns {Ext.draw.sprite.Square.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Square.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                  name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                         [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Square.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Square.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Square.Statics}  
		 */
		statics? (): Ext.draw.sprite.Square.Statics;
	}
}
declare namespace Ext.draw.sprite.Text {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Text](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Text.html)
	 * A sprite that represents text.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw',
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'text',
	 *           x: 50,
	 *           y: 50,
	 *           text: 'Sencha',
	 *           fontSize: 30,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The font displayed.
		 * @configuration
		 * @optional
		 * @default '10px sans-serif'
		 * @type {string}
		 */
		font?: string;
		/** 
		 * The family of the font displayed.
		 * @configuration
		 * @optional
		 * @default 'sans-serif'
		 * @type {string}
		 */
		fontFamily?: string;
		/** 
		 * The size of the font displayed.
		 * @configuration
		 * @optional
		 * @default '10px'
		 * @type {string|number}
		 */
		fontSize?: string | number;
		/** 
		 * The style of the font displayed. {normal, italic, oblique}
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		fontStyle?: string;
		/** 
		 * The variant of the font displayed. {normal, small-caps}
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		fontVariant?: string;
		/** 
		 * The weight of the font displayed. {normal, bold, bolder, lighter}
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		fontWeight?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * The text represented in the sprite.
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		text?: string;
		/** 
		 * The alignment of the text displayed.
		 * {left, right, center, start, end}
		 * @configuration
		 * @optional
		 * @default 'start'
		 * @type {string}
		 */
		textAlign?: string;
		/** 
		 * The baseline of the text displayed.
		 * {top, hanging, middle, alphabetic, ideographic, bottom}
		 * @configuration
		 * @optional
		 * @default "alphabetic"
		 * @type {string}
		 */
		textBaseline?: string;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The position of the sprite on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		x?: number;
		/** 
		 * The position of the sprite on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		y?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.draw.sprite.Text.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Text.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Text.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Text.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Text.Statics}  
		 */
		statics? (): Ext.draw.sprite.Text.Statics;
	}
}
declare namespace Ext.draw.sprite.Tick {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Tick](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Tick.html)
	 * A veritical line sprite. The x and y configs set the center of the line with the size
	 * value determining the height of the line (the line will be twice the height of 'size'
	 * since 'size' is added to above and below 'y' to set the line endpoints).
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'tick',
	 *           x: 20,
	 *           y: 40,
	 *           size: 10,
	 *           strokeStyle: '#388FAD',
	 *           lineWidth: 2
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The size of the sprite.
		 * Meant to be comparable to the size of a circle sprite with the same radius.
		 * @configuration
		 * @optional
		 * @default 4
		 * @type {number}
		 */
		size?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The position of the center of the sprite on the x-axis.
		 * @configuration
		 * @optional
		 * @default 'number'
		 * @type {object}
		 */
		x?: object;
		/** 
		 * The position of the center of the sprite on the y-axis.
		 * @configuration
		 * @optional
		 * @default 'number'
		 * @type {object}
		 */
		y?: object;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.draw.sprite.Tick.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Tick.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Tick.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Tick.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Tick.Statics}  
		 */
		statics? (): Ext.draw.sprite.Tick.Statics;
	}
}
declare namespace Ext.draw.sprite.Triangle {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.draw.sprite.Triangle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Triangle.html)
	 * A sprite that represents a triangle.
	 * 
	 *    Ext.create({
	 *       xtype: 'draw', 
	 *       renderTo: document.body,
	 *       width: 600,
	 *       height: 400,
	 *       sprites: [{
	 *           type: 'triangle',
	 *           size: 50,
	 *           translationX: 100,
	 *           translationY: 100,
	 *           fillStyle: '#1F6D91'
	 *       }]
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {Ext.draw.modifier.Animation}
		 */
		animation?: Ext.draw.modifier.Animation;
		/** 
		 * Current state of the sprite.
		 * Set to `true` if the sprite needs to be repainted.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * The opacity of the fill. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		fillOpacity?: number;
		/** 
		 * The color of the shape (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		fillStyle?: string;
		/** 
		 * The opacity of the sprite. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		globalAlpha?: number;
		/** 
		 * Indicates how source images are drawn onto a destination image.
		 * globalCompositeOperation attribute is not supported by the SVG and VML (excanvas) engines.
		 * @configuration
		 * @optional
		 * @default source-over
		 * @type {string}
		 */
		globalCompositeOperation?: string;
		/** 
		 * Determines whether or not the sprite is hidden.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		hidden?: boolean;
		/** 
		 * The style of the line caps.
		 * @configuration
		 * @optional
		 * @default "butt"
		 * @type {string}
		 */
		lineCap?: string;
		/** 
		 * An even number of non-negative numbers specifying a dash/space sequence.
		 * Note that while this is supported in IE8 (VML engine), the behavior is
		 * different from Canvas and SVG. Please refer to this document for details:
		 * http://msdn.microsoft.com/en-us/library/bb264085(v=vs.85).aspx
		 * Although IE9 and IE10 have Canvas support, the 'lineDash'
		 * attribute is not supported in those browsers.
		 * @configuration
		 * @optional
		 * @default []
		 * @type {any[]}
		 */
		lineDash?: any[];
		/** 
		 * A number specifying how far into the line dash sequence drawing commences.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		lineDashOffset?: number;
		/** 
		 * The style of the line join.
		 * @configuration
		 * @optional
		 * @default "miter"
		 * @type {string}
		 */
		lineJoin?: string;
		/** 
		 * The width of the line stroke.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		lineWidth?: number;
		/** 
		 * Sets the distance between the inner corner and the outer corner where two lines meet.
		 * @configuration
		 * @optional
		 * @default 10
		 * @type {number}
		 */
		miterLimit?: number;
		/** 
		 * The immediate parent of the sprite. Not necessarily a surface.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface|Ext.draw.sprite.Instancing|Ext.draw.sprite.Composite}
		 */
		parent?: Ext.draw.Surface | Ext.draw.sprite.Instancing | Ext.draw.sprite.Composite;
		/** 
		 * The SVG based path string used by the sprite.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		path?: string;
		/** 
		 * Applies an initial angle of rotation to the sprite.  May be a number
		 * specifying the rotation in degrees.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Rotation config options will be overridden by values set on
		 * the [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //rotation: 45
		 *            rotation: {
		 *                degrees: 45,
		 *                //rads: Math.PI / 4,
		 *                //centerX: 50,
		 *                //centerY: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		rotation?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.<br/>
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterX?: number;
		/** 
		 * The central coordinate of the sprite's rotate operation on the y-axis.
		 * Unless explicitly set, will default to the calculated center of the
		 * sprite along the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationRads](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationRads), and
		 * [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		rotationCenterY?: number;
		/** 
		 * The angle of rotation of the sprite in radians.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [rotation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotation), [rotationCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterX), and
		 * [rotationCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-rotationCenterY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		rotationRads?: number;
		/** 
		 * Applies initial scaling to the sprite.  May be a number specifying
		 * the amount to scale both the x and y-axis.  The number value
		 * represents a percentage by which to scale the sprite.  **1** is equal
		 * to 100%, **2** would be 200%, etc.  Or may be a config object using
		 * the below config options.
		 * 
		 * **Note:** Scaling config options will be overridden by values set on
		 * the [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX),
		 * and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *        sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            //scaling: 2,
		 *            scaling: {
		 *                x: 2,
		 *                y: 2
		 *                //centerX: 100,
		 *                //centerY: 100
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {number|object}
		 */
		scaling?: number | object;
		/** 
		 * The central coordinate of the sprite's scale operation on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterX?: number;
		/** 
		 * The central coordinate of the sprite's scale operation on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY), and [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX)
		 * @configuration
		 * @optional
		 * @default null
		 * @type {number}
		 */
		scalingCenterY?: number;
		/** 
		 * The scaling of the sprite on the x-axis.
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingY),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingX?: number;
		/** 
		 * The scaling of the sprite on the y-axis.<br/>
		 * The number value represents a percentage by which to scale the
		 * sprite.  **1** is equal to 100%, **2** would be 200%, etc.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [scaling](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scaling), [scalingX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingX),
		 * [scalingCenterX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterX), and [scalingCenterY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-scalingCenterY)
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		scalingY?: number;
		/** 
		 * The amount blur used on the shadow.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowBlur?: number;
		/** 
		 * The color of the shadow (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		shadowColor?: string;
		/** 
		 * The offset of the sprite's shadow on the x-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetX?: number;
		/** 
		 * The offset of the sprite's shadow on the y-axis.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		shadowOffsetY?: number;
		/** 
		 * The size of the sprite.
		 * Meant to be comparable to the size of a circle sprite with the same radius.
		 * @configuration
		 * @optional
		 * @default 4
		 * @type {number}
		 */
		size?: number;
		/** 
		 * The opacity of the stroke. Limited from 0 to 1.
		 * @configuration
		 * @optional
		 * @default 1
		 * @type {number}
		 */
		strokeOpacity?: number;
		/** 
		 * The color of the stroke (a CSS color value).
		 * @configuration
		 * @optional
		 * @default "none"
		 * @type {string}
		 */
		strokeStyle?: string;
		/** 
		 * The surface that this sprite is rendered into.
		 * This config is not meant to be used directly.
		 * Please use the [Ext.draw.Surface.add](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.Surface.html#method-add) method instead.
		 * @configuration
		 * @optional
		 * @type {Ext.draw.Surface}
		 */
		surface?: Ext.draw.Surface;
		/** 
		 * Determines whether the fill and stroke are affected by sprite transformations.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		transformFillStroke?: boolean;
		/** 
		 * Applies an initial translation, adjustment in x/y positioning, to the
		 * sprite.
		 * 
		 * **Note:** Translation config options will be overridden by values set
		 * on the [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY) configs.
		 * 
		 *    Ext.create({
		 *        xtype: 'draw',
		 *        renderTo: Ext.getBody(),
		 *        width: 600,
		 *        height: 400,
		 *            sprites: [{
		 *            type: 'rect',
		 *            x: 50,
		 *            y: 50,
		 *            width: 100,
		 *            height: 100,
		 *            fillStyle: '#1F6D91',
		 *            translation: {
		 *                x: 50,
		 *                y: 50
		 *            }
		 *        }]
		 *    });
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		translation?: object;
		/** 
		 * The translation, position offset, of the sprite on the x-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationY](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationY)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationX?: number;
		/** 
		 * The translation, position offset, of the sprite on the y-axis.
		 * 
		 * **Note:** Transform configs are _always_ performed in the following
		 * order:
		 * 
		 * 1. Scaling
		 * 2. Rotation
		 * 3. Translation
		 * 
		 * See also: [translation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translation) and [translationX](https://docs.sencha.com/extjs/6.2.0/classic/Ext.draw.sprite.Sprite.html#cfg-translationX)
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		translationY?: number;
		/** 
		 * The stacking order of the sprite.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		zIndex?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                           config
		 * @returns {Ext.draw.sprite.Triangle.Statics}        this
		 */
		initConfig? (config: object): Ext.draw.sprite.Triangle.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                    name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                           [value] The value to set for the name parameter.
		 * @returns {Ext.draw.sprite.Triangle.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.draw.sprite.Triangle.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.draw.sprite.Triangle.Statics}  
		 */
		statics? (): Ext.draw.sprite.Triangle.Statics;
	}
}

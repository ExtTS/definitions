declare namespace Ext.data.writer {
	/** 
	 * [Ext.data.writer.Json](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html)
	 * This class is used to write [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) data to the server in a JSON format.
	 * The [allowSingle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-allowSingle) configuration can be set to false to force the records to always
	 * be encoded in an array, even if there is only a single record being sent.
	 */
	class Json extends Ext.data.writer.Writer {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.writer.Json.Statics}
		 */
		self?: Ext.data.writer.Json.Statics | Ext.data.writer.Writer.Statics | Ext.Base.Statics;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                               members    The members to add to this class.
		 * @param   {boolean}                                              [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                              [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.writer.Json|Ext.data.writer.Writer|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.writer.Json;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.writer.Writer;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                               members
		 * @returns {Ext.data.writer.Json|Ext.data.writer.Writer|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.writer.Json;
		static addStatics? (members: object): typeof Ext.data.writer.Writer;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                               name
		 * @param   {object}                                               member
		 * @returns {Ext.data.writer.Json|Ext.data.writer.Writer|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.writer.Json;
		static addMember? (name: object, member: object): typeof Ext.data.writer.Writer;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                               fn
		 * @param   {object}                                               scope
		 * @returns {Ext.data.writer.Json|Ext.data.writer.Writer|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.writer.Json;
		static onExtended? (fn: object, scope: object): typeof Ext.data.writer.Writer;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the value of [allDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-allDataOptions).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getAllDataOptions? (): object;
		/** 
		 * Returns the value of [allowSingle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-allowSingle).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAllowSingle? (): boolean;
		/** 
		 * Returns the value of [clientIdProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-clientIdProperty).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getClientIdProperty? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-dateFormat).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDateFormat? (): string;
		/** 
		 * Returns the value of [encode](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-encode).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getEncode? (): boolean;
		/** 
		 * Returns the value of [expandData](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-expandData).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getExpandData? (): boolean;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [nameProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-nameProperty).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getNameProperty? (): string;
		/** 
		 * Returns the value of [partialDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-partialDataOptions).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getPartialDataOptions? (): object;
		/** 
		 * Formats the data for each record before sending it to the server. This method should
		 * be overridden to format the data in a way that differs from the default.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model}               record      The record that we are writing to the server.
		 * @param   {Ext.data.operation.Operation} [operation] An operation object.
		 * @returns {object}                       
		 * An object literal of name/value keys to be written to the server.
		 * By default this method returns the data property on the record.
		 */
		getRecordData? (record: Ext.data.Model, operation?: Ext.data.operation.Operation): object;
		/** 
		 * Returns the value of [rootProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-rootProperty).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getRootProperty? (): string;
		/** 
		 * Returns the value of [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-transform).
		 * @method
		 * @public (method)
		 * @returns {Function|object}  
		 */
		getTransform? (): ExtGlobalFunction | object;
		/** 
		 * Returns the value of [writeAllFields](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeAllFields).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getWriteAllFields? (): boolean;
		/** 
		 * Returns the value of [writeRecordId](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeRecordId).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getWriteRecordId? (): boolean;
		/** 
		 * Sets the value of [allDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-allDataOptions).
		 * @method
		 * @public (method)
		 * @param   {object} allDataOptions The new value.
		 * @returns {void}                  
		 */
		setAllDataOptions? (allDataOptions: object): void;
		/** 
		 * Sets the value of [allowSingle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-allowSingle).
		 * @method
		 * @public (method)
		 * @param   {boolean} allowSingle The new value.
		 * @returns {void}                
		 */
		setAllowSingle? (allowSingle: boolean): void;
		/** 
		 * Sets the value of [clientIdProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-clientIdProperty).
		 * @method
		 * @public (method)
		 * @param   {string} clientIdProperty The new value.
		 * @returns {void}                    
		 */
		setClientIdProperty? (clientIdProperty: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                        name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                               [value] The value to set for the name parameter.
		 * @returns {Ext.data.writer.Json|Ext.data.writer.Writer|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.writer.Json;
		setConfig? (name: string | object, value?: object): Ext.data.writer.Writer;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-dateFormat).
		 * @method
		 * @public (method)
		 * @param   {string} dateFormat The new value.
		 * @returns {void}              
		 */
		setDateFormat? (dateFormat: string): void;
		/** 
		 * Sets the value of [encode](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-encode).
		 * @method
		 * @public (method)
		 * @param   {boolean} encode The new value.
		 * @returns {void}           
		 */
		setEncode? (encode: boolean): void;
		/** 
		 * Sets the value of [expandData](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-expandData).
		 * @method
		 * @public (method)
		 * @param   {boolean} expandData The new value.
		 * @returns {void}               
		 */
		setExpandData? (expandData: boolean): void;
		/** 
		 * Sets the value of [nameProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-nameProperty).
		 * @method
		 * @public (method)
		 * @param   {string} nameProperty The new value.
		 * @returns {void}                
		 */
		setNameProperty? (nameProperty: string): void;
		/** 
		 * Sets the value of [partialDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-partialDataOptions).
		 * @method
		 * @public (method)
		 * @param   {object} partialDataOptions The new value.
		 * @returns {void}                      
		 */
		setPartialDataOptions? (partialDataOptions: object): void;
		/** 
		 * Sets the value of [rootProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-rootProperty).
		 * @method
		 * @public (method)
		 * @param   {string} rootProperty The new value.
		 * @returns {void}                
		 */
		setRootProperty? (rootProperty: string): void;
		/** 
		 * Sets the value of [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-transform).
		 * @method
		 * @public (method)
		 * @param   {Function|object} transform The new value.
		 * @returns {void}                      
		 */
		setTransform? (transform: ExtGlobalFunction | object): void;
		/** 
		 * Sets the value of [writeAllFields](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeAllFields).
		 * @method
		 * @public (method)
		 * @param   {boolean} writeAllFields The new value.
		 * @returns {void}                   
		 */
		setWriteAllFields? (writeAllFields: boolean): void;
		/** 
		 * Sets the value of [writeRecordId](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeRecordId).
		 * @method
		 * @public (method)
		 * @param   {boolean} writeRecordId The new value.
		 * @returns {void}                  
		 */
		setWriteRecordId? (writeRecordId: boolean): void;
		/** 
		 * Prepares a Proxy's [Ext.data.Request](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Request.html) object.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Request} request The request object.
		 * @returns {Ext.data.Request}         The modified request object.
		 */
		write? (request: Ext.data.Request): Ext.data.Request;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * The Reader classes support dot-delimited data mappings for extracting nested raw data into fields, so the
		 * writer must support converting the flat [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) structure back into the original nested data
		 * format. Using the same mappings when available, the Writer will simply split each delimiter into a nested
		 * object in the output, which should exactly match the input format. For example, record data like this:
		 * 
		 *    my.nested.property: 'foo',
		 *    my.nested.another: 'bar',
		 *    my.somethingElse: 123
		 * 
		 * should write out as...
		 * 
		 *    my: {
		 *        nested: {
		 *            property: 'foo',
		 *            another: 'bar
		 *        },
		 *        somethingElse: 123
		 *    }
		 * 
		 * This behavior is governed by the [expandData](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-expandData) config. By default, this option is `false` for
		 * compatibility reasons, and will output a flat structure matching the flat record format. Setting this config
		 * to `true` will enable the expanded mapping behavior as shown here. This method could also be overridden
		 * to provide an even more customized output data structure.
		 * @method
		 * @protected (method)
		 * @param   {object} data
		 * @returns {void}        
		 */
		getExpandedData? (data: object): void;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                               config
		 * @returns {Ext.data.writer.Json|Ext.data.writer.Writer|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.writer.Json;
		initConfig? (config: object): Ext.data.writer.Writer;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Write the record data to the request in the appropriate format.
		 * @method
		 * @protected (method)
		 * @param   {object}           request
		 * @param   {object}           data
		 * @returns {Ext.data.Request}         The request.
		 */
		writeRecords? (request: object, data: object): Ext.data.Request;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.writer.Writer.writeRecords](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#method-writeRecords).
		 * Write the record data to the request in the appropriate format.
		 * @method
		 * @protected (method)
		 * @param   {Ext.data.Request} request The request.
		 * @param   {any[]}            data    An array of objects containing data.
		 * @returns {Ext.data.Request}         The request.
		 */
		writeRecords? (request: Ext.data.Request, data: any[]): Ext.data.Request;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.writer.Json.Statics|Ext.data.writer.Writer.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.writer.Json.Statics;
		statics? (): Ext.data.writer.Writer.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		applyTransform? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                             names The names of the linked objects to destroy.
		 * @returns {Ext.data.writer.Json|Ext.data.writer.Writer|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.writer.Json;
		unlink? (names: string[]): Ext.data.writer.Writer;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html)
	 * Base Writer class used by most subclasses of [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.Server.html). This class
	 * is responsible for taking a set of [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.operation.Operation.html) objects and a
	 * [Ext.data.Request](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Request.html) object and modifying that request based on the Operations.
	 * 
	 * For example a [Ext.data.writer.Json](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html) would format the Operations and their
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) instances based on the config options passed to the JsonWriter's
	 * constructor.
	 * 
	 * Writers are not needed for any kind of local storage - whether via a
	 * [Web Storage proxy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.WebStorage.html) (see
	 * [localStorage](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.LocalStorage.html) and
	 * [sessionStorage](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.SessionStorage.html))
	 * or just in memory via a [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.Memory.html).
	 * 
	 * # Dates
	 * 
	 * Before sending dates to the server, they can be formatted using an [Ext.Date](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Date.html)
	 * format. These formats can be specified both on the field and the writer itself. In terms
	 * of precedence, from highest to lowest:
	 * 
	 * - [Writer.dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-dateFormat) The writer `dateFormat` will always have the
	 *   highest precedence.
	 * - [Ext.data.field.Date.dateWriteFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateWriteFormat) The `dateWriteFormat` given to the field
	 *   instance. This is handled by [Ext.data.field.Date.serialize](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#method-serialize).
	 * - [Field.dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateFormat) This is handled by the field's
	 *   `serialize` method.
	 * - [Field.dateReadFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateReadFormat) Also handled by the
	 *   field's `serialize` method.
	 */
	class Writer extends Ext.Base {
		/** 
		 * If this property is specified by the target class of this mixin its properties are
		 * used to configure the created [`Ext.Factory`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Factory.html).
		 * @property
		 * @public (property)
		 * @default {defaultType: null}
		 * @type {object}
		 */
		factoryConfig?: object;
		/** 
		 * `true` in this class to identify an object as an instantiated Writer, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isWriter?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.writer.Writer.Statics}
		 */
		self?: Ext.data.writer.Writer.Statics | Ext.Base.Statics;
		/** 
		 * @property
		 * @private (property)
		 * @default 'factoryable'
		 * @type {string}
		 */
		mixinId?: string;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members    The members to add to this class.
		 * @param   {boolean}                         [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                         [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.writer.Writer|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.writer.Writer;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members
		 * @returns {Ext.data.writer.Writer|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.writer.Writer;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          name
		 * @param   {object}                          member
		 * @returns {Ext.data.writer.Writer|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.writer.Writer;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          fn
		 * @param   {object}                          scope
		 * @returns {Ext.data.writer.Writer|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.writer.Writer;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates new Writer.
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the value of [allDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-allDataOptions).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getAllDataOptions? (): object;
		/** 
		 * Returns the value of [clientIdProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-clientIdProperty).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getClientIdProperty? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-dateFormat).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDateFormat? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [nameProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-nameProperty).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getNameProperty? (): string;
		/** 
		 * Returns the value of [partialDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-partialDataOptions).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getPartialDataOptions? (): object;
		/** 
		 * Formats the data for each record before sending it to the server. This method should
		 * be overridden to format the data in a way that differs from the default.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model}               record      The record that we are writing to the server.
		 * @param   {Ext.data.operation.Operation} [operation] An operation object.
		 * @returns {object}                       
		 * An object literal of name/value keys to be written to the server.
		 * By default this method returns the data property on the record.
		 */
		getRecordData? (record: Ext.data.Model, operation?: Ext.data.operation.Operation): object;
		/** 
		 * Returns the value of [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-transform).
		 * @method
		 * @public (method)
		 * @returns {Function|object}  
		 */
		getTransform? (): ExtGlobalFunction | object;
		/** 
		 * Returns the value of [writeAllFields](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeAllFields).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getWriteAllFields? (): boolean;
		/** 
		 * Returns the value of [writeRecordId](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeRecordId).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getWriteRecordId? (): boolean;
		/** 
		 * Sets the value of [allDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-allDataOptions).
		 * @method
		 * @public (method)
		 * @param   {object} allDataOptions The new value.
		 * @returns {void}                  
		 */
		setAllDataOptions? (allDataOptions: object): void;
		/** 
		 * Sets the value of [clientIdProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-clientIdProperty).
		 * @method
		 * @public (method)
		 * @param   {string} clientIdProperty The new value.
		 * @returns {void}                    
		 */
		setClientIdProperty? (clientIdProperty: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                   name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                          [value] The value to set for the name parameter.
		 * @returns {Ext.data.writer.Writer|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.writer.Writer;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-dateFormat).
		 * @method
		 * @public (method)
		 * @param   {string} dateFormat The new value.
		 * @returns {void}              
		 */
		setDateFormat? (dateFormat: string): void;
		/** 
		 * Sets the value of [nameProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-nameProperty).
		 * @method
		 * @public (method)
		 * @param   {string} nameProperty The new value.
		 * @returns {void}                
		 */
		setNameProperty? (nameProperty: string): void;
		/** 
		 * Sets the value of [partialDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-partialDataOptions).
		 * @method
		 * @public (method)
		 * @param   {object} partialDataOptions The new value.
		 * @returns {void}                      
		 */
		setPartialDataOptions? (partialDataOptions: object): void;
		/** 
		 * Sets the value of [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-transform).
		 * @method
		 * @public (method)
		 * @param   {Function|object} transform The new value.
		 * @returns {void}                      
		 */
		setTransform? (transform: ExtGlobalFunction | object): void;
		/** 
		 * Sets the value of [writeAllFields](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeAllFields).
		 * @method
		 * @public (method)
		 * @param   {boolean} writeAllFields The new value.
		 * @returns {void}                   
		 */
		setWriteAllFields? (writeAllFields: boolean): void;
		/** 
		 * Sets the value of [writeRecordId](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeRecordId).
		 * @method
		 * @public (method)
		 * @param   {boolean} writeRecordId The new value.
		 * @returns {void}                  
		 */
		setWriteRecordId? (writeRecordId: boolean): void;
		/** 
		 * Prepares a Proxy's [Ext.data.Request](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Request.html) object.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Request} request The request object.
		 * @returns {Ext.data.Request}         The modified request object.
		 */
		write? (request: Ext.data.Request): Ext.data.Request;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                          config
		 * @returns {Ext.data.writer.Writer|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.writer.Writer;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Write the record data to the request in the appropriate format.
		 * @method
		 * @protected (method)
		 * @param   {Ext.data.Request} request The request.
		 * @param   {any[]}            data    An array of objects containing data.
		 * @returns {Ext.data.Request}         The request.
		 */
		writeRecords? (request: Ext.data.Request, data: any[]): Ext.data.Request;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.writer.Writer.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.writer.Writer.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		applyTransform? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                        names The names of the linked objects to destroy.
		 * @returns {Ext.data.writer.Writer|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.writer.Writer;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * [Ext.data.writer.Xml](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html)
	 * This class is used to write [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) data to the server in an XML format.
	 * The [documentRoot](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-documentRoot) property is used to specify the root element in the XML document.
	 * The [record](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-record) option is used to specify the element name for each record that will make up the XML document.
	 */
	class Xml extends Ext.data.writer.Writer {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.writer.Xml.Statics}
		 */
		self?: Ext.data.writer.Xml.Statics | Ext.data.writer.Writer.Statics | Ext.Base.Statics;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members    The members to add to this class.
		 * @param   {boolean}                                             [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                             [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.writer.Xml|Ext.data.writer.Writer|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.writer.Xml;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.writer.Writer;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members
		 * @returns {Ext.data.writer.Xml|Ext.data.writer.Writer|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.writer.Xml;
		static addStatics? (members: object): typeof Ext.data.writer.Writer;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              name
		 * @param   {object}                                              member
		 * @returns {Ext.data.writer.Xml|Ext.data.writer.Writer|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.writer.Xml;
		static addMember? (name: object, member: object): typeof Ext.data.writer.Writer;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              fn
		 * @param   {object}                                              scope
		 * @returns {Ext.data.writer.Xml|Ext.data.writer.Writer|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.writer.Xml;
		static onExtended? (fn: object, scope: object): typeof Ext.data.writer.Writer;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates new Writer.
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the value of [allDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-allDataOptions).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getAllDataOptions? (): object;
		/** 
		 * Returns the value of [clientIdProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-clientIdProperty).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getClientIdProperty? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-dateFormat).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDateFormat? (): string;
		/** 
		 * Returns the value of [defaultDocumentRoot](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-defaultDocumentRoot).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDefaultDocumentRoot? (): string;
		/** 
		 * Returns the value of [documentRoot](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-documentRoot).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDocumentRoot? (): string;
		/** 
		 * Returns the value of [header](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-header).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getHeader? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [nameProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-nameProperty).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getNameProperty? (): string;
		/** 
		 * Returns the value of [partialDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-partialDataOptions).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getPartialDataOptions? (): object;
		/** 
		 * Returns the value of [record](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-record).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getRecord? (): string;
		/** 
		 * Formats the data for each record before sending it to the server. This method should
		 * be overridden to format the data in a way that differs from the default.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model}               record      The record that we are writing to the server.
		 * @param   {Ext.data.operation.Operation} [operation] An operation object.
		 * @returns {object}                       
		 * An object literal of name/value keys to be written to the server.
		 * By default this method returns the data property on the record.
		 */
		getRecordData? (record: Ext.data.Model, operation?: Ext.data.operation.Operation): object;
		/** 
		 * Returns the value of [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-transform).
		 * @method
		 * @public (method)
		 * @returns {Function|object}  
		 */
		getTransform? (): ExtGlobalFunction | object;
		/** 
		 * Returns the value of [writeAllFields](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeAllFields).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getWriteAllFields? (): boolean;
		/** 
		 * Returns the value of [writeRecordId](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeRecordId).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getWriteRecordId? (): boolean;
		/** 
		 * Serializes an object to XML.
		 * Properties will be serialized as child elements unless their first character is `'@'`
		 * 
		 * For example:
		 * 
		 *     myWriter.objectToElement('SystemComponent', {
		 *         "@SystemNumber": '10118795',
		 *         "SystemInfo>SystemName": 'Phase Noise Measurement System',
		 *         AssetId: 'DE3208',
		 *         AgilentModel: 'E5505A',
		 *         SerialNumber: 'US44101357',
		 *     }, []).join('');
		 * 
		 * becomes
		 * 
		 *     <SystemComponent SystemNumber="10118795">
		 *       <SystemInfo>
		 *           <SystemName>Phase Noise Measurement System</SystemName>
		 *       </SystemInfo>
		 *       <AssetId>DE3208</AssetId>
		 *       <AgilentModel>E5505A</AgilentModel>
		 *       <SerialNumber>US44101357</SerialNumber>
		 *     </SystemComponent>
		 * 
		 * @method
		 * @public (method)
		 * @param   {string} name     The element name for the object.
		 * @param   {object} o        The object to serialize.
		 * @param   {any[]}  [output] The array into which to serialize the object.
		 * @returns {void}            
		 */
		objectToElement? (name: string, o: object, output?: any[]): void;
		/** 
		 * Sets the value of [allDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-allDataOptions).
		 * @method
		 * @public (method)
		 * @param   {object} allDataOptions The new value.
		 * @returns {void}                  
		 */
		setAllDataOptions? (allDataOptions: object): void;
		/** 
		 * Sets the value of [clientIdProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-clientIdProperty).
		 * @method
		 * @public (method)
		 * @param   {string} clientIdProperty The new value.
		 * @returns {void}                    
		 */
		setClientIdProperty? (clientIdProperty: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                       name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                              [value] The value to set for the name parameter.
		 * @returns {Ext.data.writer.Xml|Ext.data.writer.Writer|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.writer.Xml;
		setConfig? (name: string | object, value?: object): Ext.data.writer.Writer;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-dateFormat).
		 * @method
		 * @public (method)
		 * @param   {string} dateFormat The new value.
		 * @returns {void}              
		 */
		setDateFormat? (dateFormat: string): void;
		/** 
		 * Sets the value of [defaultDocumentRoot](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-defaultDocumentRoot).
		 * @method
		 * @public (method)
		 * @param   {string} defaultDocumentRoot The new value.
		 * @returns {void}                       
		 */
		setDefaultDocumentRoot? (defaultDocumentRoot: string): void;
		/** 
		 * Sets the value of [documentRoot](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-documentRoot).
		 * @method
		 * @public (method)
		 * @param   {string} documentRoot The new value.
		 * @returns {void}                
		 */
		setDocumentRoot? (documentRoot: string): void;
		/** 
		 * Sets the value of [header](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-header).
		 * @method
		 * @public (method)
		 * @param   {string} header The new value.
		 * @returns {void}          
		 */
		setHeader? (header: string): void;
		/** 
		 * Sets the value of [nameProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-nameProperty).
		 * @method
		 * @public (method)
		 * @param   {string} nameProperty The new value.
		 * @returns {void}                
		 */
		setNameProperty? (nameProperty: string): void;
		/** 
		 * Sets the value of [partialDataOptions](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-partialDataOptions).
		 * @method
		 * @public (method)
		 * @param   {object} partialDataOptions The new value.
		 * @returns {void}                      
		 */
		setPartialDataOptions? (partialDataOptions: object): void;
		/** 
		 * Sets the value of [record](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-record).
		 * @method
		 * @public (method)
		 * @param   {string} record The new value.
		 * @returns {void}          
		 */
		setRecord? (record: string): void;
		/** 
		 * Sets the value of [transform](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-transform).
		 * @method
		 * @public (method)
		 * @param   {Function|object} transform The new value.
		 * @returns {void}                      
		 */
		setTransform? (transform: ExtGlobalFunction | object): void;
		/** 
		 * Sets the value of [writeAllFields](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeAllFields).
		 * @method
		 * @public (method)
		 * @param   {boolean} writeAllFields The new value.
		 * @returns {void}                   
		 */
		setWriteAllFields? (writeAllFields: boolean): void;
		/** 
		 * Sets the value of [writeRecordId](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeRecordId).
		 * @method
		 * @public (method)
		 * @param   {boolean} writeRecordId The new value.
		 * @returns {void}                  
		 */
		setWriteRecordId? (writeRecordId: boolean): void;
		/** 
		 * Prepares a Proxy's [Ext.data.Request](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Request.html) object.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Request} request The request object.
		 * @returns {Ext.data.Request}         The modified request object.
		 */
		write? (request: Ext.data.Request): Ext.data.Request;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                              config
		 * @returns {Ext.data.writer.Xml|Ext.data.writer.Writer|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.writer.Xml;
		initConfig? (config: object): Ext.data.writer.Writer;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Write the record data to the request in the appropriate format.
		 * @method
		 * @protected (method)
		 * @param   {object}           request
		 * @param   {object}           data
		 * @returns {Ext.data.Request}         The request.
		 */
		writeRecords? (request: object, data: object): Ext.data.Request;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.writer.Writer.writeRecords](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#method-writeRecords).
		 * Write the record data to the request in the appropriate format.
		 * @method
		 * @protected (method)
		 * @param   {Ext.data.Request} request The request.
		 * @param   {any[]}            data    An array of objects containing data.
		 * @returns {Ext.data.Request}         The request.
		 */
		writeRecords? (request: Ext.data.Request, data: any[]): Ext.data.Request;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.writer.Xml.Statics|Ext.data.writer.Writer.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.writer.Xml.Statics;
		statics? (): Ext.data.writer.Writer.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} transform
		 * @returns {void}             
		 */
		applyTransform? (transform: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                            names The names of the linked objects to destroy.
		 * @returns {Ext.data.writer.Xml|Ext.data.writer.Writer|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.writer.Xml;
		unlink? (names: string[]): Ext.data.writer.Writer;
		unlink? (names: string[]): Ext.Base;
	}
}
declare namespace Ext.data {
	class DataWriter extends Ext.data.writer.Writer {}
	class JsonWriter extends Ext.data.writer.Json {}
	class Writer extends Ext.data.writer.Writer {}
	class XmlWriter extends Ext.data.writer.Xml {}
}
declare namespace Ext.data.writer.Json {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.writer.Json](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html)
	 * This class is used to write [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) data to the server in a JSON format.
	 * The [allowSingle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-allowSingle) configuration can be set to false to force the records to always
	 * be encoded in an array, even if there is only a single record being sent.
	 */
	interface Def extends Ext.data.writer.Json {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.writer.Json.Cfg}
		 */
		config?: Ext.data.writer.Json.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.writer.Json.Statics|Ext.data.writer.Writer.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.writer.Json.Statics}
		 */
		statics?: (() => Ext.data.writer.Json.Statics | Ext.data.writer.Writer.Statics | Ext.Base.Statics) | Ext.data.writer.Json.Statics | any;
	}
}
declare namespace Ext.data.writer.Writer {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html)
	 * Base Writer class used by most subclasses of [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.Server.html). This class
	 * is responsible for taking a set of [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.operation.Operation.html) objects and a
	 * [Ext.data.Request](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Request.html) object and modifying that request based on the Operations.
	 * 
	 * For example a [Ext.data.writer.Json](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html) would format the Operations and their
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) instances based on the config options passed to the JsonWriter's
	 * constructor.
	 * 
	 * Writers are not needed for any kind of local storage - whether via a
	 * [Web Storage proxy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.WebStorage.html) (see
	 * [localStorage](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.LocalStorage.html) and
	 * [sessionStorage](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.SessionStorage.html))
	 * or just in memory via a [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.Memory.html).
	 * 
	 * # Dates
	 * 
	 * Before sending dates to the server, they can be formatted using an [Ext.Date](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Date.html)
	 * format. These formats can be specified both on the field and the writer itself. In terms
	 * of precedence, from highest to lowest:
	 * 
	 * - [Writer.dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-dateFormat) The writer `dateFormat` will always have the
	 *   highest precedence.
	 * - [Ext.data.field.Date.dateWriteFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateWriteFormat) The `dateWriteFormat` given to the field
	 *   instance. This is handled by [Ext.data.field.Date.serialize](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#method-serialize).
	 * - [Field.dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateFormat) This is handled by the field's
	 *   `serialize` method.
	 * - [Field.dateReadFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateReadFormat) Also handled by the
	 *   field's `serialize` method.
	 */
	interface Def extends Ext.data.writer.Writer {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.writer.Writer.Cfg}
		 */
		config?: Ext.data.writer.Writer.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.writer.Writer.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.writer.Writer.Statics}
		 */
		statics?: (() => Ext.data.writer.Writer.Statics | Ext.Base.Statics) | Ext.data.writer.Writer.Statics | any;
	}
}
declare namespace Ext.data.writer.Xml {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.writer.Xml](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html)
	 * This class is used to write [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) data to the server in an XML format.
	 * The [documentRoot](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-documentRoot) property is used to specify the root element in the XML document.
	 * The [record](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-record) option is used to specify the element name for each record that will make up the XML document.
	 */
	interface Def extends Ext.data.writer.Xml {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - [Grid](https://docs.sencha.com/extjs/6.2.0/classic/Ext.grid.Panel.html) features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.writer.Xml.Cfg}
		 */
		config?: Ext.data.writer.Xml.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * **Note:** Only applies to [Ext.Component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) derived classes when used as
		 * a config in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define).
		 * 
		 * This property provides a shorter alternative to creating objects than using a full
		 * class name. Using `xtype` is the most common way to define component instances,
		 * especially in a container. For example, the items in a form containing text fields
		 * could be created explicitly like so:
		 * 
		 *     items: [
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Foo'
		 *         }),
		 *         Ext.create('Ext.form.field.Text', {
		 *             fieldLabel: 'Bar'
		 *         }),
		 *         Ext.create('Ext.form.field.Number', {
		 *             fieldLabel: 'Num'
		 *         })
		 *     ]
		 * 
		 * But by using `xtype`, the above becomes:
		 * 
		 *     items: [
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Foo'
		 *         },
		 *         {
		 *             xtype: 'textfield',
		 *             fieldLabel: 'Bar'
		 *         },
		 *         {
		 *             xtype: 'numberfield',
		 *             fieldLabel: 'Num'
		 *         }
		 *     ]
		 * 
		 * When the `xtype` is common to many items, [Ext.container.Container.defaultType](https://docs.sencha.com/extjs/6.2.0/classic/Ext.container.Container.html#cfg-defaultType)
		 * is another way to specify the `xtype` for all items that don't have an explicit `xtype`:
		 * 
		 *     defaultType: 'textfield',
		 *     items: [
		 *         { fieldLabel: 'Foo' },
		 *         { fieldLabel: 'Bar' },
		 *         { fieldLabel: 'Num', xtype: 'numberfield' }
		 *     ]
		 * 
		 * Each member of the `items` array is now just a "configuration object". These objects
		 * are used to create and configure component instances. A configuration object can be
		 * manually used to instantiate a component using [Ext.widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-widget):
		 * 
		 *     var text1 = Ext.create('Ext.form.field.Text', {
		 *         fieldLabel: 'Foo'
		 *     });
		 *    
		 *     // or alternatively:
		 *    
		 *     var text1 = Ext.widget({
		 *         xtype: 'textfield',
		 *         fieldLabel: 'Foo'
		 *     });
		 * 
		 * This conversion of configuration objects into instantiated components is done when
		 * a container is created as part of its {Ext.container.AbstractContainer#initComponent}
		 * process. As part of the same process, the `items` array is converted from its raw
		 * array form into a [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/classic/Ext.util.MixedCollection.html) instance.
		 * 
		 * You can define your own `xtype` on a custom [component](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Component.html) by specifying
		 * the `xtype` property in [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define). For example:
		 * 
		 *    Ext.define('MyApp.PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Care should be taken when naming an `xtype` in a custom component because there is
		 * a single, shared scope for all xtypes. Third part components should consider using
		 * a prefix to avoid collisions.
		 * 
		 *    Ext.define('Foo.form.CoolButton', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'ux-coolbutton',
		 *        text: 'Cool!'
		 *    });
		 * 
		 * See [Ext.enums.Widget](https://docs.sencha.com/extjs/6.2.0/classic/Ext.enums.Widget.html) for list of all available xtypes.
		 * @property
		 * @protected (property)
		 * @type {Ext.enums.Widget}
		 */
		xtype?: Ext.enums.Widget;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.writer.Xml.Statics|Ext.data.writer.Writer.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.writer.Xml.Statics}
		 */
		statics?: (() => Ext.data.writer.Xml.Statics | Ext.data.writer.Writer.Statics | Ext.Base.Statics) | Ext.data.writer.Xml.Statics | any;
	}
}
declare namespace Ext.data.writer.Json {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.writer.Json](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html)
	 * This class is used to write [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) data to the server in a JSON format.
	 * The [allowSingle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-allowSingle) configuration can be set to false to force the records to always
	 * be encoded in an array, even if there is only a single record being sent.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                               members    The members to add to this class.
		 * @param   {boolean}                                              [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                              [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.writer.Json|Ext.data.writer.Writer|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.writer.Json;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.writer.Writer;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                               members
		 * @returns {Ext.data.writer.Json|Ext.data.writer.Writer|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.writer.Json;
		addStatics? (members: object): typeof Ext.data.writer.Writer;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                               name
		 * @param   {object}                                               member
		 * @returns {Ext.data.writer.Json|Ext.data.writer.Writer|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.writer.Json;
		addMember? (name: object, member: object): typeof Ext.data.writer.Writer;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                               fn
		 * @param   {object}                                               scope
		 * @returns {Ext.data.writer.Json|Ext.data.writer.Writer|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.writer.Json;
		onExtended? (fn: object, scope: object): typeof Ext.data.writer.Writer;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.writer.Writer {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html)
	 * Base Writer class used by most subclasses of [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.Server.html). This class
	 * is responsible for taking a set of [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.operation.Operation.html) objects and a
	 * [Ext.data.Request](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Request.html) object and modifying that request based on the Operations.
	 * 
	 * For example a [Ext.data.writer.Json](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html) would format the Operations and their
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) instances based on the config options passed to the JsonWriter's
	 * constructor.
	 * 
	 * Writers are not needed for any kind of local storage - whether via a
	 * [Web Storage proxy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.WebStorage.html) (see
	 * [localStorage](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.LocalStorage.html) and
	 * [sessionStorage](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.SessionStorage.html))
	 * or just in memory via a [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.Memory.html).
	 * 
	 * # Dates
	 * 
	 * Before sending dates to the server, they can be formatted using an [Ext.Date](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Date.html)
	 * format. These formats can be specified both on the field and the writer itself. In terms
	 * of precedence, from highest to lowest:
	 * 
	 * - [Writer.dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-dateFormat) The writer `dateFormat` will always have the
	 *   highest precedence.
	 * - [Ext.data.field.Date.dateWriteFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateWriteFormat) The `dateWriteFormat` given to the field
	 *   instance. This is handled by [Ext.data.field.Date.serialize](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#method-serialize).
	 * - [Field.dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateFormat) This is handled by the field's
	 *   `serialize` method.
	 * - [Field.dateReadFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateReadFormat) Also handled by the
	 *   field's `serialize` method.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members    The members to add to this class.
		 * @param   {boolean}                         [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                         [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.writer.Writer|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.writer.Writer;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members
		 * @returns {Ext.data.writer.Writer|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.writer.Writer;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          name
		 * @param   {object}                          member
		 * @returns {Ext.data.writer.Writer|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.writer.Writer;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          fn
		 * @param   {object}                          scope
		 * @returns {Ext.data.writer.Writer|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.writer.Writer;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.writer.Xml {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.writer.Xml](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html)
	 * This class is used to write [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) data to the server in an XML format.
	 * The [documentRoot](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-documentRoot) property is used to specify the root element in the XML document.
	 * The [record](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-record) option is used to specify the element name for each record that will make up the XML document.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members    The members to add to this class.
		 * @param   {boolean}                                             [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                             [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.writer.Xml|Ext.data.writer.Writer|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.writer.Xml;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.writer.Writer;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members
		 * @returns {Ext.data.writer.Xml|Ext.data.writer.Writer|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.writer.Xml;
		addStatics? (members: object): typeof Ext.data.writer.Writer;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              name
		 * @param   {object}                                              member
		 * @returns {Ext.data.writer.Xml|Ext.data.writer.Writer|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.writer.Xml;
		addMember? (name: object, member: object): typeof Ext.data.writer.Writer;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              fn
		 * @param   {object}                                              scope
		 * @returns {Ext.data.writer.Xml|Ext.data.writer.Writer|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.writer.Xml;
		onExtended? (fn: object, scope: object): typeof Ext.data.writer.Writer;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.writer.Json {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.writer.Json](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html)
	 * This class is used to write [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) data to the server in a JSON format.
	 * The [allowSingle](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-allowSingle) configuration can be set to false to force the records to always
	 * be encoded in an array, even if there is only a single record being sent.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * This object contains the options passed to [`Ext.data.Model.getData`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#method-getData) when
		 * writing [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) records or when `writeAllFields` is set
		 * to `true`.
		 * 
		 * _NOTE:_ The `serialize` option cannot be used here.
		 * @configuration
		 * @optional
		 * @default {persist: true}
		 * @type {object}
		 */
		allDataOptions?: object;
		/** 
		 * Configure with `false` to ensure that records are always wrapped in an array, even if there is only
		 * one record being sent. When there is more than one record, they will always be encoded into an array.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		allowSingle?: boolean;
		/** 
		 * When specified this property causes the [`Ext.data.Model.idProperty`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-idProperty) of
		 * newly created records to be sent to the server as this name instead of the
		 * value of the `idProperty`.
		 * 
		 * For example, by default, the following code:
		 * 
		 *     Ext.define('Person', {
		 *         idProperty: 'id',  // this is the default value (for clarity)
		 *    
		 *         fields: [ 'name' ]
		 *     });
		 *    
		 *     var person = new Person({
		 *         // no id provided, so one is generated
		 *         name: 'Clark Kent'
		 *     });
		 * 
		 * Will send this to the server:
		 * 
		 *     {
		 *         id: 'Person-1',
		 *         name: 'Clark Kent'
		 *     }
		 * 
		 * This can be an issue if the server expects an integer for the "id" property.
		 * You can use [`Ext.data.Model.identifier`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-identifier) to produce identifiers that
		 * the server would recognize or use this config to send the client's id in a
		 * different property.
		 * 
		 *     Ext.define('Person', {
		 *         idProperty: 'id',  // this is the default value (for clarity)
		 *    
		 *         proxy: {
		 *             writer: {
		 *                 clientIdProperty: 'clientId'
		 *             }
		 *         },
		 *    
		 *         fields: [ 'name' ]
		 *     });
		 * 
		 * Given the above, the server is sent this data now:
		 * 
		 *     {
		 *         clientId: 'Person-1',
		 *         name: 'Clark Kent'
		 *     }
		 * 
		 * While this config provides the behavior of [`Ext.data.Model.clientIdProperty`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-clientIdProperty)
		 * from previous releases, this property is not as useful as a suitable
		 * [`Ext.data.Model.identifier`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-identifier) due to id's appearing in foreign-key fields
		 * and in [`Ext.data.Model.manyToMany`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-manyToMany) associations.
		 * 
		 * See [`Ext.data.Model.identifier`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-identifier) for more on id generation.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		clientIdProperty?: string;
		/** 
		 * This is used for each field of type date in the model to format the value before
		 * it is sent to the server.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		dateFormat?: string;
		/** 
		 * Configure `true` to send record data (all record fields if [writeAllFields](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-writeAllFields) is `true`)
		 * as a JSON encoded HTTP parameter named by the [rootProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-rootProperty) configuration.
		 * 
		 * The encode option should only be set to true when a [rootProperty](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-rootProperty) is defined, because the values will be
		 * sent as part of the request parameters as opposed to a raw post. The root will be the name of the parameter
		 * sent to the server.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		encode?: boolean;
		/** 
		 * By default, when dot-delimited field [mappings](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-nameProperty) are
		 * used (e.g. `name: 'myProperty', mapping: 'my.nested.property'`) the writer will simply output a flat data
		 * object containing the mapping string literal as the property name (e.g. `{ 'my.nested.property': 'foo' }`).
		 * 
		 * Mappings are used to map incoming nested JSON to flat Ext models. In many case, the data output by the
		 * writer should preferrably match the original nested data format. Setting this config to `true` will ensure
		 * that the output will instead look like `{ my: { nested: { property: 'foo' }}}`. The output is generated
		 * by [getExpandedData](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#method-getExpandedData), which can optionally be overridden to apply more customized logic.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		expandData?: boolean;
		/** 
		 * This property is used to read the key for each value that will be sent to the
		 * server.
		 * 
		 * For example:
		 * 
		 *    Ext.define('Person', {
		 *        extend: 'Ext.data.Model',
		 *        fields: [{
		 *            name: 'first',
		 *            mapping: 'firstName'
		 *        }, {
		 *            name: 'last',
		 *            mapping: 'lastName'
		 *        }, {
		 *            name: 'age'
		 *        }]
		 *    });
		 *    
		 *    new Ext.data.writer.Writer({
		 *        nameProperty: 'mapping'
		 *    });
		 *    
		 *    // This will be sent to the server
		 *    {
		 *        firstName: 'first name value',
		 *        lastName: 'last name value',
		 *        age: 1
		 *    }
		 * 
		 * If the value is not present, the field name will always be used.
		 * @configuration
		 * @optional
		 * @default 'name'
		 * @type {string}
		 */
		nameProperty?: string;
		/** 
		 * This object contains the options passed to [`Ext.data.Model.getData`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#method-getData) when
		 * writing non [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) records or when `writeAllFields` is
		 * set to `false`.
		 * 
		 * _NOTE:_ The `serialize` option cannot be used here.
		 * @configuration
		 * @optional
		 * @default {changes: true, critical: true}
		 * @type {object}
		 */
		partialDataOptions?: object;
		/** 
		 * The HTTP parameter name by which JSON encoded records will be passed to the server if the
		 * [encode](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html#cfg-encode) option is `true`.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		rootProperty?: string;
		/** 
		 * If a transform function is set, it will be invoked just before [writeRecords](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#method-writeRecords)
		 * executes. It is passed the unserialized data object and the [request](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Request.html)
		 * object. The transform function returns a data object, which can be a modified version of the original
		 * data object, or a completely new data object. The transform can be a function, or an object
		 * with a 'fn' key and an optional 'scope' key. Example usage:
		 * 
		 *    Ext.create('Ext.data.Store', {
		 *        model: 'User',
		 *        proxy: {
		 *            type: 'ajax',
		 *            url : 'users.json',
		 *            writer: {
		 *                type: 'json',
		 *                transform: {
		 *                    fn: function(data, request) {
		 *                        // do some manipulation of the unserialized data object
		 *                        return data;
		 *                    },
		 *                    scope: this
		 *                }
		 *            }
		 *        },
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {ExtGlobalFunction|object}
		 */
		transform?: ExtGlobalFunction | object;
		/** 
		 * `true` to write all fields from the record to the
		 * server. If set to `false` it will only send the fields that were modified. Note
		 * that any fields that have [`Ext.data.field.Field.persist`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Field.html#cfg-persist) set to `false`
		 * will still be ignored while those with [`Ext.data.field.Field.critical`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Field.html#cfg-critical)
		 * set to `true` will be included.
		 * 
		 * The exact set of fields written is determined by `allDataOptions` (when `true`)
		 * or `partialDataOptions` (when `false`). This option is ignored and treated as
		 * `true` when writing [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) records.
		 * 
		 * It is seldom a good idea to use this config. Rather use `allDataOptions` or
		 * `partialDataOptions` to control what fields are sent for records based on their
		 * [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) state.
		 * 
		 * In the previous release, this was default `true`.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		writeAllFields?: boolean;
		/** 
		 * By default, each record's id is always included in the output for non-phantom
		 * records since in most cases the id will be required on the server to process
		 * the record action. This is helpful since the id will normally not be modified,
		 * and so would not be sent to the server unless [writeAllFields](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeAllFields) was
		 * explicitly enabled.
		 * 
		 * However, there are cases where it is not desirable for the record id to be passed
		 * in the data directly. For example, when using a RESTful API the record id would
		 * typically be appended to the url instead.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		writeRecordId?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.data.writer.Json.Statics}        this
		 */
		initConfig? (config: object): Ext.data.writer.Json.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.data.writer.Json.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.writer.Json.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.writer.Json.Statics}  
		 */
		statics? (): Ext.data.writer.Json.Statics;
	}
}
declare namespace Ext.data.writer.Writer {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.writer.Writer](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html)
	 * Base Writer class used by most subclasses of [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.Server.html). This class
	 * is responsible for taking a set of [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.operation.Operation.html) objects and a
	 * [Ext.data.Request](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Request.html) object and modifying that request based on the Operations.
	 * 
	 * For example a [Ext.data.writer.Json](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Json.html) would format the Operations and their
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) instances based on the config options passed to the JsonWriter's
	 * constructor.
	 * 
	 * Writers are not needed for any kind of local storage - whether via a
	 * [Web Storage proxy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.WebStorage.html) (see
	 * [localStorage](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.LocalStorage.html) and
	 * [sessionStorage](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.SessionStorage.html))
	 * or just in memory via a [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.Memory.html).
	 * 
	 * # Dates
	 * 
	 * Before sending dates to the server, they can be formatted using an [Ext.Date](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Date.html)
	 * format. These formats can be specified both on the field and the writer itself. In terms
	 * of precedence, from highest to lowest:
	 * 
	 * - [Writer.dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-dateFormat) The writer `dateFormat` will always have the
	 *   highest precedence.
	 * - [Ext.data.field.Date.dateWriteFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateWriteFormat) The `dateWriteFormat` given to the field
	 *   instance. This is handled by [Ext.data.field.Date.serialize](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#method-serialize).
	 * - [Field.dateFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateFormat) This is handled by the field's
	 *   `serialize` method.
	 * - [Field.dateReadFormat](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Date.html#cfg-dateReadFormat) Also handled by the
	 *   field's `serialize` method.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * This object contains the options passed to [`Ext.data.Model.getData`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#method-getData) when
		 * writing [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) records or when `writeAllFields` is set
		 * to `true`.
		 * 
		 * _NOTE:_ The `serialize` option cannot be used here.
		 * @configuration
		 * @optional
		 * @default {persist: true}
		 * @type {object}
		 */
		allDataOptions?: object;
		/** 
		 * When specified this property causes the [`Ext.data.Model.idProperty`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-idProperty) of
		 * newly created records to be sent to the server as this name instead of the
		 * value of the `idProperty`.
		 * 
		 * For example, by default, the following code:
		 * 
		 *     Ext.define('Person', {
		 *         idProperty: 'id',  // this is the default value (for clarity)
		 *    
		 *         fields: [ 'name' ]
		 *     });
		 *    
		 *     var person = new Person({
		 *         // no id provided, so one is generated
		 *         name: 'Clark Kent'
		 *     });
		 * 
		 * Will send this to the server:
		 * 
		 *     {
		 *         id: 'Person-1',
		 *         name: 'Clark Kent'
		 *     }
		 * 
		 * This can be an issue if the server expects an integer for the "id" property.
		 * You can use [`Ext.data.Model.identifier`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-identifier) to produce identifiers that
		 * the server would recognize or use this config to send the client's id in a
		 * different property.
		 * 
		 *     Ext.define('Person', {
		 *         idProperty: 'id',  // this is the default value (for clarity)
		 *    
		 *         proxy: {
		 *             writer: {
		 *                 clientIdProperty: 'clientId'
		 *             }
		 *         },
		 *    
		 *         fields: [ 'name' ]
		 *     });
		 * 
		 * Given the above, the server is sent this data now:
		 * 
		 *     {
		 *         clientId: 'Person-1',
		 *         name: 'Clark Kent'
		 *     }
		 * 
		 * While this config provides the behavior of [`Ext.data.Model.clientIdProperty`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-clientIdProperty)
		 * from previous releases, this property is not as useful as a suitable
		 * [`Ext.data.Model.identifier`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-identifier) due to id's appearing in foreign-key fields
		 * and in [`Ext.data.Model.manyToMany`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-manyToMany) associations.
		 * 
		 * See [`Ext.data.Model.identifier`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-identifier) for more on id generation.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		clientIdProperty?: string;
		/** 
		 * This is used for each field of type date in the model to format the value before
		 * it is sent to the server.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		dateFormat?: string;
		/** 
		 * This property is used to read the key for each value that will be sent to the
		 * server.
		 * 
		 * For example:
		 * 
		 *    Ext.define('Person', {
		 *        extend: 'Ext.data.Model',
		 *        fields: [{
		 *            name: 'first',
		 *            mapping: 'firstName'
		 *        }, {
		 *            name: 'last',
		 *            mapping: 'lastName'
		 *        }, {
		 *            name: 'age'
		 *        }]
		 *    });
		 *    
		 *    new Ext.data.writer.Writer({
		 *        nameProperty: 'mapping'
		 *    });
		 *    
		 *    // This will be sent to the server
		 *    {
		 *        firstName: 'first name value',
		 *        lastName: 'last name value',
		 *        age: 1
		 *    }
		 * 
		 * If the value is not present, the field name will always be used.
		 * @configuration
		 * @optional
		 * @default 'name'
		 * @type {string}
		 */
		nameProperty?: string;
		/** 
		 * This object contains the options passed to [`Ext.data.Model.getData`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#method-getData) when
		 * writing non [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) records or when `writeAllFields` is
		 * set to `false`.
		 * 
		 * _NOTE:_ The `serialize` option cannot be used here.
		 * @configuration
		 * @optional
		 * @default {changes: true, critical: true}
		 * @type {object}
		 */
		partialDataOptions?: object;
		/** 
		 * If a transform function is set, it will be invoked just before [writeRecords](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#method-writeRecords)
		 * executes. It is passed the unserialized data object and the [request](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Request.html)
		 * object. The transform function returns a data object, which can be a modified version of the original
		 * data object, or a completely new data object. The transform can be a function, or an object
		 * with a 'fn' key and an optional 'scope' key. Example usage:
		 * 
		 *    Ext.create('Ext.data.Store', {
		 *        model: 'User',
		 *        proxy: {
		 *            type: 'ajax',
		 *            url : 'users.json',
		 *            writer: {
		 *                type: 'json',
		 *                transform: {
		 *                    fn: function(data, request) {
		 *                        // do some manipulation of the unserialized data object
		 *                        return data;
		 *                    },
		 *                    scope: this
		 *                }
		 *            }
		 *        },
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {ExtGlobalFunction|object}
		 */
		transform?: ExtGlobalFunction | object;
		/** 
		 * `true` to write all fields from the record to the
		 * server. If set to `false` it will only send the fields that were modified. Note
		 * that any fields that have [`Ext.data.field.Field.persist`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Field.html#cfg-persist) set to `false`
		 * will still be ignored while those with [`Ext.data.field.Field.critical`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Field.html#cfg-critical)
		 * set to `true` will be included.
		 * 
		 * The exact set of fields written is determined by `allDataOptions` (when `true`)
		 * or `partialDataOptions` (when `false`). This option is ignored and treated as
		 * `true` when writing [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) records.
		 * 
		 * It is seldom a good idea to use this config. Rather use `allDataOptions` or
		 * `partialDataOptions` to control what fields are sent for records based on their
		 * [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) state.
		 * 
		 * In the previous release, this was default `true`.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		writeAllFields?: boolean;
		/** 
		 * By default, each record's id is always included in the output for non-phantom
		 * records since in most cases the id will be required on the server to process
		 * the record action. This is helpful since the id will normally not be modified,
		 * and so would not be sent to the server unless [writeAllFields](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeAllFields) was
		 * explicitly enabled.
		 * 
		 * However, there are cases where it is not desirable for the record id to be passed
		 * in the data directly. For example, when using a RESTful API the record id would
		 * typically be appended to the url instead.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		writeRecordId?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                         config
		 * @returns {Ext.data.writer.Writer.Statics}        this
		 */
		initConfig? (config: object): Ext.data.writer.Writer.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                  name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                         [value] The value to set for the name parameter.
		 * @returns {Ext.data.writer.Writer.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.writer.Writer.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.writer.Writer.Statics}  
		 */
		statics? (): Ext.data.writer.Writer.Statics;
	}
}
declare namespace Ext.data.writer.Xml {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.writer.Xml](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html)
	 * This class is used to write [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html) data to the server in an XML format.
	 * The [documentRoot](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-documentRoot) property is used to specify the root element in the XML document.
	 * The [record](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-record) option is used to specify the element name for each record that will make up the XML document.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * This object contains the options passed to [`Ext.data.Model.getData`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#method-getData) when
		 * writing [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) records or when `writeAllFields` is set
		 * to `true`.
		 * 
		 * _NOTE:_ The `serialize` option cannot be used here.
		 * @configuration
		 * @optional
		 * @default {persist: true}
		 * @type {object}
		 */
		allDataOptions?: object;
		/** 
		 * When specified this property causes the [`Ext.data.Model.idProperty`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-idProperty) of
		 * newly created records to be sent to the server as this name instead of the
		 * value of the `idProperty`.
		 * 
		 * For example, by default, the following code:
		 * 
		 *     Ext.define('Person', {
		 *         idProperty: 'id',  // this is the default value (for clarity)
		 *    
		 *         fields: [ 'name' ]
		 *     });
		 *    
		 *     var person = new Person({
		 *         // no id provided, so one is generated
		 *         name: 'Clark Kent'
		 *     });
		 * 
		 * Will send this to the server:
		 * 
		 *     {
		 *         id: 'Person-1',
		 *         name: 'Clark Kent'
		 *     }
		 * 
		 * This can be an issue if the server expects an integer for the "id" property.
		 * You can use [`Ext.data.Model.identifier`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-identifier) to produce identifiers that
		 * the server would recognize or use this config to send the client's id in a
		 * different property.
		 * 
		 *     Ext.define('Person', {
		 *         idProperty: 'id',  // this is the default value (for clarity)
		 *    
		 *         proxy: {
		 *             writer: {
		 *                 clientIdProperty: 'clientId'
		 *             }
		 *         },
		 *    
		 *         fields: [ 'name' ]
		 *     });
		 * 
		 * Given the above, the server is sent this data now:
		 * 
		 *     {
		 *         clientId: 'Person-1',
		 *         name: 'Clark Kent'
		 *     }
		 * 
		 * While this config provides the behavior of [`Ext.data.Model.clientIdProperty`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-clientIdProperty)
		 * from previous releases, this property is not as useful as a suitable
		 * [`Ext.data.Model.identifier`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-identifier) due to id's appearing in foreign-key fields
		 * and in [`Ext.data.Model.manyToMany`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-manyToMany) associations.
		 * 
		 * See [`Ext.data.Model.identifier`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#cfg-identifier) for more on id generation.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		clientIdProperty?: string;
		/** 
		 * This is used for each field of type date in the model to format the value before
		 * it is sent to the server.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		dateFormat?: string;
		/** 
		 * The root to be used if [documentRoot](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-documentRoot) is empty and a root is required
		 * to form a valid XML document.
		 * @configuration
		 * @optional
		 * @default 'xmlData'
		 * @type {string}
		 */
		defaultDocumentRoot?: string;
		/** 
		 * The name of the root element of the document. Defaults to <tt>'xmlData'</tt>.
		 * If there is more than 1 record and the root is not specified, the default document root will still be used
		 * to ensure a valid XML document is created.
		 * 
		 * If the [record](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Xml.html#cfg-record) mapping includes a root element name, eg: "SystemInfo>Operation", and
		 * the selector includes the root element name, then you must configure this as `false`
		 * @configuration
		 * @optional
		 * @default 'xmlData'
		 * @type {string}
		 */
		documentRoot?: string;
		/** 
		 * A header to use in the XML document (such as setting the encoding or version).
		 * Defaults to <tt>''</tt>.
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		header?: string;
		/** 
		 * This property is used to read the key for each value that will be sent to the
		 * server.
		 * 
		 * For example:
		 * 
		 *    Ext.define('Person', {
		 *        extend: 'Ext.data.Model',
		 *        fields: [{
		 *            name: 'first',
		 *            mapping: 'firstName'
		 *        }, {
		 *            name: 'last',
		 *            mapping: 'lastName'
		 *        }, {
		 *            name: 'age'
		 *        }]
		 *    });
		 *    
		 *    new Ext.data.writer.Writer({
		 *        nameProperty: 'mapping'
		 *    });
		 *    
		 *    // This will be sent to the server
		 *    {
		 *        firstName: 'first name value',
		 *        lastName: 'last name value',
		 *        age: 1
		 *    }
		 * 
		 * If the value is not present, the field name will always be used.
		 * @configuration
		 * @optional
		 * @default 'name'
		 * @type {string}
		 */
		nameProperty?: string;
		/** 
		 * This object contains the options passed to [`Ext.data.Model.getData`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#method-getData) when
		 * writing non [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) records or when `writeAllFields` is
		 * set to `false`.
		 * 
		 * _NOTE:_ The `serialize` option cannot be used here.
		 * @configuration
		 * @optional
		 * @default {changes: true, critical: true}
		 * @type {object}
		 */
		partialDataOptions?: object;
		/** 
		 * The name of the node to use for each record. Defaults to
		 * the owning [Proxy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.proxy.Proxy.html)'s [Reader](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.reader.Xml.html)'s
		 * [Ext.data.reader.Xml.record](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.reader.Xml.html#cfg-record) setting, or `'record'`.
		 * @configuration
		 * @optional
		 * @default 'record'
		 * @type {string}
		 */
		record?: string;
		/** 
		 * If a transform function is set, it will be invoked just before [writeRecords](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#method-writeRecords)
		 * executes. It is passed the unserialized data object and the [request](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Request.html)
		 * object. The transform function returns a data object, which can be a modified version of the original
		 * data object, or a completely new data object. The transform can be a function, or an object
		 * with a 'fn' key and an optional 'scope' key. Example usage:
		 * 
		 *    Ext.create('Ext.data.Store', {
		 *        model: 'User',
		 *        proxy: {
		 *            type: 'ajax',
		 *            url : 'users.json',
		 *            writer: {
		 *                type: 'json',
		 *                transform: {
		 *                    fn: function(data, request) {
		 *                        // do some manipulation of the unserialized data object
		 *                        return data;
		 *                    },
		 *                    scope: this
		 *                }
		 *            }
		 *        },
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {ExtGlobalFunction|object}
		 */
		transform?: ExtGlobalFunction | object;
		/** 
		 * `true` to write all fields from the record to the
		 * server. If set to `false` it will only send the fields that were modified. Note
		 * that any fields that have [`Ext.data.field.Field.persist`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Field.html#cfg-persist) set to `false`
		 * will still be ignored while those with [`Ext.data.field.Field.critical`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.field.Field.html#cfg-critical)
		 * set to `true` will be included.
		 * 
		 * The exact set of fields written is determined by `allDataOptions` (when `true`)
		 * or `partialDataOptions` (when `false`). This option is ignored and treated as
		 * `true` when writing [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) records.
		 * 
		 * It is seldom a good idea to use this config. Rather use `allDataOptions` or
		 * `partialDataOptions` to control what fields are sent for records based on their
		 * [`Ext.data.Model.phantom`](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.Model.html#property-phantom) state.
		 * 
		 * In the previous release, this was default `true`.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		writeAllFields?: boolean;
		/** 
		 * By default, each record's id is always included in the output for non-phantom
		 * records since in most cases the id will be required on the server to process
		 * the record action. This is helpful since the id will normally not be modified,
		 * and so would not be sent to the server unless [writeAllFields](https://docs.sencha.com/extjs/6.2.0/classic/Ext.data.writer.Writer.html#cfg-writeAllFields) was
		 * explicitly enabled.
		 * 
		 * However, there are cases where it is not desirable for the record id to be passed
		 * in the data directly. For example, when using a RESTful API the record id would
		 * typically be appended to the url instead.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		writeRecordId?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/classic/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example [Ext.button.Button](https://docs.sencha.com/extjs/6.2.0/classic/Ext.button.Button.html) definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.data.writer.Xml.Statics}        this
		 */
		initConfig? (config: object): Ext.data.writer.Xml.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.writer.Xml.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.writer.Xml.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/classic/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.writer.Xml.Statics}  
		 */
		statics? (): Ext.data.writer.Xml.Statics;
	}
}

declare namespace Ext.data {
	/** 
	 * [Ext.data.AbstractStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html)
	 * AbstractStore is a superclass of [Ext.data.ProxyStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html) and [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html). It's never used directly,
	 * but offers a set of methods used by both of those subclasses.
	 * 
	 * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
	 * you're probably looking for is [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
	 */
	class AbstractStore extends Ext.Base {
		/** 
		 * The page that the Store has most recently loaded (see [loadPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadPage))
		 * @property
		 * @public (property)
		 * @default 1
		 * @type {number}
		 */
		currentPage?: number;
		/** 
		 * If this property is specified by the target class of this mixin its properties are
		 * used to configure the created [`Ext.Factory`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Factory.html).
		 * @property
		 * @public (property)
		 * @default {defaultType: 'store', type: 'store'}
		 * @type {object}
		 */
		factoryConfig?: object;
		/** 
		 * This object holds a key for any event that has a listener. The listener may be set
		 * directly on the instance, or on its class or a super class (via [observe](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#static-method-observe)) or
		 * on the [MVC EventBus](https://docs.sencha.com/extjs/6.2.0/modern/Ext.app.EventBus.html). The values of this object are truthy
		 * (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
		 * of listeners. The value for an event is truthy if the event must be fired and is
		 * falsy if there is no need to fire the event.
		 * 
		 * The intended use of this property is to avoid the expense of fireEvent calls when
		 * there are no listeners. This can be particularly helpful when one would otherwise
		 * have to call fireEvent hundreds or thousands of times. It is used like this:
		 * 
		 *     if (this.hasListeners.foo) {
		 *         this.fireEvent('foo', this, arg1);
		 *     }
		 * 
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		readonly hasListeners?: object;
		/** 
		 * `true` in this class to identify an object as an instantiated Observable, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isObservable?: boolean;
		/** 
		 * `true` in this class to identify an object as an instantiated Store, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isStore?: boolean;
		/** 
		 * A counter that is increased by `beginUpdate` and decreased by `endUpdate`. When
		 * this transitions from 0 to 1 the [`beginupdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-beginupdate) event is
		 * fired. When it transitions back from 1 to 0 the [`endupdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-endupdate)
		 * event is fired.
		 * @property
		 * @public (property)
		 * @readonly
		 * @default 0
		 * @type {number}
		 */
		readonly updating?: number;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.AbstractStore.Statics}
		 */
		self?: Ext.data.AbstractStore.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * Matches options property names within a listeners specification object  - property names which are never used as event names.
		 * @property
		 * @private (property)
		 * @default {scope: 1, delay: 1, buffer: 1, onFrame: 1, single: 1, args: 1, destroyable: 1, priority: 1, order: 1}
		 * @type {object}
		 */
		$eventOptions?: object;
		/** 
		 * We don't want the base destructor to clear the prototype because
		 * our destroyObservable handler must be called the very last. It will take care
		 * of the prototype after completing Observable destruction sequence.
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$vetoClearingPrototypeOnDestroy?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		deprecated?: object;
		/** 
		 * Initial suspended call count. Incremented when [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents) is called, decremented when [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) is called.
		 * @property
		 * @private (property)
		 * @default 0
		 * @type {number}
		 */
		eventsSuspended?: number;
		/** 
		 * `true` if the Store is currently loading via its Proxy.
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		loading?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @default 'factoryable'
		 * @type {string}
		 */
		mixinId?: string;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members    The members to add to this class.
		 * @param   {boolean}                         [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                         [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.AbstractStore|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members
		 * @returns {Ext.data.AbstractStore|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.AbstractStore;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          name
		 * @param   {object}                          member
		 * @returns {Ext.data.AbstractStore|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          fn
		 * @param   {object}                          scope
		 * @returns {Ext.data.AbstractStore|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * documented above
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * Adds a new Filter to this Store's [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {object[]|Ext.util.Filter[]} filters         The set of filters to add to the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters).
		 * @param   {boolean}                    [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                       
		 */
		addFilter? (filters: object[] | Ext.util.Filter[], suppressEvent?: boolean): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                                  eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                                [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                                         [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.data.AbstractStore.methodParams.addListener.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                                         [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                                         
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addListener? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.data.AbstractStore.methodParams.addListener.Options, order?: string): object;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * This method may be called to indicate the start of multiple changes to the store.
		 * 
		 * Automatic synchronization as configured by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred
		 * until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple mutations can be coalesced
		 * into one synchronization operation.
		 * 
		 * Internally this method increments a counter that is decremented by `endUpdate`. It
		 * is important, therefore, that if you call `beginUpdate` directly you match that
		 * call with a call to `endUpdate` or you will prevent the collection from updating
		 * properly.
		 * 
		 * For example:
		 * 
		 *     var store = Ext.StoreManager.lookup({
		 *         //...
		 *         autoSync: true
		 *     });
		 *    
		 *     store.beginUpdate();
		 *    
		 *     record.set('fieldName', 'newValue');
		 *    
		 *     store.add(item);
		 *     // ...
		 *    
		 *     store.insert(index, otherItem);
		 *     //...
		 *    
		 *     // Interested parties will listen for the endupdate event
		 *     store.endUpdate();
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginUpdate? (): void;
		/** 
		 * Reverts to a view of the Record cache with no filtering applied.
		 * @method
		 * @public (method)
		 * @param   {boolean} [suppressEvent]
		 * If `true` the filter is cleared silently.
		 * 
		 * For a locally filtered Store, this means that the filter collection is cleared without firing the
		 * [datachanged](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-datachanged) event.
		 * 
		 * For a remotely filtered Store, this means that the filter collection is cleared, but the store
		 * is not reloaded from the server.
		 * @returns {void}                    
		 */
		clearFilter? (suppressEvent?: boolean): void;
		/** 
		 * Clear the store grouping
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearGrouping? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Checks if a record is in the current active data set.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record
		 * @returns {boolean}               `true` if the record is in the current active data set.
		 */
		contains? (record: Ext.data.Model): boolean;
		/** 
		 * Perform the Store destroying sequence. Override this method to add destruction
		 * behaviors to your custom Stores.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		doDestroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * This method is called after modifications are complete on a store. For details
		 * see [`beginUpdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		endUpdate? (): void;
		/** 
		 * Filters the data in the Store by one or more fields. Example usage:
		 * 
		 *    //filter with a single field
		 *    myStore.filter('firstName', 'Don');
		 *    
		 *    //filtering with multiple filters
		 *    myStore.filter([
		 *        {
		 *            property : 'firstName',
		 *            value    : 'Don'
		 *        },
		 *        {
		 *            property : 'lastName',
		 *            value    : 'Griffin'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) instances, and delegates
		 * the actual filtering to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter[]} [filters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of filter configurations.
		 * @param   {string}                   [value]   The property value by which to filter. Only applicable if `filters` is a string.
		 * @returns {void}                               
		 */
		filter? (filters?: string | Ext.util.Filter[], value?: string): void;
		/** 
		 * Filters by a function. The specified function will be called for each
		 * Record in this Store. If the function returns `true` the Record is included,
		 * otherwise it is filtered out.
		 * 
		 * When store is filtered, most of the methods for accessing store data will be working only
		 * within the set of filtered records. The notable exception is [getById](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getById).
		 * @method
		 * @public (method)
		 * @param   {Function}       fn          The function to be called. It will be passed the following parameters:
		 * @param   {Ext.data.Model} [fn.record]
		 * The record to test for filtering. Access field values
		 *  using [Ext.data.Model.get](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-get).
		 * @param   {void}           fn.returns
		 * @param   {object}         [scope]
		 * The scope (this reference) in which the function is executed.
		 * Defaults to this Store.
		 * @returns {void}                       
		 */
		filterBy? (fn: ((record?: Ext.data.Model) => void) | ExtGlobalFunction, scope?: object): void;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of the Record field to test.
		 * @param   {string|RegExp} value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}        [startIndex]    The index to start searching at
		 * @param   {boolean}       [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}       [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {number}                        The matched index or -1
		 */
		find? (property: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;
		/** 
		 * Find the index of the first matching Record in this Store by a function.
		 * If the function returns `true` it is considered a match.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {Function}       fn           The function to be called. It will be passed the following parameters:
		 * @param   {Ext.data.Model} [fn.record]
		 * The record to test for filtering. Access field values
		 *  using [Ext.data.Model.get](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-get).
		 * @param   {object}         [fn.id]      The ID of the Record passed.
		 * @param   {void}           fn.returns
		 * @param   {object}         [scope]
		 * The scope (this reference) in which the function is executed.
		 * Defaults to this Store.
		 * @param   {number}         [startIndex] The index to start searching at
		 * @returns {number}                      The matched index or -1
		 */
		findBy? (fn: ((record?: Ext.data.Model, id?: object) => void) | ExtGlobalFunction, scope?: object, startIndex?: number): number;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string} fieldName    The name of the Record field to test.
		 * @param   {object} value        The value to match the field against.
		 * @param   {number} [startIndex] The index to start searching at
		 * @returns {number}              The matched index or -1
		 */
		findExact? (fieldName: string, value: object, startIndex?: number): number;
		/** 
		 * Finds the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}         fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}  value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}         [startIndex]    The index to start searching at
		 * @param   {boolean}        [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}        [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}        [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.Model}                 The matched record or null
		 */
		findRecord? (fieldName: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Get the Record at the specified index.
		 * 
		 * The index is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}         index The index of the Record to find.
		 * @returns {Ext.data.Model}       The Record at the passed index. Returns null if not found.
		 */
		getAt? (index: number): Ext.data.Model;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Get the Record with the specified id.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            id The id of the Record to find.
		 * @returns {Ext.data.Model}    The Record with the passed id. Returns null if not found.
		 */
		getById? (id: any): Ext.data.Model;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Gets the number of records in store.
		 * 
		 * If using paging, this may not be the total size of the dataset. If the data object
		 * used by the Reader contains the dataset size, then the [Ext.data.ProxyStore.getTotalCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getTotalCount) function returns
		 * the dataset size.  **Note**: see the Important note in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load).
		 * 
		 * When store is filtered, it's the number of records matching the filter.
		 * @method
		 * @public (method)
		 * @returns {number}  The number of Records in the Store.
		 */
		getCount? (): number;
		/** 
		 * Gets the filters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.FilterCollection}            The filters
		 */
		getFilters? (autoCreate: object): Ext.util.FilterCollection;
		/** 
		 * Returns the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDir? (): string;
		/** 
		 * Returns the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @returns {object|Ext.util.Grouper}  
		 */
		getGrouper? (): object | Ext.util.Grouper;
		/** 
		 * Returns a collection of readonly sub-collections of your store's records
		 * with grouping applied. These sub-collections are maintained internally by
		 * the collection.
		 * 
		 * See [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField), [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir). Example for a store
		 * containing records with a color field:
		 * 
		 *    var myStore = Ext.create('Ext.data.Store', {
		 *        groupField: 'color',
		 *        groupDir  : 'DESC'
		 *    });
		 *    
		 *    myStore.getGroups();
		 * 
		 * The above should result in the following format:
		 * 
		 *    [
		 *        {
		 *            name: 'yellow',
		 *            children: [
		 *                // all records where the color field is 'yellow'
		 *            ]
		 *        },
		 *        {
		 *            name: 'red',
		 *            children: [
		 *                // all records where the color field is 'red'
		 *            ]
		 *        }
		 *    ]
		 * 
		 * Group contents are affected by filtering.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection}  The grouped data
		 */
		getGroups? (): Ext.util.Collection;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getPageSize? (): number;
		/** 
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}           start The starting index. Defaults to zero.
		 * @param   {number}           end   The ending index. Defaults to the last record. The end index **is included**.
		 * @returns {Ext.data.Model[]}       An array of records.
		 */
		getRange? (start: number, end: number): Ext.data.Model[];
		/** 
		 * Returns the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteFilter? (): boolean;
		/** 
		 * Returns the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteSort? (): boolean;
		/** 
		 * Gets the sorters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.SorterCollection}            The sorters
		 */
		getSorters? (autoCreate: object): Ext.util.SorterCollection;
		/** 
		 * Returns the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getStatefulFilters? (): boolean;
		/** 
		 * Returns the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStoreId? (): string;
		/** 
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {string|object} grouper
		 * Either a string name of one of the fields in this Store's
		 * configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an object, or a [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Grouper.html) configuration object.
		 * @param   {string}        [direction] The overall direction to group the data by. Defaults to the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @returns {void}                      
		 */
		group? (grouper: string | object, direction?: string): void;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Tests whether the store currently has any active filters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is filtered.
		 */
		isFiltered? (): boolean;
		/** 
		 * Tests whether the store currently has an active grouper.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is grouped.
		 */
		isGrouped? (): boolean;
		/** 
		 * Returns `true` if the Store has been loaded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store has been loaded.
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns `true` if the Store is currently performing a load operation.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store is currently loading.
		 */
		isLoading? (): boolean;
		/** 
		 * Tests whether the store currently has any active sorters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is sorted.
		 */
		isSorted? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                         eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                       [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                                [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.data.AbstractStore.methodParams.on.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                                [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                                
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		on? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.data.AbstractStore.methodParams.on.Options, order?: string): object;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an individual Filter from the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) using the passed Filter/Filter id and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter} toRemove        The id of a Filter to remove from the filter set, or a Filter instance to remove.
		 * @param   {boolean}                [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                   
		 */
		removeFilter? (toRemove: string | Ext.util.Filter, suppressEvent?: boolean): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                   name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                          [value] The value to set for the name parameter.
		 * @returns {Ext.data.AbstractStore|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setFilters? (): void;
		/** 
		 * Sets the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @param   {string} groupDir The new value.
		 * @returns {void}            
		 */
		setGroupDir? (groupDir: string): void;
		/** 
		 * Sets the value of [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField).
		 * @method
		 * @public (method)
		 * @param   {string} groupField The new value.
		 * @returns {void}              
		 */
		setGroupField? (groupField: string): void;
		/** 
		 * Sets the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.util.Grouper} grouper The new value.
		 * @returns {void}                            
		 */
		setGrouper? (grouper: object | Ext.util.Grouper): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @param   {number} pageSize The new value.
		 * @returns {void}            
		 */
		setPageSize? (pageSize: number): void;
		/** 
		 * Sets the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteFilter The new value.
		 * @returns {void}                 
		 */
		setRemoteFilter? (remoteFilter: boolean): void;
		/** 
		 * Sets the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteSort The new value.
		 * @returns {void}               
		 */
		setRemoteSort? (remoteSort: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setSorters? (): void;
		/** 
		 * Sets the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @param   {boolean} statefulFilters The new value.
		 * @returns {void}                    
		 */
		setStatefulFilters? (statefulFilters: boolean): void;
		/** 
		 * Sets the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @param   {string} storeId The new value.
		 * @returns {void}           
		 */
		setStoreId? (storeId: string): void;
		/** 
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction] The overall direction to sort the data by.
		 * @returns {Ext.util.Sorter[]}                    
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string): Ext.util.Sorter[];
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Destructor for classes that extend Observable.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                          config
		 * @returns {Ext.data.AbstractStore|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.AbstractStore;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.AbstractStore.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorter
		 * @returns {void}          
		 */
		addFieldTransform? (sorter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @param   {object} filtersCollection
		 * @returns {void}                     
		 */
		applyFilters? (filters: object, filtersCollection: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} grouper
		 * @returns {void}           
		 */
		applyGrouper? (grouper: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorters
		 * @param   {object} sortersCollection
		 * @returns {void}                     
		 */
		applySorters? (sorters: object, sortersCollection: object): void;
		/** 
		 * Restores state to the passed state
		 * @method
		 * @private (method)
		 * @param   {object} state
		 * @returns {void}         
		 */
		applyState? (state: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		fireGroupChange? (): void;
		/** 
		 * Returns the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getAutoSort? (): boolean;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getGroupField? (): void;
		/** 
		 * Returns the grouping, sorting and filtered state of this Store.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getState? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Returns true if the store has a pending load task.
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the store has a pending load task.
		 */
		hasPendingLoad? (): boolean;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * This is attached to the data Collection's beforesort event only if not remoteSort
		 * If remoteSort, the event is fired before the reload call in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-load).
		 * @method
		 * @private (method)
		 * @param   {object} store
		 * @param   {object} sorters
		 * @returns {void}           
		 */
		onBeforeCollectionSort? (store: object, sorters: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onFilterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onSorterEndUpdate? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Determines if the passed range is available in the page cache.
		 * @method
		 * @private (method)
		 * @param   {number} start The start index
		 * @param   {number} end   The end index in the range
		 * @returns {void}         
		 */
		rangeCached? (start: number, end: number): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Sets the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @param   {boolean} autoSort The new value.
		 * @returns {void}             
		 */
		setAutoSort? (autoSort: boolean): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                        names The names of the linked objects to destroy.
		 * @returns {Ext.data.AbstractStore|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.AbstractStore;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoSort
		 * @returns {void}            
		 */
		updateAutoSort? (autoSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} field
		 * @returns {void}         
		 */
		updateGroupField? (field: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @returns {void}                
		 */
		updateRemoteFilter? (remoteFilter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @returns {void}              
		 */
		updateRemoteSort? (remoteSort: object): void;
	}
	/** 
	 * [Ext.data.ArrayStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from Array data easier. An ArrayStore will be
	 * automatically configured with a [Ext.data.reader.Array](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Array.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = Ext.create('Ext.data.ArrayStore', {
	 *        // store configs
	 *        storeId: 'myStore',
	 *        // reader configs
	 *        fields: [
	 *           'company',
	 *           {name: 'price', type: 'float'},
	 *           {name: 'change', type: 'float'},
	 *           {name: 'pctChange', type: 'float'},
	 *           {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
	 *        ]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    var myData = [
	 *        ['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
	 *        ['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
	 *        ['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
	 *        ['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
	 *        ['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
	 *    ];
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#cfg-data) config option.
	 */
	class ArrayStore extends Ext.data.Store {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.ArrayStore.Statics}
		 */
		self?: Ext.data.ArrayStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 members    The members to add to this class.
		 * @param   {boolean}                                                                                [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.ArrayStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ArrayStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 members
		 * @returns {Ext.data.ArrayStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.ArrayStore;
		static addStatics? (members: object): typeof Ext.data.Store;
		static addStatics? (members: object): typeof Ext.data.ProxyStore;
		static addStatics? (members: object): typeof Ext.data.AbstractStore;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 name
		 * @param   {object}                                                                                 member
		 * @returns {Ext.data.ArrayStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.ArrayStore;
		static addMember? (name: object, member: object): typeof Ext.data.Store;
		static addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		static addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 fn
		 * @param   {object}                                                                                 scope
		 * @returns {Ext.data.ArrayStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.ArrayStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		static onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates the store.
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                The model instances that were added
		 */
		add? (model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {...Ext.data.Model|...object} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                  The model instances that were added
		 */
		add? (...model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * Adds a new Filter to this Store's [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {object[]|Ext.util.Filter[]} filters         The set of filters to add to the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters).
		 * @param   {boolean}                    [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                       
		 */
		addFilter? (filters: object[] | Ext.util.Filter[], suppressEvent?: boolean): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * (Local sort only) Inserts the passed Record into the Store at the index where it
		 * should go based on the current sort information.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Record} record
		 * @returns {void}                   
		 */
		addSorted? (record: Ext.data.Record): void;
		/** 
		 * Runs the aggregate function for all the records in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {Function} fn
		 * The function to execute. The function is called with a single parameter,
		 * an array of records for that group.
		 * @param   {object}   scope   The scope to execute the function in. Defaults to the store.
		 * @param   {boolean}  grouped
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @param   {string}   field   The field to get the value from
		 * @returns {object}           An object literal with the group names and their appropriate values.
		 */
		aggregate? (fn: ExtGlobalFunction, scope: object, grouped: boolean, field: string): object;
		/** 
		 * Gets the average value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The average value, if no items exist, 0.
		 */
		average? (field: string, grouped?: boolean): object;
		/** 
		 * This method may be called to indicate the start of multiple changes to the store.
		 * 
		 * Automatic synchronization as configured by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred
		 * until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple mutations can be coalesced
		 * into one synchronization operation.
		 * 
		 * Internally this method increments a counter that is decremented by `endUpdate`. It
		 * is important, therefore, that if you call `beginUpdate` directly you match that
		 * call with a call to `endUpdate` or you will prevent the collection from updating
		 * properly.
		 * 
		 * For example:
		 * 
		 *     var store = Ext.StoreManager.lookup({
		 *         //...
		 *         autoSync: true
		 *     });
		 *    
		 *     store.beginUpdate();
		 *    
		 *     record.set('fieldName', 'newValue');
		 *    
		 *     store.add(item);
		 *     // ...
		 *    
		 *     store.insert(index, otherItem);
		 *     //...
		 *    
		 *     // Interested parties will listen for the endupdate event
		 *     store.endUpdate();
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginUpdate? (): void;
		/** 
		 * Reverts to a view of the Record cache with no filtering applied.
		 * @method
		 * @public (method)
		 * @param   {boolean} [suppressEvent]
		 * If `true` the filter is cleared silently.
		 * 
		 * For a locally filtered Store, this means that the filter collection is cleared without firing the
		 * [datachanged](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-datachanged) event.
		 * 
		 * For a remotely filtered Store, this means that the filter collection is cleared, but the store
		 * is not reloaded from the server.
		 * @returns {void}                    
		 */
		clearFilter? (suppressEvent?: boolean): void;
		/** 
		 * Clear the store grouping
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearGrouping? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Commits all Records with [outstanding changes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords). To handle updates for changes,
		 * subscribe to the Store's [update event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-update), and perform updating when the third parameter is
		 * [Ext.data.Record.COMMIT](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#static-property-COMMIT).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		commitChanges? (): void;
		/** 
		 * Gets the count of items in the store.
		 * 
		 * When store is filtered, only items within the filter are counted.
		 * @method
		 * @public (method)
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the count for each group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            the count
		 */
		count? (grouped?: boolean): number;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * This method is called after modifications are complete on a store. For details
		 * see [`beginUpdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		endUpdate? (): void;
		/** 
		 * Filters the data in the Store by one or more fields. Example usage:
		 * 
		 *    //filter with a single field
		 *    myStore.filter('firstName', 'Don');
		 *    
		 *    //filtering with multiple filters
		 *    myStore.filter([
		 *        {
		 *            property : 'firstName',
		 *            value    : 'Don'
		 *        },
		 *        {
		 *            property : 'lastName',
		 *            value    : 'Griffin'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) instances, and delegates
		 * the actual filtering to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter[]} [filters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of filter configurations.
		 * @param   {string}                   [value]   The property value by which to filter. Only applicable if `filters` is a string.
		 * @returns {void}                               
		 */
		filter? (filters?: string | Ext.util.Filter[], value?: string): void;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of the Record field to test.
		 * @param   {string|RegExp} value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}        [startIndex]    The index to start searching at
		 * @param   {boolean}       [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}       [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {number}                        The matched index or -1
		 */
		find? (property: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string} fieldName    The name of the Record field to test.
		 * @param   {object} value        The value to match the field against.
		 * @param   {number} [startIndex] The index to start searching at
		 * @returns {number}              The matched index or -1
		 */
		findExact? (fieldName: string, value: object, startIndex?: number): number;
		/** 
		 * Finds the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}         fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}  value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}         [startIndex]    The index to start searching at
		 * @param   {boolean}        [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}        [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}        [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.Model}                 The matched record or null
		 */
		findRecord? (fieldName: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Convenience function for getting the first model instance in the store.
		 * 
		 * When store is filtered, will return first item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the first record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The first model instance in the store, or undefined
		 */
		first? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Called when the event handler which called the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method exits.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		flushLoad? (): void;
		/** 
		 * Returns the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAsynchronousLoad? (): boolean;
		/** 
		 * Get the Record at the specified index.
		 * 
		 * The index is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}         index The index of the Record to find.
		 * @returns {Ext.data.Model}       The Record at the passed index. Returns null if not found.
		 */
		getAt? (index: number): Ext.data.Model;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Returns the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean|object}  
		 */
		getAutoLoad? (): boolean | object;
		/** 
		 * Returns the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoSync? (): boolean;
		/** 
		 * Returns the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchUpdateMode? (): string;
		/** 
		 * Get the Record with the specified id.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            id The id of the Record to find.
		 * @returns {Ext.data.Model}    The Record with the passed id. Returns null if not found.
		 */
		getById? (id: any): Ext.data.Model;
		/** 
		 * Get the Record with the specified internalId.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            internalId The id of the Record to find.
		 * @returns {Ext.data.Model}            The Record with the passed internalId. Returns null if not found.
		 */
		getByInternalId? (internalId: any): Ext.data.Model;
		/** 
		 * Returns the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearOnPageLoad? (): boolean;
		/** 
		 * Returns the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearRemovedOnLoad? (): boolean;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Gets the number of records in store.
		 * 
		 * If using paging, this may not be the total size of the dataset. If the data object
		 * used by the Reader contains the dataset size, then the [Ext.data.ProxyStore.getTotalCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getTotalCount) function returns
		 * the dataset size.  **Note**: see the Important note in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load).
		 * 
		 * When store is filtered, it's the number of records matching the filter.
		 * @method
		 * @public (method)
		 * @returns {number}  The number of Records in the Store.
		 */
		getCount? (): number;
		/** 
		 * Returns the store's records.
		 * 
		 * **Note:** If your store has been filtered, getData() will return a filtered
		 * collection.  Use `getData().[getSource()`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#method-getSource) to
		 * fetch all unfiltered records.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection} 
		 * An [Ext.util.Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) of records
		 * (an empty Collection if no records are held by the store).
		 */
		getData? (): Ext.util.Collection;
		/** 
		 * Returns the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraKeys? (): object;
		/** 
		 * Returns the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @returns {object[]|string[]}  
		 */
		getFields? (): object[] | string[];
		/** 
		 * Gets the filters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.FilterCollection}            The filters
		 */
		getFilters? (autoCreate: object): Ext.util.FilterCollection;
		/** 
		 * Returns the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDir? (): string;
		/** 
		 * Returns the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @returns {object|Ext.util.Grouper}  
		 */
		getGrouper? (): object | Ext.util.Grouper;
		/** 
		 * Returns a collection of readonly sub-collections of your store's records
		 * with grouping applied. These sub-collections are maintained internally by
		 * the collection.
		 * 
		 * See [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField), [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir). Example for a store
		 * containing records with a color field:
		 * 
		 *    var myStore = Ext.create('Ext.data.Store', {
		 *        groupField: 'color',
		 *        groupDir  : 'DESC'
		 *    });
		 *    
		 *    myStore.getGroups();
		 * 
		 * The above should result in the following format:
		 * 
		 *    [
		 *        {
		 *            name: 'yellow',
		 *            children: [
		 *                // all records where the color field is 'yellow'
		 *            ]
		 *        },
		 *        {
		 *            name: 'red',
		 *            children: [
		 *                // all records where the color field is 'red'
		 *            ]
		 *        }
		 *    ]
		 * 
		 * Group contents are affected by filtering.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection}  The grouped data
		 */
		getGroups? (): Ext.util.Collection;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Gets all [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) added or updated since the last commit. Note that the order of records
		 * returned is not deterministic and does not indicate the order in which records were modified. Note also that
		 * removed records are not included (use [getRemovedRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getRemovedRecords) for that).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The added and updated Model instances
		 */
		getModifiedRecords? (): Ext.data.Model[];
		/** 
		 * Returns all [`phantom`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records in this store.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  A possibly empty array of `phantom` records.
		 */
		getNewRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getPageSize? (): number;
		/** 
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}           start The starting index. Defaults to zero.
		 * @param   {number}           end   The ending index. Defaults to the last record. The end index **is included**.
		 * @returns {Ext.data.Model[]}       An array of records.
		 */
		getRange? (start: number, end: number): Ext.data.Model[];
		/** 
		 * Returns the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteFilter? (): boolean;
		/** 
		 * Returns the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteSort? (): boolean;
		/** 
		 * Returns any records that have been removed from the store but not yet destroyed on the proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]} 
		 * The removed Model instances. Note that this is a _copy_ of the store's
		 * array, so may be mutated.
		 */
		getRemovedRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Session}  
		 */
		getSession? (): Ext.data.Session;
		/** 
		 * Returns the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSortOnLoad? (): boolean;
		/** 
		 * Gets the sorters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.SorterCollection}            The sorters
		 */
		getSorters? (autoCreate: object): Ext.util.SorterCollection;
		/** 
		 * Returns the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getStatefulFilters? (): boolean;
		/** 
		 * Returns the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStoreId? (): string;
		/** 
		 * Returns the total number of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances that the [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html)
		 * indicates exist. This will usually differ from [getCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getCount) when using paging - getCount returns the
		 * number of records loaded into the Store at the moment, getTotalCount returns the number of records that
		 * could be loaded into the Store if the Store contained all data
		 * @method
		 * @public (method)
		 * @returns {number} 
		 * The total number of Model instances available via the Proxy. 0 returned if
		 * no value has been set via the reader.
		 */
		getTotalCount? (): number;
		/** 
		 * Returns the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getTrackRemoved? (): boolean;
		/** 
		 * Returns all valid, non-phantom Model instances that have been updated in the Store but not yet synchronized with the Proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The updated Model instances
		 */
		getUpdatedRecords? (): Ext.data.Model[];
		/** 
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {string|object} grouper
		 * Either a string name of one of the fields in this Store's
		 * configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an object, or a [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Grouper.html) configuration object.
		 * @param   {string}        [direction] The overall direction to group the data by. Defaults to the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @returns {void}                      
		 */
		group? (grouper: string | object, direction?: string): void;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Get the index of the record within the store.
		 * 
		 * When store is filtered, records outside of filter will not be found.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) object to find.
		 * @returns {number}                The index of the passed Record. Returns -1 if not found.
		 */
		indexOf? (record: Ext.data.Model): number;
		/** 
		 * Get the index within the store of the Record with the passed id.
		 * 
		 * Like [indexOf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-indexOf), this method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {string} id The id of the Record to find.
		 * @returns {number}    The index of the Record. Returns -1 if not found.
		 */
		indexOfId? (id: string): number;
		/** 
		 * Inserts Model instances into the Store at the given index and fires the add event.
		 * See also [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
		 * @method
		 * @public (method)
		 * @param   {number}                                          index   The start index at which to insert the passed Records.
		 * @param   {Ext.data.Model|Ext.data.Model[]|object|object[]} records
		 * An [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instance, the
		 * data needed to populate an instance or an array of either of these.
		 * @returns {Ext.data.Model[]}                                        records The added records
		 */
		insert? (index: number, records: Ext.data.Model | Ext.data.Model[] | object | object[]): Ext.data.Model[];
		/** 
		 * Tests whether the store currently has any active filters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is filtered.
		 */
		isFiltered? (): boolean;
		/** 
		 * Tests whether the store currently has an active grouper.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is grouped.
		 */
		isGrouped? (): boolean;
		/** 
		 * Returns `true` if the Store has been loaded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store has been loaded.
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns true if the Store is currently performing a load operation
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store is currently loading
		 */
		isLoading? (): boolean;
		/** 
		 * Tests whether the store currently has any active sorters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is sorted.
		 */
		isSorted? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Convenience function for getting the last model instance in the store.
		 * 
		 * When store is filtered, will return last item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the last record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The last model instance in the store, or undefined
		 */
		last? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Loads an array of data straight into the Store.
		 * 
		 * Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
		 * processed by a reader). If your data requires processing to decode the data structure, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#method-loadRawData).
		 * @method
		 * @public (method)
		 * @param   {object} data
		 * @param   {object} append
		 * @returns {void}          
		 */
		loadData? (data: object, append: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.Store.loadData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadData).
		 * Loads an array of data straight into the Store.
		 * 
		 * Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
		 * processed by a reader). If your data requires processing to decode the data structure, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @param   {boolean}                   [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {void}                               
		 */
		loadData? (data: Ext.data.Model[] | object[], append?: boolean): void;
		/** 
		 * Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
		 * load operation, passing in calculated 'start' and 'limit' params.
		 * @method
		 * @public (method)
		 * @param   {number} page      The number of the page to load.
		 * @param   {object} [options] See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		loadPage? (page: number, options?: object): void;
		/** 
		 * Loads data via the bound Proxy's reader
		 * 
		 * Use this method if you are attempting to load data and want to utilize the configured data reader.
		 * 
		 * As of 4.2, this method will no longer fire the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-load) event.
		 * @method
		 * @public (method)
		 * @param   {object[]} data     The full JSON object you'd like to load into the Data store.
		 * @param   {boolean}  [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {boolean}  
		 * `true` if the reader processed the records correctly. See [Ext.data.reader.Reader.successProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-successProperty).
		 * If the reader did not process the records, nothing will be added.
		 */
		loadRawData? (data: object[], append?: boolean): boolean;
		/** 
		 * Gets the maximum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the maximum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The maximum value, if no items exist, undefined.
		 */
		max? (field: string, grouped?: boolean): object;
		/** 
		 * Gets the minimum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the minimum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The minimum value, if no items exist, undefined.
		 */
		min? (field: string, grouped?: boolean): object;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Loads the next 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		nextPage? (options: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Loads the previous 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		previousPage? (options: object): void;
		/** 
		 * Query all the cached records in this Store by name/value pair.
		 * The parameters will be used to generated a filter function that is given
		 * to the queryBy method.
		 * 
		 * This method complements queryBy by generating the query function automatically.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @public (method)
		 * @param   {string}              property        The property to create the filter function for
		 * @param   {string|RegExp}       value           The string/regex to compare the property value to
		 * @param   {boolean}             [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}             [caseSensitive] `true` to create a case-sensitive regex.
		 * @param   {boolean}             [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.util.Collection}                 The matched records
		 */
		query? (property: string, value: string | RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.util.Collection;
		/** 
		 * [Rejects](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-reject) outstanding changes on all [modified records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords)
		 * and re-insert any records that were removed locally. Any phantom records will be removed.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		rejectChanges? (): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Reloads the store using the last options passed to the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method. You can use the reload method to reload the
		 * store using the parameters from the last load() call. For example:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload();
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution will pass the `userid` parameter in the request. The [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) execution
		 * will also send the same `userid` parameter in its request as it will reuse the `params` object from the last [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) call.
		 * 
		 * You can override a param by passing in the config object with the `params` object:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216,
		 *            foo    : 'bar'
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload({
		 *        params : {
		 *            userid : 1234
		 *        }
		 *    });
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution sends the `userid` and `foo` parameters but in the [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) it only sends
		 * the `userid` paramter because you are overriding the `params` config not just overriding the one param. To only change a single param
		 * but keep other params, you will have to get the last params from the [lastOptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#property-lastOptions) property:
		 * 
		 *    var lastOptions = store.lastOptions,
		 *        lastParams = Ext.clone(lastOptions.params); // make a copy of the last params so we don't affect future reload() calls
		 *    
		 *    lastParams.userid = 1234;
		 *    
		 *    store.reload({
		 *        params : lastParams
		 *    });
		 * 
		 * This will now send the `userid` parameter as `1234` and the `foo` param as `'bar'`.
		 * @method
		 * @public (method)
		 * @param   {object} [options]
		 * A config object which contains options which may override the options passed to the previous load call. See the
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method for valid configs.
		 * @returns {void}             
		 */
		reload? (options?: object): void;
		/** 
		 * Removes the specified record(s) from the Store, firing the [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove)
		 * event for the removed records.
		 * 
		 * After all records have been removed a single `datachanged` is fired.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model|Ext.data.Model[]|number|number[]} records
		 * Model instance or
		 * array of instances to remove or an array of indices from which to remove records.
		 * @param   {object}                                          isMove  (private)
		 * @param   {object}                                          silent  (private)
		 * @returns {void}                                                    
		 */
		remove? (records: Ext.data.Model | Ext.data.Model[] | number | number[], isMove: object, silent: object): void;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Removes all items from the store.
		 * 
		 * Individual record [`remove`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events are not fired by this method.
		 * @method
		 * @public (method)
		 * @param   {boolean}          [silent]
		 * Pass `true` to prevent the [`clear`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-clear) event from being fired.
		 * 
		 * This method is affected by filtering.
		 * @returns {Ext.data.Model[]}          The removed records.
		 */
		removeAll? (silent?: boolean): Ext.data.Model[];
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-removeAll).
		 * Removes all records from the store. This method does a "fast remove",
		 * individual remove events are not called. The [clear](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-clear) event is
		 * fired upon completion.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]|void}  
		 */
		removeAll? (): void;
		/** 
		 * Removes the model instance(s) at the given index
		 * @method
		 * @public (method)
		 * @param   {number} index   The record index
		 * @param   {number} [count] The number of records to delete
		 * @returns {void}           
		 */
		removeAt? (index: number, count?: number): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an individual Filter from the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) using the passed Filter/Filter id and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter} toRemove        The id of a Filter to remove from the filter set, or a Filter instance to remove.
		 * @param   {boolean}                [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                   
		 */
		removeFilter? (toRemove: string | Ext.util.Filter, suppressEvent?: boolean): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @param   {boolean} syncNow
		 * Pass `true` to synchronize now. Only synchronizes with the Proxy if the suspension
		 * count has gone to zero (We are not under a higher level of suspension)
		 * @returns {void}            
		 */
		resumeAutoSync? (syncNow: boolean): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Saves all pending changes via the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy). Use [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) instead.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		save? (): void;
		/** 
		 * Sets the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} asynchronousLoad The new value.
		 * @returns {void}                     
		 */
		setAsynchronousLoad? (asynchronousLoad: boolean): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean|object} autoLoad The new value.
		 * @returns {void}                    
		 */
		setAutoLoad? (autoLoad: boolean | object): void;
		/** 
		 * Sets the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoSync The new value.
		 * @returns {void}             
		 */
		setAutoSync? (autoSync: boolean): void;
		/** 
		 * Sets the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @param   {string} batchUpdateMode The new value.
		 * @returns {void}                   
		 */
		setBatchUpdateMode? (batchUpdateMode: string): void;
		/** 
		 * Sets the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearOnPageLoad The new value.
		 * @returns {void}                    
		 */
		setClearOnPageLoad? (clearOnPageLoad: boolean): void;
		/** 
		 * Sets the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearRemovedOnLoad The new value.
		 * @returns {void}                       
		 */
		setClearRemovedOnLoad? (clearRemovedOnLoad: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                                          name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                                 [value] The value to set for the name parameter.
		 * @returns {Ext.data.ArrayStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.ArrayStore;
		setConfig? (name: string | object, value?: object): Ext.data.Store;
		setConfig? (name: string | object, value?: object): Ext.data.ProxyStore;
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Loads an array of data directly into the Store.
		 * 
		 * setData() is ideal if your data's format is already in its appropriate format (e.g. it doesn't need to be
		 * processed by a reader). If your data's structure requires processing, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * 
		 * Use [loadData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadData), [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add), or [insert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-insert) if records need to be
		 * appended to the current recordset.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @returns {void}                           
		 */
		setData? (data: Ext.data.Model[] | object[]): void;
		/** 
		 * Sets the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @param   {object} extraKeys The new value.
		 * @returns {void}             
		 */
		setExtraKeys? (extraKeys: object): void;
		/** 
		 * Sets the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @param   {object[]|string[]} fields The new value.
		 * @returns {void}                     
		 */
		setFields? (fields: object[] | string[]): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setFilters? (): void;
		/** 
		 * Sets the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @param   {string} groupDir The new value.
		 * @returns {void}            
		 */
		setGroupDir? (groupDir: string): void;
		/** 
		 * Sets the value of [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField).
		 * @method
		 * @public (method)
		 * @param   {string} groupField The new value.
		 * @returns {void}              
		 */
		setGroupField? (groupField: string): void;
		/** 
		 * Sets the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.util.Grouper} grouper The new value.
		 * @returns {void}                            
		 */
		setGrouper? (grouper: object | Ext.util.Grouper): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @param   {number} pageSize The new value.
		 * @returns {void}            
		 */
		setPageSize? (pageSize: number): void;
		/** 
		 * Sets the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteFilter The new value.
		 * @returns {void}                 
		 */
		setRemoteFilter? (remoteFilter: boolean): void;
		/** 
		 * Sets the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteSort The new value.
		 * @returns {void}               
		 */
		setRemoteSort? (remoteSort: boolean): void;
		/** 
		 * Sets the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} session The new value.
		 * @returns {void}                     
		 */
		setSession? (session: Ext.data.Session): void;
		/** 
		 * Sets the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} sortOnLoad The new value.
		 * @returns {void}               
		 */
		setSortOnLoad? (sortOnLoad: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setSorters? (): void;
		/** 
		 * Sets the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @param   {boolean} statefulFilters The new value.
		 * @returns {void}                    
		 */
		setStatefulFilters? (statefulFilters: boolean): void;
		/** 
		 * Sets the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @param   {string} storeId The new value.
		 * @returns {void}           
		 */
		setStoreId? (storeId: string): void;
		/** 
		 * Sets the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @param   {boolean} trackRemoved The new value.
		 * @returns {void}                 
		 */
		setTrackRemoved? (trackRemoved: boolean): void;
		/** 
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction] The overall direction to sort the data by.
		 * @returns {Ext.util.Sorter[]}                    
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string): Ext.util.Sorter[];
		/** 
		 * Sums the value of `field` for each [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in store
		 * and returns the result.
		 * 
		 * When store is filtered, only sums items within the filter.
		 * @method
		 * @public (method)
		 * @param   {string}  field     A field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the sum for that group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            The sum
		 */
		sum? (field: string, grouped?: boolean): number;
		/** 
		 * Suspends automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendAutoSync? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Inherit docs
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		contains? (record: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.contains](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-contains).
		 * Checks if a record is in the current active data set.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record
		 * @returns {void|boolean}          `true` if the record is in the current active data set.
		 */
		contains? (record: Ext.data.Model): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		doDestroy? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                                 config
		 * @returns {Ext.data.ArrayStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.ArrayStore;
		initConfig? (config: object): Ext.data.Store;
		initConfig? (config: object): Ext.data.ProxyStore;
		initConfig? (config: object): Ext.data.AbstractStore;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Called internally when a Proxy has completed a load request
		 * @method
		 * @protected (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyLoad? (operation: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.ArrayStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.ArrayStore.Statics;
		statics? (): Ext.data.Store.Statics;
		statics? (): Ext.data.ProxyStore.Statics;
		statics? (): Ext.data.AbstractStore.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorter
		 * @returns {void}          
		 */
		addFieldTransform? (sorter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		addObserver? (observer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @param   {object} type
		 * @returns {void}                      
		 */
		afterChange? (record: object, modifiedFieldNames: object, type: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterCommit? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterDrop? (record: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @returns {void}                      
		 */
		afterEdit? (record: object, modifiedFieldNames: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterErase? (record: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to..
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterReject? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} asynchronousLoad
		 * @returns {void}                    
		 */
		applyAsynchronousLoad? (asynchronousLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} extraKeys
		 * @returns {void}             
		 */
		applyExtraKeys? (extraKeys: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fields
		 * @returns {void}          
		 */
		applyFields? (fields: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @param   {object} filtersCollection
		 * @returns {void}                     
		 */
		applyFilters? (filters: object, filtersCollection: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} grouper
		 * @returns {void}           
		 */
		applyGrouper? (grouper: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @returns {void}         
		 */
		applyProxy? (proxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorters
		 * @param   {object} sortersCollection
		 * @returns {void}                     
		 */
		applySorters? (sorters: object, sortersCollection: object): void;
		/** 
		 * Restores state to the passed state
		 * @method
		 * @private (method)
		 * @param   {object} state
		 * @returns {void}         
		 */
		applyState? (state: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} args
		 * @returns {void}          
		 */
		callObservers? (action: object, args: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} isLoad
		 * @returns {void}          
		 */
		clearData? (isLoad: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.clearData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-clearData).
		 * to be implemented by subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearData? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		constructDataCollection? (): void;
		/** 
		 * saves any phantom records
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @param   {object} options
		 * @returns {void}           
		 */
		create? (data: object, options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createFiltersCollection? (): void;
		/** 
		 * Converts a literal to a model, if it's not a model already
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model|object} record The record to create
		 * @returns {Ext.data.Model}               
		 */
		createModel? (record: Ext.data.Model | object): Ext.data.Model;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createSortersCollection? (): void;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * tells the attached proxy to destroy the given records
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		erase? (options: object): void;
		/** 
		 * Similar to a load, however no records are added to the store. This is useful
		 * in allowing the developer to decide what to do with the new records.
		 * @method
		 * @private (method)
		 * @param   {object} [options] See [load options](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		fetch? (options?: object): void;
		/** 
		 * private
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @returns {void}      
		 */
		filterDataSource? (fn: object): void;
		/** 
		 * Filter function for new records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNew? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNewOnly? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterRejects? (item: object): void;
		/** 
		 * Filter function for updated records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterUpdated? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		fireGroupChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		forceLocalSort? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @param   {object} scope
		 * @param   {object} records
		 * @param   {object} field
		 * @returns {void}           
		 */
		getAggregate? (fn: object, scope: object, records: object, field: object): void;
		/** 
		 * Returns the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.Model}  
		 */
		getAssociatedEntity? (): Ext.data.Model;
		/** 
		 * Returns the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getAutoSort? (): boolean;
		/** 
		 * Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
		 * This is broken out into a separate function to allow for customisation of the listeners
		 * @method
		 * @private (method)
		 * @returns {object}  The listeners object
		 */
		getBatchListeners? (): object;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Returns the complete unfiltered collection.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getDataSource? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getGroupField? (): void;
		/** 
		 * Returns the array of records which have been removed since the last time this store was synced.
		 * 
		 * This is used internally, when purging removed records after a successful sync.
		 * This is overridden by TreeStore because TreeStore accumulates deleted records on removal
		 * of child nodes from their parent, _not_ on removal of records from its collection. The collection
		 * has records added on expand, and removed on collapse.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRawRemovedRecords? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRejectRecords? (): void;
		/** 
		 * Returns the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.schema.Role}  
		 */
		getRole? (): Ext.data.schema.Role;
		/** 
		 * Returns the grouping, sorting and filtered state of this Store.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getState? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Returns true if the store has a pending load task.
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the store has a pending load task.
		 */
		hasPendingLoad? (): boolean;
		/** 
		 * Checks whether records are being moved within the store. This can be used in conjunction with the
		 * [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-add) and [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events to determine whether the records are being removed/added
		 * or just having the position changed.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]|Ext.data.Model} [records] The record(s).
		 * @returns {number}                          
		 * The number of records being moved. `0` if no records are moving. If records are passed
		 * the number will refer to how many of the passed records are moving.
		 */
		isMoving? (records?: Ext.data.Model[] | Ext.data.Model): number;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @returns {void}        
		 */
		loadInlineData? (data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		notifySorterChange? (): void;
		/** 
		 * Attached as the 'complete' event listener to a proxy's Batch object. Iterates over the batch operations
		 * and updates the Store's internal data MixedCollection.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchComplete? (batch: object, operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchException? (batch: object, operation: object): void;
		/** 
		 * Attached as the 'operationcomplete' event listener to a proxy's Batch object. By default just calls through
		 * to onProxyWrite.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchOperationComplete? (batch: object, operation: object): void;
		/** 
		 * This is attached to the data Collection's beforesort event only if not remoteSort
		 * If remoteSort, the event is fired before the reload call in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-load).
		 * @method
		 * @private (method)
		 * @param   {object} store
		 * @param   {object} sorters
		 * @returns {void}           
		 */
		onBeforeCollectionSort? (store: object, sorters: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} cls
		 * @param   {object} data
		 * @param   {object} hooks
		 * @returns {void}         
		 */
		onClassExtended? (cls: object, data: object, hooks: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} records
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionAddItems? (collection: object, records: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionBeforeItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionBeginUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionEndUpdate? (): void;
		/** 
		 * When the collection informs us that it has filtered, this LocalStore must react.
		 * AbstractStore#onFilterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilter? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} items
		 * @returns {void}              
		 */
		onCollectionFilterAdd? (collection: object, items: object): void;
		/** 
		 * If our source collection informs us that a filtered out item has changed, we must still fire the events...
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilteredItemChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionRemove? (collection: object, info: object): void;
		/** 
		 * When the collection informs us that it has sorted, this LocalStore must react.
		 * AbstractStore#onSorterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionSort? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCreateRecords? (): void;
		/** 
		 * Removes any records when a write is returned from the server.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]}             records   The array of removed records
		 * @param   {Ext.data.operation.Operation} operation The operation that just completed
		 * @param   {boolean}                      success   True if the operation was successful
		 * @returns {void}                                   
		 */
		onDestroyRecords? (records: Ext.data.Model[], operation: Ext.data.operation.Operation, success: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onErase? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onFilterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} rec
		 * @param   {object} oldId
		 * @param   {object} newId
		 * @returns {void}         
		 */
		onIdChanged? (rec: object, oldId: object, newId: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} meta
		 * @returns {void}         
		 */
		onMetaChange? (proxy: object, meta: object): void;
		/** 
		 * Callback for any write Operation over the Proxy. Updates the Store's MixedCollection to reflect
		 * the updates provided by the Proxy
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyWrite? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onSorterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdate? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdateRecords? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Query all the cached records in this Store by field.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @private (method)
		 * @param   {string}           field The field from each record to use.
		 * @param   {object}           value The value to match.
		 * @returns {Ext.data.Model[]}       The matched records.
		 */
		queryRecords? (field: string, value: object): Ext.data.Model[];
		/** 
		 * Determines if the passed range is available in the page cache.
		 * @method
		 * @private (method)
		 * @param   {number} start The start index
		 * @param   {number} end   The end index in the range
		 * @returns {void}         
		 */
		rangeCached? (start: number, end: number): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		removeObserver? (observer: object): void;
		/** 
		 * Sets the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} associatedEntity The new value.
		 * @returns {void}                            
		 */
		setAssociatedEntity? (associatedEntity: Ext.data.Model): void;
		/** 
		 * Sets the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @param   {boolean} autoSort The new value.
		 * @returns {void}             
		 */
		setAutoSort? (autoSort: boolean): void;
		/** 
		 * Make a set of records be current in the store. This means that unneeded records
		 * will be removed and new records will be added.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]} records The records to be current in the store.
		 * @returns {void}                     
		 */
		setRecords? (records: Ext.data.Model[]): void;
		/** 
		 * Sets the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.schema.Role} role The new value.
		 * @returns {void}                      
		 */
		setRole? (role: Ext.data.schema.Role): void;
		/** 
		 * This method is basically the same as the JavaScript Array splice method.
		 * 
		 * Negative indexes are interpreted starting at the end of the collection. That is,
		 * a value of -1 indicates the last item, or equivalent to `length - 1`.
		 * @method
		 * @private (method)
		 * @param   {number}          index    The index at which to add or remove items.
		 * @param   {number|object[]} toRemove
		 * The number of items to remove or an array of the
		 * items to remove.
		 * @param   {object[]}        [toAdd]  The items to insert at the given `index`.
		 * @returns {void}                     
		 */
		splice? (index: number, toRemove: number | object[], toAdd?: object[]): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                               names The names of the linked objects to destroy.
		 * @returns {Ext.data.ArrayStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.ArrayStore;
		unlink? (names: string[]): Ext.data.Store;
		unlink? (names: string[]): Ext.data.ProxyStore;
		unlink? (names: string[]): Ext.data.AbstractStore;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		update? (options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoLoad
		 * @returns {void}            
		 */
		updateAutoLoad? (autoLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoSort
		 * @returns {void}            
		 */
		updateAutoSort? (autoSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} field
		 * @returns {void}         
		 */
		updateGroupField? (field: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} oldProxy
		 * @returns {void}            
		 */
		updateProxy? (proxy: object, oldProxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @returns {void}                
		 */
		updateRemoteFilter? (remoteFilter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @returns {void}              
		 */
		updateRemoteSort? (remoteSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} track
		 * @returns {void}         
		 */
		updateTrackRemoved? (track: object): void;
	}
	/** 
	 * [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html)
	 * Provides a mechanism to run one or more [operations](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * in a given order. Fires the `operationcomplete` event after the completion of each
	 * Operation, and the `complete` event when all Operations have been successfully executed.
	 * Fires an `exception` event if any of the Operations encounter an exception.
	 * 
	 * Usually these are only used internally by [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) classes.
	 */
	class Batch extends Ext.Base {
		/** 
		 * Ordered array of operations that raised an exception during the most recent
		 * batch execution and did not successfully complete
		 * @property
		 * @public (property)
		 * @default []
		 * @type {Ext.data.operation.Operation[]}
		 */
		exceptions?: Ext.data.operation.Operation[];
		/** 
		 * This object holds a key for any event that has a listener. The listener may be set
		 * directly on the instance, or on its class or a super class (via [observe](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#static-method-observe)) or
		 * on the [MVC EventBus](https://docs.sencha.com/extjs/6.2.0/modern/Ext.app.EventBus.html). The values of this object are truthy
		 * (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
		 * of listeners. The value for an event is truthy if the event must be fired and is
		 * falsy if there is no need to fire the event.
		 * 
		 * The intended use of this property is to avoid the expense of fireEvent calls when
		 * there are no listeners. This can be particularly helpful when one would otherwise
		 * have to call fireEvent hundreds or thousands of times. It is used like this:
		 * 
		 *     if (this.hasListeners.foo) {
		 *         this.fireEvent('foo', this, arg1);
		 *     }
		 * 
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		readonly hasListeners?: object;
		/** 
		 * `true` in this class to identify an object as an instantiated Observable, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isObservable?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.Batch.Statics}
		 */
		self?: Ext.data.Batch.Statics | Ext.Base.Statics;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members    The members to add to this class.
		 * @param   {boolean}                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Batch|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Batch;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members
		 * @returns {Ext.data.Batch|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.Batch;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  name
		 * @param   {object}                  member
		 * @returns {Ext.data.Batch|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.Batch;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  fn
		 * @param   {object}                  scope
		 * @returns {Ext.data.Batch|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.Batch;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates new Batch object.
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object
		 */
		constructor (config?: object);
		/** 
		 * Adds a new operation to this batch at the end of the [operations](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#property-operations) array
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {Ext.data.operation.Operation|Ext.data.operation.Operation[]} operation The [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object or an array of operations.
		 * @returns {Ext.data.Batch}                                                        this
		 */
		add? (operation: Ext.data.operation.Operation | Ext.data.operation.Operation[]): Ext.data.Batch;
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                          eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                        [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                                 [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.data.Batch.methodParams.addListener.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                                 [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                                 
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addListener? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.data.Batch.methodParams.addListener.Options, order?: string): object;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Gets the currently running operation. Will return null if the batch has
		 * not started or is completed.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.operation.Operation}  The operation
		 */
		getCurrent? (): Ext.data.operation.Operation;
		/** 
		 * Gets any operations that have returned without success in this batch.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.operation.Operation[]}  The exceptions
		 */
		getExceptions? (): Ext.data.operation.Operation[];
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Gets the operations for this batch.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.operation.Operation[]}  The operations.
		 */
		getOperations? (): Ext.data.operation.Operation[];
		/** 
		 * Returns the value of [pauseOnException](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#cfg-pauseOnException).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getPauseOnException? (): boolean;
		/** 
		 * Gets the total number of operations in this batch.
		 * @method
		 * @public (method)
		 * @returns {number}  The total
		 */
		getTotal? (): number;
		/** 
		 * Checks if this batch has any exceptions.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if this batch has any exceptions.
		 */
		hasException? (): boolean;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Checks if this batch is complete.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if this batch is complete.
		 */
		isComplete? (): boolean;
		/** 
		 * Checks if this batch is running.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if this batch is running.
		 */
		isRunning? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                 eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                               [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                        [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.data.Batch.methodParams.on.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                        [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                        
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		on? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.data.Batch.methodParams.on.Options, order?: string): object;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Pauses execution of the batch, but does not cancel the current operation
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.data.Batch}  this
		 */
		pause? (): Ext.data.Batch;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Kicks off execution of the batch, continuing from the current operation. This is intended
		 * for restarting a [paused](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#method-pause) batch after an exception, and the operation that raised
		 * the exception will now be retried. The batch will then continue with its normal processing until
		 * all operations are complete or another exception is encountered.
		 * 
		 * Note that if the batch is already running any call to retry will be ignored.
		 * @method
		 * @public (method)
		 * @chainable
		 * @returns {Ext.data.Batch}  this
		 */
		retry? (): Ext.data.Batch;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}           name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                  [value] The value to set for the name parameter.
		 * @returns {Ext.data.Batch|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Batch;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [pauseOnException](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#cfg-pauseOnException).
		 * @method
		 * @public (method)
		 * @param   {boolean} pauseOnException The new value.
		 * @returns {void}                     
		 */
		setPauseOnException? (pauseOnException: boolean): void;
		/** 
		 * Sorts the [`operations`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) based on their type and
		 * the foreign key dependencies of the entities. Consider a simple Parent and Child
		 * case where the Child has a "parentId" field. If this batch contains two `create`
		 * operations, one of a Parent and one for its Child, the server must receive and
		 * process the `create` of the Parent before the Child can be created.
		 * 
		 * In the case of `destroy` operations this order is reversed. The Child entity must be
		 * destroyed before the Parent to avoid any foreign key constraints (a Child with an
		 * invalid parentId field).
		 * 
		 * Further, `create` operations must all occur before `update` operations to ensure
		 * that all entities exist that might be now referenced by the updates. The created
		 * entities can safely reference already existing entities.
		 * 
		 * Finally, `destroy` operations are sorted after `update` operations to allow those
		 * updates to remove references to the soon-to-be-deleted entities.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		sort? (): void;
		/** 
		 * Kicks off execution of the batch, continuing from the next operation if the previous
		 * operation encountered an exception, or if execution was paused. Use this method to start
		 * the batch for the first time or to restart a paused batch by skipping the current
		 * unsuccessful operation.
		 * 
		 * To retry processing the current operation before continuing to the rest of the batch (e.g.
		 * because you explicitly handled the operation's exception), call [retry](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#method-retry) instead.
		 * 
		 * Note that if the batch is already running any call to start will be ignored.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {object}         index
		 * @returns {Ext.data.Batch}       this
		 */
		start? (index: object): Ext.data.Batch;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Destructor for classes that extend Observable.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                  config
		 * @returns {Ext.data.Batch|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.Batch;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Batch.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.Batch.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                names The names of the linked objects to destroy.
		 * @returns {Ext.data.Batch|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.Batch;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * [Ext.data.BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html)
	 * A BufferedStore maintains a sparsely populated map of pages corresponding to an extremely large server-side dataset.
	 * 
	 * Use a BufferedStore when the dataset size is so large that the database and network latency, and client memory requirements
	 * preclude caching the entire dataset in a regular [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
	 * 
	 * When using a BufferedStore _not all of the dataset is present in the client_. Only pages which have been
	 * requested by the UI (usually a GridPanel) and surrounding pages will be present. Retention
	 * of viewed pages in the BufferedStore after they have been scrolled out of view is configurable. See [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone),
	 * [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone) and [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount).
	 * 
	 * To use a BufferedStore, initiate the loading process by loading the first page. The number of rows rendered are
	 * determined automatically, and the range of pages needed to keep the cache primed for scrolling is
	 * requested and cached.
	 * Example:
	 * 
	 *    myBufferedStore.loadPage(1); // Load page 1
	 * 
	 * A BufferedRenderer is instantiated which will monitor the scrolling in the grid, and
	 * refresh the view's rows from the page cache as needed. It will also pull new data into the page
	 * cache when scrolling of the view draws upon data near either end of the prefetched data.
	 * 
	 * The margins which trigger view refreshing from the prefetched data are Ext.grid.plugin.BufferedRenderer.numFromEdge,
	 * Ext.grid.plugin.BufferedRenderer.leadingBufferZone and Ext.grid.plugin.BufferedRenderer.trailingBufferZone.
	 * 
	 * The margins which trigger loading more data into the page cache are, [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone) and
	 * [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone).
	 * 
	 * By default, only 5 pages of data (in addition to the pages which over the visible region) are cached in the page cache,
	 * with old pages being evicted from the cache as the view moves down through the dataset. This is controlled by the
	 * [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount) setting.
	 * 
	 * Setting this value to zero means that no pages are _ever_ scrolled out of the page cache, and
	 * that eventually the whole dataset may become present in the page cache. This is sometimes desirable
	 * as long as datasets do not reach astronomical proportions.
	 * 
	 * Selection state may be maintained across page boundaries by configuring the SelectionModel not to discard
	 * records from its collection when those Records cycle out of the Store's primary collection. This is done
	 * by configuring the SelectionModel like this:
	 * 
	 *    selModel: {
	 *        pruneRemoved: false
	 *    }
	 * 
	 */
	class BufferedStore extends Ext.data.ProxyStore {
		/** 
		 * `true` in this class to identify an object as an instantiated BufferedStore, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isBufferedStore?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.BufferedStore.Statics}
		 */
		self?: Ext.data.BufferedStore.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                     members    The members to add to this class.
		 * @param   {boolean}                                                                    [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                    [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.BufferedStore|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.BufferedStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                     members
		 * @returns {Ext.data.BufferedStore|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.BufferedStore;
		static addStatics? (members: object): typeof Ext.data.ProxyStore;
		static addStatics? (members: object): typeof Ext.data.AbstractStore;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                     name
		 * @param   {object}                                                                     member
		 * @returns {Ext.data.BufferedStore|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.BufferedStore;
		static addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		static addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                     fn
		 * @param   {object}                                                                     scope
		 * @returns {Ext.data.BufferedStore|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.BufferedStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * documented above
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * Adds a new Filter to this Store's [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {object[]|Ext.util.Filter[]} filters         The set of filters to add to the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters).
		 * @param   {boolean}                    [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                       
		 */
		addFilter? (filters: object[] | Ext.util.Filter[], suppressEvent?: boolean): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * We are using applyData so that we can return nothing and prevent the `this.data`
		 * property to be overridden.
		 * @method
		 * @public (method)
		 * @param   {any[]|object} data
		 * @returns {void}              
		 */
		applyData? (data: any[] | object): void;
		/** 
		 * This method may be called to indicate the start of multiple changes to the store.
		 * 
		 * Automatic synchronization as configured by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred
		 * until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple mutations can be coalesced
		 * into one synchronization operation.
		 * 
		 * Internally this method increments a counter that is decremented by `endUpdate`. It
		 * is important, therefore, that if you call `beginUpdate` directly you match that
		 * call with a call to `endUpdate` or you will prevent the collection from updating
		 * properly.
		 * 
		 * For example:
		 * 
		 *     var store = Ext.StoreManager.lookup({
		 *         //...
		 *         autoSync: true
		 *     });
		 *    
		 *     store.beginUpdate();
		 *    
		 *     record.set('fieldName', 'newValue');
		 *    
		 *     store.add(item);
		 *     // ...
		 *    
		 *     store.insert(index, otherItem);
		 *     //...
		 *    
		 *     // Interested parties will listen for the endupdate event
		 *     store.endUpdate();
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginUpdate? (): void;
		/** 
		 * Reverts to a view of the Record cache with no filtering applied.
		 * @method
		 * @public (method)
		 * @param   {boolean} [suppressEvent]
		 * If `true` the filter is cleared silently.
		 * 
		 * For a locally filtered Store, this means that the filter collection is cleared without firing the
		 * [datachanged](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-datachanged) event.
		 * 
		 * For a remotely filtered Store, this means that the filter collection is cleared, but the store
		 * is not reloaded from the server.
		 * @returns {void}                    
		 */
		clearFilter? (suppressEvent?: boolean): void;
		/** 
		 * Clear the store grouping
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearGrouping? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Inherit docs
		 * @method
		 * @public (method)
		 * @param   {object}  record
		 * @returns {boolean}        `true` if the record is in the current active data set.
		 */
		contains? (record: object): boolean;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.contains](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-contains).
		 * Checks if a record is in the current active data set.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record
		 * @returns {boolean}               `true` if the record is in the current active data set.
		 */
		contains? (record: Ext.data.Model): boolean;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * This method is called after modifications are complete on a store. For details
		 * see [`beginUpdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		endUpdate? (): void;
		/** 
		 * Filters by a function. The specified function will be called for each
		 * Record in this Store. If the function returns `true` the Record is included,
		 * otherwise it is filtered out.
		 * 
		 * When store is filtered, most of the methods for accessing store data will be working only
		 * within the set of filtered records. The notable exception is [getById](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#method-getById).
		 * @method
		 * @public (method)
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		filterBy? (fn: object, scope: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-filterBy).
		 * Filters by a function. The specified function will be called for each
		 * Record in this Store. If the function returns `true` the Record is included,
		 * otherwise it is filtered out.
		 * 
		 * When store is filtered, most of the methods for accessing store data will be working only
		 * within the set of filtered records. The notable exception is [getById](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getById).
		 * @method
		 * @public (method)
		 * @param   {Function}       fn          The function to be called. It will be passed the following parameters:
		 * @param   {Ext.data.Model} [fn.record]
		 * The record to test for filtering. Access field values
		 *  using [Ext.data.Model.get](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-get).
		 * @param   {void}           fn.returns
		 * @param   {object}         [scope]
		 * The scope (this reference) in which the function is executed.
		 * Defaults to this Store.
		 * @returns {void}                       
		 */
		filterBy? (fn: ((record?: Ext.data.Model) => void) | ExtGlobalFunction, scope?: object): void;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of the Record field to test.
		 * @param   {string|RegExp} value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}        [startIndex]    The index to start searching at
		 * @param   {boolean}       [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}       [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {number}                        The matched index or -1
		 */
		find? (property: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string} fieldName    The name of the Record field to test.
		 * @param   {object} value        The value to match the field against.
		 * @param   {number} [startIndex] The index to start searching at
		 * @returns {number}              The matched index or -1
		 */
		findExact? (fieldName: string, value: object, startIndex?: number): number;
		/** 
		 * Finds the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}         fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}  value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}         [startIndex]    The index to start searching at
		 * @param   {boolean}        [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}        [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}        [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.Model}                 The matched record or null
		 */
		findRecord? (fieldName: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Called when the event handler which called the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#method-load) method exits.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		flushLoad? (): void;
		/** 
		 * Returns the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAsynchronousLoad? (): boolean;
		/** 
		 * Get the Record at the specified index.
		 * 
		 * The index is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}         index The index of the Record to find.
		 * @returns {Ext.data.Model}       The Record at the passed index. Returns null if not found.
		 */
		getAt? (index: number): Ext.data.Model;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Returns the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean|object}  
		 */
		getAutoLoad? (): boolean | object;
		/** 
		 * Returns the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoSync? (): boolean;
		/** 
		 * Returns the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchUpdateMode? (): string;
		/** 
		 * Get the Record with the specified id.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            id The id of the Record to find.
		 * @returns {Ext.data.Model}    The Record with the passed id. Returns null if not found.
		 */
		getById? (id: any): Ext.data.Model;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-data).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getData? (): number;
		/** 
		 * Returns the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @returns {object[]|string[]}  
		 */
		getFields? (): object[] | string[];
		/** 
		 * Gets the filters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.FilterCollection}            The filters
		 */
		getFilters? (autoCreate: object): Ext.util.FilterCollection;
		/** 
		 * Returns the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDir? (): string;
		/** 
		 * Returns the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @returns {object|Ext.util.Grouper}  
		 */
		getGrouper? (): object | Ext.util.Grouper;
		/** 
		 * Returns a collection of readonly sub-collections of your store's records
		 * with grouping applied. These sub-collections are maintained internally by
		 * the collection.
		 * 
		 * See [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField), [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir). Example for a store
		 * containing records with a color field:
		 * 
		 *    var myStore = Ext.create('Ext.data.Store', {
		 *        groupField: 'color',
		 *        groupDir  : 'DESC'
		 *    });
		 *    
		 *    myStore.getGroups();
		 * 
		 * The above should result in the following format:
		 * 
		 *    [
		 *        {
		 *            name: 'yellow',
		 *            children: [
		 *                // all records where the color field is 'yellow'
		 *            ]
		 *        },
		 *        {
		 *            name: 'red',
		 *            children: [
		 *                // all records where the color field is 'red'
		 *            ]
		 *        }
		 *    ]
		 * 
		 * Group contents are affected by filtering.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection}  The grouped data
		 */
		getGroups? (): Ext.util.Collection;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getLeadingBufferZone? (): number;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Gets all [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) added or updated since the last commit. Note that the order of records
		 * returned is not deterministic and does not indicate the order in which records were modified. Note also that
		 * removed records are not included (use [getRemovedRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getRemovedRecords) for that).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The added and updated Model instances
		 */
		getModifiedRecords? (): Ext.data.Model[];
		/** 
		 * Returns all [`phantom`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records in this store.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  A possibly empty array of `phantom` records.
		 */
		getNewRecords? (): Ext.data.Model[];
		/** 
		 * Determines the page from a record index
		 * @method
		 * @public (method)
		 * @param   {number} index The record index
		 * @returns {number}       The page the record belongs to
		 */
		getPageFromRecordIndex? (index: number): number;
		/** 
		 * Returns the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getPageSize? (): number;
		/** 
		 * Returns the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.proxy.Proxy|object}  
		 */
		getProxy? (): string | Ext.data.proxy.Proxy | object;
		/** 
		 * Returns the value of [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getPurgePageCount? (): number;
		/** 
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {object}           start
		 * @param   {object}           end
		 * @param   {object}           options
		 * @returns {Ext.data.Model[]}         An array of records.
		 */
		getRange? (start: object, end: object, options: object): Ext.data.Model[];
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.getRange](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getRange).
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}           start The starting index. Defaults to zero.
		 * @param   {number}           end   The ending index. Defaults to the last record. The end index **is included**.
		 * @returns {Ext.data.Model[]}       An array of records.
		 */
		getRange? (start: number, end: number): Ext.data.Model[];
		/** 
		 * Returns the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteFilter? (): boolean;
		/** 
		 * Returns the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteSort? (): boolean;
		/** 
		 * Returns any records that have been removed from the store but not yet destroyed on the proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]} 
		 * The removed Model instances. Note that this is a _copy_ of the store's
		 * array, so may be mutated.
		 */
		getRemovedRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSortOnLoad? (): boolean;
		/** 
		 * Gets the sorters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.SorterCollection}            The sorters
		 */
		getSorters? (autoCreate: object): Ext.util.SorterCollection;
		/** 
		 * Returns the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getStatefulFilters? (): boolean;
		/** 
		 * Returns the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStoreId? (): string;
		/** 
		 * Returns the total number of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances that the [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html)
		 * indicates exist. This will usually differ from [getCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getCount) when using paging - getCount returns the
		 * number of records loaded into the Store at the moment, getTotalCount returns the number of records that
		 * could be loaded into the Store if the Store contained all data
		 * @method
		 * @public (method)
		 * @returns {number} 
		 * The total number of Model instances available via the Proxy. 0 returned if
		 * no value has been set via the reader.
		 */
		getTotalCount? (): number;
		/** 
		 * Returns the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getTrackRemoved? (): boolean;
		/** 
		 * Returns the value of [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getTrailingBufferZone? (): number;
		/** 
		 * Returns all valid, non-phantom Model instances that have been updated in the Store but not yet synchronized with the Proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The updated Model instances
		 */
		getUpdatedRecords? (): Ext.data.Model[];
		/** 
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {object} grouper
		 * @param   {object} direction
		 * @returns {void}             
		 */
		group? (grouper: object, direction: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.group](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-group).
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {string|object} grouper
		 * Either a string name of one of the fields in this Store's
		 * configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an object, or a [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Grouper.html) configuration object.
		 * @param   {string}        [direction] The overall direction to group the data by. Defaults to the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @returns {void}                      
		 */
		group? (grouper: string | object, direction?: string): void;
		/** 
		 * Guarantee a specific range, this will load the store with a range (that
		 * must be the `pageSize` or smaller) and take care of any loading that may
		 * be necessary.
		 * @method
		 * @public (method)
		 * @param   {object} start
		 * @param   {object} end
		 * @param   {object} callback
		 * @param   {object} scope
		 * @param   {object} options
		 * @returns {void}            
		 */
		guaranteeRange? (start: object, end: object, callback: object, scope: object, options: object): void;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Get the index of the record within the store.
		 * 
		 * When store is filtered, records outside of filter will not be found.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) object to find.
		 * @returns {number}                The index of the passed Record. Returns -1 if not found.
		 */
		indexOf? (record: Ext.data.Model): number;
		/** 
		 * Get the index within the store of the Record with the passed id.
		 * 
		 * Like [indexOf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#method-indexOf), this method is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {string} id The id of the Record to find.
		 * @returns {number}    The index of the Record. Returns -1 if not found.
		 */
		indexOfId? (id: string): number;
		/** 
		 * Tests whether the store currently has any active filters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is filtered.
		 */
		isFiltered? (): boolean;
		/** 
		 * Tests whether the store currently has an active grouper.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is grouped.
		 */
		isGrouped? (): boolean;
		/** 
		 * Returns `true` if the Store has been loaded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store has been loaded.
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns true if the Store is currently performing a load operation
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store is currently loading
		 */
		isLoading? (): boolean;
		/** 
		 * Tests whether the store currently has any active sorters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is sorted.
		 */
		isSorted? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Prefetches data into the store using its configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @param   {object} [options]
		 * config object, passed into the [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object before loading.
		 * See [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#method-load)
		 * @returns {void}             
		 */
		prefetch? (options?: object): void;
		/** 
		 * Prefetches a page of data.
		 * @method
		 * @public (method)
		 * @param   {number} page      The page to prefetch
		 * @param   {object} [options]
		 * config object, passed into the [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object before loading.
		 * See [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#method-load)
		 * @returns {void}             
		 */
		prefetchPage? (page: number, options?: object): void;
		/** 
		 * Ensures that the specified range of rows is present in the cache.
		 * 
		 * Converts the row range to a page range and then only load pages which are not already
		 * present in the page cache.
		 * @method
		 * @public (method)
		 * @param   {object} start
		 * @param   {object} end
		 * @returns {void}         
		 */
		prefetchRange? (start: object, end: object): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * 
		 * @method
		 * @public (method)
		 * @param   {object} silent
		 * @returns {void}          
		 */
		removeAll? (silent: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-removeAll).
		 * Removes all records from the store. This method does a "fast remove",
		 * individual remove events are not called. The [clear](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-clear) event is
		 * fired upon completion.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAll? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an individual Filter from the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) using the passed Filter/Filter id and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter} toRemove        The id of a Filter to remove from the filter set, or a Filter instance to remove.
		 * @param   {boolean}                [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                   
		 */
		removeFilter? (toRemove: string | Ext.util.Filter, suppressEvent?: boolean): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @param   {boolean} syncNow
		 * Pass `true` to synchronize now. Only synchronizes with the Proxy if the suspension
		 * count has gone to zero (We are not under a higher level of suspension)
		 * @returns {void}            
		 */
		resumeAutoSync? (syncNow: boolean): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Saves all pending changes via the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy). Use [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) instead.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		save? (): void;
		/** 
		 * Sets the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} asynchronousLoad The new value.
		 * @returns {void}                     
		 */
		setAsynchronousLoad? (asynchronousLoad: boolean): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean|object} autoLoad The new value.
		 * @returns {void}                    
		 */
		setAutoLoad? (autoLoad: boolean | object): void;
		/** 
		 * Sets the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoSync The new value.
		 * @returns {void}             
		 */
		setAutoSync? (autoSync: boolean): void;
		/** 
		 * Sets the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @param   {string} batchUpdateMode The new value.
		 * @returns {void}                   
		 */
		setBatchUpdateMode? (batchUpdateMode: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                              name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                     [value] The value to set for the name parameter.
		 * @returns {Ext.data.BufferedStore|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.BufferedStore;
		setConfig? (name: string | object, value?: object): Ext.data.ProxyStore;
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-data).
		 * @method
		 * @public (method)
		 * @param   {number} data The new value.
		 * @returns {void}        
		 */
		setData? (data: number): void;
		/** 
		 * Sets the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @param   {object[]|string[]} fields The new value.
		 * @returns {void}                     
		 */
		setFields? (fields: object[] | string[]): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setFilters? (): void;
		/** 
		 * Sets the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @param   {string} groupDir The new value.
		 * @returns {void}            
		 */
		setGroupDir? (groupDir: string): void;
		/** 
		 * Sets the value of [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField).
		 * @method
		 * @public (method)
		 * @param   {string} groupField The new value.
		 * @returns {void}              
		 */
		setGroupField? (groupField: string): void;
		/** 
		 * Sets the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.util.Grouper} grouper The new value.
		 * @returns {void}                            
		 */
		setGrouper? (grouper: object | Ext.util.Grouper): void;
		/** 
		 * Sets the value of [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone).
		 * @method
		 * @public (method)
		 * @param   {number} leadingBufferZone The new value.
		 * @returns {void}                     
		 */
		setLeadingBufferZone? (leadingBufferZone: number): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @param   {number} pageSize The new value.
		 * @returns {void}            
		 */
		setPageSize? (pageSize: number): void;
		/** 
		 * Sets the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.proxy.Proxy|object} proxy The new value.
		 * @returns {void}                                     
		 */
		setProxy? (proxy: string | Ext.data.proxy.Proxy | object): void;
		/** 
		 * Sets the value of [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount).
		 * @method
		 * @public (method)
		 * @param   {number} purgePageCount The new value.
		 * @returns {void}                  
		 */
		setPurgePageCount? (purgePageCount: number): void;
		/** 
		 * Sets the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteFilter The new value.
		 * @returns {void}                 
		 */
		setRemoteFilter? (remoteFilter: boolean): void;
		/** 
		 * Sets the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteSort The new value.
		 * @returns {void}               
		 */
		setRemoteSort? (remoteSort: boolean): void;
		/** 
		 * Sets the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} sortOnLoad The new value.
		 * @returns {void}               
		 */
		setSortOnLoad? (sortOnLoad: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setSorters? (): void;
		/** 
		 * Sets the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @param   {boolean} statefulFilters The new value.
		 * @returns {void}                    
		 */
		setStatefulFilters? (statefulFilters: boolean): void;
		/** 
		 * Sets the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @param   {string} storeId The new value.
		 * @returns {void}           
		 */
		setStoreId? (storeId: string): void;
		/** 
		 * Sets the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @param   {boolean} trackRemoved The new value.
		 * @returns {void}                 
		 */
		setTrackRemoved? (trackRemoved: boolean): void;
		/** 
		 * Sets the value of [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone).
		 * @method
		 * @public (method)
		 * @param   {number} trailingBufferZone The new value.
		 * @returns {void}                      
		 */
		setTrailingBufferZone? (trailingBufferZone: number): void;
		/** 
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {object}            field
		 * @param   {object}            direction
		 * @param   {object}            mode
		 * @returns {Ext.util.Sorter[]}           
		 */
		sort? (field: object, direction: object, mode: object): Ext.util.Sorter[];
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort).
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction] The overall direction to sort the data by.
		 * @returns {Ext.util.Sorter[]}                    
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string): Ext.util.Sorter[];
		/** 
		 * Suspends automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendAutoSync? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Destructor for classes that extend Observable.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		doDestroy? (): void;
		/** 
		 * A BufferedStore always reports that it contains the full dataset.
		 * The number of records that happen to be cached at any one time is never useful.
		 * @method
		 * @private (method)
		 * @returns {void|number}  
		 */
		getCount? (): void;
		getCount? (): number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                     config
		 * @returns {Ext.data.BufferedStore|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.BufferedStore;
		initConfig? (config: object): Ext.data.ProxyStore;
		initConfig? (config: object): Ext.data.AbstractStore;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.BufferedStore.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.BufferedStore.Statics;
		statics? (): Ext.data.ProxyStore.Statics;
		statics? (): Ext.data.AbstractStore.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorter
		 * @returns {void}          
		 */
		addFieldTransform? (sorter: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterCommit? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterErase? (record: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to..
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterReject? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} asynchronousLoad
		 * @returns {void}                    
		 */
		applyAsynchronousLoad? (asynchronousLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fields
		 * @returns {void}          
		 */
		applyFields? (fields: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @param   {object} filtersCollection
		 * @returns {void}                     
		 */
		applyFilters? (filters: object, filtersCollection: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} grouper
		 * @returns {void}           
		 */
		applyGrouper? (grouper: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @returns {void}         
		 */
		applyProxy? (proxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorters
		 * @param   {object} sortersCollection
		 * @returns {void}                     
		 */
		applySorters? (sorters: object, sortersCollection: object): void;
		/** 
		 * Restores state to the passed state
		 * @method
		 * @private (method)
		 * @param   {object} state
		 * @returns {void}         
		 */
		applyState? (state: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * to be implemented by subclasses
		 * @method
		 * @private (method)
		 * @param   {object} isLoad
		 * @returns {void}          
		 */
		clearData? (isLoad: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.clearData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-clearData).
		 * to be implemented by subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearData? (): void;
		/** 
		 * saves any phantom records
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @param   {object} options
		 * @returns {void}           
		 */
		create? (data: object, options: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * tells the attached proxy to destroy the given records
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		erase? (options: object): void;
		/** 
		 * Filter function for new records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNew? (item: object): void;
		/** 
		 * Filter function for updated records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterUpdated? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		fireGroupChange? (): void;
		/** 
		 * Returns the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getAutoSort? (): boolean;
		/** 
		 * Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
		 * This is broken out into a separate function to allow for customisation of the listeners
		 * @method
		 * @private (method)
		 * @returns {object}  The listeners object
		 */
		getBatchListeners? (): object;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getGroupField? (): void;
		/** 
		 * Returns the array of records which have been removed since the last time this store was synced.
		 * 
		 * This is used internally, when purging removed records after a successful sync.
		 * This is overridden by TreeStore because TreeStore accumulates deleted records on removal
		 * of child nodes from their parent, _not_ on removal of records from its collection. The collection
		 * has records added on expand, and removed on collapse.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRawRemovedRecords? (): void;
		/** 
		 * Returns the grouping, sorting and filtered state of this Store.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getState? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Returns true if the store has a pending load task.
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the store has a pending load task.
		 */
		hasPendingLoad? (): boolean;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Attached as the 'complete' event listener to a proxy's Batch object. Iterates over the batch operations
		 * and updates the Store's internal data MixedCollection.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchComplete? (batch: object, operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchException? (batch: object, operation: object): void;
		/** 
		 * Attached as the 'operationcomplete' event listener to a proxy's Batch object. By default just calls through
		 * to onProxyWrite.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchOperationComplete? (batch: object, operation: object): void;
		/** 
		 * This is attached to the data Collection's beforesort event only if not remoteSort
		 * If remoteSort, the event is fired before the reload call in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-load).
		 * @method
		 * @private (method)
		 * @param   {object} store
		 * @param   {object} sorters
		 * @returns {void}           
		 */
		onBeforeCollectionSort? (store: object, sorters: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} cls
		 * @param   {object} data
		 * @param   {object} hooks
		 * @returns {void}         
		 */
		onClassExtended? (cls: object, data: object, hooks: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCreateRecords? (): void;
		/** 
		 * Removes any records when a write is returned from the server.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]}             records   The array of removed records
		 * @param   {Ext.data.operation.Operation} operation The operation that just completed
		 * @param   {boolean}                      success   True if the operation was successful
		 * @returns {void}                                   
		 */
		onDestroyRecords? (records: Ext.data.Model[], operation: Ext.data.operation.Operation, success: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onErase? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onFilterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} meta
		 * @returns {void}         
		 */
		onMetaChange? (proxy: object, meta: object): void;
		/** 
		 * Callback for any write Operation over the Proxy. Updates the Store's MixedCollection to reflect
		 * the updates provided by the Proxy
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyWrite? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onSorterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdate? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdateRecords? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Sets the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @param   {boolean} autoSort The new value.
		 * @returns {void}             
		 */
		setAutoSort? (autoSort: boolean): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                   names The names of the linked objects to destroy.
		 * @returns {Ext.data.BufferedStore|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.BufferedStore;
		unlink? (names: string[]): Ext.data.ProxyStore;
		unlink? (names: string[]): Ext.data.AbstractStore;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		update? (options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoLoad
		 * @returns {void}            
		 */
		updateAutoLoad? (autoLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoSort
		 * @returns {void}            
		 */
		updateAutoSort? (autoSort: object): void;
		/** 
		 * 
		 * @method
		 * @private (method)
		 * @param   {object} field
		 * @returns {void}         
		 */
		updateGroupField? (field: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} oldProxy
		 * @returns {void}            
		 */
		updateProxy? (proxy: object, oldProxy: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @param   {object} oldRemoteFilter
		 * @returns {void}                   
		 */
		updateRemoteFilter? (remoteFilter: object, oldRemoteFilter: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.updateRemoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-updateRemoteFilter).
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @returns {void}                
		 */
		updateRemoteFilter? (remoteFilter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @param   {object} oldRemoteSort
		 * @returns {void}                 
		 */
		updateRemoteSort? (remoteSort: object, oldRemoteSort: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.updateRemoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-updateRemoteSort).
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @returns {void}              
		 */
		updateRemoteSort? (remoteSort: object): void;
	}
	/** 
	 * [Ext.data.Connection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html)
	 * The Connection class encapsulates a connection to the page's originating domain, allowing requests to be made either
	 * to a configured URL, or to a URL specified at request time.
	 * 
	 * Requests made by this class are asynchronous, and will return immediately. No data from the server will be available
	 * to the statement immediately following the [request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-request) call. To process returned data, use a success callback
	 * in the request options object, or an [event listener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#event-requestcomplete).
	 * 
	 * # File Uploads
	 * 
	 * File uploads are not performed using normal "Ajax" techniques, that is they are not performed using XMLHttpRequests.
	 * Instead the form is submitted in the standard manner with the DOM &lt;form&gt; element temporarily modified to have its
	 * target set to refer to a dynamically generated, hidden &lt;iframe&gt; which is inserted into the document but removed
	 * after the return data has been gathered.
	 * 
	 * The server response is parsed by the browser to create the document for the IFRAME. If the server is using JSON to
	 * send the return object, then the Content-Type header must be set to "text/html" in order to tell the browser to
	 * insert the text unchanged into the document body.
	 * 
	 * Characters which are significant to an HTML parser must be sent as HTML entities, so encode `&lt;` as `&amp;lt;`, `&amp;` as
	 * `&amp;amp;` etc.
	 * 
	 * The response text is retrieved from the document, and a fake XMLHttpRequest object is created containing a
	 * responseText property in order to conform to the requirements of event handlers and callbacks.
	 * 
	 * Be aware that file upload packets are sent with the content type multipart/form and some server technologies
	 * (notably JEE) may require some custom processing in order to retrieve parameter names and parameter values from the
	 * packet content.
	 * 
	 * Also note that it's not possible to check the response code of the hidden iframe, so the success handler will ALWAYS fire.
	 * 
	 * # Binary Posts
	 * 
	 * The class supports posting binary data to the server by using native browser capabilities, or a flash polyfill plugin in browsers that do not support native binary posting (e.g. Internet Explorer version 9 or less). A number of limitations exist when the polyfill is used:
	 * 
	 * - Only asynchronous connections are supported.
	 * - Only the POST method can be used.
	 * - The return data can only be binary for now. Set the [binary](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-binary) parameter to <tt>true</tt>.
	 * - Only the 0, 1 and 4 (complete) readyState values will be reported to listeners.
	 * - The flash object will be injected at the bottom of the document and should be invisible.
	 * - Important: See note about packaing the flash plugin with the app in the documenetation of [BinaryXhr](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.flash.BinaryXhr.html).
	 */
	class Connection extends Ext.Base {
		/** 
		 * This object holds a key for any event that has a listener. The listener may be set
		 * directly on the instance, or on its class or a super class (via [observe](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#static-method-observe)) or
		 * on the [MVC EventBus](https://docs.sencha.com/extjs/6.2.0/modern/Ext.app.EventBus.html). The values of this object are truthy
		 * (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
		 * of listeners. The value for an event is truthy if the event must be fired and is
		 * falsy if there is no need to fire the event.
		 * 
		 * The intended use of this property is to avoid the expense of fireEvent calls when
		 * there are no listeners. This can be particularly helpful when one would otherwise
		 * have to call fireEvent hundreds or thousands of times. It is used like this:
		 * 
		 *     if (this.hasListeners.foo) {
		 *         this.fireEvent('foo', this, arg1);
		 *     }
		 * 
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		readonly hasListeners?: object;
		/** 
		 * `true` in this class to identify an object as an instantiated Observable, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isObservable?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.Connection.Statics}
		 */
		self?: Ext.data.Connection.Statics | Ext.Base.Statics;
		/** 
		 * Matches options property names within a listeners specification object  - property names which are never used as event names.
		 * @property
		 * @private (property)
		 * @default {scope: 1, delay: 1, buffer: 1, onFrame: 1, single: 1, args: 1, destroyable: 1, priority: 1, order: 1}
		 * @type {object}
		 */
		$eventOptions?: object;
		/** 
		 * We don't want the base destructor to clear the prototype because
		 * our destroyObservable handler must be called the very last. It will take care
		 * of the prototype after completing Observable destruction sequence.
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$vetoClearingPrototypeOnDestroy?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @default /multipart\/form-data/i
		 * @type {RegExp}
		 */
		enctypeRe?: RegExp;
		/** 
		 * Initial suspended call count. Incremented when [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents) is called, decremented when [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) is called.
		 * @property
		 * @private (property)
		 * @default 0
		 * @type {number}
		 */
		eventsSuspended?: number;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                       members    The members to add to this class.
		 * @param   {boolean}                      [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                      [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Connection|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Connection;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                       members
		 * @returns {Ext.data.Connection|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.Connection;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                       name
		 * @param   {object}                       member
		 * @returns {Ext.data.Connection|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.Connection;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                       fn
		 * @param   {object}                       scope
		 * @returns {Ext.data.Connection|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.Connection;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Aborts an active request.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.request.Ajax} [request] Defaults to the last request
		 * @returns {void}                            
		 */
		abort? (request?: Ext.data.request.Ajax): void;
		/** 
		 * Aborts all active requests
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		abortAll? (): void;
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                               eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                             [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                                      [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.data.Connection.methodParams.addListener.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                                      [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                                      
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addListener? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.data.Connection.methodParams.addListener.Options, order?: string): object;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [async](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-async).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAsync? (): boolean;
		/** 
		 * Returns the value of [autoAbort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-autoAbort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoAbort? (): boolean;
		/** 
		 * Returns the value of [binary](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-binary).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBinary? (): boolean;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [cors](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-cors).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getCors? (): boolean;
		/** 
		 * Returns the value of [defaultHeaders](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-defaultHeaders).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getDefaultHeaders? (): object;
		/** 
		 * Returns the value of [defaultPostHeader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-defaultPostHeader).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDefaultPostHeader? (): string;
		/** 
		 * Returns the value of [defaultXdrContentType](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-defaultXdrContentType).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDefaultXdrContentType? (): string;
		/** 
		 * Returns the value of [defaultXhrHeader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-defaultXhrHeader).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDefaultXhrHeader? (): string;
		/** 
		 * Returns the value of [disableCaching](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-disableCaching).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getDisableCaching? (): boolean;
		/** 
		 * Returns the value of [disableCachingParam](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-disableCachingParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDisableCachingParam? (): string;
		/** 
		 * Returns the value of [extraParams](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraParams? (): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [isXdr](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-isXdr).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getIsXdr? (): boolean;
		/** 
		 * Returns the value of [method](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-method).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getMethod? (): string;
		/** 
		 * Returns the value of [password](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-password).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getPassword? (): string;
		/** 
		 * Returns the value of [timeout](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getTimeout? (): number;
		/** 
		 * Returns the value of [url](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-url).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getUrl? (): string;
		/** 
		 * Returns the value of [useDefaultXhrHeader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-useDefaultXhrHeader).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getUseDefaultXhrHeader? (): boolean;
		/** 
		 * Returns the value of [username](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-username).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getUsername? (): string;
		/** 
		 * Returns the value of [withCredentials](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-withCredentials).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getWithCredentials? (): boolean;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Determines whether this object has a request outstanding.
		 * @method
		 * @public (method)
		 * @param   {object}  [request] Defaults to the last transaction
		 * @returns {boolean}           True if there is an outstanding request.
		 */
		isLoading? (request?: object): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                      eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                    [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                             [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.data.Connection.methodParams.on.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                             [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                             
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		on? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.data.Connection.methodParams.on.Options, order?: string): object;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Sends an HTTP (Ajax) request to a remote server.
		 * 
		 * **Important:** Ajax server requests are asynchronous, and this call will
		 * return before the response has been received.
		 * 
		 * Instead, process any returned data using a promise:
		 * 
		 *     Ext.Ajax.request({
		 *         url: 'ajax_demo/sample.json'
		 *     }).then(function(response, opts) {
		 *         var obj = Ext.decode(response.responseText);
		 *         console.dir(obj);
		 *     },
		 *     function(response, opts) {
		 *         console.log('server-side failure with status code ' + response.status);
		 *     });
		 * 
		 * Or in callback functions:
		 * 
		 *     Ext.Ajax.request({
		 *         url: 'ajax_demo/sample.json',
		 *    
		 *         success: function(response, opts) {
		 *             var obj = Ext.decode(response.responseText);
		 *             console.dir(obj);
		 *         },
		 *    
		 *         failure: function(response, opts) {
		 *             console.log('server-side failure with status code ' + response.status);
		 *         }
		 *     });
		 * 
		 * To execute a callback function in the correct scope, use the `scope` option.
		 * @method
		 * @public (method)
		 * @param   {object|Ext.data.Connection.methodParams.request.Options} options
		 * An object which may contain the following properties:
		 * 
		 * (The options object may also contain any other property which might be needed to perform
		 * postprocessing in a callback because it is passed to callback functions.)
		 * @returns {Ext.data.request.Base}                                   
		 * The request object. This may be used to abort the
		 * request.
		 */
		request? (options: object | Ext.data.Connection.methodParams.request.Options): Ext.data.request.Base;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [async](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-async).
		 * @method
		 * @public (method)
		 * @param   {boolean} async The new value.
		 * @returns {void}          
		 */
		setAsync? (async: boolean): void;
		/** 
		 * Sets the value of [autoAbort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-autoAbort).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoAbort The new value.
		 * @returns {void}              
		 */
		setAutoAbort? (autoAbort: boolean): void;
		/** 
		 * Sets the value of [binary](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-binary).
		 * @method
		 * @public (method)
		 * @param   {boolean} binary The new value.
		 * @returns {void}           
		 */
		setBinary? (binary: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.data.Connection|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Connection;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [cors](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-cors).
		 * @method
		 * @public (method)
		 * @param   {boolean} cors The new value.
		 * @returns {void}         
		 */
		setCors? (cors: boolean): void;
		/** 
		 * Sets the value of [defaultHeaders](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-defaultHeaders).
		 * @method
		 * @public (method)
		 * @param   {object} defaultHeaders The new value.
		 * @returns {void}                  
		 */
		setDefaultHeaders? (defaultHeaders: object): void;
		/** 
		 * Sets the value of [defaultPostHeader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-defaultPostHeader).
		 * @method
		 * @public (method)
		 * @param   {string} defaultPostHeader The new value.
		 * @returns {void}                     
		 */
		setDefaultPostHeader? (defaultPostHeader: string): void;
		/** 
		 * Sets the value of [defaultXdrContentType](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-defaultXdrContentType).
		 * @method
		 * @public (method)
		 * @param   {string} defaultXdrContentType The new value.
		 * @returns {void}                         
		 */
		setDefaultXdrContentType? (defaultXdrContentType: string): void;
		/** 
		 * Sets the value of [defaultXhrHeader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-defaultXhrHeader).
		 * @method
		 * @public (method)
		 * @param   {string} defaultXhrHeader The new value.
		 * @returns {void}                    
		 */
		setDefaultXhrHeader? (defaultXhrHeader: string): void;
		/** 
		 * Sets the value of [disableCaching](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-disableCaching).
		 * @method
		 * @public (method)
		 * @param   {boolean} disableCaching The new value.
		 * @returns {void}                   
		 */
		setDisableCaching? (disableCaching: boolean): void;
		/** 
		 * Sets the value of [disableCachingParam](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-disableCachingParam).
		 * @method
		 * @public (method)
		 * @param   {string} disableCachingParam The new value.
		 * @returns {void}                       
		 */
		setDisableCachingParam? (disableCachingParam: string): void;
		/** 
		 * Sets the value of [extraParams](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-extraParams).
		 * @method
		 * @public (method)
		 * @param   {object} extraParams The new value.
		 * @returns {void}               
		 */
		setExtraParams? (extraParams: object): void;
		/** 
		 * Sets the value of [isXdr](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-isXdr).
		 * @method
		 * @public (method)
		 * @param   {boolean} isXdr The new value.
		 * @returns {void}          
		 */
		setIsXdr? (isXdr: boolean): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [method](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-method).
		 * @method
		 * @public (method)
		 * @param   {string} method The new value.
		 * @returns {void}          
		 */
		setMethod? (method: string): void;
		/** 
		 * Sets various options such as the url, params for the request
		 * @method
		 * @public (method)
		 * @param   {object} options The initial options
		 * @param   {object} scope   The scope to execute in
		 * @returns {object}         The params for the request
		 */
		setOptions? (options: object, scope: object): object;
		/** 
		 * Sets the value of [password](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-password).
		 * @method
		 * @public (method)
		 * @param   {string} password The new value.
		 * @returns {void}            
		 */
		setPassword? (password: string): void;
		/** 
		 * Sets the value of [timeout](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @param   {number} timeout The new value.
		 * @returns {void}           
		 */
		setTimeout? (timeout: number): void;
		/** 
		 * Sets the value of [url](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-url).
		 * @method
		 * @public (method)
		 * @param   {string} url The new value.
		 * @returns {void}       
		 */
		setUrl? (url: string): void;
		/** 
		 * Sets the value of [useDefaultXhrHeader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-useDefaultXhrHeader).
		 * @method
		 * @public (method)
		 * @param   {boolean} useDefaultXhrHeader The new value.
		 * @returns {void}                        
		 */
		setUseDefaultXhrHeader? (useDefaultXhrHeader: boolean): void;
		/** 
		 * Sets the value of [username](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-username).
		 * @method
		 * @public (method)
		 * @param   {string} username The new value.
		 * @returns {void}            
		 */
		setUsername? (username: string): void;
		/** 
		 * Sets the value of [withCredentials](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-withCredentials).
		 * @method
		 * @public (method)
		 * @param   {boolean} withCredentials The new value.
		 * @returns {void}                    
		 */
		setWithCredentials? (withCredentials: boolean): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Destructor for classes that extend Observable.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.data.Connection|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.Connection;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Connection.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.Connection.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * Clears the timeout on the request
		 * @method
		 * @private (method)
		 * @param   {object} request The request
		 * @returns {void}           
		 */
		clearTimeout? (request: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @param   {object} requestOptions
		 * @returns {void}                  
		 */
		createRequest? (options: object, requestOptions: object): void;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Gets the form object from options.
		 * @method
		 * @private (method)
		 * @param   {object}      options The request options
		 * @returns {HTMLElement}         The form, null if not passed
		 */
		getForm? (options: object): HTMLElement;
		/** 
		 * Gets the most recent request
		 * @method
		 * @private (method)
		 * @returns {object}  The request. Null if there is no recent request
		 */
		getLatest? (): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Detects whether the form is intended to be used for an upload.
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		isFormUpload? (options: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the browser can natively post binary data.
		 */
		nativeBinaryPostSupport? (): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} request
		 * @returns {void}           
		 */
		onRequestComplete? (request: object): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Template method for overriding method
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @param   {string} method
		 * @returns {string}         The modified method
		 */
		setupMethod? (options: object, method: string): string;
		/** 
		 * Template method for overriding params
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @param   {string} params
		 * @returns {string}         The modified params
		 */
		setupParams? (options: object, params: string): string;
		/** 
		 * Template method for overriding url
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @param   {string} url
		 * @returns {string}         The modified url
		 */
		setupUrl? (options: object, url: string): string;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                     names The names of the linked objects to destroy.
		 * @returns {Ext.data.Connection|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.Connection;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * [Ext.data.DirectStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html)
	 * Small helper class to create an [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) configured with an [Ext.data.proxy.Direct](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html)
	 * and [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) to make interacting with an [Ext.direct.Manager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.direct.Manager.html) server-side
	 * [Provider](https://docs.sencha.com/extjs/6.2.0/modern/Ext.direct.Provider.html) easier. To create a different proxy/reader combination create a basic
	 * [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) configured as needed.
	 * 
	 * **Note:** Although they are not listed, this class inherits all of the config options of:
	 * 
	 * - **[Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)**
	 * - **[JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html)**
	 *   <ul>
	 *   <li>**[rootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html#cfg-rootProperty)**
	 * - **[totalProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html#cfg-totalProperty)**
	 * 
	 * </li>
	 * <li>
	 * 
	 * **[DirectProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html)**
	 * 
	 * - **[directFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-directFn)**
	 * - **[paramOrder](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-paramOrder)**
	 * - **[paramsAsHash](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-paramsAsHash)**
	 * 
	 * </li>
	 * </ul>
	 */
	class DirectStore extends Ext.data.Store {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.DirectStore.Statics}
		 */
		self?: Ext.data.DirectStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                  members    The members to add to this class.
		 * @param   {boolean}                                                                                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.DirectStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.DirectStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                  members
		 * @returns {Ext.data.DirectStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.DirectStore;
		static addStatics? (members: object): typeof Ext.data.Store;
		static addStatics? (members: object): typeof Ext.data.ProxyStore;
		static addStatics? (members: object): typeof Ext.data.AbstractStore;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                  name
		 * @param   {object}                                                                                  member
		 * @returns {Ext.data.DirectStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.DirectStore;
		static addMember? (name: object, member: object): typeof Ext.data.Store;
		static addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		static addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                  fn
		 * @param   {object}                                                                                  scope
		 * @returns {Ext.data.DirectStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.DirectStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		static onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                The model instances that were added
		 */
		add? (model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {...Ext.data.Model|...object} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                  The model instances that were added
		 */
		add? (...model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * Adds a new Filter to this Store's [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {object[]|Ext.util.Filter[]} filters         The set of filters to add to the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters).
		 * @param   {boolean}                    [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                       
		 */
		addFilter? (filters: object[] | Ext.util.Filter[], suppressEvent?: boolean): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * (Local sort only) Inserts the passed Record into the Store at the index where it
		 * should go based on the current sort information.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Record} record
		 * @returns {void}                   
		 */
		addSorted? (record: Ext.data.Record): void;
		/** 
		 * Runs the aggregate function for all the records in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {Function} fn
		 * The function to execute. The function is called with a single parameter,
		 * an array of records for that group.
		 * @param   {object}   scope   The scope to execute the function in. Defaults to the store.
		 * @param   {boolean}  grouped
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @param   {string}   field   The field to get the value from
		 * @returns {object}           An object literal with the group names and their appropriate values.
		 */
		aggregate? (fn: ExtGlobalFunction, scope: object, grouped: boolean, field: string): object;
		/** 
		 * Gets the average value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The average value, if no items exist, 0.
		 */
		average? (field: string, grouped?: boolean): object;
		/** 
		 * This method may be called to indicate the start of multiple changes to the store.
		 * 
		 * Automatic synchronization as configured by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred
		 * until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple mutations can be coalesced
		 * into one synchronization operation.
		 * 
		 * Internally this method increments a counter that is decremented by `endUpdate`. It
		 * is important, therefore, that if you call `beginUpdate` directly you match that
		 * call with a call to `endUpdate` or you will prevent the collection from updating
		 * properly.
		 * 
		 * For example:
		 * 
		 *     var store = Ext.StoreManager.lookup({
		 *         //...
		 *         autoSync: true
		 *     });
		 *    
		 *     store.beginUpdate();
		 *    
		 *     record.set('fieldName', 'newValue');
		 *    
		 *     store.add(item);
		 *     // ...
		 *    
		 *     store.insert(index, otherItem);
		 *     //...
		 *    
		 *     // Interested parties will listen for the endupdate event
		 *     store.endUpdate();
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginUpdate? (): void;
		/** 
		 * Reverts to a view of the Record cache with no filtering applied.
		 * @method
		 * @public (method)
		 * @param   {boolean} [suppressEvent]
		 * If `true` the filter is cleared silently.
		 * 
		 * For a locally filtered Store, this means that the filter collection is cleared without firing the
		 * [datachanged](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-datachanged) event.
		 * 
		 * For a remotely filtered Store, this means that the filter collection is cleared, but the store
		 * is not reloaded from the server.
		 * @returns {void}                    
		 */
		clearFilter? (suppressEvent?: boolean): void;
		/** 
		 * Clear the store grouping
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearGrouping? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Commits all Records with [outstanding changes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords). To handle updates for changes,
		 * subscribe to the Store's [update event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-update), and perform updating when the third parameter is
		 * [Ext.data.Record.COMMIT](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#static-property-COMMIT).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		commitChanges? (): void;
		/** 
		 * Gets the count of items in the store.
		 * 
		 * When store is filtered, only items within the filter are counted.
		 * @method
		 * @public (method)
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the count for each group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            the count
		 */
		count? (grouped?: boolean): number;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * This method is called after modifications are complete on a store. For details
		 * see [`beginUpdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		endUpdate? (): void;
		/** 
		 * Filters the data in the Store by one or more fields. Example usage:
		 * 
		 *    //filter with a single field
		 *    myStore.filter('firstName', 'Don');
		 *    
		 *    //filtering with multiple filters
		 *    myStore.filter([
		 *        {
		 *            property : 'firstName',
		 *            value    : 'Don'
		 *        },
		 *        {
		 *            property : 'lastName',
		 *            value    : 'Griffin'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) instances, and delegates
		 * the actual filtering to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter[]} [filters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of filter configurations.
		 * @param   {string}                   [value]   The property value by which to filter. Only applicable if `filters` is a string.
		 * @returns {void}                               
		 */
		filter? (filters?: string | Ext.util.Filter[], value?: string): void;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of the Record field to test.
		 * @param   {string|RegExp} value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}        [startIndex]    The index to start searching at
		 * @param   {boolean}       [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}       [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {number}                        The matched index or -1
		 */
		find? (property: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string} fieldName    The name of the Record field to test.
		 * @param   {object} value        The value to match the field against.
		 * @param   {number} [startIndex] The index to start searching at
		 * @returns {number}              The matched index or -1
		 */
		findExact? (fieldName: string, value: object, startIndex?: number): number;
		/** 
		 * Finds the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}         fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}  value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}         [startIndex]    The index to start searching at
		 * @param   {boolean}        [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}        [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}        [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.Model}                 The matched record or null
		 */
		findRecord? (fieldName: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Convenience function for getting the first model instance in the store.
		 * 
		 * When store is filtered, will return first item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the first record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The first model instance in the store, or undefined
		 */
		first? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Called when the event handler which called the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method exits.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		flushLoad? (): void;
		/** 
		 * Returns the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAsynchronousLoad? (): boolean;
		/** 
		 * Get the Record at the specified index.
		 * 
		 * The index is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}         index The index of the Record to find.
		 * @returns {Ext.data.Model}       The Record at the passed index. Returns null if not found.
		 */
		getAt? (index: number): Ext.data.Model;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Returns the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean|object}  
		 */
		getAutoLoad? (): boolean | object;
		/** 
		 * Returns the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoSync? (): boolean;
		/** 
		 * Returns the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchUpdateMode? (): string;
		/** 
		 * Get the Record with the specified id.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            id The id of the Record to find.
		 * @returns {Ext.data.Model}    The Record with the passed id. Returns null if not found.
		 */
		getById? (id: any): Ext.data.Model;
		/** 
		 * Get the Record with the specified internalId.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            internalId The id of the Record to find.
		 * @returns {Ext.data.Model}            The Record with the passed internalId. Returns null if not found.
		 */
		getByInternalId? (internalId: any): Ext.data.Model;
		/** 
		 * Returns the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearOnPageLoad? (): boolean;
		/** 
		 * Returns the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearRemovedOnLoad? (): boolean;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Gets the number of records in store.
		 * 
		 * If using paging, this may not be the total size of the dataset. If the data object
		 * used by the Reader contains the dataset size, then the [Ext.data.ProxyStore.getTotalCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getTotalCount) function returns
		 * the dataset size.  **Note**: see the Important note in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load).
		 * 
		 * When store is filtered, it's the number of records matching the filter.
		 * @method
		 * @public (method)
		 * @returns {number}  The number of Records in the Store.
		 */
		getCount? (): number;
		/** 
		 * Returns the store's records.
		 * 
		 * **Note:** If your store has been filtered, getData() will return a filtered
		 * collection.  Use `getData().[getSource()`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#method-getSource) to
		 * fetch all unfiltered records.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection} 
		 * An [Ext.util.Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) of records
		 * (an empty Collection if no records are held by the store).
		 */
		getData? (): Ext.util.Collection;
		/** 
		 * Returns the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraKeys? (): object;
		/** 
		 * Returns the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @returns {object[]|string[]}  
		 */
		getFields? (): object[] | string[];
		/** 
		 * Gets the filters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.FilterCollection}            The filters
		 */
		getFilters? (autoCreate: object): Ext.util.FilterCollection;
		/** 
		 * Returns the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDir? (): string;
		/** 
		 * Returns the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @returns {object|Ext.util.Grouper}  
		 */
		getGrouper? (): object | Ext.util.Grouper;
		/** 
		 * Returns a collection of readonly sub-collections of your store's records
		 * with grouping applied. These sub-collections are maintained internally by
		 * the collection.
		 * 
		 * See [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField), [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir). Example for a store
		 * containing records with a color field:
		 * 
		 *    var myStore = Ext.create('Ext.data.Store', {
		 *        groupField: 'color',
		 *        groupDir  : 'DESC'
		 *    });
		 *    
		 *    myStore.getGroups();
		 * 
		 * The above should result in the following format:
		 * 
		 *    [
		 *        {
		 *            name: 'yellow',
		 *            children: [
		 *                // all records where the color field is 'yellow'
		 *            ]
		 *        },
		 *        {
		 *            name: 'red',
		 *            children: [
		 *                // all records where the color field is 'red'
		 *            ]
		 *        }
		 *    ]
		 * 
		 * Group contents are affected by filtering.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection}  The grouped data
		 */
		getGroups? (): Ext.util.Collection;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Gets all [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) added or updated since the last commit. Note that the order of records
		 * returned is not deterministic and does not indicate the order in which records were modified. Note also that
		 * removed records are not included (use [getRemovedRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getRemovedRecords) for that).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The added and updated Model instances
		 */
		getModifiedRecords? (): Ext.data.Model[];
		/** 
		 * Returns all [`phantom`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records in this store.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  A possibly empty array of `phantom` records.
		 */
		getNewRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getPageSize? (): number;
		/** 
		 * Returns the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.proxy.Proxy|object}  
		 */
		getProxy? (): string | Ext.data.proxy.Proxy | object;
		/** 
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}           start The starting index. Defaults to zero.
		 * @param   {number}           end   The ending index. Defaults to the last record. The end index **is included**.
		 * @returns {Ext.data.Model[]}       An array of records.
		 */
		getRange? (start: number, end: number): Ext.data.Model[];
		/** 
		 * Returns the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteFilter? (): boolean;
		/** 
		 * Returns the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteSort? (): boolean;
		/** 
		 * Returns any records that have been removed from the store but not yet destroyed on the proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]} 
		 * The removed Model instances. Note that this is a _copy_ of the store's
		 * array, so may be mutated.
		 */
		getRemovedRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Session}  
		 */
		getSession? (): Ext.data.Session;
		/** 
		 * Returns the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSortOnLoad? (): boolean;
		/** 
		 * Gets the sorters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.SorterCollection}            The sorters
		 */
		getSorters? (autoCreate: object): Ext.util.SorterCollection;
		/** 
		 * Returns the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getStatefulFilters? (): boolean;
		/** 
		 * Returns the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStoreId? (): string;
		/** 
		 * Returns the total number of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances that the [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html)
		 * indicates exist. This will usually differ from [getCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getCount) when using paging - getCount returns the
		 * number of records loaded into the Store at the moment, getTotalCount returns the number of records that
		 * could be loaded into the Store if the Store contained all data
		 * @method
		 * @public (method)
		 * @returns {number} 
		 * The total number of Model instances available via the Proxy. 0 returned if
		 * no value has been set via the reader.
		 */
		getTotalCount? (): number;
		/** 
		 * Returns the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getTrackRemoved? (): boolean;
		/** 
		 * Returns all valid, non-phantom Model instances that have been updated in the Store but not yet synchronized with the Proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The updated Model instances
		 */
		getUpdatedRecords? (): Ext.data.Model[];
		/** 
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {string|object} grouper
		 * Either a string name of one of the fields in this Store's
		 * configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an object, or a [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Grouper.html) configuration object.
		 * @param   {string}        [direction] The overall direction to group the data by. Defaults to the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @returns {void}                      
		 */
		group? (grouper: string | object, direction?: string): void;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Get the index of the record within the store.
		 * 
		 * When store is filtered, records outside of filter will not be found.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) object to find.
		 * @returns {number}                The index of the passed Record. Returns -1 if not found.
		 */
		indexOf? (record: Ext.data.Model): number;
		/** 
		 * Get the index within the store of the Record with the passed id.
		 * 
		 * Like [indexOf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-indexOf), this method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {string} id The id of the Record to find.
		 * @returns {number}    The index of the Record. Returns -1 if not found.
		 */
		indexOfId? (id: string): number;
		/** 
		 * Inserts Model instances into the Store at the given index and fires the add event.
		 * See also [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
		 * @method
		 * @public (method)
		 * @param   {number}                                          index   The start index at which to insert the passed Records.
		 * @param   {Ext.data.Model|Ext.data.Model[]|object|object[]} records
		 * An [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instance, the
		 * data needed to populate an instance or an array of either of these.
		 * @returns {Ext.data.Model[]}                                        records The added records
		 */
		insert? (index: number, records: Ext.data.Model | Ext.data.Model[] | object | object[]): Ext.data.Model[];
		/** 
		 * Tests whether the store currently has any active filters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is filtered.
		 */
		isFiltered? (): boolean;
		/** 
		 * Tests whether the store currently has an active grouper.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is grouped.
		 */
		isGrouped? (): boolean;
		/** 
		 * Returns `true` if the Store has been loaded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store has been loaded.
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns true if the Store is currently performing a load operation
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store is currently loading
		 */
		isLoading? (): boolean;
		/** 
		 * Tests whether the store currently has any active sorters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is sorted.
		 */
		isSorted? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Convenience function for getting the last model instance in the store.
		 * 
		 * When store is filtered, will return last item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the last record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The last model instance in the store, or undefined
		 */
		last? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Loads an array of data straight into the Store.
		 * 
		 * Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
		 * processed by a reader). If your data requires processing to decode the data structure, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @param   {boolean}                   [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {void}                               
		 */
		loadData? (data: Ext.data.Model[] | object[], append?: boolean): void;
		/** 
		 * Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
		 * load operation, passing in calculated 'start' and 'limit' params.
		 * @method
		 * @public (method)
		 * @param   {number} page      The number of the page to load.
		 * @param   {object} [options] See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		loadPage? (page: number, options?: object): void;
		/** 
		 * Loads data via the bound Proxy's reader
		 * 
		 * Use this method if you are attempting to load data and want to utilize the configured data reader.
		 * 
		 * As of 4.2, this method will no longer fire the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-load) event.
		 * @method
		 * @public (method)
		 * @param   {object[]} data     The full JSON object you'd like to load into the Data store.
		 * @param   {boolean}  [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {boolean}  
		 * `true` if the reader processed the records correctly. See [Ext.data.reader.Reader.successProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-successProperty).
		 * If the reader did not process the records, nothing will be added.
		 */
		loadRawData? (data: object[], append?: boolean): boolean;
		/** 
		 * Gets the maximum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the maximum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The maximum value, if no items exist, undefined.
		 */
		max? (field: string, grouped?: boolean): object;
		/** 
		 * Gets the minimum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the minimum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The minimum value, if no items exist, undefined.
		 */
		min? (field: string, grouped?: boolean): object;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Loads the next 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		nextPage? (options: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Loads the previous 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		previousPage? (options: object): void;
		/** 
		 * Query all the cached records in this Store by name/value pair.
		 * The parameters will be used to generated a filter function that is given
		 * to the queryBy method.
		 * 
		 * This method complements queryBy by generating the query function automatically.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @public (method)
		 * @param   {string}              property        The property to create the filter function for
		 * @param   {string|RegExp}       value           The string/regex to compare the property value to
		 * @param   {boolean}             [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}             [caseSensitive] `true` to create a case-sensitive regex.
		 * @param   {boolean}             [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.util.Collection}                 The matched records
		 */
		query? (property: string, value: string | RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.util.Collection;
		/** 
		 * [Rejects](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-reject) outstanding changes on all [modified records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords)
		 * and re-insert any records that were removed locally. Any phantom records will be removed.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		rejectChanges? (): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Reloads the store using the last options passed to the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method. You can use the reload method to reload the
		 * store using the parameters from the last load() call. For example:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload();
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution will pass the `userid` parameter in the request. The [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) execution
		 * will also send the same `userid` parameter in its request as it will reuse the `params` object from the last [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) call.
		 * 
		 * You can override a param by passing in the config object with the `params` object:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216,
		 *            foo    : 'bar'
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload({
		 *        params : {
		 *            userid : 1234
		 *        }
		 *    });
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution sends the `userid` and `foo` parameters but in the [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) it only sends
		 * the `userid` paramter because you are overriding the `params` config not just overriding the one param. To only change a single param
		 * but keep other params, you will have to get the last params from the [lastOptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#property-lastOptions) property:
		 * 
		 *    var lastOptions = store.lastOptions,
		 *        lastParams = Ext.clone(lastOptions.params); // make a copy of the last params so we don't affect future reload() calls
		 *    
		 *    lastParams.userid = 1234;
		 *    
		 *    store.reload({
		 *        params : lastParams
		 *    });
		 * 
		 * This will now send the `userid` parameter as `1234` and the `foo` param as `'bar'`.
		 * @method
		 * @public (method)
		 * @param   {object} [options]
		 * A config object which contains options which may override the options passed to the previous load call. See the
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method for valid configs.
		 * @returns {void}             
		 */
		reload? (options?: object): void;
		/** 
		 * Removes the specified record(s) from the Store, firing the [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove)
		 * event for the removed records.
		 * 
		 * After all records have been removed a single `datachanged` is fired.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model|Ext.data.Model[]|number|number[]} records
		 * Model instance or
		 * array of instances to remove or an array of indices from which to remove records.
		 * @param   {object}                                          isMove  (private)
		 * @param   {object}                                          silent  (private)
		 * @returns {void}                                                    
		 */
		remove? (records: Ext.data.Model | Ext.data.Model[] | number | number[], isMove: object, silent: object): void;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Removes all items from the store.
		 * 
		 * Individual record [`remove`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events are not fired by this method.
		 * @method
		 * @public (method)
		 * @param   {boolean}          [silent]
		 * Pass `true` to prevent the [`clear`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-clear) event from being fired.
		 * 
		 * This method is affected by filtering.
		 * @returns {Ext.data.Model[]}          The removed records.
		 */
		removeAll? (silent?: boolean): Ext.data.Model[];
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-removeAll).
		 * Removes all records from the store. This method does a "fast remove",
		 * individual remove events are not called. The [clear](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-clear) event is
		 * fired upon completion.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]|void}  
		 */
		removeAll? (): void;
		/** 
		 * Removes the model instance(s) at the given index
		 * @method
		 * @public (method)
		 * @param   {number} index   The record index
		 * @param   {number} [count] The number of records to delete
		 * @returns {void}           
		 */
		removeAt? (index: number, count?: number): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an individual Filter from the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) using the passed Filter/Filter id and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter} toRemove        The id of a Filter to remove from the filter set, or a Filter instance to remove.
		 * @param   {boolean}                [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                   
		 */
		removeFilter? (toRemove: string | Ext.util.Filter, suppressEvent?: boolean): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @param   {boolean} syncNow
		 * Pass `true` to synchronize now. Only synchronizes with the Proxy if the suspension
		 * count has gone to zero (We are not under a higher level of suspension)
		 * @returns {void}            
		 */
		resumeAutoSync? (syncNow: boolean): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Saves all pending changes via the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy). Use [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) instead.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		save? (): void;
		/** 
		 * Sets the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} asynchronousLoad The new value.
		 * @returns {void}                     
		 */
		setAsynchronousLoad? (asynchronousLoad: boolean): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean|object} autoLoad The new value.
		 * @returns {void}                    
		 */
		setAutoLoad? (autoLoad: boolean | object): void;
		/** 
		 * Sets the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoSync The new value.
		 * @returns {void}             
		 */
		setAutoSync? (autoSync: boolean): void;
		/** 
		 * Sets the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @param   {string} batchUpdateMode The new value.
		 * @returns {void}                   
		 */
		setBatchUpdateMode? (batchUpdateMode: string): void;
		/** 
		 * Sets the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearOnPageLoad The new value.
		 * @returns {void}                    
		 */
		setClearOnPageLoad? (clearOnPageLoad: boolean): void;
		/** 
		 * Sets the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearRemovedOnLoad The new value.
		 * @returns {void}                       
		 */
		setClearRemovedOnLoad? (clearRemovedOnLoad: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                                           name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                                  [value] The value to set for the name parameter.
		 * @returns {Ext.data.DirectStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.DirectStore;
		setConfig? (name: string | object, value?: object): Ext.data.Store;
		setConfig? (name: string | object, value?: object): Ext.data.ProxyStore;
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Loads an array of data directly into the Store.
		 * 
		 * setData() is ideal if your data's format is already in its appropriate format (e.g. it doesn't need to be
		 * processed by a reader). If your data's structure requires processing, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * 
		 * Use [loadData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadData), [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add), or [insert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-insert) if records need to be
		 * appended to the current recordset.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @returns {void}                           
		 */
		setData? (data: Ext.data.Model[] | object[]): void;
		/** 
		 * Sets the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @param   {object} extraKeys The new value.
		 * @returns {void}             
		 */
		setExtraKeys? (extraKeys: object): void;
		/** 
		 * Sets the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @param   {object[]|string[]} fields The new value.
		 * @returns {void}                     
		 */
		setFields? (fields: object[] | string[]): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setFilters? (): void;
		/** 
		 * Sets the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @param   {string} groupDir The new value.
		 * @returns {void}            
		 */
		setGroupDir? (groupDir: string): void;
		/** 
		 * Sets the value of [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField).
		 * @method
		 * @public (method)
		 * @param   {string} groupField The new value.
		 * @returns {void}              
		 */
		setGroupField? (groupField: string): void;
		/** 
		 * Sets the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.util.Grouper} grouper The new value.
		 * @returns {void}                            
		 */
		setGrouper? (grouper: object | Ext.util.Grouper): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @param   {number} pageSize The new value.
		 * @returns {void}            
		 */
		setPageSize? (pageSize: number): void;
		/** 
		 * Sets the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.proxy.Proxy|object} proxy The new value.
		 * @returns {void}                                     
		 */
		setProxy? (proxy: string | Ext.data.proxy.Proxy | object): void;
		/** 
		 * Sets the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteFilter The new value.
		 * @returns {void}                 
		 */
		setRemoteFilter? (remoteFilter: boolean): void;
		/** 
		 * Sets the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteSort The new value.
		 * @returns {void}               
		 */
		setRemoteSort? (remoteSort: boolean): void;
		/** 
		 * Sets the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} session The new value.
		 * @returns {void}                     
		 */
		setSession? (session: Ext.data.Session): void;
		/** 
		 * Sets the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} sortOnLoad The new value.
		 * @returns {void}               
		 */
		setSortOnLoad? (sortOnLoad: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setSorters? (): void;
		/** 
		 * Sets the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @param   {boolean} statefulFilters The new value.
		 * @returns {void}                    
		 */
		setStatefulFilters? (statefulFilters: boolean): void;
		/** 
		 * Sets the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @param   {string} storeId The new value.
		 * @returns {void}           
		 */
		setStoreId? (storeId: string): void;
		/** 
		 * Sets the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @param   {boolean} trackRemoved The new value.
		 * @returns {void}                 
		 */
		setTrackRemoved? (trackRemoved: boolean): void;
		/** 
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction] The overall direction to sort the data by.
		 * @returns {Ext.util.Sorter[]}                    
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string): Ext.util.Sorter[];
		/** 
		 * Sums the value of `field` for each [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in store
		 * and returns the result.
		 * 
		 * When store is filtered, only sums items within the filter.
		 * @method
		 * @public (method)
		 * @param   {string}  field     A field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the sum for that group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            The sum
		 */
		sum? (field: string, grouped?: boolean): number;
		/** 
		 * Suspends automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendAutoSync? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Inherit docs
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		contains? (record: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.contains](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-contains).
		 * Checks if a record is in the current active data set.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record
		 * @returns {void|boolean}          `true` if the record is in the current active data set.
		 */
		contains? (record: Ext.data.Model): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		doDestroy? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                                  config
		 * @returns {Ext.data.DirectStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.DirectStore;
		initConfig? (config: object): Ext.data.Store;
		initConfig? (config: object): Ext.data.ProxyStore;
		initConfig? (config: object): Ext.data.AbstractStore;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Called internally when a Proxy has completed a load request
		 * @method
		 * @protected (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyLoad? (operation: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.DirectStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.DirectStore.Statics;
		statics? (): Ext.data.Store.Statics;
		statics? (): Ext.data.ProxyStore.Statics;
		statics? (): Ext.data.AbstractStore.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorter
		 * @returns {void}          
		 */
		addFieldTransform? (sorter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		addObserver? (observer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @param   {object} type
		 * @returns {void}                      
		 */
		afterChange? (record: object, modifiedFieldNames: object, type: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterCommit? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterDrop? (record: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @returns {void}                      
		 */
		afterEdit? (record: object, modifiedFieldNames: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterErase? (record: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to..
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterReject? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} asynchronousLoad
		 * @returns {void}                    
		 */
		applyAsynchronousLoad? (asynchronousLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} extraKeys
		 * @returns {void}             
		 */
		applyExtraKeys? (extraKeys: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fields
		 * @returns {void}          
		 */
		applyFields? (fields: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @param   {object} filtersCollection
		 * @returns {void}                     
		 */
		applyFilters? (filters: object, filtersCollection: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} grouper
		 * @returns {void}           
		 */
		applyGrouper? (grouper: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @returns {void}         
		 */
		applyProxy? (proxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorters
		 * @param   {object} sortersCollection
		 * @returns {void}                     
		 */
		applySorters? (sorters: object, sortersCollection: object): void;
		/** 
		 * Restores state to the passed state
		 * @method
		 * @private (method)
		 * @param   {object} state
		 * @returns {void}         
		 */
		applyState? (state: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} args
		 * @returns {void}          
		 */
		callObservers? (action: object, args: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} isLoad
		 * @returns {void}          
		 */
		clearData? (isLoad: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.clearData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-clearData).
		 * to be implemented by subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearData? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		constructDataCollection? (): void;
		/** 
		 * saves any phantom records
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @param   {object} options
		 * @returns {void}           
		 */
		create? (data: object, options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createFiltersCollection? (): void;
		/** 
		 * Converts a literal to a model, if it's not a model already
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model|object} record The record to create
		 * @returns {Ext.data.Model}               
		 */
		createModel? (record: Ext.data.Model | object): Ext.data.Model;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createSortersCollection? (): void;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * tells the attached proxy to destroy the given records
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		erase? (options: object): void;
		/** 
		 * Similar to a load, however no records are added to the store. This is useful
		 * in allowing the developer to decide what to do with the new records.
		 * @method
		 * @private (method)
		 * @param   {object} [options] See [load options](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		fetch? (options?: object): void;
		/** 
		 * private
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @returns {void}      
		 */
		filterDataSource? (fn: object): void;
		/** 
		 * Filter function for new records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNew? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNewOnly? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterRejects? (item: object): void;
		/** 
		 * Filter function for updated records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterUpdated? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		fireGroupChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		forceLocalSort? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @param   {object} scope
		 * @param   {object} records
		 * @param   {object} field
		 * @returns {void}           
		 */
		getAggregate? (fn: object, scope: object, records: object, field: object): void;
		/** 
		 * Returns the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.Model}  
		 */
		getAssociatedEntity? (): Ext.data.Model;
		/** 
		 * Returns the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getAutoSort? (): boolean;
		/** 
		 * Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
		 * This is broken out into a separate function to allow for customisation of the listeners
		 * @method
		 * @private (method)
		 * @returns {object}  The listeners object
		 */
		getBatchListeners? (): object;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Returns the complete unfiltered collection.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getDataSource? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getGroupField? (): void;
		/** 
		 * Returns the array of records which have been removed since the last time this store was synced.
		 * 
		 * This is used internally, when purging removed records after a successful sync.
		 * This is overridden by TreeStore because TreeStore accumulates deleted records on removal
		 * of child nodes from their parent, _not_ on removal of records from its collection. The collection
		 * has records added on expand, and removed on collapse.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRawRemovedRecords? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRejectRecords? (): void;
		/** 
		 * Returns the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.schema.Role}  
		 */
		getRole? (): Ext.data.schema.Role;
		/** 
		 * Returns the grouping, sorting and filtered state of this Store.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getState? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Returns true if the store has a pending load task.
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the store has a pending load task.
		 */
		hasPendingLoad? (): boolean;
		/** 
		 * Checks whether records are being moved within the store. This can be used in conjunction with the
		 * [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-add) and [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events to determine whether the records are being removed/added
		 * or just having the position changed.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]|Ext.data.Model} [records] The record(s).
		 * @returns {number}                          
		 * The number of records being moved. `0` if no records are moving. If records are passed
		 * the number will refer to how many of the passed records are moving.
		 */
		isMoving? (records?: Ext.data.Model[] | Ext.data.Model): number;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @returns {void}        
		 */
		loadInlineData? (data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		notifySorterChange? (): void;
		/** 
		 * Attached as the 'complete' event listener to a proxy's Batch object. Iterates over the batch operations
		 * and updates the Store's internal data MixedCollection.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchComplete? (batch: object, operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchException? (batch: object, operation: object): void;
		/** 
		 * Attached as the 'operationcomplete' event listener to a proxy's Batch object. By default just calls through
		 * to onProxyWrite.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchOperationComplete? (batch: object, operation: object): void;
		/** 
		 * This is attached to the data Collection's beforesort event only if not remoteSort
		 * If remoteSort, the event is fired before the reload call in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-load).
		 * @method
		 * @private (method)
		 * @param   {object} store
		 * @param   {object} sorters
		 * @returns {void}           
		 */
		onBeforeCollectionSort? (store: object, sorters: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} cls
		 * @param   {object} data
		 * @param   {object} hooks
		 * @returns {void}         
		 */
		onClassExtended? (cls: object, data: object, hooks: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} records
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionAddItems? (collection: object, records: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionBeforeItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionBeginUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionEndUpdate? (): void;
		/** 
		 * When the collection informs us that it has filtered, this LocalStore must react.
		 * AbstractStore#onFilterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilter? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} items
		 * @returns {void}              
		 */
		onCollectionFilterAdd? (collection: object, items: object): void;
		/** 
		 * If our source collection informs us that a filtered out item has changed, we must still fire the events...
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilteredItemChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionRemove? (collection: object, info: object): void;
		/** 
		 * When the collection informs us that it has sorted, this LocalStore must react.
		 * AbstractStore#onSorterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionSort? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCreateRecords? (): void;
		/** 
		 * Removes any records when a write is returned from the server.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]}             records   The array of removed records
		 * @param   {Ext.data.operation.Operation} operation The operation that just completed
		 * @param   {boolean}                      success   True if the operation was successful
		 * @returns {void}                                   
		 */
		onDestroyRecords? (records: Ext.data.Model[], operation: Ext.data.operation.Operation, success: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onErase? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onFilterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} rec
		 * @param   {object} oldId
		 * @param   {object} newId
		 * @returns {void}         
		 */
		onIdChanged? (rec: object, oldId: object, newId: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} meta
		 * @returns {void}         
		 */
		onMetaChange? (proxy: object, meta: object): void;
		/** 
		 * Callback for any write Operation over the Proxy. Updates the Store's MixedCollection to reflect
		 * the updates provided by the Proxy
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyWrite? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onSorterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdate? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdateRecords? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Query all the cached records in this Store by field.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @private (method)
		 * @param   {string}           field The field from each record to use.
		 * @param   {object}           value The value to match.
		 * @returns {Ext.data.Model[]}       The matched records.
		 */
		queryRecords? (field: string, value: object): Ext.data.Model[];
		/** 
		 * Determines if the passed range is available in the page cache.
		 * @method
		 * @private (method)
		 * @param   {number} start The start index
		 * @param   {number} end   The end index in the range
		 * @returns {void}         
		 */
		rangeCached? (start: number, end: number): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		removeObserver? (observer: object): void;
		/** 
		 * Sets the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} associatedEntity The new value.
		 * @returns {void}                            
		 */
		setAssociatedEntity? (associatedEntity: Ext.data.Model): void;
		/** 
		 * Sets the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @param   {boolean} autoSort The new value.
		 * @returns {void}             
		 */
		setAutoSort? (autoSort: boolean): void;
		/** 
		 * Make a set of records be current in the store. This means that unneeded records
		 * will be removed and new records will be added.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]} records The records to be current in the store.
		 * @returns {void}                     
		 */
		setRecords? (records: Ext.data.Model[]): void;
		/** 
		 * Sets the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.schema.Role} role The new value.
		 * @returns {void}                      
		 */
		setRole? (role: Ext.data.schema.Role): void;
		/** 
		 * This method is basically the same as the JavaScript Array splice method.
		 * 
		 * Negative indexes are interpreted starting at the end of the collection. That is,
		 * a value of -1 indicates the last item, or equivalent to `length - 1`.
		 * @method
		 * @private (method)
		 * @param   {number}          index    The index at which to add or remove items.
		 * @param   {number|object[]} toRemove
		 * The number of items to remove or an array of the
		 * items to remove.
		 * @param   {object[]}        [toAdd]  The items to insert at the given `index`.
		 * @returns {void}                     
		 */
		splice? (index: number, toRemove: number | object[], toAdd?: object[]): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                                names The names of the linked objects to destroy.
		 * @returns {Ext.data.DirectStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.DirectStore;
		unlink? (names: string[]): Ext.data.Store;
		unlink? (names: string[]): Ext.data.ProxyStore;
		unlink? (names: string[]): Ext.data.AbstractStore;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		update? (options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoLoad
		 * @returns {void}            
		 */
		updateAutoLoad? (autoLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoSort
		 * @returns {void}            
		 */
		updateAutoSort? (autoSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} field
		 * @returns {void}         
		 */
		updateGroupField? (field: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} oldProxy
		 * @returns {void}            
		 */
		updateProxy? (proxy: object, oldProxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @returns {void}                
		 */
		updateRemoteFilter? (remoteFilter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @returns {void}              
		 */
		updateRemoteSort? (remoteSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} track
		 * @returns {void}         
		 */
		updateTrackRemoved? (track: object): void;
	}
	/** 
	 * [Ext.data.Error](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Error.html)
	 * This class hols the results of a validator for an [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html). These objects are
	 * placed in an [`Ext.data.ErrorCollection`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html) and returned by [`Ext.data.Model.validate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate).
	 * 
	 * Usually this class does not need to be instantiated directly - instances are instead created
	 * automatically when [validate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate) on a model instance.
	 * @deprecated
	 */
	class Error extends Ext.Base {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.Error.Statics}
		 */
		self?: Ext.data.Error.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members    The members to add to this class.
		 * @param   {boolean}                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Error|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Error;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members
		 * @returns {Ext.data.Error|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.Error;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  name
		 * @param   {object}                  member
		 * @returns {Ext.data.Error|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.Error;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  fn
		 * @param   {object}                  scope
		 * @returns {Ext.data.Error|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.Error;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Error.html#cfg-field).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getField? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [message](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Error.html#cfg-message).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getMessage? (): string;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}           name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                  [value] The value to set for the name parameter.
		 * @returns {Ext.data.Error|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Error;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Error.html#cfg-field).
		 * @method
		 * @public (method)
		 * @param   {string} field The new value.
		 * @returns {void}         
		 */
		setField? (field: string): void;
		/** 
		 * Sets the value of [message](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Error.html#cfg-message).
		 * @method
		 * @public (method)
		 * @param   {string} message The new value.
		 * @returns {void}           
		 */
		setMessage? (message: string): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                  config
		 * @returns {Ext.data.Error|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.Error;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Error.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.Error.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                names The names of the linked objects to destroy.
		 * @returns {Ext.data.Error|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.Error;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * [Ext.data.ErrorCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html)
	 * Wraps a collection of validation error responses and provides convenient functions for
	 * accessing and errors for specific fields.
	 * 
	 * Usually this class does not need to be instantiated directly - instances are instead
	 * created automatically when [validate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate) on a model instance:
	 * 
	 *     // Validate some existing model instance - in this case it returned 2 failures
	 *     // messages
	 *    
	 *     var errors = myModel.validate();
	 *     errors.isValid(); //false
	 *    
	 *     errors.length; //2
	 *     errors.getByField('name');  // [{field: 'name',  message: 'must be present'}]
	 *     errors.getByField('title'); // [{field: 'title', message: 'is too short'}]
	 * 
	 */
	class ErrorCollection extends Ext.util.MixedCollection {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.ErrorCollection.Statics}
		 */
		self?: Ext.data.ErrorCollection.Statics | Ext.util.MixedCollection.Statics | Ext.util.AbstractMixedCollection.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      members    The members to add to this class.
		 * @param   {boolean}                                                                                     [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                     [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.ErrorCollection|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ErrorCollection;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.util.MixedCollection;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.util.AbstractMixedCollection;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      members
		 * @returns {Ext.data.ErrorCollection|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.ErrorCollection;
		static addStatics? (members: object): typeof Ext.util.MixedCollection;
		static addStatics? (members: object): typeof Ext.util.AbstractMixedCollection;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      name
		 * @param   {object}                                                                                      member
		 * @returns {Ext.data.ErrorCollection|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.ErrorCollection;
		static addMember? (name: object, member: object): typeof Ext.util.MixedCollection;
		static addMember? (name: object, member: object): typeof Ext.util.AbstractMixedCollection;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      fn
		 * @param   {object}                                                                                      scope
		 * @returns {Ext.data.ErrorCollection|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.ErrorCollection;
		static onExtended? (fn: object, scope: object): typeof Ext.util.MixedCollection;
		static onExtended? (fn: object, scope: object): typeof Ext.util.AbstractMixedCollection;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Adds all elements of an Array or an Object to the collection.
		 * @method
		 * @public (method)
		 * @param   {object|any[]} objs
		 * An Object containing properties which will be added
		 * to the collection, or an Array of values, each of which are added to the collection.
		 * Functions references will be added to the collection if [`allowFunctions`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.AbstractMixedCollection.html#cfg-allowFunctions)
		 * has been set to `true`.
		 * @returns {void}              
		 */
		addAll? (objs: object | any[]): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Removes all items from the collection.  Fires the [clear](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.AbstractMixedCollection.html#event-clear) event when complete.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clear? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Creates a shallow copy of this collection
		 * @method
		 * @public (method)
		 * @returns {Ext.util.MixedCollection}  
		 */
		clone? (): Ext.util.MixedCollection;
		/** 
		 * Collects unique values of a particular property in this MixedCollection
		 * @method
		 * @public (method)
		 * @param   {string}  property     The property to collect on
		 * @param   {string}  [root]
		 * 'root' property to extract the first argument from. This is used mainly when
		 * summing fields in records, where the fields are all stored inside the 'data' object
		 * @param   {boolean} [allowBlank] Pass true to allow null, undefined or empty string values
		 * @returns {any[]}                The unique values
		 */
		collect? (property: string, root?: string, allowBlank?: boolean): any[];
		/** 
		 * Returns true if the collection contains the passed Object as an item.
		 * @method
		 * @public (method)
		 * @param   {object}  o The Object to look for in the collection.
		 * @returns {boolean}   True if the collection contains the Object as an item.
		 */
		contains? (o: object): boolean;
		/** 
		 * Returns true if the collection contains the passed Object as a key.
		 * @method
		 * @public (method)
		 * @param   {string}  key The key to look for in the collection.
		 * @returns {boolean}     True if the collection contains the Object as a key.
		 */
		containsKey? (key: string): boolean;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Filters the objects in this collection by a set of [Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html)s, or by a single
		 * property/value pair with optional parameters for substring matching and case sensitivity. See
		 * [Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for an example of using Filter objects (preferred). Alternatively,
		 * MixedCollection can be easily filtered by property like this:
		 * 
		 *    //create a simple store with a few people defined
		 *    var people = new Ext.util.MixedCollection();
		 *    people.addAll([
		 *        {id: 1, age: 25, name: 'Ed'},
		 *        {id: 2, age: 24, name: 'Tommy'},
		 *        {id: 3, age: 24, name: 'Arne'},
		 *        {id: 4, age: 26, name: 'Aaron'}
		 *    ]);
		 *    
		 *    //a new MixedCollection containing only the items where age == 24
		 *    var middleAged = people.filter('age', 24);
		 * 
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Filter[]|string} property        A property on your objects, or an array of [Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) objects
		 * @param   {string|RegExp}            value
		 * Either string that the property values
		 * should start with or a RegExp to test against the property
		 * @param   {boolean}                  [anyMatch]      True to match any part of the string, not just the beginning
		 * @param   {boolean}                  [caseSensitive] True for case sensitive comparison.
		 * @returns {Ext.util.MixedCollection}                 The new filtered collection
		 */
		filter? (property: Ext.util.Filter[] | string, value: string | RegExp, anyMatch?: boolean, caseSensitive?: boolean): Ext.util.MixedCollection;
		/** 
		 * Returns the first item in the collection which elicits a true return value from the passed selection function.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		find? (): void;
		/** 
		 * Finds the index of the first matching object in this collection by a specific property/value.
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of a property on your objects.
		 * @param   {string|RegExp} value
		 * A string that the property values
		 * should start with or a RegExp to test against the property.
		 * @param   {number}        [start]         The index to start searching at.
		 * @param   {boolean}       [anyMatch]      True to match any part of the string, not just the beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison.
		 * @returns {number}                        The matched index or -1
		 */
		findIndex? (property: string, value: string | RegExp, start?: number, anyMatch?: boolean, caseSensitive?: boolean): number;
		/** 
		 * Calculates the insertion index of the new item based upon the comparison function passed, or the current sort order.
		 * @method
		 * @public (method)
		 * @param   {object}   newItem    The new object to find the insertion position of.
		 * @param   {Function} [sorterFn]
		 * The function to sort by. This is the same as the sorting function
		 * passed to [sortBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html#method-sortBy). It accepts 2 items from this MixedCollection, and returns -1 0, or 1
		 * depending on the relative sort positions of the 2 compared items.
		 * 
		 * If omitted, a function [generated](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html#method-generateComparator) from the currently defined set of
		 * [sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html#cfg-sorters) will be used.
		 * @returns {number}              The insertion point to add the new item into this MixedCollection at using [insert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html#method-insert)
		 */
		findInsertionIndex? (newItem: object, sorterFn?: ExtGlobalFunction): number;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the first item in the collection.
		 * @method
		 * @public (method)
		 * @returns {object}  the first item in the collection..
		 */
		first? (): object;
		/** 
		 * Returns a comparator function which compares two items and returns -1, 0, or 1 depending
		 * on the currently defined set of [sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sortable.html#cfg-sorters).
		 * 
		 * If there are no [sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sortable.html#cfg-sorters) defined, it returns a function which returns `0` meaning
		 * that no sorting will occur.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		generateComparator? (): void;
		/** 
		 * Returns the item associated with the passed key OR index.
		 * Key has priority over index.  This is the equivalent
		 * of calling [getByKey](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.AbstractMixedCollection.html#method-getByKey) first, then if nothing matched calling [getAt](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.AbstractMixedCollection.html#method-getAt).
		 * @method
		 * @public (method)
		 * @param   {string|number} key The key or index of the item.
		 * @returns {object}        
		 * If the item is found, returns the item.  If the item was not found, returns `undefined`.
		 * If an item was found, but is a Class, returns `null`.
		 */
		get? (key: string | number): object;
		/** 
		 * Returns the item at the specified index.
		 * @method
		 * @public (method)
		 * @param   {number} index The index of the item.
		 * @returns {object}       The item at the specified index.
		 */
		getAt? (index: number): object;
		/** 
		 * Returns all of the errors for the given field
		 * @method
		 * @public (method)
		 * @param   {string}   fieldName The field to get errors for
		 * @returns {object[]}           All errors for the given field
		 */
		getByField? (fieldName: string): object[];
		/** 
		 * Returns the item associated with the passed key.
		 * @method
		 * @public (method)
		 * @param   {string|number} key The key of the item.
		 * @returns {object}            The item associated with the passed key.
		 */
		getByKey? (key: string | number): object;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the number of items in the collection.
		 * @method
		 * @public (method)
		 * @returns {number}  the number of items in the collection.
		 */
		getCount? (): number;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * A function which will be called, passing a newly added object
		 * when the object is added without a separate id.  The function
		 * should yield the key by which that object will be indexed.
		 * 
		 * If no key is yielded, then the object will be added, but it
		 * cannot be accessed or removed quickly. Finding it in this
		 * collection for interrogation or removal will require a linear
		 * scan of this collection's items.
		 * 
		 * The default implementation simply returns `item.id` but you can
		 * provide your own implementation to return a different value as
		 * in the following examples:
		 * 
		 *    // normal way
		 *    var mc = new Ext.util.MixedCollection();
		 *    mc.add(someEl.dom.id, someEl);
		 *    mc.add(otherEl.dom.id, otherEl);
		 *    //and so on
		 *    
		 *    // using getKey
		 *    var mc = new Ext.util.MixedCollection({
		 *        getKey: function(el){
		 *            return el.dom.id;
		 *        }
		 *    });
		 *    mc.add(someEl);
		 *    mc.add(otherEl);
		 * 
		 * @method
		 * @public (method)
		 * @template
		 * @param   {object} item
		 * @returns {object}      The key for the passed item.
		 */
		getKey? (item: object): object;
		/** 
		 * Returns a range of items in this collection
		 * @method
		 * @public (method)
		 * @param   {number} [startIndex] The starting index. Defaults to 0.
		 * @param   {number} [endIndex]   The ending index. Defaults to the last item.
		 * @returns {any[]}               An array of items
		 */
		getRange? (startIndex?: number, endIndex?: number): any[];
		/** 
		 * Returns the value of [sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sortable.html#cfg-sorters).
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Sorter[]|object[]}  
		 */
		getSorters? (): Ext.util.Sorter[] | object[];
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Returns index within the collection of the passed Object.
		 * @method
		 * @public (method)
		 * @param   {object} o The item to find the index of.
		 * @returns {number}   index of the item. Returns -1 if not found.
		 */
		indexOf? (o: object): number;
		/** 
		 * Returns index within the collection of the passed key.
		 * @method
		 * @public (method)
		 * @param   {string} key The key to find the index of.
		 * @returns {number}     index of the key.
		 */
		indexOfKey? (key: string): number;
		/** 
		 * Inserts an item at the specified index in the collection. Fires the [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.AbstractMixedCollection.html#event-add) event when complete.
		 * @method
		 * @public (method)
		 * @param   {number}                          index The index to insert the item at.
		 * @param   {string|object|string[]|object[]} key
		 * The key to associate with the new item, or the item itself.
		 * May also be an array of either to insert multiple items at once.
		 * @param   {object|object[]}                 [o]
		 * If the second parameter was a key, the new item.
		 * May also be an array to insert multiple items at once.
		 * @returns {object}                                The item inserted or an array of items inserted.
		 */
		insert? (index: number, key: string | object | string[] | object[], o?: object | object[]): object;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Returns true if there are no errors in the collection
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		isValid? (): boolean;
		/** 
		 * Returns the last item in the collection.
		 * @method
		 * @public (method)
		 * @returns {object}  the last item in the collection..
		 */
		last? (): object;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Remove an item from the collection.
		 * @method
		 * @public (method)
		 * @param   {object} o The item to remove.
		 * @returns {object}   The item removed or false if no item was removed.
		 */
		remove? (o: object): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Remove all items in the collection. Can also be used
		 * to remove only the items in the passed array.
		 * @method
		 * @public (method)
		 * @param   {any[]}                    [items] An array of items to be removed.
		 * @returns {Ext.util.MixedCollection}         this object
		 */
		removeAll? (items?: any[]): Ext.util.MixedCollection;
		/** 
		 * Remove an item from a specified index in the collection. Fires the [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.AbstractMixedCollection.html#event-remove) event when complete.
		 * @method
		 * @public (method)
		 * @param   {number} index The index within the collection of the item to remove.
		 * @returns {object}       The item removed or false if no item was removed.
		 */
		removeAt? (index: number): object;
		/** 
		 * Removes an item associated with the passed key fom the collection.
		 * @method
		 * @public (method)
		 * @param   {string} key
		 * The key of the item to remove. If `null` is passed,
		 * all objects which yielded no key from the configured [getKey](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.AbstractMixedCollection.html#method-getKey) function are removed.
		 * @returns {object}     Only returned if removing at a specified key. The item removed or false if no item was removed.
		 */
		removeAtKey? (key: string): object;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Remove a range of items starting at a specified index in the collection.
		 * Does not fire the remove event.
		 * @method
		 * @public (method)
		 * @param   {number} index         The index within the collection of the item to remove.
		 * @param   {number} [removeCount] The nuber of items to remove beginning at the specified index.
		 * @returns {object}               The last item removed or false if no item was removed.
		 */
		removeRange? (index: number, removeCount?: number): object;
		/** 
		 * Reorders each of the items based on a mapping from old index to new index. Internally this
		 * just translates into a sort. The 'sort' event is fired whenever reordering has
		 * occurred.
		 * @method
		 * @public (method)
		 * @param   {object} mapping
		 * Mapping from old item index to new item index
		 * 
		 *    // example of moving the last of 4 items to the front of the collection
		 *    // and moving each one before it forward one
		 *    collection.reorder({
		 *        0: 1,
		 *        1: 2,
		 *        2: 3,
		 *        3: 0,
		 *    });
		 * 
		 * @returns {void}           
		 */
		reorder? (mapping: object): void;
		/** 
		 * Replaces an item in the collection. Fires the [replace](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.AbstractMixedCollection.html#event-replace) event when complete.
		 * @method
		 * @public (method)
		 * @param   {string} key
		 * The key associated with the item to replace, or the replacement item.
		 * 
		 * If you supplied a [getKey](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.AbstractMixedCollection.html#method-getKey) implementation for this MixedCollection, or if the key
		 * of your stored items is in a property called _`id`_, then the MixedCollection
		 * will be able to _derive_ the key of the replacement item. If you want to replace an item
		 * with one having the same key value, then just pass the replacement item in this parameter.
		 * @param   {object} o
		 * {Object} o (optional) If the first parameter passed was a key, the item to associate
		 * with that key.
		 * @returns {object}     The new item.
		 */
		replace? (key: string, o: object): object;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                                               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.ErrorCollection|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.ErrorCollection;
		setConfig? (name: string | object, value?: object): Ext.util.MixedCollection;
		setConfig? (name: string | object, value?: object): Ext.util.AbstractMixedCollection;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sortable.html#cfg-sorters).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Sorter[]|object[]} sorters The new value.
		 * @returns {void}                               
		 */
		setSorters? (sorters: Ext.util.Sorter[] | object[]): void;
		/** 
		 * Updates the sorters collection and triggers sorting of this Sortable. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([{
		 *        property : 'age',
		 *        direction: 'ASC'
		 *    }, {
		 *        property : 'name',
		 *        direction: 'DESC'
		 *    }]);
		 * 
		 * Classes which use this mixin must implement a **`soSort`** method which accepts a comparator function computed from
		 * the full sorter set which performs the sort in an implementation-specific way.
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]           Either a string name of one of the fields in this Store's configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction]         The overall direction to sort the data by.
		 * @param   {string}                   [insertionPosition]
		 * Where to put the new sorter in the collection of sorters.
		 * This may take the following values:
		 * 
		 * - `replace` : This means that the new sorter(s) becomes the sole sorter set for this Sortable. This is the most useful call mode
		 *   to programatically sort by multiple fields.
		 * - `prepend` : This means that the new sorters are inserted as the primary sorters, unchanged, and the sorter list length must be controlled by the developer.
		 * - `multi` :  This is mainly useful for implementing intuitive "Sort by this" user interfaces such as the GridPanel's column sorting UI.
		 *   This mode is only supported when passing a property name and a direction.
		 *   This means that the new sorter is becomes the primary sorter. If the sorter was **already** the primary sorter, the direction
		 *   of sort is toggled if no direction parameter is specified.
		 *   The number of sorters maintained is limited by the [multiSortLimit](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sortable.html#cfg-multiSortLimit) configuration.
		 * - `append` : This means that the new sorter becomes the last sorter.
		 * @returns {Ext.util.Sorter[]}                            The new sorters.
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string, insertionPosition?: string): Ext.util.Sorter[];
		/** 
		 * Sorts the collection by a single sorter function
		 * @method
		 * @public (method)
		 * @param   {Function} sorterFn The function to sort by
		 * @returns {void}              
		 */
		sortBy? (sorterFn: ExtGlobalFunction): void;
		/** 
		 * Sorts this collection by **key**s.
		 * @method
		 * @public (method)
		 * @param   {string}   [direction] 'ASC' or 'DESC'. Defaults to 'ASC'.
		 * @param   {Function} [fn]
		 * Comparison function that defines the sort order.
		 * Defaults to sorting by case insensitive string.
		 * @returns {void}                 
		 */
		sortByKey? (direction?: string, fn?: ExtGlobalFunction): void;
		/** 
		 * Collects all of the values of the given property and returns their sum
		 * @method
		 * @public (method)
		 * @param   {string} property The property to sum by
		 * @param   {string} [root]
		 * 'root' property to extract the first argument from. This is used mainly when
		 * summing fields in records, where the fields are all stored inside the 'data' object
		 * @param   {number} [start]  The record index to start at
		 * @param   {number} [end]    The record index to end at
		 * @returns {number}          The total
		 */
		sum? (property: string, root?: string, start?: number, end?: number): number;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Change the key for an existing item in the collection. If the old key
		 * does not exist this is a no-op.
		 * @method
		 * @public (method)
		 * @param   {object} oldKey The old key
		 * @param   {object} newKey The new key
		 * @returns {void}          
		 */
		updateKey? (oldKey: object, newKey: object): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Gets the first sorter from the sorters collection, excluding
		 * any groupers that may be in place
		 * @method
		 * @protected (method)
		 * @returns {Ext.util.Sorter}  The sorter, null if none exist
		 */
		getFirstSorter? (): Ext.util.Sorter;
		/** 
		 * Returns the number of Sorters which apply to this Sortable.
		 * 
		 * May be overridden in subclasses. [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) in particlar overrides
		 * this because its groupers must contribute to the sorter count so that the sort method above executes doSort.
		 * @method
		 * @protected (method)
		 * @returns {void}  
		 */
		getSorterCount? (): void;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                                      config
		 * @returns {Ext.data.ErrorCollection|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.ErrorCollection;
		initConfig? (config: object): Ext.util.MixedCollection;
		initConfig? (config: object): Ext.util.AbstractMixedCollection;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.ErrorCollection.Statics|Ext.util.MixedCollection.Statics|Ext.util.AbstractMixedCollection.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.ErrorCollection.Statics;
		statics? (): Ext.util.MixedCollection.Statics;
		statics? (): Ext.util.AbstractMixedCollection.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * Performs the actual sorting based on a direction and a sorting function. Internally,
		 * this creates a temporary array of all items in the MixedCollection, sorts it and then writes
		 * the sorted array data back into this.items and this.keys
		 * @method
		 * @private (method)
		 * @param   {string}   property Property to sort by ('key', 'value', or 'index')
		 * @param   {string}   [dir]    Direction to sort 'ASC' or 'DESC'. Defaults to 'ASC'.
		 * @param   {Function} [fn]
		 * Comparison function that defines the sort order.
		 * Defaults to sorting by numeric value.
		 * @returns {void}              
		 */
		_sort? (property: string, dir?: string, fn?: ExtGlobalFunction): void;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @mixed
		 * @private (method+property)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 * @type {object}
		 */
		captureArgs?: ((o: object, fn: object, scope: object) => void) | object | any;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Returns a regular expression based on the given value and matching options. This is used internally for finding and filtering,
		 * and by [Ext.data.Store.filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter)
		 * @method
		 * @private (method)
		 * @param   {string}  value         The value to create the regex for. This is escaped using Ext.escapeRe
		 * @param   {boolean} anyMatch      True to allow any match - no regex start/end line anchors will be added. Defaults to false
		 * @param   {boolean} caseSensitive True to make the regex case sensitive (adds 'i' switch to regex). Defaults to false.
		 * @param   {boolean} exactMatch    True to force exact match (^ and $ characters added to the regex). Defaults to false. Ignored if anyMatch is true.
		 * @returns {void}                  
		 */
		createValueMatcher? (value: string, anyMatch: boolean, caseSensitive: boolean, exactMatch: boolean): void;
		/** 
		 * Normalizes an array of sorter objects, ensuring that they are all [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances
		 * @method
		 * @private (method)
		 * @param   {object[]}          sorters The sorters array
		 * @returns {Ext.util.Sorter[]}         Array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) objects
		 */
		decodeSorters? (sorters: object[]): Ext.util.Sorter[];
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * Private multi insert implementation.
		 * @method
		 * @private (method)
		 * @param   {object} index
		 * @param   {object} keys
		 * @param   {object} objects
		 * @returns {void}           
		 */
		doInsert? (index: object, keys: object, objects: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorterFn
		 * @returns {void}            
		 */
		doSort? (sorterFn: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		emptyComparator? (): void;
		/** 
		 * Extracts all of the given property values from the items in the MC. Mainly used as a supporting method for
		 * functions like sum and collect.
		 * @method
		 * @private (method)
		 * @param   {string} property The property to extract
		 * @param   {string} [root]
		 * 'root' property to extract the first argument from. This is used mainly when
		 * extracting field data from Model instances, where the fields are stored inside the 'data' object
		 * @returns {any[]}           The extracted values
		 */
		extractValues? (property: string, root?: string): any[];
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * For API parity with Store's PageMap class. Buffered rendering checks if the Store has the range
		 * required to render. The Store delegates this question to its backing data object which may be an instance
		 * of its private PageMap class, or a MixedCollection.
		 * @method
		 * @private (method)
		 * @param   {object} start
		 * @param   {object} end
		 * @returns {void}         
		 */
		hasRange? (start: object, end: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onBeforeSort? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		rebuildIndexMap? (): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                                    names The names of the linked objects to destroy.
		 * @returns {Ext.data.ErrorCollection|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.ErrorCollection;
		unlink? (names: string[]): Ext.util.MixedCollection;
		unlink? (names: string[]): Ext.util.AbstractMixedCollection;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html)
	 * A chained store is a store that is a "view" of an existing store. The data comes from the
	 * [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source), however this view of the store may be sorted &amp; filtered independently without
	 * having any impact on the [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source) store.
	 */
	class ChainedStore extends Ext.data.AbstractStore {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.ChainedStore.Statics}
		 */
		self?: Ext.data.ChainedStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                members    The members to add to this class.
		 * @param   {boolean}                                               [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                               [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.ChainedStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ChainedStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                members
		 * @returns {Ext.data.ChainedStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.ChainedStore;
		static addStatics? (members: object): typeof Ext.data.AbstractStore;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                name
		 * @param   {object}                                                member
		 * @returns {Ext.data.ChainedStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.ChainedStore;
		static addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                fn
		 * @param   {object}                                                scope
		 * @returns {Ext.data.ChainedStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.ChainedStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * documented above
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                The model instances that were added
		 */
		add? (model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {...Ext.data.Model|...object} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                  The model instances that were added
		 */
		add? (...model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * Adds a new Filter to this Store's [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {object[]|Ext.util.Filter[]} filters         The set of filters to add to the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters).
		 * @param   {boolean}                    [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                       
		 */
		addFilter? (filters: object[] | Ext.util.Filter[], suppressEvent?: boolean): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Runs the aggregate function for all the records in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {Function} fn
		 * The function to execute. The function is called with a single parameter,
		 * an array of records for that group.
		 * @param   {object}   scope   The scope to execute the function in. Defaults to the store.
		 * @param   {boolean}  grouped
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @param   {string}   field   The field to get the value from
		 * @returns {object}           An object literal with the group names and their appropriate values.
		 */
		aggregate? (fn: ExtGlobalFunction, scope: object, grouped: boolean, field: string): object;
		/** 
		 * Gets the average value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The average value, if no items exist, 0.
		 */
		average? (field: string, grouped?: boolean): object;
		/** 
		 * This method may be called to indicate the start of multiple changes to the store.
		 * 
		 * Automatic synchronization as configured by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred
		 * until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple mutations can be coalesced
		 * into one synchronization operation.
		 * 
		 * Internally this method increments a counter that is decremented by `endUpdate`. It
		 * is important, therefore, that if you call `beginUpdate` directly you match that
		 * call with a call to `endUpdate` or you will prevent the collection from updating
		 * properly.
		 * 
		 * For example:
		 * 
		 *     var store = Ext.StoreManager.lookup({
		 *         //...
		 *         autoSync: true
		 *     });
		 *    
		 *     store.beginUpdate();
		 *    
		 *     record.set('fieldName', 'newValue');
		 *    
		 *     store.add(item);
		 *     // ...
		 *    
		 *     store.insert(index, otherItem);
		 *     //...
		 *    
		 *     // Interested parties will listen for the endupdate event
		 *     store.endUpdate();
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginUpdate? (): void;
		/** 
		 * Reverts to a view of the Record cache with no filtering applied.
		 * @method
		 * @public (method)
		 * @param   {boolean} [suppressEvent]
		 * If `true` the filter is cleared silently.
		 * 
		 * For a locally filtered Store, this means that the filter collection is cleared without firing the
		 * [datachanged](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-datachanged) event.
		 * 
		 * For a remotely filtered Store, this means that the filter collection is cleared, but the store
		 * is not reloaded from the server.
		 * @returns {void}                    
		 */
		clearFilter? (suppressEvent?: boolean): void;
		/** 
		 * Clear the store grouping
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearGrouping? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Collects unique values for a particular dataIndex from this store.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * 
		 *    var store = Ext.create('Ext.data.Store', {
		 *        fields: ['name'],
		 *        data: [{
		 *            name: 'Larry'
		 *        }, {
		 *            name: 'Darryl'
		 *        }, {
		 *            name: 'Darryl'
		 *        }]
		 *    });
		 *    
		 *    store.collect('name');
		 *    // returns ["Larry", "Darryl"]
		 * 
		 * @method
		 * @public (method)
		 * @param   {string}                                                           property         The property to collect
		 * @param   {object|Ext.data.ChainedStore.methodParams.collect.IncludeOptions} [includeOptions] An object which contains options which modify how the store is traversed.
		 * @returns {object[]}                                                                          An array of the unique values
		 */
		collect? (property: string, includeOptions?: object | Ext.data.ChainedStore.methodParams.collect.IncludeOptions): object[];
		/** 
		 * Gets the count of items in the store.
		 * 
		 * When store is filtered, only items within the filter are counted.
		 * @method
		 * @public (method)
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the count for each group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            the count
		 */
		count? (grouped?: boolean): number;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Perform the Store destroying sequence. Override this method to add destruction
		 * behaviors to your custom Stores.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		doDestroy? (): void;
		/** 
		 * Calls the specified function for each [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in the store.
		 * 
		 * When store is filtered, only loops over the filtered records.
		 * @method
		 * @public (method)
		 * @param   {Function}                                                      fn
		 * The function to call. The [Record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) is passed as the first parameter.
		 * Returning `false` aborts and exits the iteration.
		 * @param   {object}                                                        [scope]
		 * The scope (`this` reference) in which the function is executed.
		 * Defaults to the current [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in the iteration.
		 * @param   {object|Ext.data.ChainedStore.methodParams.each.IncludeOptions} [includeOptions] An object which contains options which modify how the store is traversed.
		 * @returns {void}                                                                           
		 */
		each? (fn: ExtGlobalFunction, scope?: object, includeOptions?: object | Ext.data.ChainedStore.methodParams.each.IncludeOptions): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * This method is called after modifications are complete on a store. For details
		 * see [`beginUpdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		endUpdate? (): void;
		/** 
		 * Filters the data in the Store by one or more fields. Example usage:
		 * 
		 *    //filter with a single field
		 *    myStore.filter('firstName', 'Don');
		 *    
		 *    //filtering with multiple filters
		 *    myStore.filter([
		 *        {
		 *            property : 'firstName',
		 *            value    : 'Don'
		 *        },
		 *        {
		 *            property : 'lastName',
		 *            value    : 'Griffin'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) instances, and delegates
		 * the actual filtering to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter[]} [filters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of filter configurations.
		 * @param   {string}                   [value]   The property value by which to filter. Only applicable if `filters` is a string.
		 * @returns {void}                               
		 */
		filter? (filters?: string | Ext.util.Filter[], value?: string): void;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of the Record field to test.
		 * @param   {string|RegExp} value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}        [startIndex]    The index to start searching at
		 * @param   {boolean}       [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}       [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {number}                        The matched index or -1
		 */
		find? (property: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string} fieldName    The name of the Record field to test.
		 * @param   {object} value        The value to match the field against.
		 * @param   {number} [startIndex] The index to start searching at
		 * @returns {number}              The matched index or -1
		 */
		findExact? (fieldName: string, value: object, startIndex?: number): number;
		/** 
		 * Finds the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}         fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}  value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}         [startIndex]    The index to start searching at
		 * @param   {boolean}        [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}        [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}        [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.Model}                 The matched record or null
		 */
		findRecord? (fieldName: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Convenience function for getting the first model instance in the store.
		 * 
		 * When store is filtered, will return first item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the first record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The first model instance in the store, or undefined
		 */
		first? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Get the Record at the specified index.
		 * 
		 * The index is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}         index The index of the Record to find.
		 * @returns {Ext.data.Model}       The Record at the passed index. Returns null if not found.
		 */
		getAt? (index: number): Ext.data.Model;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Get the Record with the specified id.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            id The id of the Record to find.
		 * @returns {Ext.data.Model}    The Record with the passed id. Returns null if not found.
		 */
		getById? (id: any): Ext.data.Model;
		/** 
		 * Get the Record with the specified internalId.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            internalId The id of the Record to find.
		 * @returns {Ext.data.Model}            The Record with the passed internalId. Returns null if not found.
		 */
		getByInternalId? (internalId: any): Ext.data.Model;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Gets the number of records in store.
		 * 
		 * If using paging, this may not be the total size of the dataset. If the data object
		 * used by the Reader contains the dataset size, then the [Ext.data.ProxyStore.getTotalCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getTotalCount) function returns
		 * the dataset size.  **Note**: see the Important note in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load).
		 * 
		 * When store is filtered, it's the number of records matching the filter.
		 * @method
		 * @public (method)
		 * @returns {number}  The number of Records in the Store.
		 */
		getCount? (): number;
		/** 
		 * Returns the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraKeys? (): object;
		/** 
		 * Gets the filters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.FilterCollection}            The filters
		 */
		getFilters? (autoCreate: object): Ext.util.FilterCollection;
		/** 
		 * Returns the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDir? (): string;
		/** 
		 * Returns the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @returns {object|Ext.util.Grouper}  
		 */
		getGrouper? (): object | Ext.util.Grouper;
		/** 
		 * Returns a collection of readonly sub-collections of your store's records
		 * with grouping applied. These sub-collections are maintained internally by
		 * the collection.
		 * 
		 * See [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField), [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir). Example for a store
		 * containing records with a color field:
		 * 
		 *    var myStore = Ext.create('Ext.data.Store', {
		 *        groupField: 'color',
		 *        groupDir  : 'DESC'
		 *    });
		 *    
		 *    myStore.getGroups();
		 * 
		 * The above should result in the following format:
		 * 
		 *    [
		 *        {
		 *            name: 'yellow',
		 *            children: [
		 *                // all records where the color field is 'yellow'
		 *            ]
		 *        },
		 *        {
		 *            name: 'red',
		 *            children: [
		 *                // all records where the color field is 'red'
		 *            ]
		 *        }
		 *    ]
		 * 
		 * Group contents are affected by filtering.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection}  The grouped data
		 */
		getGroups? (): Ext.util.Collection;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Get the model used for this store.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model}  The model
		 */
		getModel? (): Ext.data.Model;
		/** 
		 * Returns the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getPageSize? (): number;
		/** 
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}           start The starting index. Defaults to zero.
		 * @param   {number}           end   The ending index. Defaults to the last record. The end index **is included**.
		 * @returns {Ext.data.Model[]}       An array of records.
		 */
		getRange? (start: number, end: number): Ext.data.Model[];
		/** 
		 * Returns the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteFilter? (): boolean;
		/** 
		 * Returns the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteSort? (): boolean;
		/** 
		 * Gets the sorters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.SorterCollection}            The sorters
		 */
		getSorters? (autoCreate: object): Ext.util.SorterCollection;
		/** 
		 * Returns the value of [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Store|string}  
		 */
		getSource? (): Ext.data.Store | string;
		/** 
		 * Returns the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getStatefulFilters? (): boolean;
		/** 
		 * Returns the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStoreId? (): string;
		/** 
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {string|object} grouper
		 * Either a string name of one of the fields in this Store's
		 * configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an object, or a [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Grouper.html) configuration object.
		 * @param   {string}        [direction] The overall direction to group the data by. Defaults to the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @returns {void}                      
		 */
		group? (grouper: string | object, direction?: string): void;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Get the index of the record within the store.
		 * 
		 * When store is filtered, records outside of filter will not be found.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) object to find.
		 * @returns {number}                The index of the passed Record. Returns -1 if not found.
		 */
		indexOf? (record: Ext.data.Model): number;
		/** 
		 * Get the index within the store of the Record with the passed id.
		 * 
		 * Like [indexOf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#method-indexOf), this method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {string} id The id of the Record to find.
		 * @returns {number}    The index of the Record. Returns -1 if not found.
		 */
		indexOfId? (id: string): number;
		/** 
		 * Inserts Model instances into the Store at the given index and fires the add event.
		 * See also [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#method-add).
		 * @method
		 * @public (method)
		 * @param   {number}                                          index   The start index at which to insert the passed Records.
		 * @param   {Ext.data.Model|Ext.data.Model[]|object|object[]} records
		 * An [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instance, the
		 * data needed to populate an instance or an array of either of these.
		 * @returns {Ext.data.Model[]}                                        records The added records
		 */
		insert? (index: number, records: Ext.data.Model | Ext.data.Model[] | object | object[]): Ext.data.Model[];
		/** 
		 * Tests whether the store currently has any active filters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is filtered.
		 */
		isFiltered? (): boolean;
		/** 
		 * Tests whether the store currently has an active grouper.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is grouped.
		 */
		isGrouped? (): boolean;
		/** 
		 * Returns `true` if the Store has been loaded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store has been loaded.
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns `true` if the Store is currently performing a load operation.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store is currently loading.
		 */
		isLoading? (): boolean;
		/** 
		 * Tests whether the store currently has any active sorters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is sorted.
		 */
		isSorted? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Convenience function for getting the last model instance in the store.
		 * 
		 * When store is filtered, will return last item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the last record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The last model instance in the store, or undefined
		 */
		last? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Gets the maximum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the maximum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The maximum value, if no items exist, undefined.
		 */
		max? (field: string, grouped?: boolean): object;
		/** 
		 * Gets the minimum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the minimum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The minimum value, if no items exist, undefined.
		 */
		min? (field: string, grouped?: boolean): object;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Query all the cached records in this Store by name/value pair.
		 * The parameters will be used to generated a filter function that is given
		 * to the queryBy method.
		 * 
		 * This method complements queryBy by generating the query function automatically.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @public (method)
		 * @param   {string}              property        The property to create the filter function for
		 * @param   {string|RegExp}       value           The string/regex to compare the property value to
		 * @param   {boolean}             [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}             [caseSensitive] `true` to create a case-sensitive regex.
		 * @param   {boolean}             [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.util.Collection}                 The matched records
		 */
		query? (property: string, value: string | RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.util.Collection;
		/** 
		 * Query all the cached records in this Store using a filtering function. The specified function
		 * will be called with each record in this Store. If the function returns `true` the record is
		 * included in the results.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @public (method)
		 * @param   {Function}            fn          The function to be called. It will be passed the following parameters:
		 * @param   {Ext.data.Model}      [fn.record]
		 * The record to test for filtering. Access field values
		 *  using [Ext.data.Model.get](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-get).
		 * @param   {object}              [fn.id]     The ID of the Record passed.
		 * @param   {void}                fn.returns
		 * @param   {object}              [scope]
		 * The scope (this reference) in which the function is executed
		 * Defaults to this Store.
		 * @returns {Ext.util.Collection}             The matched records
		 */
		queryBy? (fn: ((record?: Ext.data.Model, id?: object) => void) | ExtGlobalFunction, scope?: object): Ext.util.Collection;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an individual Filter from the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) using the passed Filter/Filter id and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter} toRemove        The id of a Filter to remove from the filter set, or a Filter instance to remove.
		 * @param   {boolean}                [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                   
		 */
		removeFilter? (toRemove: string | Ext.util.Filter, suppressEvent?: boolean): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                         name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                [value] The value to set for the name parameter.
		 * @returns {Ext.data.ChainedStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.ChainedStore;
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @param   {object} extraKeys The new value.
		 * @returns {void}             
		 */
		setExtraKeys? (extraKeys: object): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setFilters? (): void;
		/** 
		 * Sets the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @param   {string} groupDir The new value.
		 * @returns {void}            
		 */
		setGroupDir? (groupDir: string): void;
		/** 
		 * Sets the value of [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField).
		 * @method
		 * @public (method)
		 * @param   {string} groupField The new value.
		 * @returns {void}              
		 */
		setGroupField? (groupField: string): void;
		/** 
		 * Sets the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.util.Grouper} grouper The new value.
		 * @returns {void}                            
		 */
		setGrouper? (grouper: object | Ext.util.Grouper): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @param   {number} pageSize The new value.
		 * @returns {void}            
		 */
		setPageSize? (pageSize: number): void;
		/** 
		 * Sets the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteFilter The new value.
		 * @returns {void}                 
		 */
		setRemoteFilter? (remoteFilter: boolean): void;
		/** 
		 * Sets the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteSort The new value.
		 * @returns {void}               
		 */
		setRemoteSort? (remoteSort: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setSorters? (): void;
		/** 
		 * Sets the value of [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Store|string} source The new value.
		 * @returns {void}                         
		 */
		setSource? (source: Ext.data.Store | string): void;
		/** 
		 * Sets the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @param   {boolean} statefulFilters The new value.
		 * @returns {void}                    
		 */
		setStatefulFilters? (statefulFilters: boolean): void;
		/** 
		 * Sets the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @param   {string} storeId The new value.
		 * @returns {void}           
		 */
		setStoreId? (storeId: string): void;
		/** 
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction] The overall direction to sort the data by.
		 * @returns {Ext.util.Sorter[]}                    
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string): Ext.util.Sorter[];
		/** 
		 * Sums the value of `field` for each [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in store
		 * and returns the result.
		 * 
		 * When store is filtered, only sums items within the filter.
		 * @method
		 * @public (method)
		 * @param   {string}  field     A field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the sum for that group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            The sum
		 */
		sum? (field: string, grouped?: boolean): number;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Inherit docs
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		contains? (record: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.contains](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-contains).
		 * Checks if a record is in the current active data set.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record
		 * @returns {void|boolean}          `true` if the record is in the current active data set.
		 */
		contains? (record: Ext.data.Model): boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                config
		 * @returns {Ext.data.ChainedStore|Ext.data.AbstractStore|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.ChainedStore;
		initConfig? (config: object): Ext.data.AbstractStore;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.ChainedStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.ChainedStore.Statics;
		statics? (): Ext.data.AbstractStore.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorter
		 * @returns {void}          
		 */
		addFieldTransform? (sorter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @param   {object} filtersCollection
		 * @returns {void}                     
		 */
		applyFilters? (filters: object, filtersCollection: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} grouper
		 * @returns {void}           
		 */
		applyGrouper? (grouper: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorters
		 * @param   {object} sortersCollection
		 * @returns {void}                     
		 */
		applySorters? (sorters: object, sortersCollection: object): void;
		/** 
		 * Restores state to the passed state
		 * @method
		 * @private (method)
		 * @param   {object} state
		 * @returns {void}         
		 */
		applyState? (state: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		fireGroupChange? (): void;
		/** 
		 * Returns the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getAutoSort? (): boolean;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getGroupField? (): void;
		/** 
		 * Returns the grouping, sorting and filtered state of this Store.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getState? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Returns true if the store has a pending load task.
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the store has a pending load task.
		 */
		hasPendingLoad? (): boolean;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * This is attached to the data Collection's beforesort event only if not remoteSort
		 * If remoteSort, the event is fired before the reload call in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-load).
		 * @method
		 * @private (method)
		 * @param   {object} store
		 * @param   {object} sorters
		 * @returns {void}           
		 */
		onBeforeCollectionSort? (store: object, sorters: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onFilterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onSorterEndUpdate? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Determines if the passed range is available in the page cache.
		 * @method
		 * @private (method)
		 * @param   {number} start The start index
		 * @param   {number} end   The end index in the range
		 * @returns {void}         
		 */
		rangeCached? (start: number, end: number): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Sets the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @param   {boolean} autoSort The new value.
		 * @returns {void}             
		 */
		setAutoSort? (autoSort: boolean): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                              names The names of the linked objects to destroy.
		 * @returns {Ext.data.ChainedStore|Ext.data.AbstractStore|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.ChainedStore;
		unlink? (names: string[]): Ext.data.AbstractStore;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoSort
		 * @returns {void}            
		 */
		updateAutoSort? (autoSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} field
		 * @returns {void}         
		 */
		updateGroupField? (field: object): void;
		/** 
		 * <debug></debug>
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @param   {object} oldRemoteFilter
		 * @returns {void}                   
		 */
		updateRemoteFilter? (remoteFilter: object, oldRemoteFilter: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.updateRemoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-updateRemoteFilter).
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @returns {void}                
		 */
		updateRemoteFilter? (remoteFilter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @param   {object} oldRemoteSort
		 * @returns {void}                 
		 */
		updateRemoteSort? (remoteSort: object, oldRemoteSort: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.updateRemoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-updateRemoteSort).
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @returns {void}              
		 */
		updateRemoteSort? (remoteSort: object): void;
	}
	/** 
	 * [Ext.data.JsonP](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html)
	 * This class is used to create JSONP requests. JSONP is a mechanism that allows for making
	 * requests for data cross domain. JSONP is basically a `&lt;script&gt;` node with the source of the url executing
	 * a function that was created by [Ext.data.JsonP](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html). Once the resource has loaded, the `&lt;script&gt;` node will be destroyed.
	 * 
	 * If you have a request such as:
	 * 
	 *    Ext.data.JsonP.request({
	 *        url : 'foo.php'
	 *    });
	 * 
	 * [Ext.data.JsonP](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html) will create a `&lt;script&gt;` node in the `&lt;head&gt;` with the `src` attribute pointing to
	 * `foo.php?callback=Ext.data.JsonP.callback1`. The `foo.php` script will have to detect the `callback` URL parameter
	 * and return valid JavaScript:
	 * 
	 *    Ext.data.JsonP.callback1({"foo":"bar"});
	 * 
	 * A simple PHP example would look like:
	 * 
	 *    &lt;?php
	 *    
	 *    $data = array('foo' =&gt; 'bar');
	 *    
	 *    if (!empty($_REQUEST['callback'])) {
	 *        header('Content-Type: application/javascript');
	 *        echo $_REQUEST['callback'] . '(';
	 *    }
	 *    
	 *    echo json_encode($data);
	 *    
	 *    if (!empty($_REQUEST['callback']) {
	 *        echo ');';
	 *    }
	 *    
	 *    ?&gt;
	 * 
	 * More information is available [here](http://en.wikipedia.org/wiki/JSONP). You can also use [JSONPLint](http://www.jsonplint.com) to test your JSONP.
	 * @singleton (definition)
	 */
	interface JsonP extends Ext.Base {
		/** 
		 * Specifies the GET parameter that will be sent to the server containing the function name to be executed when
		 * the request completes. Defaults to <tt>callback</tt>. Thus, a common request will be in the form of
		 * url?callback=Ext.data.JsonP.callback1
		 * @property
		 * @public (property)
		 * @default 'callback'
		 * @type {string}
		 */
		callbackKey?: string;
		/** 
		 * True to add a unique cache-buster param to requests. Defaults to <tt>true</tt>.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		disableCaching?: boolean;
		/** 
		 * Change the parameter which is sent went disabling caching through a cache buster. Defaults to <tt>'_dc'</tt>.
		 * @property
		 * @public (property)
		 * @default '_dc'
		 * @type {string}
		 */
		disableCachingParam?: string;
		/** 
		 * A default timeout for any JsonP requests. If the request has not completed in this time the
		 * failure callback will be fired. The timeout is in ms. Defaults to <tt>30000</tt>.
		 * @property
		 * @public (property)
		 * @default 30000
		 * @type {number}
		 */
		timeout?: number;
		/** 
		 * Abort a request. If the request parameter is not specified all open requests will
		 * be aborted.
		 * @method
		 * @public (method)
		 * @param   {object|string} [request] The request to abort
		 * @returns {void}                    
		 */
		abort? (request?: object | string): void;
		/** 
		 * Makes a JSONP request.
		 * @method
		 * @public (method)
		 * @param   {object} options
		 * An object which may contain the following properties. Note that options will
		 * take priority over any defaults that are specified in the class.
		 * 
		 * - **url** : String <div class="sub-desc">The URL to request.</div>
		 * - **params** : Object (Optional)<div class="sub-desc">An object containing a series of
		 *   key value pairs that will be sent along with the request.</div>
		 * - **timeout** : Number (Optional) <div class="sub-desc">See [timeout](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html#property-timeout)</div>
		 * - **callbackKey** : String (Optional) <div class="sub-desc">See [callbackKey](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html#property-callbackKey)</div>
		 * - **callbackName** : String (Optional) <div class="sub-desc">The function name to use for this request.
		 *   By default this name will be auto-generated: Ext.data.JsonP.callback1, Ext.data.JsonP.callback2, etc.
		 *   Setting this option to "my_name" will force the function name to be Ext.data.JsonP.my_name.
		 *   Use this if you want deterministic behavior, but be careful - the callbackName should be different
		 *   in each JsonP request that you make.</div>
		 * - **disableCaching** : Boolean (Optional) <div class="sub-desc">See [disableCaching](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html#property-disableCaching)</div>
		 * - **disableCachingParam** : String (Optional) <div class="sub-desc">See [disableCachingParam](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html#property-disableCachingParam)</div>
		 * - **success** : Function (Optional) <div class="sub-desc">A function to execute if the request succeeds.</div>
		 * - **failure** : Function (Optional) <div class="sub-desc">A function to execute if the request fails.</div>
		 * - **callback** : Function (Optional) <div class="sub-desc">A function to execute when the request
		 *   completes, whether it is a success or failure.</div>
		 * - **scope** : Object (Optional)<div class="sub-desc">The scope in
		 *   which to execute the callbacks: The "this" object for the callback function. Defaults to the browser window.</div>
		 * @returns {object}         request An object containing the request details.
		 */
		request? (options: object): object;
	}
	/** 
	 * [Ext.data.JsonPStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from different domain JSON data easier.
	 * A JsonPStore will be automatically configured with a [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) and a [JsonPProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.JsonP.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.JsonPStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *    
	 *        // proxy configs
	 *        url: 'get-images.php',
	 *    
	 *        // reader configs
	 *        root: 'images',
	 *        fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    stcCallback({
	 *        images: [
	 *            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
	 *            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
	 *        ]
	 *    })
	 * 
	 * Where stcCallback is the callback name passed in the request to the remote domain. See [JsonPProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.JsonP.html)
	 * for details of how this works.
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#cfg-data) config option.
	 */
	class JsonPStore extends Ext.data.Store {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.JsonPStore.Statics}
		 */
		self?: Ext.data.JsonPStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 members    The members to add to this class.
		 * @param   {boolean}                                                                                [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.JsonPStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.JsonPStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 members
		 * @returns {Ext.data.JsonPStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.JsonPStore;
		static addStatics? (members: object): typeof Ext.data.Store;
		static addStatics? (members: object): typeof Ext.data.ProxyStore;
		static addStatics? (members: object): typeof Ext.data.AbstractStore;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 name
		 * @param   {object}                                                                                 member
		 * @returns {Ext.data.JsonPStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.JsonPStore;
		static addMember? (name: object, member: object): typeof Ext.data.Store;
		static addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		static addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 fn
		 * @param   {object}                                                                                 scope
		 * @returns {Ext.data.JsonPStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.JsonPStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		static onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                The model instances that were added
		 */
		add? (model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {...Ext.data.Model|...object} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                  The model instances that were added
		 */
		add? (...model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * Adds a new Filter to this Store's [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {object[]|Ext.util.Filter[]} filters         The set of filters to add to the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters).
		 * @param   {boolean}                    [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                       
		 */
		addFilter? (filters: object[] | Ext.util.Filter[], suppressEvent?: boolean): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * (Local sort only) Inserts the passed Record into the Store at the index where it
		 * should go based on the current sort information.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Record} record
		 * @returns {void}                   
		 */
		addSorted? (record: Ext.data.Record): void;
		/** 
		 * Runs the aggregate function for all the records in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {Function} fn
		 * The function to execute. The function is called with a single parameter,
		 * an array of records for that group.
		 * @param   {object}   scope   The scope to execute the function in. Defaults to the store.
		 * @param   {boolean}  grouped
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @param   {string}   field   The field to get the value from
		 * @returns {object}           An object literal with the group names and their appropriate values.
		 */
		aggregate? (fn: ExtGlobalFunction, scope: object, grouped: boolean, field: string): object;
		/** 
		 * Gets the average value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The average value, if no items exist, 0.
		 */
		average? (field: string, grouped?: boolean): object;
		/** 
		 * This method may be called to indicate the start of multiple changes to the store.
		 * 
		 * Automatic synchronization as configured by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred
		 * until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple mutations can be coalesced
		 * into one synchronization operation.
		 * 
		 * Internally this method increments a counter that is decremented by `endUpdate`. It
		 * is important, therefore, that if you call `beginUpdate` directly you match that
		 * call with a call to `endUpdate` or you will prevent the collection from updating
		 * properly.
		 * 
		 * For example:
		 * 
		 *     var store = Ext.StoreManager.lookup({
		 *         //...
		 *         autoSync: true
		 *     });
		 *    
		 *     store.beginUpdate();
		 *    
		 *     record.set('fieldName', 'newValue');
		 *    
		 *     store.add(item);
		 *     // ...
		 *    
		 *     store.insert(index, otherItem);
		 *     //...
		 *    
		 *     // Interested parties will listen for the endupdate event
		 *     store.endUpdate();
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginUpdate? (): void;
		/** 
		 * Reverts to a view of the Record cache with no filtering applied.
		 * @method
		 * @public (method)
		 * @param   {boolean} [suppressEvent]
		 * If `true` the filter is cleared silently.
		 * 
		 * For a locally filtered Store, this means that the filter collection is cleared without firing the
		 * [datachanged](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-datachanged) event.
		 * 
		 * For a remotely filtered Store, this means that the filter collection is cleared, but the store
		 * is not reloaded from the server.
		 * @returns {void}                    
		 */
		clearFilter? (suppressEvent?: boolean): void;
		/** 
		 * Clear the store grouping
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearGrouping? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Commits all Records with [outstanding changes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords). To handle updates for changes,
		 * subscribe to the Store's [update event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-update), and perform updating when the third parameter is
		 * [Ext.data.Record.COMMIT](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#static-property-COMMIT).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		commitChanges? (): void;
		/** 
		 * Gets the count of items in the store.
		 * 
		 * When store is filtered, only items within the filter are counted.
		 * @method
		 * @public (method)
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the count for each group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            the count
		 */
		count? (grouped?: boolean): number;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * This method is called after modifications are complete on a store. For details
		 * see [`beginUpdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		endUpdate? (): void;
		/** 
		 * Filters the data in the Store by one or more fields. Example usage:
		 * 
		 *    //filter with a single field
		 *    myStore.filter('firstName', 'Don');
		 *    
		 *    //filtering with multiple filters
		 *    myStore.filter([
		 *        {
		 *            property : 'firstName',
		 *            value    : 'Don'
		 *        },
		 *        {
		 *            property : 'lastName',
		 *            value    : 'Griffin'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) instances, and delegates
		 * the actual filtering to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter[]} [filters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of filter configurations.
		 * @param   {string}                   [value]   The property value by which to filter. Only applicable if `filters` is a string.
		 * @returns {void}                               
		 */
		filter? (filters?: string | Ext.util.Filter[], value?: string): void;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of the Record field to test.
		 * @param   {string|RegExp} value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}        [startIndex]    The index to start searching at
		 * @param   {boolean}       [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}       [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {number}                        The matched index or -1
		 */
		find? (property: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string} fieldName    The name of the Record field to test.
		 * @param   {object} value        The value to match the field against.
		 * @param   {number} [startIndex] The index to start searching at
		 * @returns {number}              The matched index or -1
		 */
		findExact? (fieldName: string, value: object, startIndex?: number): number;
		/** 
		 * Finds the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}         fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}  value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}         [startIndex]    The index to start searching at
		 * @param   {boolean}        [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}        [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}        [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.Model}                 The matched record or null
		 */
		findRecord? (fieldName: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Convenience function for getting the first model instance in the store.
		 * 
		 * When store is filtered, will return first item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the first record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The first model instance in the store, or undefined
		 */
		first? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Called when the event handler which called the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method exits.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		flushLoad? (): void;
		/** 
		 * Returns the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAsynchronousLoad? (): boolean;
		/** 
		 * Get the Record at the specified index.
		 * 
		 * The index is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}         index The index of the Record to find.
		 * @returns {Ext.data.Model}       The Record at the passed index. Returns null if not found.
		 */
		getAt? (index: number): Ext.data.Model;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Returns the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean|object}  
		 */
		getAutoLoad? (): boolean | object;
		/** 
		 * Returns the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoSync? (): boolean;
		/** 
		 * Returns the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchUpdateMode? (): string;
		/** 
		 * Get the Record with the specified id.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            id The id of the Record to find.
		 * @returns {Ext.data.Model}    The Record with the passed id. Returns null if not found.
		 */
		getById? (id: any): Ext.data.Model;
		/** 
		 * Get the Record with the specified internalId.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            internalId The id of the Record to find.
		 * @returns {Ext.data.Model}            The Record with the passed internalId. Returns null if not found.
		 */
		getByInternalId? (internalId: any): Ext.data.Model;
		/** 
		 * Returns the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearOnPageLoad? (): boolean;
		/** 
		 * Returns the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearRemovedOnLoad? (): boolean;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Gets the number of records in store.
		 * 
		 * If using paging, this may not be the total size of the dataset. If the data object
		 * used by the Reader contains the dataset size, then the [Ext.data.ProxyStore.getTotalCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getTotalCount) function returns
		 * the dataset size.  **Note**: see the Important note in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load).
		 * 
		 * When store is filtered, it's the number of records matching the filter.
		 * @method
		 * @public (method)
		 * @returns {number}  The number of Records in the Store.
		 */
		getCount? (): number;
		/** 
		 * Returns the store's records.
		 * 
		 * **Note:** If your store has been filtered, getData() will return a filtered
		 * collection.  Use `getData().[getSource()`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#method-getSource) to
		 * fetch all unfiltered records.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection} 
		 * An [Ext.util.Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) of records
		 * (an empty Collection if no records are held by the store).
		 */
		getData? (): Ext.util.Collection;
		/** 
		 * Returns the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraKeys? (): object;
		/** 
		 * Returns the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @returns {object[]|string[]}  
		 */
		getFields? (): object[] | string[];
		/** 
		 * Gets the filters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.FilterCollection}            The filters
		 */
		getFilters? (autoCreate: object): Ext.util.FilterCollection;
		/** 
		 * Returns the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDir? (): string;
		/** 
		 * Returns the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @returns {object|Ext.util.Grouper}  
		 */
		getGrouper? (): object | Ext.util.Grouper;
		/** 
		 * Returns a collection of readonly sub-collections of your store's records
		 * with grouping applied. These sub-collections are maintained internally by
		 * the collection.
		 * 
		 * See [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField), [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir). Example for a store
		 * containing records with a color field:
		 * 
		 *    var myStore = Ext.create('Ext.data.Store', {
		 *        groupField: 'color',
		 *        groupDir  : 'DESC'
		 *    });
		 *    
		 *    myStore.getGroups();
		 * 
		 * The above should result in the following format:
		 * 
		 *    [
		 *        {
		 *            name: 'yellow',
		 *            children: [
		 *                // all records where the color field is 'yellow'
		 *            ]
		 *        },
		 *        {
		 *            name: 'red',
		 *            children: [
		 *                // all records where the color field is 'red'
		 *            ]
		 *        }
		 *    ]
		 * 
		 * Group contents are affected by filtering.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection}  The grouped data
		 */
		getGroups? (): Ext.util.Collection;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Gets all [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) added or updated since the last commit. Note that the order of records
		 * returned is not deterministic and does not indicate the order in which records were modified. Note also that
		 * removed records are not included (use [getRemovedRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getRemovedRecords) for that).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The added and updated Model instances
		 */
		getModifiedRecords? (): Ext.data.Model[];
		/** 
		 * Returns all [`phantom`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records in this store.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  A possibly empty array of `phantom` records.
		 */
		getNewRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getPageSize? (): number;
		/** 
		 * Returns the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.proxy.Proxy|object}  
		 */
		getProxy? (): string | Ext.data.proxy.Proxy | object;
		/** 
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}           start The starting index. Defaults to zero.
		 * @param   {number}           end   The ending index. Defaults to the last record. The end index **is included**.
		 * @returns {Ext.data.Model[]}       An array of records.
		 */
		getRange? (start: number, end: number): Ext.data.Model[];
		/** 
		 * Returns the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteFilter? (): boolean;
		/** 
		 * Returns the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteSort? (): boolean;
		/** 
		 * Returns any records that have been removed from the store but not yet destroyed on the proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]} 
		 * The removed Model instances. Note that this is a _copy_ of the store's
		 * array, so may be mutated.
		 */
		getRemovedRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Session}  
		 */
		getSession? (): Ext.data.Session;
		/** 
		 * Returns the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSortOnLoad? (): boolean;
		/** 
		 * Gets the sorters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.SorterCollection}            The sorters
		 */
		getSorters? (autoCreate: object): Ext.util.SorterCollection;
		/** 
		 * Returns the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getStatefulFilters? (): boolean;
		/** 
		 * Returns the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStoreId? (): string;
		/** 
		 * Returns the total number of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances that the [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html)
		 * indicates exist. This will usually differ from [getCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getCount) when using paging - getCount returns the
		 * number of records loaded into the Store at the moment, getTotalCount returns the number of records that
		 * could be loaded into the Store if the Store contained all data
		 * @method
		 * @public (method)
		 * @returns {number} 
		 * The total number of Model instances available via the Proxy. 0 returned if
		 * no value has been set via the reader.
		 */
		getTotalCount? (): number;
		/** 
		 * Returns the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getTrackRemoved? (): boolean;
		/** 
		 * Returns all valid, non-phantom Model instances that have been updated in the Store but not yet synchronized with the Proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The updated Model instances
		 */
		getUpdatedRecords? (): Ext.data.Model[];
		/** 
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {string|object} grouper
		 * Either a string name of one of the fields in this Store's
		 * configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an object, or a [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Grouper.html) configuration object.
		 * @param   {string}        [direction] The overall direction to group the data by. Defaults to the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @returns {void}                      
		 */
		group? (grouper: string | object, direction?: string): void;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Get the index of the record within the store.
		 * 
		 * When store is filtered, records outside of filter will not be found.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) object to find.
		 * @returns {number}                The index of the passed Record. Returns -1 if not found.
		 */
		indexOf? (record: Ext.data.Model): number;
		/** 
		 * Get the index within the store of the Record with the passed id.
		 * 
		 * Like [indexOf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-indexOf), this method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {string} id The id of the Record to find.
		 * @returns {number}    The index of the Record. Returns -1 if not found.
		 */
		indexOfId? (id: string): number;
		/** 
		 * Inserts Model instances into the Store at the given index and fires the add event.
		 * See also [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
		 * @method
		 * @public (method)
		 * @param   {number}                                          index   The start index at which to insert the passed Records.
		 * @param   {Ext.data.Model|Ext.data.Model[]|object|object[]} records
		 * An [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instance, the
		 * data needed to populate an instance or an array of either of these.
		 * @returns {Ext.data.Model[]}                                        records The added records
		 */
		insert? (index: number, records: Ext.data.Model | Ext.data.Model[] | object | object[]): Ext.data.Model[];
		/** 
		 * Tests whether the store currently has any active filters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is filtered.
		 */
		isFiltered? (): boolean;
		/** 
		 * Tests whether the store currently has an active grouper.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is grouped.
		 */
		isGrouped? (): boolean;
		/** 
		 * Returns `true` if the Store has been loaded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store has been loaded.
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns true if the Store is currently performing a load operation
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store is currently loading
		 */
		isLoading? (): boolean;
		/** 
		 * Tests whether the store currently has any active sorters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is sorted.
		 */
		isSorted? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Convenience function for getting the last model instance in the store.
		 * 
		 * When store is filtered, will return last item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the last record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The last model instance in the store, or undefined
		 */
		last? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Loads an array of data straight into the Store.
		 * 
		 * Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
		 * processed by a reader). If your data requires processing to decode the data structure, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @param   {boolean}                   [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {void}                               
		 */
		loadData? (data: Ext.data.Model[] | object[], append?: boolean): void;
		/** 
		 * Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
		 * load operation, passing in calculated 'start' and 'limit' params.
		 * @method
		 * @public (method)
		 * @param   {number} page      The number of the page to load.
		 * @param   {object} [options] See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		loadPage? (page: number, options?: object): void;
		/** 
		 * Loads data via the bound Proxy's reader
		 * 
		 * Use this method if you are attempting to load data and want to utilize the configured data reader.
		 * 
		 * As of 4.2, this method will no longer fire the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-load) event.
		 * @method
		 * @public (method)
		 * @param   {object[]} data     The full JSON object you'd like to load into the Data store.
		 * @param   {boolean}  [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {boolean}  
		 * `true` if the reader processed the records correctly. See [Ext.data.reader.Reader.successProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-successProperty).
		 * If the reader did not process the records, nothing will be added.
		 */
		loadRawData? (data: object[], append?: boolean): boolean;
		/** 
		 * Gets the maximum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the maximum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The maximum value, if no items exist, undefined.
		 */
		max? (field: string, grouped?: boolean): object;
		/** 
		 * Gets the minimum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the minimum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The minimum value, if no items exist, undefined.
		 */
		min? (field: string, grouped?: boolean): object;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Loads the next 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		nextPage? (options: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Loads the previous 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		previousPage? (options: object): void;
		/** 
		 * Query all the cached records in this Store by name/value pair.
		 * The parameters will be used to generated a filter function that is given
		 * to the queryBy method.
		 * 
		 * This method complements queryBy by generating the query function automatically.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @public (method)
		 * @param   {string}              property        The property to create the filter function for
		 * @param   {string|RegExp}       value           The string/regex to compare the property value to
		 * @param   {boolean}             [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}             [caseSensitive] `true` to create a case-sensitive regex.
		 * @param   {boolean}             [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.util.Collection}                 The matched records
		 */
		query? (property: string, value: string | RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.util.Collection;
		/** 
		 * [Rejects](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-reject) outstanding changes on all [modified records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords)
		 * and re-insert any records that were removed locally. Any phantom records will be removed.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		rejectChanges? (): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Reloads the store using the last options passed to the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method. You can use the reload method to reload the
		 * store using the parameters from the last load() call. For example:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload();
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution will pass the `userid` parameter in the request. The [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) execution
		 * will also send the same `userid` parameter in its request as it will reuse the `params` object from the last [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) call.
		 * 
		 * You can override a param by passing in the config object with the `params` object:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216,
		 *            foo    : 'bar'
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload({
		 *        params : {
		 *            userid : 1234
		 *        }
		 *    });
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution sends the `userid` and `foo` parameters but in the [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) it only sends
		 * the `userid` paramter because you are overriding the `params` config not just overriding the one param. To only change a single param
		 * but keep other params, you will have to get the last params from the [lastOptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#property-lastOptions) property:
		 * 
		 *    var lastOptions = store.lastOptions,
		 *        lastParams = Ext.clone(lastOptions.params); // make a copy of the last params so we don't affect future reload() calls
		 *    
		 *    lastParams.userid = 1234;
		 *    
		 *    store.reload({
		 *        params : lastParams
		 *    });
		 * 
		 * This will now send the `userid` parameter as `1234` and the `foo` param as `'bar'`.
		 * @method
		 * @public (method)
		 * @param   {object} [options]
		 * A config object which contains options which may override the options passed to the previous load call. See the
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method for valid configs.
		 * @returns {void}             
		 */
		reload? (options?: object): void;
		/** 
		 * Removes the specified record(s) from the Store, firing the [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove)
		 * event for the removed records.
		 * 
		 * After all records have been removed a single `datachanged` is fired.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model|Ext.data.Model[]|number|number[]} records
		 * Model instance or
		 * array of instances to remove or an array of indices from which to remove records.
		 * @param   {object}                                          isMove  (private)
		 * @param   {object}                                          silent  (private)
		 * @returns {void}                                                    
		 */
		remove? (records: Ext.data.Model | Ext.data.Model[] | number | number[], isMove: object, silent: object): void;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Removes all items from the store.
		 * 
		 * Individual record [`remove`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events are not fired by this method.
		 * @method
		 * @public (method)
		 * @param   {boolean}          [silent]
		 * Pass `true` to prevent the [`clear`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-clear) event from being fired.
		 * 
		 * This method is affected by filtering.
		 * @returns {Ext.data.Model[]}          The removed records.
		 */
		removeAll? (silent?: boolean): Ext.data.Model[];
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-removeAll).
		 * Removes all records from the store. This method does a "fast remove",
		 * individual remove events are not called. The [clear](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-clear) event is
		 * fired upon completion.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]|void}  
		 */
		removeAll? (): void;
		/** 
		 * Removes the model instance(s) at the given index
		 * @method
		 * @public (method)
		 * @param   {number} index   The record index
		 * @param   {number} [count] The number of records to delete
		 * @returns {void}           
		 */
		removeAt? (index: number, count?: number): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an individual Filter from the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) using the passed Filter/Filter id and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter} toRemove        The id of a Filter to remove from the filter set, or a Filter instance to remove.
		 * @param   {boolean}                [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                   
		 */
		removeFilter? (toRemove: string | Ext.util.Filter, suppressEvent?: boolean): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @param   {boolean} syncNow
		 * Pass `true` to synchronize now. Only synchronizes with the Proxy if the suspension
		 * count has gone to zero (We are not under a higher level of suspension)
		 * @returns {void}            
		 */
		resumeAutoSync? (syncNow: boolean): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Saves all pending changes via the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy). Use [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) instead.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		save? (): void;
		/** 
		 * Sets the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} asynchronousLoad The new value.
		 * @returns {void}                     
		 */
		setAsynchronousLoad? (asynchronousLoad: boolean): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean|object} autoLoad The new value.
		 * @returns {void}                    
		 */
		setAutoLoad? (autoLoad: boolean | object): void;
		/** 
		 * Sets the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoSync The new value.
		 * @returns {void}             
		 */
		setAutoSync? (autoSync: boolean): void;
		/** 
		 * Sets the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @param   {string} batchUpdateMode The new value.
		 * @returns {void}                   
		 */
		setBatchUpdateMode? (batchUpdateMode: string): void;
		/** 
		 * Sets the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearOnPageLoad The new value.
		 * @returns {void}                    
		 */
		setClearOnPageLoad? (clearOnPageLoad: boolean): void;
		/** 
		 * Sets the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearRemovedOnLoad The new value.
		 * @returns {void}                       
		 */
		setClearRemovedOnLoad? (clearRemovedOnLoad: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                                          name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                                 [value] The value to set for the name parameter.
		 * @returns {Ext.data.JsonPStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.JsonPStore;
		setConfig? (name: string | object, value?: object): Ext.data.Store;
		setConfig? (name: string | object, value?: object): Ext.data.ProxyStore;
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Loads an array of data directly into the Store.
		 * 
		 * setData() is ideal if your data's format is already in its appropriate format (e.g. it doesn't need to be
		 * processed by a reader). If your data's structure requires processing, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * 
		 * Use [loadData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadData), [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add), or [insert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-insert) if records need to be
		 * appended to the current recordset.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @returns {void}                           
		 */
		setData? (data: Ext.data.Model[] | object[]): void;
		/** 
		 * Sets the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @param   {object} extraKeys The new value.
		 * @returns {void}             
		 */
		setExtraKeys? (extraKeys: object): void;
		/** 
		 * Sets the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @param   {object[]|string[]} fields The new value.
		 * @returns {void}                     
		 */
		setFields? (fields: object[] | string[]): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setFilters? (): void;
		/** 
		 * Sets the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @param   {string} groupDir The new value.
		 * @returns {void}            
		 */
		setGroupDir? (groupDir: string): void;
		/** 
		 * Sets the value of [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField).
		 * @method
		 * @public (method)
		 * @param   {string} groupField The new value.
		 * @returns {void}              
		 */
		setGroupField? (groupField: string): void;
		/** 
		 * Sets the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.util.Grouper} grouper The new value.
		 * @returns {void}                            
		 */
		setGrouper? (grouper: object | Ext.util.Grouper): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @param   {number} pageSize The new value.
		 * @returns {void}            
		 */
		setPageSize? (pageSize: number): void;
		/** 
		 * Sets the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.proxy.Proxy|object} proxy The new value.
		 * @returns {void}                                     
		 */
		setProxy? (proxy: string | Ext.data.proxy.Proxy | object): void;
		/** 
		 * Sets the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteFilter The new value.
		 * @returns {void}                 
		 */
		setRemoteFilter? (remoteFilter: boolean): void;
		/** 
		 * Sets the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteSort The new value.
		 * @returns {void}               
		 */
		setRemoteSort? (remoteSort: boolean): void;
		/** 
		 * Sets the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} session The new value.
		 * @returns {void}                     
		 */
		setSession? (session: Ext.data.Session): void;
		/** 
		 * Sets the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} sortOnLoad The new value.
		 * @returns {void}               
		 */
		setSortOnLoad? (sortOnLoad: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setSorters? (): void;
		/** 
		 * Sets the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @param   {boolean} statefulFilters The new value.
		 * @returns {void}                    
		 */
		setStatefulFilters? (statefulFilters: boolean): void;
		/** 
		 * Sets the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @param   {string} storeId The new value.
		 * @returns {void}           
		 */
		setStoreId? (storeId: string): void;
		/** 
		 * Sets the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @param   {boolean} trackRemoved The new value.
		 * @returns {void}                 
		 */
		setTrackRemoved? (trackRemoved: boolean): void;
		/** 
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction] The overall direction to sort the data by.
		 * @returns {Ext.util.Sorter[]}                    
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string): Ext.util.Sorter[];
		/** 
		 * Sums the value of `field` for each [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in store
		 * and returns the result.
		 * 
		 * When store is filtered, only sums items within the filter.
		 * @method
		 * @public (method)
		 * @param   {string}  field     A field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the sum for that group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            The sum
		 */
		sum? (field: string, grouped?: boolean): number;
		/** 
		 * Suspends automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendAutoSync? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Inherit docs
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		contains? (record: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.contains](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-contains).
		 * Checks if a record is in the current active data set.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record
		 * @returns {void|boolean}          `true` if the record is in the current active data set.
		 */
		contains? (record: Ext.data.Model): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		doDestroy? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                                 config
		 * @returns {Ext.data.JsonPStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.JsonPStore;
		initConfig? (config: object): Ext.data.Store;
		initConfig? (config: object): Ext.data.ProxyStore;
		initConfig? (config: object): Ext.data.AbstractStore;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Called internally when a Proxy has completed a load request
		 * @method
		 * @protected (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyLoad? (operation: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.JsonPStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.JsonPStore.Statics;
		statics? (): Ext.data.Store.Statics;
		statics? (): Ext.data.ProxyStore.Statics;
		statics? (): Ext.data.AbstractStore.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorter
		 * @returns {void}          
		 */
		addFieldTransform? (sorter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		addObserver? (observer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @param   {object} type
		 * @returns {void}                      
		 */
		afterChange? (record: object, modifiedFieldNames: object, type: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterCommit? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterDrop? (record: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @returns {void}                      
		 */
		afterEdit? (record: object, modifiedFieldNames: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterErase? (record: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to..
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterReject? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} asynchronousLoad
		 * @returns {void}                    
		 */
		applyAsynchronousLoad? (asynchronousLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} extraKeys
		 * @returns {void}             
		 */
		applyExtraKeys? (extraKeys: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fields
		 * @returns {void}          
		 */
		applyFields? (fields: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @param   {object} filtersCollection
		 * @returns {void}                     
		 */
		applyFilters? (filters: object, filtersCollection: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} grouper
		 * @returns {void}           
		 */
		applyGrouper? (grouper: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @returns {void}         
		 */
		applyProxy? (proxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorters
		 * @param   {object} sortersCollection
		 * @returns {void}                     
		 */
		applySorters? (sorters: object, sortersCollection: object): void;
		/** 
		 * Restores state to the passed state
		 * @method
		 * @private (method)
		 * @param   {object} state
		 * @returns {void}         
		 */
		applyState? (state: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} args
		 * @returns {void}          
		 */
		callObservers? (action: object, args: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} isLoad
		 * @returns {void}          
		 */
		clearData? (isLoad: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.clearData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-clearData).
		 * to be implemented by subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearData? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		constructDataCollection? (): void;
		/** 
		 * saves any phantom records
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @param   {object} options
		 * @returns {void}           
		 */
		create? (data: object, options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createFiltersCollection? (): void;
		/** 
		 * Converts a literal to a model, if it's not a model already
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model|object} record The record to create
		 * @returns {Ext.data.Model}               
		 */
		createModel? (record: Ext.data.Model | object): Ext.data.Model;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createSortersCollection? (): void;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * tells the attached proxy to destroy the given records
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		erase? (options: object): void;
		/** 
		 * Similar to a load, however no records are added to the store. This is useful
		 * in allowing the developer to decide what to do with the new records.
		 * @method
		 * @private (method)
		 * @param   {object} [options] See [load options](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		fetch? (options?: object): void;
		/** 
		 * private
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @returns {void}      
		 */
		filterDataSource? (fn: object): void;
		/** 
		 * Filter function for new records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNew? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNewOnly? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterRejects? (item: object): void;
		/** 
		 * Filter function for updated records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterUpdated? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		fireGroupChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		forceLocalSort? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @param   {object} scope
		 * @param   {object} records
		 * @param   {object} field
		 * @returns {void}           
		 */
		getAggregate? (fn: object, scope: object, records: object, field: object): void;
		/** 
		 * Returns the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.Model}  
		 */
		getAssociatedEntity? (): Ext.data.Model;
		/** 
		 * Returns the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getAutoSort? (): boolean;
		/** 
		 * Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
		 * This is broken out into a separate function to allow for customisation of the listeners
		 * @method
		 * @private (method)
		 * @returns {object}  The listeners object
		 */
		getBatchListeners? (): object;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Returns the complete unfiltered collection.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getDataSource? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getGroupField? (): void;
		/** 
		 * Returns the array of records which have been removed since the last time this store was synced.
		 * 
		 * This is used internally, when purging removed records after a successful sync.
		 * This is overridden by TreeStore because TreeStore accumulates deleted records on removal
		 * of child nodes from their parent, _not_ on removal of records from its collection. The collection
		 * has records added on expand, and removed on collapse.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRawRemovedRecords? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRejectRecords? (): void;
		/** 
		 * Returns the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.schema.Role}  
		 */
		getRole? (): Ext.data.schema.Role;
		/** 
		 * Returns the grouping, sorting and filtered state of this Store.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getState? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Returns true if the store has a pending load task.
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the store has a pending load task.
		 */
		hasPendingLoad? (): boolean;
		/** 
		 * Checks whether records are being moved within the store. This can be used in conjunction with the
		 * [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-add) and [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events to determine whether the records are being removed/added
		 * or just having the position changed.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]|Ext.data.Model} [records] The record(s).
		 * @returns {number}                          
		 * The number of records being moved. `0` if no records are moving. If records are passed
		 * the number will refer to how many of the passed records are moving.
		 */
		isMoving? (records?: Ext.data.Model[] | Ext.data.Model): number;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @returns {void}        
		 */
		loadInlineData? (data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		notifySorterChange? (): void;
		/** 
		 * Attached as the 'complete' event listener to a proxy's Batch object. Iterates over the batch operations
		 * and updates the Store's internal data MixedCollection.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchComplete? (batch: object, operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchException? (batch: object, operation: object): void;
		/** 
		 * Attached as the 'operationcomplete' event listener to a proxy's Batch object. By default just calls through
		 * to onProxyWrite.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchOperationComplete? (batch: object, operation: object): void;
		/** 
		 * This is attached to the data Collection's beforesort event only if not remoteSort
		 * If remoteSort, the event is fired before the reload call in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-load).
		 * @method
		 * @private (method)
		 * @param   {object} store
		 * @param   {object} sorters
		 * @returns {void}           
		 */
		onBeforeCollectionSort? (store: object, sorters: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} cls
		 * @param   {object} data
		 * @param   {object} hooks
		 * @returns {void}         
		 */
		onClassExtended? (cls: object, data: object, hooks: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} records
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionAddItems? (collection: object, records: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionBeforeItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionBeginUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionEndUpdate? (): void;
		/** 
		 * When the collection informs us that it has filtered, this LocalStore must react.
		 * AbstractStore#onFilterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilter? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} items
		 * @returns {void}              
		 */
		onCollectionFilterAdd? (collection: object, items: object): void;
		/** 
		 * If our source collection informs us that a filtered out item has changed, we must still fire the events...
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilteredItemChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionRemove? (collection: object, info: object): void;
		/** 
		 * When the collection informs us that it has sorted, this LocalStore must react.
		 * AbstractStore#onSorterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionSort? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCreateRecords? (): void;
		/** 
		 * Removes any records when a write is returned from the server.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]}             records   The array of removed records
		 * @param   {Ext.data.operation.Operation} operation The operation that just completed
		 * @param   {boolean}                      success   True if the operation was successful
		 * @returns {void}                                   
		 */
		onDestroyRecords? (records: Ext.data.Model[], operation: Ext.data.operation.Operation, success: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onErase? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onFilterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} rec
		 * @param   {object} oldId
		 * @param   {object} newId
		 * @returns {void}         
		 */
		onIdChanged? (rec: object, oldId: object, newId: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} meta
		 * @returns {void}         
		 */
		onMetaChange? (proxy: object, meta: object): void;
		/** 
		 * Callback for any write Operation over the Proxy. Updates the Store's MixedCollection to reflect
		 * the updates provided by the Proxy
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyWrite? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onSorterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdate? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdateRecords? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Query all the cached records in this Store by field.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @private (method)
		 * @param   {string}           field The field from each record to use.
		 * @param   {object}           value The value to match.
		 * @returns {Ext.data.Model[]}       The matched records.
		 */
		queryRecords? (field: string, value: object): Ext.data.Model[];
		/** 
		 * Determines if the passed range is available in the page cache.
		 * @method
		 * @private (method)
		 * @param   {number} start The start index
		 * @param   {number} end   The end index in the range
		 * @returns {void}         
		 */
		rangeCached? (start: number, end: number): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		removeObserver? (observer: object): void;
		/** 
		 * Sets the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} associatedEntity The new value.
		 * @returns {void}                            
		 */
		setAssociatedEntity? (associatedEntity: Ext.data.Model): void;
		/** 
		 * Sets the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @param   {boolean} autoSort The new value.
		 * @returns {void}             
		 */
		setAutoSort? (autoSort: boolean): void;
		/** 
		 * Make a set of records be current in the store. This means that unneeded records
		 * will be removed and new records will be added.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]} records The records to be current in the store.
		 * @returns {void}                     
		 */
		setRecords? (records: Ext.data.Model[]): void;
		/** 
		 * Sets the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.schema.Role} role The new value.
		 * @returns {void}                      
		 */
		setRole? (role: Ext.data.schema.Role): void;
		/** 
		 * This method is basically the same as the JavaScript Array splice method.
		 * 
		 * Negative indexes are interpreted starting at the end of the collection. That is,
		 * a value of -1 indicates the last item, or equivalent to `length - 1`.
		 * @method
		 * @private (method)
		 * @param   {number}          index    The index at which to add or remove items.
		 * @param   {number|object[]} toRemove
		 * The number of items to remove or an array of the
		 * items to remove.
		 * @param   {object[]}        [toAdd]  The items to insert at the given `index`.
		 * @returns {void}                     
		 */
		splice? (index: number, toRemove: number | object[], toAdd?: object[]): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                               names The names of the linked objects to destroy.
		 * @returns {Ext.data.JsonPStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.JsonPStore;
		unlink? (names: string[]): Ext.data.Store;
		unlink? (names: string[]): Ext.data.ProxyStore;
		unlink? (names: string[]): Ext.data.AbstractStore;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		update? (options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoLoad
		 * @returns {void}            
		 */
		updateAutoLoad? (autoLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoSort
		 * @returns {void}            
		 */
		updateAutoSort? (autoSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} field
		 * @returns {void}         
		 */
		updateGroupField? (field: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} oldProxy
		 * @returns {void}            
		 */
		updateProxy? (proxy: object, oldProxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @returns {void}                
		 */
		updateRemoteFilter? (remoteFilter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @returns {void}              
		 */
		updateRemoteSort? (remoteSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} track
		 * @returns {void}         
		 */
		updateTrackRemoved? (track: object): void;
	}
	/** 
	 * [Ext.data.JsonStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from JSON data easier.
	 * A JsonStore will be automatically configured with a [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.JsonStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *    
	 *        proxy: {
	 *            type: 'ajax',
	 *            url: 'get-images.php',
	 *            reader: {
	 *                type: 'json',
	 *                rootProperty: 'images'
	 *            }
	 *        },
	 *    
	 *        //alternatively, a Model name can be given (see Ext.data.Store for an example)
	 *        fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    {
	 *        images: [
	 *            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
	 *            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
	 *        ]
	 *    }
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#cfg-data) config option.
	 */
	class JsonStore extends Ext.data.Store {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.JsonStore.Statics}
		 */
		self?: Ext.data.JsonStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                members    The members to add to this class.
		 * @param   {boolean}                                                                               [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                               [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.JsonStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.JsonStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                members
		 * @returns {Ext.data.JsonStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.JsonStore;
		static addStatics? (members: object): typeof Ext.data.Store;
		static addStatics? (members: object): typeof Ext.data.ProxyStore;
		static addStatics? (members: object): typeof Ext.data.AbstractStore;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                name
		 * @param   {object}                                                                                member
		 * @returns {Ext.data.JsonStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.JsonStore;
		static addMember? (name: object, member: object): typeof Ext.data.Store;
		static addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		static addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                fn
		 * @param   {object}                                                                                scope
		 * @returns {Ext.data.JsonStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.JsonStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		static onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                The model instances that were added
		 */
		add? (model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {...Ext.data.Model|...object} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                  The model instances that were added
		 */
		add? (...model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * Adds a new Filter to this Store's [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {object[]|Ext.util.Filter[]} filters         The set of filters to add to the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters).
		 * @param   {boolean}                    [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                       
		 */
		addFilter? (filters: object[] | Ext.util.Filter[], suppressEvent?: boolean): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * (Local sort only) Inserts the passed Record into the Store at the index where it
		 * should go based on the current sort information.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Record} record
		 * @returns {void}                   
		 */
		addSorted? (record: Ext.data.Record): void;
		/** 
		 * Runs the aggregate function for all the records in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {Function} fn
		 * The function to execute. The function is called with a single parameter,
		 * an array of records for that group.
		 * @param   {object}   scope   The scope to execute the function in. Defaults to the store.
		 * @param   {boolean}  grouped
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @param   {string}   field   The field to get the value from
		 * @returns {object}           An object literal with the group names and their appropriate values.
		 */
		aggregate? (fn: ExtGlobalFunction, scope: object, grouped: boolean, field: string): object;
		/** 
		 * Gets the average value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The average value, if no items exist, 0.
		 */
		average? (field: string, grouped?: boolean): object;
		/** 
		 * This method may be called to indicate the start of multiple changes to the store.
		 * 
		 * Automatic synchronization as configured by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred
		 * until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple mutations can be coalesced
		 * into one synchronization operation.
		 * 
		 * Internally this method increments a counter that is decremented by `endUpdate`. It
		 * is important, therefore, that if you call `beginUpdate` directly you match that
		 * call with a call to `endUpdate` or you will prevent the collection from updating
		 * properly.
		 * 
		 * For example:
		 * 
		 *     var store = Ext.StoreManager.lookup({
		 *         //...
		 *         autoSync: true
		 *     });
		 *    
		 *     store.beginUpdate();
		 *    
		 *     record.set('fieldName', 'newValue');
		 *    
		 *     store.add(item);
		 *     // ...
		 *    
		 *     store.insert(index, otherItem);
		 *     //...
		 *    
		 *     // Interested parties will listen for the endupdate event
		 *     store.endUpdate();
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginUpdate? (): void;
		/** 
		 * Reverts to a view of the Record cache with no filtering applied.
		 * @method
		 * @public (method)
		 * @param   {boolean} [suppressEvent]
		 * If `true` the filter is cleared silently.
		 * 
		 * For a locally filtered Store, this means that the filter collection is cleared without firing the
		 * [datachanged](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-datachanged) event.
		 * 
		 * For a remotely filtered Store, this means that the filter collection is cleared, but the store
		 * is not reloaded from the server.
		 * @returns {void}                    
		 */
		clearFilter? (suppressEvent?: boolean): void;
		/** 
		 * Clear the store grouping
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearGrouping? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Commits all Records with [outstanding changes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords). To handle updates for changes,
		 * subscribe to the Store's [update event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-update), and perform updating when the third parameter is
		 * [Ext.data.Record.COMMIT](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#static-property-COMMIT).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		commitChanges? (): void;
		/** 
		 * Gets the count of items in the store.
		 * 
		 * When store is filtered, only items within the filter are counted.
		 * @method
		 * @public (method)
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the count for each group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            the count
		 */
		count? (grouped?: boolean): number;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * This method is called after modifications are complete on a store. For details
		 * see [`beginUpdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		endUpdate? (): void;
		/** 
		 * Filters the data in the Store by one or more fields. Example usage:
		 * 
		 *    //filter with a single field
		 *    myStore.filter('firstName', 'Don');
		 *    
		 *    //filtering with multiple filters
		 *    myStore.filter([
		 *        {
		 *            property : 'firstName',
		 *            value    : 'Don'
		 *        },
		 *        {
		 *            property : 'lastName',
		 *            value    : 'Griffin'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) instances, and delegates
		 * the actual filtering to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter[]} [filters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of filter configurations.
		 * @param   {string}                   [value]   The property value by which to filter. Only applicable if `filters` is a string.
		 * @returns {void}                               
		 */
		filter? (filters?: string | Ext.util.Filter[], value?: string): void;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of the Record field to test.
		 * @param   {string|RegExp} value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}        [startIndex]    The index to start searching at
		 * @param   {boolean}       [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}       [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {number}                        The matched index or -1
		 */
		find? (property: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string} fieldName    The name of the Record field to test.
		 * @param   {object} value        The value to match the field against.
		 * @param   {number} [startIndex] The index to start searching at
		 * @returns {number}              The matched index or -1
		 */
		findExact? (fieldName: string, value: object, startIndex?: number): number;
		/** 
		 * Finds the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}         fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}  value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}         [startIndex]    The index to start searching at
		 * @param   {boolean}        [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}        [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}        [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.Model}                 The matched record or null
		 */
		findRecord? (fieldName: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Convenience function for getting the first model instance in the store.
		 * 
		 * When store is filtered, will return first item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the first record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The first model instance in the store, or undefined
		 */
		first? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Called when the event handler which called the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method exits.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		flushLoad? (): void;
		/** 
		 * Returns the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAsynchronousLoad? (): boolean;
		/** 
		 * Get the Record at the specified index.
		 * 
		 * The index is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}         index The index of the Record to find.
		 * @returns {Ext.data.Model}       The Record at the passed index. Returns null if not found.
		 */
		getAt? (index: number): Ext.data.Model;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Returns the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean|object}  
		 */
		getAutoLoad? (): boolean | object;
		/** 
		 * Returns the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoSync? (): boolean;
		/** 
		 * Returns the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchUpdateMode? (): string;
		/** 
		 * Get the Record with the specified id.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            id The id of the Record to find.
		 * @returns {Ext.data.Model}    The Record with the passed id. Returns null if not found.
		 */
		getById? (id: any): Ext.data.Model;
		/** 
		 * Get the Record with the specified internalId.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            internalId The id of the Record to find.
		 * @returns {Ext.data.Model}            The Record with the passed internalId. Returns null if not found.
		 */
		getByInternalId? (internalId: any): Ext.data.Model;
		/** 
		 * Returns the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearOnPageLoad? (): boolean;
		/** 
		 * Returns the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearRemovedOnLoad? (): boolean;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Gets the number of records in store.
		 * 
		 * If using paging, this may not be the total size of the dataset. If the data object
		 * used by the Reader contains the dataset size, then the [Ext.data.ProxyStore.getTotalCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getTotalCount) function returns
		 * the dataset size.  **Note**: see the Important note in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load).
		 * 
		 * When store is filtered, it's the number of records matching the filter.
		 * @method
		 * @public (method)
		 * @returns {number}  The number of Records in the Store.
		 */
		getCount? (): number;
		/** 
		 * Returns the store's records.
		 * 
		 * **Note:** If your store has been filtered, getData() will return a filtered
		 * collection.  Use `getData().[getSource()`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#method-getSource) to
		 * fetch all unfiltered records.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection} 
		 * An [Ext.util.Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) of records
		 * (an empty Collection if no records are held by the store).
		 */
		getData? (): Ext.util.Collection;
		/** 
		 * Returns the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraKeys? (): object;
		/** 
		 * Returns the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @returns {object[]|string[]}  
		 */
		getFields? (): object[] | string[];
		/** 
		 * Gets the filters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.FilterCollection}            The filters
		 */
		getFilters? (autoCreate: object): Ext.util.FilterCollection;
		/** 
		 * Returns the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDir? (): string;
		/** 
		 * Returns the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @returns {object|Ext.util.Grouper}  
		 */
		getGrouper? (): object | Ext.util.Grouper;
		/** 
		 * Returns a collection of readonly sub-collections of your store's records
		 * with grouping applied. These sub-collections are maintained internally by
		 * the collection.
		 * 
		 * See [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField), [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir). Example for a store
		 * containing records with a color field:
		 * 
		 *    var myStore = Ext.create('Ext.data.Store', {
		 *        groupField: 'color',
		 *        groupDir  : 'DESC'
		 *    });
		 *    
		 *    myStore.getGroups();
		 * 
		 * The above should result in the following format:
		 * 
		 *    [
		 *        {
		 *            name: 'yellow',
		 *            children: [
		 *                // all records where the color field is 'yellow'
		 *            ]
		 *        },
		 *        {
		 *            name: 'red',
		 *            children: [
		 *                // all records where the color field is 'red'
		 *            ]
		 *        }
		 *    ]
		 * 
		 * Group contents are affected by filtering.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection}  The grouped data
		 */
		getGroups? (): Ext.util.Collection;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Gets all [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) added or updated since the last commit. Note that the order of records
		 * returned is not deterministic and does not indicate the order in which records were modified. Note also that
		 * removed records are not included (use [getRemovedRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getRemovedRecords) for that).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The added and updated Model instances
		 */
		getModifiedRecords? (): Ext.data.Model[];
		/** 
		 * Returns all [`phantom`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records in this store.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  A possibly empty array of `phantom` records.
		 */
		getNewRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getPageSize? (): number;
		/** 
		 * Returns the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.proxy.Proxy|object}  
		 */
		getProxy? (): string | Ext.data.proxy.Proxy | object;
		/** 
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}           start The starting index. Defaults to zero.
		 * @param   {number}           end   The ending index. Defaults to the last record. The end index **is included**.
		 * @returns {Ext.data.Model[]}       An array of records.
		 */
		getRange? (start: number, end: number): Ext.data.Model[];
		/** 
		 * Returns the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteFilter? (): boolean;
		/** 
		 * Returns the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteSort? (): boolean;
		/** 
		 * Returns any records that have been removed from the store but not yet destroyed on the proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]} 
		 * The removed Model instances. Note that this is a _copy_ of the store's
		 * array, so may be mutated.
		 */
		getRemovedRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Session}  
		 */
		getSession? (): Ext.data.Session;
		/** 
		 * Returns the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSortOnLoad? (): boolean;
		/** 
		 * Gets the sorters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.SorterCollection}            The sorters
		 */
		getSorters? (autoCreate: object): Ext.util.SorterCollection;
		/** 
		 * Returns the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getStatefulFilters? (): boolean;
		/** 
		 * Returns the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStoreId? (): string;
		/** 
		 * Returns the total number of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances that the [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html)
		 * indicates exist. This will usually differ from [getCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getCount) when using paging - getCount returns the
		 * number of records loaded into the Store at the moment, getTotalCount returns the number of records that
		 * could be loaded into the Store if the Store contained all data
		 * @method
		 * @public (method)
		 * @returns {number} 
		 * The total number of Model instances available via the Proxy. 0 returned if
		 * no value has been set via the reader.
		 */
		getTotalCount? (): number;
		/** 
		 * Returns the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getTrackRemoved? (): boolean;
		/** 
		 * Returns all valid, non-phantom Model instances that have been updated in the Store but not yet synchronized with the Proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The updated Model instances
		 */
		getUpdatedRecords? (): Ext.data.Model[];
		/** 
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {string|object} grouper
		 * Either a string name of one of the fields in this Store's
		 * configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an object, or a [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Grouper.html) configuration object.
		 * @param   {string}        [direction] The overall direction to group the data by. Defaults to the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @returns {void}                      
		 */
		group? (grouper: string | object, direction?: string): void;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Get the index of the record within the store.
		 * 
		 * When store is filtered, records outside of filter will not be found.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) object to find.
		 * @returns {number}                The index of the passed Record. Returns -1 if not found.
		 */
		indexOf? (record: Ext.data.Model): number;
		/** 
		 * Get the index within the store of the Record with the passed id.
		 * 
		 * Like [indexOf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-indexOf), this method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {string} id The id of the Record to find.
		 * @returns {number}    The index of the Record. Returns -1 if not found.
		 */
		indexOfId? (id: string): number;
		/** 
		 * Inserts Model instances into the Store at the given index and fires the add event.
		 * See also [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
		 * @method
		 * @public (method)
		 * @param   {number}                                          index   The start index at which to insert the passed Records.
		 * @param   {Ext.data.Model|Ext.data.Model[]|object|object[]} records
		 * An [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instance, the
		 * data needed to populate an instance or an array of either of these.
		 * @returns {Ext.data.Model[]}                                        records The added records
		 */
		insert? (index: number, records: Ext.data.Model | Ext.data.Model[] | object | object[]): Ext.data.Model[];
		/** 
		 * Tests whether the store currently has any active filters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is filtered.
		 */
		isFiltered? (): boolean;
		/** 
		 * Tests whether the store currently has an active grouper.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is grouped.
		 */
		isGrouped? (): boolean;
		/** 
		 * Returns `true` if the Store has been loaded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store has been loaded.
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns true if the Store is currently performing a load operation
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store is currently loading
		 */
		isLoading? (): boolean;
		/** 
		 * Tests whether the store currently has any active sorters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is sorted.
		 */
		isSorted? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Convenience function for getting the last model instance in the store.
		 * 
		 * When store is filtered, will return last item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the last record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The last model instance in the store, or undefined
		 */
		last? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Loads an array of data straight into the Store.
		 * 
		 * Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
		 * processed by a reader). If your data requires processing to decode the data structure, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @param   {boolean}                   [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {void}                               
		 */
		loadData? (data: Ext.data.Model[] | object[], append?: boolean): void;
		/** 
		 * Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
		 * load operation, passing in calculated 'start' and 'limit' params.
		 * @method
		 * @public (method)
		 * @param   {number} page      The number of the page to load.
		 * @param   {object} [options] See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		loadPage? (page: number, options?: object): void;
		/** 
		 * Loads data via the bound Proxy's reader
		 * 
		 * Use this method if you are attempting to load data and want to utilize the configured data reader.
		 * 
		 * As of 4.2, this method will no longer fire the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-load) event.
		 * @method
		 * @public (method)
		 * @param   {object[]} data     The full JSON object you'd like to load into the Data store.
		 * @param   {boolean}  [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {boolean}  
		 * `true` if the reader processed the records correctly. See [Ext.data.reader.Reader.successProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-successProperty).
		 * If the reader did not process the records, nothing will be added.
		 */
		loadRawData? (data: object[], append?: boolean): boolean;
		/** 
		 * Gets the maximum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the maximum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The maximum value, if no items exist, undefined.
		 */
		max? (field: string, grouped?: boolean): object;
		/** 
		 * Gets the minimum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the minimum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The minimum value, if no items exist, undefined.
		 */
		min? (field: string, grouped?: boolean): object;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Loads the next 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		nextPage? (options: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Loads the previous 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		previousPage? (options: object): void;
		/** 
		 * Query all the cached records in this Store by name/value pair.
		 * The parameters will be used to generated a filter function that is given
		 * to the queryBy method.
		 * 
		 * This method complements queryBy by generating the query function automatically.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @public (method)
		 * @param   {string}              property        The property to create the filter function for
		 * @param   {string|RegExp}       value           The string/regex to compare the property value to
		 * @param   {boolean}             [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}             [caseSensitive] `true` to create a case-sensitive regex.
		 * @param   {boolean}             [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.util.Collection}                 The matched records
		 */
		query? (property: string, value: string | RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.util.Collection;
		/** 
		 * [Rejects](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-reject) outstanding changes on all [modified records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords)
		 * and re-insert any records that were removed locally. Any phantom records will be removed.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		rejectChanges? (): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Reloads the store using the last options passed to the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method. You can use the reload method to reload the
		 * store using the parameters from the last load() call. For example:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload();
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution will pass the `userid` parameter in the request. The [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) execution
		 * will also send the same `userid` parameter in its request as it will reuse the `params` object from the last [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) call.
		 * 
		 * You can override a param by passing in the config object with the `params` object:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216,
		 *            foo    : 'bar'
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload({
		 *        params : {
		 *            userid : 1234
		 *        }
		 *    });
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution sends the `userid` and `foo` parameters but in the [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) it only sends
		 * the `userid` paramter because you are overriding the `params` config not just overriding the one param. To only change a single param
		 * but keep other params, you will have to get the last params from the [lastOptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#property-lastOptions) property:
		 * 
		 *    var lastOptions = store.lastOptions,
		 *        lastParams = Ext.clone(lastOptions.params); // make a copy of the last params so we don't affect future reload() calls
		 *    
		 *    lastParams.userid = 1234;
		 *    
		 *    store.reload({
		 *        params : lastParams
		 *    });
		 * 
		 * This will now send the `userid` parameter as `1234` and the `foo` param as `'bar'`.
		 * @method
		 * @public (method)
		 * @param   {object} [options]
		 * A config object which contains options which may override the options passed to the previous load call. See the
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method for valid configs.
		 * @returns {void}             
		 */
		reload? (options?: object): void;
		/** 
		 * Removes the specified record(s) from the Store, firing the [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove)
		 * event for the removed records.
		 * 
		 * After all records have been removed a single `datachanged` is fired.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model|Ext.data.Model[]|number|number[]} records
		 * Model instance or
		 * array of instances to remove or an array of indices from which to remove records.
		 * @param   {object}                                          isMove  (private)
		 * @param   {object}                                          silent  (private)
		 * @returns {void}                                                    
		 */
		remove? (records: Ext.data.Model | Ext.data.Model[] | number | number[], isMove: object, silent: object): void;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Removes all items from the store.
		 * 
		 * Individual record [`remove`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events are not fired by this method.
		 * @method
		 * @public (method)
		 * @param   {boolean}          [silent]
		 * Pass `true` to prevent the [`clear`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-clear) event from being fired.
		 * 
		 * This method is affected by filtering.
		 * @returns {Ext.data.Model[]}          The removed records.
		 */
		removeAll? (silent?: boolean): Ext.data.Model[];
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-removeAll).
		 * Removes all records from the store. This method does a "fast remove",
		 * individual remove events are not called. The [clear](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-clear) event is
		 * fired upon completion.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]|void}  
		 */
		removeAll? (): void;
		/** 
		 * Removes the model instance(s) at the given index
		 * @method
		 * @public (method)
		 * @param   {number} index   The record index
		 * @param   {number} [count] The number of records to delete
		 * @returns {void}           
		 */
		removeAt? (index: number, count?: number): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an individual Filter from the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) using the passed Filter/Filter id and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter} toRemove        The id of a Filter to remove from the filter set, or a Filter instance to remove.
		 * @param   {boolean}                [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                   
		 */
		removeFilter? (toRemove: string | Ext.util.Filter, suppressEvent?: boolean): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @param   {boolean} syncNow
		 * Pass `true` to synchronize now. Only synchronizes with the Proxy if the suspension
		 * count has gone to zero (We are not under a higher level of suspension)
		 * @returns {void}            
		 */
		resumeAutoSync? (syncNow: boolean): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Saves all pending changes via the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy). Use [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) instead.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		save? (): void;
		/** 
		 * Sets the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} asynchronousLoad The new value.
		 * @returns {void}                     
		 */
		setAsynchronousLoad? (asynchronousLoad: boolean): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean|object} autoLoad The new value.
		 * @returns {void}                    
		 */
		setAutoLoad? (autoLoad: boolean | object): void;
		/** 
		 * Sets the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoSync The new value.
		 * @returns {void}             
		 */
		setAutoSync? (autoSync: boolean): void;
		/** 
		 * Sets the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @param   {string} batchUpdateMode The new value.
		 * @returns {void}                   
		 */
		setBatchUpdateMode? (batchUpdateMode: string): void;
		/** 
		 * Sets the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearOnPageLoad The new value.
		 * @returns {void}                    
		 */
		setClearOnPageLoad? (clearOnPageLoad: boolean): void;
		/** 
		 * Sets the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearRemovedOnLoad The new value.
		 * @returns {void}                       
		 */
		setClearRemovedOnLoad? (clearRemovedOnLoad: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                                         name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                                [value] The value to set for the name parameter.
		 * @returns {Ext.data.JsonStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.JsonStore;
		setConfig? (name: string | object, value?: object): Ext.data.Store;
		setConfig? (name: string | object, value?: object): Ext.data.ProxyStore;
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Loads an array of data directly into the Store.
		 * 
		 * setData() is ideal if your data's format is already in its appropriate format (e.g. it doesn't need to be
		 * processed by a reader). If your data's structure requires processing, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * 
		 * Use [loadData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadData), [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add), or [insert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-insert) if records need to be
		 * appended to the current recordset.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @returns {void}                           
		 */
		setData? (data: Ext.data.Model[] | object[]): void;
		/** 
		 * Sets the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @param   {object} extraKeys The new value.
		 * @returns {void}             
		 */
		setExtraKeys? (extraKeys: object): void;
		/** 
		 * Sets the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @param   {object[]|string[]} fields The new value.
		 * @returns {void}                     
		 */
		setFields? (fields: object[] | string[]): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setFilters? (): void;
		/** 
		 * Sets the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @param   {string} groupDir The new value.
		 * @returns {void}            
		 */
		setGroupDir? (groupDir: string): void;
		/** 
		 * Sets the value of [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField).
		 * @method
		 * @public (method)
		 * @param   {string} groupField The new value.
		 * @returns {void}              
		 */
		setGroupField? (groupField: string): void;
		/** 
		 * Sets the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.util.Grouper} grouper The new value.
		 * @returns {void}                            
		 */
		setGrouper? (grouper: object | Ext.util.Grouper): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @param   {number} pageSize The new value.
		 * @returns {void}            
		 */
		setPageSize? (pageSize: number): void;
		/** 
		 * Sets the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.proxy.Proxy|object} proxy The new value.
		 * @returns {void}                                     
		 */
		setProxy? (proxy: string | Ext.data.proxy.Proxy | object): void;
		/** 
		 * Sets the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteFilter The new value.
		 * @returns {void}                 
		 */
		setRemoteFilter? (remoteFilter: boolean): void;
		/** 
		 * Sets the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteSort The new value.
		 * @returns {void}               
		 */
		setRemoteSort? (remoteSort: boolean): void;
		/** 
		 * Sets the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} session The new value.
		 * @returns {void}                     
		 */
		setSession? (session: Ext.data.Session): void;
		/** 
		 * Sets the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} sortOnLoad The new value.
		 * @returns {void}               
		 */
		setSortOnLoad? (sortOnLoad: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setSorters? (): void;
		/** 
		 * Sets the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @param   {boolean} statefulFilters The new value.
		 * @returns {void}                    
		 */
		setStatefulFilters? (statefulFilters: boolean): void;
		/** 
		 * Sets the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @param   {string} storeId The new value.
		 * @returns {void}           
		 */
		setStoreId? (storeId: string): void;
		/** 
		 * Sets the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @param   {boolean} trackRemoved The new value.
		 * @returns {void}                 
		 */
		setTrackRemoved? (trackRemoved: boolean): void;
		/** 
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction] The overall direction to sort the data by.
		 * @returns {Ext.util.Sorter[]}                    
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string): Ext.util.Sorter[];
		/** 
		 * Sums the value of `field` for each [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in store
		 * and returns the result.
		 * 
		 * When store is filtered, only sums items within the filter.
		 * @method
		 * @public (method)
		 * @param   {string}  field     A field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the sum for that group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            The sum
		 */
		sum? (field: string, grouped?: boolean): number;
		/** 
		 * Suspends automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendAutoSync? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Inherit docs
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		contains? (record: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.contains](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-contains).
		 * Checks if a record is in the current active data set.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record
		 * @returns {void|boolean}          `true` if the record is in the current active data set.
		 */
		contains? (record: Ext.data.Model): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		doDestroy? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                                config
		 * @returns {Ext.data.JsonStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.JsonStore;
		initConfig? (config: object): Ext.data.Store;
		initConfig? (config: object): Ext.data.ProxyStore;
		initConfig? (config: object): Ext.data.AbstractStore;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Called internally when a Proxy has completed a load request
		 * @method
		 * @protected (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyLoad? (operation: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.JsonStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.JsonStore.Statics;
		statics? (): Ext.data.Store.Statics;
		statics? (): Ext.data.ProxyStore.Statics;
		statics? (): Ext.data.AbstractStore.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorter
		 * @returns {void}          
		 */
		addFieldTransform? (sorter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		addObserver? (observer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @param   {object} type
		 * @returns {void}                      
		 */
		afterChange? (record: object, modifiedFieldNames: object, type: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterCommit? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterDrop? (record: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @returns {void}                      
		 */
		afterEdit? (record: object, modifiedFieldNames: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterErase? (record: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to..
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterReject? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} asynchronousLoad
		 * @returns {void}                    
		 */
		applyAsynchronousLoad? (asynchronousLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} extraKeys
		 * @returns {void}             
		 */
		applyExtraKeys? (extraKeys: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fields
		 * @returns {void}          
		 */
		applyFields? (fields: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @param   {object} filtersCollection
		 * @returns {void}                     
		 */
		applyFilters? (filters: object, filtersCollection: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} grouper
		 * @returns {void}           
		 */
		applyGrouper? (grouper: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @returns {void}         
		 */
		applyProxy? (proxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorters
		 * @param   {object} sortersCollection
		 * @returns {void}                     
		 */
		applySorters? (sorters: object, sortersCollection: object): void;
		/** 
		 * Restores state to the passed state
		 * @method
		 * @private (method)
		 * @param   {object} state
		 * @returns {void}         
		 */
		applyState? (state: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} args
		 * @returns {void}          
		 */
		callObservers? (action: object, args: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} isLoad
		 * @returns {void}          
		 */
		clearData? (isLoad: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.clearData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-clearData).
		 * to be implemented by subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearData? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		constructDataCollection? (): void;
		/** 
		 * saves any phantom records
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @param   {object} options
		 * @returns {void}           
		 */
		create? (data: object, options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createFiltersCollection? (): void;
		/** 
		 * Converts a literal to a model, if it's not a model already
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model|object} record The record to create
		 * @returns {Ext.data.Model}               
		 */
		createModel? (record: Ext.data.Model | object): Ext.data.Model;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createSortersCollection? (): void;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * tells the attached proxy to destroy the given records
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		erase? (options: object): void;
		/** 
		 * Similar to a load, however no records are added to the store. This is useful
		 * in allowing the developer to decide what to do with the new records.
		 * @method
		 * @private (method)
		 * @param   {object} [options] See [load options](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		fetch? (options?: object): void;
		/** 
		 * private
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @returns {void}      
		 */
		filterDataSource? (fn: object): void;
		/** 
		 * Filter function for new records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNew? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNewOnly? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterRejects? (item: object): void;
		/** 
		 * Filter function for updated records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterUpdated? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		fireGroupChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		forceLocalSort? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @param   {object} scope
		 * @param   {object} records
		 * @param   {object} field
		 * @returns {void}           
		 */
		getAggregate? (fn: object, scope: object, records: object, field: object): void;
		/** 
		 * Returns the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.Model}  
		 */
		getAssociatedEntity? (): Ext.data.Model;
		/** 
		 * Returns the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getAutoSort? (): boolean;
		/** 
		 * Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
		 * This is broken out into a separate function to allow for customisation of the listeners
		 * @method
		 * @private (method)
		 * @returns {object}  The listeners object
		 */
		getBatchListeners? (): object;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Returns the complete unfiltered collection.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getDataSource? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getGroupField? (): void;
		/** 
		 * Returns the array of records which have been removed since the last time this store was synced.
		 * 
		 * This is used internally, when purging removed records after a successful sync.
		 * This is overridden by TreeStore because TreeStore accumulates deleted records on removal
		 * of child nodes from their parent, _not_ on removal of records from its collection. The collection
		 * has records added on expand, and removed on collapse.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRawRemovedRecords? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRejectRecords? (): void;
		/** 
		 * Returns the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.schema.Role}  
		 */
		getRole? (): Ext.data.schema.Role;
		/** 
		 * Returns the grouping, sorting and filtered state of this Store.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getState? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Returns true if the store has a pending load task.
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the store has a pending load task.
		 */
		hasPendingLoad? (): boolean;
		/** 
		 * Checks whether records are being moved within the store. This can be used in conjunction with the
		 * [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-add) and [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events to determine whether the records are being removed/added
		 * or just having the position changed.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]|Ext.data.Model} [records] The record(s).
		 * @returns {number}                          
		 * The number of records being moved. `0` if no records are moving. If records are passed
		 * the number will refer to how many of the passed records are moving.
		 */
		isMoving? (records?: Ext.data.Model[] | Ext.data.Model): number;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @returns {void}        
		 */
		loadInlineData? (data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		notifySorterChange? (): void;
		/** 
		 * Attached as the 'complete' event listener to a proxy's Batch object. Iterates over the batch operations
		 * and updates the Store's internal data MixedCollection.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchComplete? (batch: object, operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchException? (batch: object, operation: object): void;
		/** 
		 * Attached as the 'operationcomplete' event listener to a proxy's Batch object. By default just calls through
		 * to onProxyWrite.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchOperationComplete? (batch: object, operation: object): void;
		/** 
		 * This is attached to the data Collection's beforesort event only if not remoteSort
		 * If remoteSort, the event is fired before the reload call in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-load).
		 * @method
		 * @private (method)
		 * @param   {object} store
		 * @param   {object} sorters
		 * @returns {void}           
		 */
		onBeforeCollectionSort? (store: object, sorters: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} cls
		 * @param   {object} data
		 * @param   {object} hooks
		 * @returns {void}         
		 */
		onClassExtended? (cls: object, data: object, hooks: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} records
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionAddItems? (collection: object, records: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionBeforeItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionBeginUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionEndUpdate? (): void;
		/** 
		 * When the collection informs us that it has filtered, this LocalStore must react.
		 * AbstractStore#onFilterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilter? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} items
		 * @returns {void}              
		 */
		onCollectionFilterAdd? (collection: object, items: object): void;
		/** 
		 * If our source collection informs us that a filtered out item has changed, we must still fire the events...
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilteredItemChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionRemove? (collection: object, info: object): void;
		/** 
		 * When the collection informs us that it has sorted, this LocalStore must react.
		 * AbstractStore#onSorterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionSort? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCreateRecords? (): void;
		/** 
		 * Removes any records when a write is returned from the server.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]}             records   The array of removed records
		 * @param   {Ext.data.operation.Operation} operation The operation that just completed
		 * @param   {boolean}                      success   True if the operation was successful
		 * @returns {void}                                   
		 */
		onDestroyRecords? (records: Ext.data.Model[], operation: Ext.data.operation.Operation, success: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onErase? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onFilterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} rec
		 * @param   {object} oldId
		 * @param   {object} newId
		 * @returns {void}         
		 */
		onIdChanged? (rec: object, oldId: object, newId: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} meta
		 * @returns {void}         
		 */
		onMetaChange? (proxy: object, meta: object): void;
		/** 
		 * Callback for any write Operation over the Proxy. Updates the Store's MixedCollection to reflect
		 * the updates provided by the Proxy
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyWrite? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onSorterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdate? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdateRecords? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Query all the cached records in this Store by field.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @private (method)
		 * @param   {string}           field The field from each record to use.
		 * @param   {object}           value The value to match.
		 * @returns {Ext.data.Model[]}       The matched records.
		 */
		queryRecords? (field: string, value: object): Ext.data.Model[];
		/** 
		 * Determines if the passed range is available in the page cache.
		 * @method
		 * @private (method)
		 * @param   {number} start The start index
		 * @param   {number} end   The end index in the range
		 * @returns {void}         
		 */
		rangeCached? (start: number, end: number): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		removeObserver? (observer: object): void;
		/** 
		 * Sets the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} associatedEntity The new value.
		 * @returns {void}                            
		 */
		setAssociatedEntity? (associatedEntity: Ext.data.Model): void;
		/** 
		 * Sets the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @param   {boolean} autoSort The new value.
		 * @returns {void}             
		 */
		setAutoSort? (autoSort: boolean): void;
		/** 
		 * Make a set of records be current in the store. This means that unneeded records
		 * will be removed and new records will be added.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]} records The records to be current in the store.
		 * @returns {void}                     
		 */
		setRecords? (records: Ext.data.Model[]): void;
		/** 
		 * Sets the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.schema.Role} role The new value.
		 * @returns {void}                      
		 */
		setRole? (role: Ext.data.schema.Role): void;
		/** 
		 * This method is basically the same as the JavaScript Array splice method.
		 * 
		 * Negative indexes are interpreted starting at the end of the collection. That is,
		 * a value of -1 indicates the last item, or equivalent to `length - 1`.
		 * @method
		 * @private (method)
		 * @param   {number}          index    The index at which to add or remove items.
		 * @param   {number|object[]} toRemove
		 * The number of items to remove or an array of the
		 * items to remove.
		 * @param   {object[]}        [toAdd]  The items to insert at the given `index`.
		 * @returns {void}                     
		 */
		splice? (index: number, toRemove: number | object[], toAdd?: object[]): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                              names The names of the linked objects to destroy.
		 * @returns {Ext.data.JsonStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.JsonStore;
		unlink? (names: string[]): Ext.data.Store;
		unlink? (names: string[]): Ext.data.ProxyStore;
		unlink? (names: string[]): Ext.data.AbstractStore;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		update? (options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoLoad
		 * @returns {void}            
		 */
		updateAutoLoad? (autoLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoSort
		 * @returns {void}            
		 */
		updateAutoSort? (autoSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} field
		 * @returns {void}         
		 */
		updateGroupField? (field: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} oldProxy
		 * @returns {void}            
		 */
		updateProxy? (proxy: object, oldProxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @returns {void}                
		 */
		updateRemoteFilter? (remoteFilter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @returns {void}              
		 */
		updateRemoteSort? (remoteSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} track
		 * @returns {void}         
		 */
		updateTrackRemoved? (track: object): void;
	}
	/** 
	 * A mixin that provides common store methods for [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) &amp; [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html).
	 * @private (class)
	 */
	class LocalStore extends Ext.Mixin {}
	/** 
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html)
	 * A Model or Entity represents some object that your application manages. For example, one
	 * might define a Model for Users, Products, Cars, or other real-world object that we want
	 * to model in the system. Models are used by [stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html), which are in
	 * turn used by many of the data-bound components in Ext.
	 * 
	 * # Fields
	 * 
	 * Models are defined as a set of fields and any arbitrary methods and properties relevant
	 * to the model. For example:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            {name: 'name',  type: 'string'},
	 *            {name: 'age',   type: 'int', convert: null},
	 *            {name: 'phone', type: 'string'},
	 *            {name: 'alive', type: 'boolean', defaultValue: true, convert: null}
	 *        ],
	 *    
	 *        changeName: function() {
	 *            var oldName = this.get('name'),
	 *                newName = oldName + " The Barbarian";
	 *    
	 *            this.set('name', newName);
	 *        }
	 *    });
	 * 
	 * Now we can create instances of our User model and call any model logic we defined:
	 * 
	 *    var user = Ext.create('User', {
	 *        id   : 'ABCD12345',
	 *        name : 'Conan',
	 *        age  : 24,
	 *        phone: '555-555-5555'
	 *    });
	 *    
	 *    user.changeName();
	 *    user.get('name'); //returns "Conan The Barbarian"
	 * 
	 * By default, the built in field types such as number and boolean coerce string values
	 * in the raw data by virtue of their [Ext.data.field.Field.convert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#method-convert) method.
	 * When the server can be relied upon to send data in a format that does not need to be
	 * converted, disabling this can improve performance. The [Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html)
	 * and [Array](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Array.html) readers are likely candidates for this
	 * optimization. To disable field conversions you simply specify `null` for the field's
	 * [convert config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-convert).
	 * 
	 * ## The "id" Field and `idProperty`
	 * 
	 * A Model definition always has an _identifying field_ which should yield a unique key
	 * for each instance. By default, a field named "id" will be created with a
	 * [mapping](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-mapping) of "id". This happens because of the default
	 * [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) provided in Model definitions.
	 * 
	 * To alter which field is the identifying field, use the [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) config.
	 * 
	 * # Validators
	 * 
	 * Models have built-in support for field validators. Validators are added to models as in
	 * the follow example:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            { name: 'name',     type: 'string' },
	 *            { name: 'age',      type: 'int' },
	 *            { name: 'phone',    type: 'string' },
	 *            { name: 'gender',   type: 'string' },
	 *            { name: 'username', type: 'string' },
	 *            { name: 'alive',    type: 'boolean', defaultValue: true }
	 *        ],
	 *    
	 *        validators: {
	 *            age: 'presence',
	 *            name: { type: 'length', min: 2 },
	 *            gender: { type: 'inclusion', list: ['Male', 'Female'] },
	 *            username: [
	 *                { type: 'exclusion', list: ['Admin', 'Operator'] },
	 *                { type: 'format', matcher: /([a-z]+)[0-9]{2,3}/i }
	 *            ]
	 *        }
	 *    });
	 * 
	 * The derived type of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) can also provide validation. If `validators`
	 * need to be duplicated on multiple fields, instead consider creating a custom field type.
	 * 
	 * ## Validation
	 * 
	 * The results of the validators can be retrieved via the "associated" validation record:
	 * 
	 *    var instance = Ext.create('User', {
	 *        name: 'Ed',
	 *        gender: 'Male',
	 *        username: 'edspencer'
	 *    });
	 *    
	 *    var validation = instance.getValidation();
	 * 
	 * The returned object is an instance of [`Ext.data.Validation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html) and has as its fields the
	 * result of the field `validators`. The validation object is "dirty" if there are one or
	 * more validation errors present.
	 * 
	 * This record is also available when using data binding as a "pseudo-association" called
	 * "validation". This pseudo-association can be hidden by an explicitly declared
	 * association by the same name (for compatibility reasons), but doing so is not
	 * recommended.
	 * 
	 * The `Ext.Component.modelValidation` config can be used to enable automatic
	 * binding from the "validation" of a record to the form fields that may be bound to its
	 * values.
	 * 
	 * # Associations
	 * 
	 * Models often have associations with other Models. These associations can be defined by
	 * fields (often called "foreign keys") or by other data such as a many-to-many (or "matrix").
	 * See [Ext.data.schema.Association](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Association.html) for information about configuring and using associations.
	 * 
	 * # Using a Proxy
	 * 
	 * Models are great for representing types of data and relationships, but sooner or later we're going to want to load or
	 * save that data somewhere. All loading and saving of data is handled via a [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html), which
	 * can be set directly on the Model:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email'],
	 *    
	 *        proxy: {
	 *            type: 'rest',
	 *            url : '/users'
	 *        }
	 *    });
	 * 
	 * Here we've set up a [Rest Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Rest.html), which knows how to load and save data to and from a
	 * RESTful backend. Let's see how this works:
	 * 
	 *    var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
	 *    
	 *    user.save(); //POST /users
	 * 
	 * Calling [save](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-save) on the new Model instance tells the configured RestProxy that we wish to persist this Model's
	 * data onto our server. RestProxy figures out that this Model hasn't been saved before because it doesn't have an id,
	 * and performs the appropriate action - in this case issuing a POST request to the url we configured (/users). We
	 * configure any Proxy on any Model and always follow this API - see [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) for a full list.
	 * 
	 * Loading data via the Proxy is accomplished with the static `load` method:
	 * 
	 *    //Uses the configured RestProxy to make a GET request to /users/123
	 *    User.load(123, {
	 *        success: function(user) {
	 *            console.log(user.getId()); //logs 123
	 *        }
	 *    });
	 * 
	 * Models can also be updated and destroyed easily:
	 * 
	 *    //the user Model we loaded in the last snippet:
	 *    user.set('name', 'Edward Spencer');
	 *    
	 *    //tells the Proxy to save the Model. In this case it will perform a PUT request to /users/123 as this Model already has an id
	 *    user.save({
	 *        success: function() {
	 *            console.log('The User was updated');
	 *        }
	 *    });
	 *    
	 *    //tells the Proxy to destroy the Model. Performs a DELETE request to /users/123
	 *    user.erase({
	 *        success: function() {
	 *            console.log('The User was destroyed!');
	 *        }
	 *    });
	 * 
	 * # HTTP Parameter names when using a [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html)
	 * 
	 * By default, the model ID is specified in an HTTP parameter named `id`. To change the
	 * name of this parameter use the Proxy's [idParam](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-idParam)
	 * configuration.
	 * 
	 * Parameters for other commonly passed values such as
	 * [page number](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-pageParam) or
	 * [start row](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-startParam) may also be configured.
	 * 
	 * # Usage in Stores
	 * 
	 * It is very common to want to load a set of Model instances to be displayed and manipulated in the UI. We do this by
	 * creating a [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html):
	 * 
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User'
	 *    });
	 *    
	 *    //uses the Proxy we set up on Model to load the Store data
	 *    store.load();
	 * 
	 * A Store is just a collection of Model instances - usually loaded from a server somewhere. Store can also maintain a
	 * set of added, updated and removed Model instances to be synchronized with the server via the Proxy. See the [Store docs](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) for more information on Stores.
	 */
	class Model extends Ext.Base {
		/** 
		 * The default proxy to use for instances of this Model when no proxy is configured
		 * on the instance.  When specified, the model will use this proxy instead of
		 * requesting one from the [Session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html).
		 * 
		 * Can be a string "type", or a [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) config object.
		 * 
		 * This proxy is not inherited by subclasses.
		 * @property
		 * @protected (property)
		 * @static
		 * @default 'memory'
		 * @type {string|object}
		 */
		static defaultProxy?: string | object;
		/** 
		 * True if this record has been modified.
		 * @property
		 * @public (property)
		 * @readonly
		 * @default false
		 * @type {boolean}
		 */
		readonly dirty?: boolean;
		/** 
		 * True if this record is pending delete on the server. This is set by the `drop`
		 * method and transmitted to the server by the `save` method.
		 * @property
		 * @public (property)
		 * @readonly
		 * @default false
		 * @type {boolean}
		 */
		readonly dropped?: boolean;
		/** 
		 * Internal flag used to track whether or not the model instance is currently being edited.
		 * @property
		 * @public (property)
		 * @readonly
		 * @default false
		 * @type {boolean}
		 */
		readonly editing?: boolean;
		/** 
		 * The short name of this entity class. This name is derived from the `namespace` of
		 * the associated `schema` and this class name. By default, a class is not given a
		 * shortened name.
		 * 
		 * All entities in a given `schema` must have a unique `entityName`.
		 * 
		 * For more details see "Relative Naming" in [Ext.data.schema.Schema](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Schema.html).
		 * @property
		 * @public (property)
		 * @type {string}
		 */
		entityName?: string;
		/** 
		 * True if this record has been erased on the server. This flag is set of the `erase`
		 * method.
		 * @property
		 * @public (property)
		 * @readonly
		 * @default false
		 * @type {boolean}
		 */
		readonly erased?: boolean;
		/** 
		 * This property is incremented on each modification of a record.
		 * @property
		 * @public (property)
		 * @readonly
		 * @default 1
		 * @type {number}
		 */
		readonly generation?: number;
		/** 
		 * The value `true` to identify this class and its subclasses.
		 * @property
		 * @public (property)
		 * @readonly
		 * @default true
		 * @type {boolean}
		 */
		readonly isEntity?: boolean;
		/** 
		 * The value `true` to identify this class and its subclasses.
		 * @property
		 * @public (property)
		 * @readonly
		 * @default true
		 * @type {boolean}
		 */
		readonly isModel?: boolean;
		/** 
		 * A hash of field values which holds the initial values of fields before a set of edits
		 * are [committed](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-commit).
		 * @property
		 * @public (property)
		 * @type {object}
		 */
		modified?: object;
		/** 
		 * True when the record does not yet exist in a server-side database. Any record which
		 * has a real database identity set as its `idProperty` is NOT a phantom -- it's real.
		 * @property
		 * @public (property)
		 * @default false
		 * @type {boolean}
		 */
		phantom?: boolean;
		/** 
		 * The [`Ext.data.schema.Schema`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Schema.html) to which this entity and its associations belong.
		 * @property
		 * @public (property)
		 * @readonly
		 * @default 'default'
		 * @type {Ext.data.schema.Schema}
		 */
		readonly schema?: Ext.data.schema.Schema;
		/** 
		 * The [Ext.data.Session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html) for this record.
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {Ext.data.Session}
		 */
		readonly session?: Ext.data.Session;
		/** 
		 * The [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) to which this instance belongs.
		 * 
		 * **Note:** If this instance is bound to multiple stores, this property
		 * will reference only the first.
		 * @property
		 * @public (property)
		 * @type {Ext.data.Store}
		 */
		store?: Ext.data.Store;
		/** 
		 * This value is initially "R" or "C" indicating the initial CRUD state. As the
		 * record changes and the various joined parties (stores, sessions, etc.) are notified
		 * this value is updated prior to these calls. In other words, the joined parties
		 * are notified after the `crudState` is updated. This means that the `crudState`
		 * property may be briefly out of sync with underlying changes if this state is used
		 * outside of these notifications.
		 * 
		 * The possible states have these meanings:
		 * 
		 * - "R" - The record is in a cleanly retrieved (unmodified) state.
		 * - "C" - The record is in a newly created (`phantom`) state.
		 * - "U" - The record is in an updated, `modified` (`dirty`) state.
		 * - "D" - The record is in a `dropped` state.
		 * @property
		 * @protected (property)
		 * @readonly
		 * @default 'R'
		 * @type {'C'|'R'|'U'|'D'}
		 */
		readonly crudState?: 'C' | 'R' | 'U' | 'D';
		/** 
		 * This value is initially `null` indicating there is no previous CRUD state. As the
		 * record changes and the various joined parties (stores, sessions, etc.) are notified
		 * this value is updated for the _subsequent_ calls. In other words, the joined parties
		 * are notified and then `crudStateWas` is modified for the next update.
		 * 
		 * The value of this property has the same meaning as `crudState`.
		 * @property
		 * @protected (property)
		 * @readonly
		 * @type {'C'|'R'|'U'|'D'}
		 */
		readonly crudStateWas?: 'C' | 'R' | 'U' | 'D';
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.Model.Statics}
		 */
		self?: Ext.data.Model.Statics | Ext.Base.Statics;
		/** 
		 * @property
		 * @private (property)
		 * @default {convert: false, silent: true}
		 * @type {object}
		 */
		_rejectOptions?: object;
		/** 
		 * This object is used whenever the set() method is called and given a string as the
		 * first argument. This approach saves memory (and GC costs) since we could be called
		 * a lot.
		 * @property
		 * @private (property)
		 * @default {}
		 * @type {object}
		 */
		_singleProp?: object;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		deprecated?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		erasing?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		evented?: boolean;
		/** 
		 * This property is indexed by field name and contains the ordinal of that field. The
		 * ordinal often has meaning to servers and is derived based on the position in the
		 * `fields` array.
		 * 
		 * This can be used like so:
		 * 
		 *     Ext.define('MyApp.models.User', {
		 *         extend: 'Ext.data.Model',
		 *    
		 *         fields: [
		 *             { name: 'name' }
		 *         ]
		 *     });
		 *    
		 *     var nameOrdinal = MyApp.models.User.fieldOrdinals.name;
		 *    
		 *     // or, if you have an instance:
		 *    
		 *     var user = new MyApp.models.User();
		 *     var nameOrdinal = user.fieldOrdinals.name;
		 * 
		 * @property
		 * @private (property)
		 * @readonly
		 * @type {object}
		 */
		readonly fieldOrdinals?: object;
		/** 
		 * An array fields defined for this Model (including fields defined in superclasses)
		 * in ordinal order; that is in declaration order.
		 * @property
		 * @private (property)
		 * @readonly
		 * @type {Ext.data.field.Field[]}
		 */
		readonly fields?: Ext.data.field.Field[];
		/** 
		 * @property
		 * @private (property)
		 * @default 'record'
		 * @type {string}
		 */
		observableType?: string;
		/** 
		 * This object is similar to the `modified` object except it holds the data values as
		 * they were prior to the most recent change.
		 * @property
		 * @private (property)
		 * @readonly
		 * @type {object}
		 */
		readonly previousValues?: object;
		/** 
		 * ---
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Record ids are more flexible.
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		validIdRe?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members    The members to add to this class.
		 * @param   {boolean}                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Model|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Model;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members
		 * @returns {Ext.data.Model|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.Model;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Returns the configured Proxy for this Model.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {Ext.data.proxy.Proxy}  The proxy
		 */
		static getProxy? (): Ext.data.proxy.Proxy;
		/** 
		 * Asynchronously loads a model instance by id. Any processing of the loaded
		 * record should be done in a callback.
		 * 
		 * Sample usage:
		 * 
		 *    Ext.define('MyApp.User', {
		 *        extend: 'Ext.data.Model',
		 *        fields: [
		 *            {name: 'id', type: 'int'},
		 *            {name: 'name', type: 'string'}
		 *        ]
		 *    });
		 *    
		 *    MyApp.User.load(10, {
		 *        scope: this,
		 *        failure: function(record, operation) {
		 *            //do something if the load failed
		 *        },
		 *        success: function(record, operation) {
		 *            //do something if the load succeeded
		 *        },
		 *        callback: function(record, operation, success) {
		 *            //do something whether the load succeeded or failed
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {number|string}                                         id
		 * The ID of the model to load.
		 * **NOTE:** The model returned must have an ID matching the param in the load
		 * request.
		 * @param   {object|Ext.data.Model.staticMethodParams.load.Options} [options]
		 * The options param is an
		 * [Ext.data.operation.Read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) config object containing success, failure and
		 * callback functions, plus optional scope.
		 * @param   {Ext.data.Session}                                      [session] The session for this record.
		 * @returns {Ext.data.Model}                                        
		 * The newly created model. Note that the model will
		 * (probably) still be loading once it is returned from this method. To do any
		 * post-processing on the data, the appropriate place to do see is in the
		 * callback.
		 */
		static load? (id: number | string, options?: object | Ext.data.Model.staticMethodParams.load.Options, session?: Ext.data.Session): Ext.data.Model;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * Sets the Proxy to use for this model. Accepts any options that can be accepted by
		 * [Ext.createByAlias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-createByAlias).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object|Ext.data.proxy.Proxy} proxy The proxy
		 * @returns {Ext.data.proxy.Proxy}                     
		 */
		static setProxy? (proxy: string | object | Ext.data.proxy.Proxy): Ext.data.proxy.Proxy;
		/** 
		 * This method adds the given set of fields to this model class.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {string[]|object[]} newFields
		 * The new fields to add. Based on the `name`
		 * of a field this may replace a previous field definition.
		 * @returns {void}                        
		 */
		static addFields? (newFields: string[] | object[]): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Removes the given set of fields from this model.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {boolean|string[]} removeFields
		 * The names of fields to remove or `true`
		 * to remove all existing fields. Removes are processed first followed by adds so
		 * if a field name appears in `newFields` as well that field will effectively be
		 * added (however, in that case there is no need to include the field in this
		 * array).
		 * @returns {void}                          
		 */
		static removeFields? (removeFields: boolean | string[]): void;
		/** 
		 * This method replaces the specified set of fields with a given set of new fields.
		 * Fields should normally be considered immutable, but if the timing is right (that
		 * is, before derived classes are declared), it is permissible to change the fields
		 * collection.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {string[]|object[]} newFields
		 * The new fields to add. Based on the `name`
		 * of a field this may replace a previous field definition.
		 * @param   {boolean|string[]}  removeFields
		 * The names of fields to remove or `true`
		 * to remove all existing fields. Removes are processed first followed by adds so
		 * if a field name appears in `newFields` as well that field will effectively be
		 * added (however, in that case there is no need to include the field in this
		 * array).
		 * @returns {void}                           
		 */
		static replaceFields? (newFields: string[] | object[], removeFields: boolean | string[]): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  name
		 * @param   {object}                  member
		 * @returns {Ext.data.Model|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.Model;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} id
		 * @param   {object} data
		 * @param   {object} session
		 * @returns {void}           
		 */
		static createWithId? (id: object, data: object, session: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @returns {void}        
		 */
		static getField? (name: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static getFields? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static getFieldsMap? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} data
		 * @returns {void}        
		 */
		static getIdFromData? (data: object): void;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  fn
		 * @param   {object}                  scope
		 * @returns {Ext.data.Model|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.Model;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} data
		 * @param   {object} session
		 */
		constructor (data: object, session: object);
		/** 
		 * Aborts a pending [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-load) operation. If the record is not loading, this does nothing.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		abort? (): void;
		/** 
		 * Begins an edit. While in edit mode, no events (e.g.. the `update` event) are
		 * relayed to the containing store. When an edit has begun, it must be followed by
		 * either `endEdit` or `cancelEdit`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginEdit? (): void;
		/** 
		 * Cancels all changes made in the current edit operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		cancelEdit? (): void;
		/** 
		 * Creates a clone of this record. States like `dropped`, `phantom` and `dirty` are
		 * all preserved in the cloned record.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} [session]
		 * The session to which the new record
		 * belongs.
		 * @returns {Ext.data.Model}             The cloned record.
		 */
		clone? (session?: Ext.data.Session): Ext.data.Model;
		/** 
		 * Usually called by the [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) which owns the model instance. Commits all changes made to the
		 * instance since either creation or the last commit operation.
		 * 
		 * Developers should subscribe to the [Ext.data.Store.update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-update) event to have their code notified of commit
		 * operations.
		 * @method
		 * @public (method)
		 * @param   {boolean}  [silent]             Pass `true` to skip notification of the owning store of the change.
		 * @param   {string[]} [modifiedFieldNames]
		 * Array of field names changed during sync with server if known.
		 * Omit or pass `null` if unknown. An empty array means that it is known that no fields were modified
		 * by the server's response.
		 * Defaults to false.
		 * @returns {void}                          
		 */
		commit? (silent?: boolean, modifiedFieldNames?: string[]): void;
		/** 
		 * Creates a clean copy of this record. The returned record will not consider any its
		 * fields as modified.
		 * 
		 * To generate a phantom instance with a new id pass `null`:
		 * 
		 *    var rec = record.copy(null); // clone the record but no id (one is generated)
		 * 
		 * @method
		 * @public (method)
		 * @param   {string}           [newId]
		 * A new id, defaults to the id of the instance being copied.
		 * See [`idProperty`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty).
		 * @param   {Ext.data.Session} [session]
		 * The session to which the new record
		 * belongs.
		 * @returns {Ext.data.Model}             
		 */
		copy? (newId?: string, session?: Ext.data.Session): Ext.data.Model;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Marks this record as `dropped` and waiting to be deleted on the server. When a
		 * record is dropped, it is automatically removed from all association stores and
		 * any child records associated to this record are also dropped (a "cascade delete")
		 * depending on the `cascade` parameter.
		 * @method
		 * @public (method)
		 * @param   {boolean} [cascade]
		 * Pass `false` to disable the cascade to drop child
		 * records.
		 * @returns {void}              
		 */
		drop? (cascade?: boolean): void;
		/** 
		 * Ends an edit. If any data was modified, the containing store is notified
		 * (ie, the store's `update` event will fire).
		 * @method
		 * @public (method)
		 * @param   {boolean}  [silent]             True to not notify any stores of the change.
		 * @param   {string[]} [modifiedFieldNames] Array of field names changed during edit.
		 * @returns {void}                          
		 */
		endEdit? (silent?: boolean, modifiedFieldNames?: string[]): void;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object|Ext.data.Model.methodParams.erase.Options} [options] Options to pass to the proxy.
		 * @returns {Ext.data.operation.Destroy}                                 The destroy operation
		 */
		erase? (options?: object | Ext.data.Model.methodParams.erase.Options): Ext.data.operation.Destroy;
		/** 
		 * Returns the value of the given field.
		 * @method
		 * @public (method)
		 * @param   {string} fieldName The name of the field.
		 * @returns {object}           The value of the specified field.
		 */
		get? (fieldName: string): object;
		/** 
		 * Gets all of the data from this Models _loaded_ associations. It does this
		 * recursively. For example if we have a User which hasMany Orders, and each Order
		 * hasMany OrderItems, it will return an object like this:
		 * 
		 *    {
		 *        orders: [
		 *            {
		 *                id: 123,
		 *                status: 'shipped',
		 *                orderItems: [
		 *                    ...
		 *                ]
		 *            }
		 *        ]
		 *    }
		 * 
		 * @method
		 * @public (method)
		 * @param   {object}                                                               [result]
		 * The object on to which the associations will be added. If
		 * no object is passed one is created. This object is then returned.
		 * @param   {boolean|object|Ext.data.Model.methodParams.getAssociatedData.Options} [options]
		 * An object containing options describing the data
		 * desired.
		 * @returns {object}                                                                         The nested data set for the Model's loaded associations.
		 */
		getAssociatedData? (result?: object, options?: boolean | object | Ext.data.Model.methodParams.getAssociatedData.Options): object;
		/** 
		 * Gets an object of only the fields that have been modified since this record was
		 * created or committed. Only persistent fields are tracked in the `modified` set so
		 * this method will only return changes to persistent fields.
		 * 
		 * For more control over the returned data, see [`getData`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-getData).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getChanges? (): object;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the array of fields that are declared as critical (must always send).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.field.Field[]}  
		 */
		getCriticalFields? (): Ext.data.field.Field[];
		/** 
		 * Gets all values for each field in this model and returns an object containing the
		 * current data. This can be tuned by passing an `options` object with various
		 * properties describing the desired result. Passing `true` simply returns all fields
		 * _and_ all associated record data.
		 * @method
		 * @public (method)
		 * @param   {boolean|object|Ext.data.Model.methodParams.getData.Options} [options]
		 * An object containing options describing the data
		 * desired. If `true` is passed it is treated as an object with `associated` set to
		 * `true`.
		 * @returns {object}                                                               An object containing all the values in this model.
		 */
		getData? (options?: boolean | object | Ext.data.Model.methodParams.getData.Options): object;
		/** 
		 * Get the fields array for this model.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.field.Field[]}  The fields array
		 */
		getFields? (): Ext.data.field.Field[];
		/** 
		 * Returns the unique ID allocated to this model instance as defined by `idProperty`.
		 * @method
		 * @public (method)
		 * @returns {number|string}  The id
		 */
		getId? (): number | string;
		/** 
		 * Get the idProperty for this model.
		 * @method
		 * @public (method)
		 * @returns {string}  The idProperty
		 */
		getIdProperty? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the original value of a modified field. If there is no modified value,
		 * `undefined` will be return. Also see [isModified](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-isModified).
		 * @method
		 * @public (method)
		 * @param   {string} fieldName The name of the field for which to return the original value.
		 * @returns {object}           modified
		 */
		getModified? (fieldName: string): object;
		/** 
		 * This method returns the value of a field given its name prior to its most recent
		 * change.
		 * @method
		 * @public (method)
		 * @param   {string} fieldName The field's [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name).
		 * @returns {object} 
		 * The value of the given field prior to its current value. `undefined`
		 * if there is no previous value;
		 */
		getPrevious? (fieldName: string): object;
		/** 
		 * Returns the configured Proxy for this Model.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.proxy.Proxy}  The proxy
		 */
		getProxy? (): Ext.data.proxy.Proxy;
		/** 
		 * Returns the array of fields that are declared as non-persist or "transient".
		 * @method
		 * @public (method)
		 * @returns {Ext.data.field.Field[]}  
		 */
		getTransientFields? (): Ext.data.field.Field[];
		/** 
		 * Returns the [`Ext.data.Validation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html) record holding the results of this record's
		 * `validators`. This record is lazily created on first request and is then kept on
		 * this record to be updated later.
		 * 
		 * See the class description for more about `validators`.
		 * @method
		 * @public (method)
		 * @param   {boolean}             [refresh]
		 * Pass `false` to not call the `refresh` method on the
		 * validation instance prior to returning it. Pass `true` to force a `refresh` of the
		 * validation instance. By default the returned record is only refreshed if changes
		 * have been made to this record.
		 * @returns {Ext.data.Validation}           The `Validation` record for this record.
		 */
		getValidation? (refresh?: boolean): Ext.data.Validation;
		/** 
		 * Checks whether this model is loading data from the [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if in a loading state.
		 */
		isLoading? (): boolean;
		/** 
		 * Returns true if the passed field name has been [`modified`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-modified) since the load or last commit.
		 * @method
		 * @public (method)
		 * @param   {string}  fieldName The field's [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name).
		 * @returns {boolean}           
		 */
		isModified? (fieldName: string): boolean;
		/** 
		 * Checks if the model is valid. See [getValidation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-getValidation).
		 * @method
		 * @public (method)
		 * @returns {boolean}  True if the model is valid.
		 */
		isValid? (): boolean;
		/** 
		 * Tells this model instance that an observer is looking at it.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Store} item The store to which this model has been added.
		 * @returns {void}                
		 */
		join? (item: Ext.data.Store): void;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object|Ext.data.Model.methodParams.load.Options} [options] Options to pass to the proxy.
		 * @returns {Ext.data.operation.Read}                                   The read operation.
		 */
		load? (options?: object | Ext.data.Model.methodParams.load.Options): Ext.data.operation.Read;
		/** 
		 * Called when the model id is changed.
		 * @method
		 * @public (method)
		 * @param   {object} id    The new id.
		 * @param   {object} oldId The old id.
		 * @returns {void}         
		 */
		onIdChanged? (id: object, oldId: object): void;
		/** 
		 * Usually called by the [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) to which this model instance has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join). Rejects
		 * all changes made to the model instance since either creation, or the last commit operation. Modified fields are
		 * reverted to their original values.
		 * 
		 * Developers should subscribe to the [Ext.data.Store.update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-update) event to have their code notified of reject
		 * operations.
		 * @method
		 * @public (method)
		 * @param   {boolean} [silent] `true` to skip notification of the owning store of the change.
		 * @returns {void}             
		 */
		reject? (silent?: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object|Ext.data.Model.methodParams.save.Options}                                [options] Options to pass to the proxy.
		 * @returns {Ext.data.operation.Create|Ext.data.operation.Update|Ext.data.operation.Destroy} 
		 * The operation instance for saving this model.  The type of operation returned
		 * depends on the model state at the time of the action.
		 * 
		 * - [phantom](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) model - [Ext.data.operation.Create](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Create.html)
		 * - [modified](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-isModified) model - [Ext.data.operation.Update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Update.html)
		 * - [dropped](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-dropped) model - [Ext.data.operation.Destroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Destroy.html)
		 */
		save? (options?: object | Ext.data.Model.methodParams.save.Options): Ext.data.operation.Create | Ext.data.operation.Update | Ext.data.operation.Destroy;
		/** 
		 * Sets the given field to the given value. For example:
		 * 
		 *     record.set('name', 'value');
		 * 
		 * This method can also be passed an object containing multiple values to set at once.
		 * For example:
		 * 
		 *     record.set({
		 *         name: 'value',
		 *         age: 42
		 *     });
		 * 
		 * The following store events are fired when the modified record belongs to a store:
		 * 
		 * - [beginupdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-beginupdate)
		 * - [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-update)
		 * - [endupdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-endupdate)
		 * @method
		 * @public (method)
		 * @param   {string|object}                                  fieldName
		 * The field to set, or an object containing key/value
		 * pairs.
		 * @param   {object}                                         newValue  The value for the field (if `fieldName` is a string).
		 * @param   {object|Ext.data.Model.methodParams.set.Options} [options] Options for governing this update.
		 * @returns {string[]}                                                 The array of modified field names or null if nothing was modified.
		 */
		set? (fieldName: string | object, newValue: object, options?: object | Ext.data.Model.methodParams.set.Options): string[];
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}           name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                  [value] The value to set for the name parameter.
		 * @returns {Ext.data.Model|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Model;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the model instance's id field to the given id.
		 * @method
		 * @public (method)
		 * @param   {number|string} id        The new id.
		 * @param   {object}        [options] See [set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-set).
		 * @returns {void}                    
		 */
		setId? (id: number | string, options?: object): void;
		/** 
		 * Set the session for this record.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} session The session
		 * @returns {void}                     
		 */
		setSession? (session: Ext.data.Session): void;
		/** 
		 * Returns a url-suitable string for this model instance. By default this just returns the name of the Model class
		 * followed by the instance ID - for example an instance of MyApp.model.User with ID 123 will return 'user/123'.
		 * @method
		 * @public (method)
		 * @returns {string}  The url string for this model instance.
		 */
		toUrl? (): string;
		/** 
		 * Tells this model instance that it has been removed from the store.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Store} store The store from which this model has been removed.
		 * @returns {void}                 
		 */
		unjoin? (store: Ext.data.Store): void;
		/** 
		 * Validates the current data against all of its configured [validators](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-validators). The
		 * returned collection holds an object for each reported problem from a `validator`.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.ErrorCollection}  The errors collection.
		 */
		validate? (): Ext.data.ErrorCollection;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Return a unique observable ID. Model is not observable but tree nodes ([`Ext.data.NodeInterface`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html)) are, so
		 * they must be globally unique within the [observableType](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-observableType).
		 * @method
		 * @protected (method)
		 * @returns {void}  
		 */
		getObservableId? (): void;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                  config
		 * @returns {Ext.data.Model|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.Model;
		initConfig? (config: object): Ext.Base;
		/** 
		 * This method is called by the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) after loading a model from
		 * the server. This is after processing any inline associations that are available.
		 * @method
		 * @protected (method)
		 * @template
		 * @returns {void}  
		 */
		onLoad? (): void;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Model.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.Model.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * Helper function used by afterEdit, afterReject and afterCommit. Calls the given
		 * method on the [`Ext.data.Store`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) that this instance has [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join), if any.
		 * The store function will always be called with the model instance as its single
		 * argument. If this model is joined to a [Ext.data.NodeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeStore.html), then this method calls
		 * the given method on the NodeStore and the associated [Ext.data.TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html).
		 * @method
		 * @private (method)
		 * @param   {string} funcName The name function to call on each store.
		 * @param   {any[]}  [args]
		 * The arguments to pass to the method. This instance is
		 * always inserted as the first argument.
		 * @returns {void}            
		 */
		callJoined? (funcName: string, args?: any[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearState? (): void;
		/** 
		 * Copies data from the passed record into this record. If the passed record is undefined, does nothing.
		 * 
		 * If this is a phantom record (represented only in the client, with no corresponding database entry), and
		 * the source record is not a phantom, then this record acquires the id of the source record.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} sourceRecord The record to copy data from.
		 * @returns {string[]}                    The names of the fields which changed value.
		 */
		copyFrom? (sourceRecord: Ext.data.Model): string[];
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} name
		 * @returns {void}        
		 */
		getField? (name: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getFieldsMap? (): void;
		/** 
		 * Gets the names of all the fields that were modified during an edit.
		 * @method
		 * @private (method)
		 * @param   {object}   [old] The saved data from `beginEdit`.
		 * @returns {string[]}       The array of modified field names.
		 */
		getModifiedFieldNames? (old?: object): string[];
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Checks if two values are equal, taking into account certain special factors, for
		 * example dates.
		 * @method
		 * @private (method)
		 * @param   {object}  lhs The first value.
		 * @param   {object}  rhs The second value.
		 * @returns {boolean}     True if the values are equal.
		 */
		isEqual? (lhs: object, rhs: object): boolean;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * This method produces the `initializeFn` for this class. If there are no fields
		 * requiring [conversion](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-convert) and no fields requiring
		 * a [default value](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-defaultValue) then this method will
		 * return `null`.
		 * @method
		 * @private (method)
		 * @param   {object}   cls
		 * @returns {Function}     The `initializeFn` for this class (or null).
		 */
		makeInitializeFn? (cls: object): ExtGlobalFunction;
		/** 
		 * Called when an associated record instance has been set.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model}       record The record.
		 * @param   {Ext.data.schema.Role} role   The role.
		 * @returns {void}                        
		 */
		onAssociatedRecordSet? (record: Ext.data.Model, role: Ext.data.schema.Role): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		setErased? (): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                names The names of the linked objects to destroy.
		 * @returns {Ext.data.Model|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.Model;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * [Ext.data.ModelManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ModelManager.html)
	 * This class has been deprecated. Use [`Ext.data.schema.Schema`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Schema.html) instead.
	 * @singleton (definition)
	 */
	interface ModelManager extends Ext.Base {
		/** 
		 * Returns the [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) class for a given model name
		 * @method
		 * @public (method)
		 * @param   {string|object}  id The classname of the model or the model class itself.
		 * @returns {Ext.data.Model}    a model class.
		 */
		getModel? (id: string | object): Ext.data.Model;
	}
	/** 
	 * [Ext.data.NodeInterface](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html)
	 * This class is used as a set of methods that are applied to the prototype of a
	 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) to decorate it with a Node API. This means that models
	 * used in conjunction with a tree will have all of the tree related methods available
	 * on the model. In general, this class will not be used directly by the developer.
	 * 
	 * This class also creates extra [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) on the model, if they do
	 * not exist, to help maintain the tree state and UI. These fields are documented as
	 * config options.
	 * 
	 * The data fields used to render a tree node are: [text](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-text), [leaf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-leaf),
	 * [children](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-children), and [expanded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-expanded).  Once a node is loaded to the tree store
	 * you can use [get()](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-get) to fetch the value of a given field
	 * name (provided there is not a convenience accessor on the Node for that field).
	 * 
	 *    Ext.tip.QuickTipManager.init(); // not required when using Ext.application()
	 *    
	 *    var root = {
	 *        expanded: true,
	 *        children: [{
	 *            text: "Leaf node (&lt;i&gt;no folder/arrow icon&lt;/i&gt;)",
	 *            leaf: true,
	 *            qtitle: 'Sample Tip Title',
	 *            qtip: 'Tip body'
	 *        }, {
	 *            text: "Parent node expanded",
	 *            expanded: true,
	 *            children: [{
	 *                text: "Expanded leaf node 1",
	 *                leaf: true
	 *            }, {
	 *                text: "Expanded leaf node 2",
	 *                leaf: true
	 *            }]
	 *        }, {
	 *            text: "Parent node collapsed",
	 *            children: [{
	 *                text: "Collapsed leaf node 1",
	 *                leaf: true
	 *            }, {
	 *                text: "Collapsed leaf node 2",
	 *                leaf: true
	 *            }]
	 *        }]
	 *    };
	 *    
	 *    var tree = Ext.create('Ext.tree.Panel', {
	 *        title: 'TreePanel',
	 *        width: 260,
	 *        height: 200,
	 *        root: root,
	 *        rootVisible: false,
	 *        renderTo: document.body,
	 *        bbar: ['The first node ', {
	 *            text: 'is a leaf?',
	 *            handler: function () {
	 *                var firstChild = tree.getRootNode().getChildAt(0);
	 *                Ext.Msg.alert('Is Leaf?', firstChild.isLeaf());
	 *            }
	 *        }, {
	 *            text: 'has text?',
	 *            handler: function () {
	 *                var firstChild = tree.getRootNode().getChildAt(0);
	 *                Ext.Msg.alert('Has Text:', firstChild.get('text'));
	 *            }
	 *        }]
	 *    });
	 * 
	 * The following configs have methods used to set the value / state of the node at
	 * runtime:
	 * 
	 * **[children](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-children) / [leaf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-leaf)**
	 * 
	 * - [appendChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-appendChild)
	 * - [hasChildNodes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-hasChildNodes)
	 * - [insertBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertBefore)
	 * - [insertChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertChild)
	 * - [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-remove)
	 * - [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-removeAll)
	 * - [removeChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-removeChild)
	 * - [replaceChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-replaceChild)
	 * 
	 * **[expanded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-expanded)**
	 * 
	 * - [expand](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-expand)
	 * - [expandChildren](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-expandChildren)
	 * - [collapse](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-collapse)
	 * - [collapseChildren](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-collapseChildren)
	 * 
	 * The remaining configs may be set using [set()](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-set).
	 * 
	 *    node.set('text', 'Changed Text'); // example showing how to change the node label
	 * 
	 * The [qtip](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtip), [qtitle](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtitle), and [qshowDelay](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qshowDelay) use QuickTips and
	 * requires initializing Ext.tip.QuickTipManager unless the application is
	 * created using [Ext.application](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-application).
	 * 
	 *    Ext.tip.QuickTipManager.init();
	 * 
	 * For additional information and examples see the description for
	 * Ext.tree.Panel.
	 */
	class NodeInterface extends Ext.Base {
		/** 
		 * An array of this nodes children.  Array will be empty if this node has no children.
		 * @property
		 * @public (property)
		 * @type {Ext.data.NodeInterface[]}
		 */
		childNodes?: Ext.data.NodeInterface[];
		/** 
		 * A reference to this node's first child node. `null` if this node has no children.
		 * @property
		 * @public (property)
		 * @type {Ext.data.NodeInterface}
		 */
		firstChild?: Ext.data.NodeInterface;
		/** 
		 * `true` in this class to identify an object as an instantiated Node, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isNode?: boolean;
		/** 
		 * A reference to this node's last child node. `null` if this node has no children.
		 * @property
		 * @public (property)
		 * @type {Ext.data.NodeInterface}
		 */
		lastChild?: Ext.data.NodeInterface;
		/** 
		 * A reference to this node's next sibling node. `null` if this node does not have a next sibling.
		 * @property
		 * @public (property)
		 * @type {Ext.data.NodeInterface}
		 */
		nextSibling?: Ext.data.NodeInterface;
		/** 
		 * A reference to this node's parent node. `null` if this node is the root node.
		 * @property
		 * @public (property)
		 * @type {Ext.data.NodeInterface}
		 */
		parentNode?: Ext.data.NodeInterface;
		/** 
		 * A reference to this node's previous sibling node. `null` if this node does not have a previous sibling.
		 * @property
		 * @public (property)
		 * @type {Ext.data.NodeInterface}
		 */
		previousSibling?: Ext.data.NodeInterface;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.NodeInterface.Statics}
		 */
		self?: Ext.data.NodeInterface.Statics | Ext.Base.Statics;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members    The members to add to this class.
		 * @param   {boolean}                         [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                         [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.NodeInterface|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.NodeInterface;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members
		 * @returns {Ext.data.NodeInterface|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.NodeInterface;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * This method allows you to decorate a Model's class to implement the NodeInterface.
		 * This adds a set of methods, new events, new properties and new fields on every Record.
		 * @method
		 * @public (method)
		 * @static
		 * @param   {Ext.Class|Ext.data.Model} model
		 * The Model class or an instance of the Model class you want to
		 * decorate the prototype of.
		 * @returns {void}                           
		 */
		static decorate? (model: Ext.Class | Ext.data.Model): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          name
		 * @param   {object}                          member
		 * @returns {Ext.data.NodeInterface|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.NodeInterface;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          fn
		 * @param   {object}                          scope
		 * @returns {Ext.data.NodeInterface|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.NodeInterface;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Inserts node(s) as the last child node of this node.
		 * 
		 * If the node was previously a child node of another parent node, it will be removed from that node first.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.NodeInterface|Ext.data.NodeInterface[]|object} node             The node or Array of nodes to append
		 * @param   {boolean}                                                [suppressEvents]
		 * True to suppress firing of
		 * events.
		 * @param   {boolean}                                                [commit]
		 * @returns {Ext.data.NodeInterface}                                                  The appended node if single append, or null if an array was passed
		 */
		appendChild? (node: Ext.data.NodeInterface | Ext.data.NodeInterface[] | object, suppressEvents?: boolean, commit?: boolean): Ext.data.NodeInterface;
		/** 
		 * Bubbles up the tree from this node, calling the specified function with each node. The arguments to the function
		 * will be the args provided or the current node. If the function returns false at any point,
		 * the bubble is stopped.
		 * @method
		 * @public (method)
		 * @param   {Function} fn      The function to call
		 * @param   {object}   [scope] The scope (this reference) in which the function is executed. Defaults to the current Node.
		 * @param   {any[]}    [args]  The args to call the function with. Defaults to passing the current Node.
		 * @returns {void}             
		 */
		bubble? (fn: ExtGlobalFunction, scope?: object, args?: any[]): void;
		/** 
		 * Cascades down the tree from this node, calling the specified functions with each node. The arguments to the function
		 * will be the args provided or the current node. If the `before` function returns false at any point,
		 * the cascade is stopped on that branch.
		 * 
		 * Note that the 3 argument form passing `fn, scope, args` is still supported. The `fn` function is as before, called
		 * _before_ cascading down into child nodes. If it returns `false`, the child nodes are not traversed.
		 * @method
		 * @public (method)
		 * @param   {object|Ext.data.NodeInterface.methodParams.cascade.Spec} spec An object containing before and after functions, scope and an argument list.
		 * @returns {void}                                                         
		 */
		cascade? (spec: object | Ext.data.NodeInterface.methodParams.cascade.Spec): void;
		/** 
		 * Collapse this node.
		 * @method
		 * @public (method)
		 * @param   {boolean}  [recursive] True to recursively collapse all the children
		 * @param   {Function} [callback]  The function to execute once the collapse completes
		 * @param   {object}   [scope]     The scope to run the callback in
		 * @returns {void}                 
		 */
		collapse? (recursive?: boolean, callback?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Collapse all the children of this node.
		 * @method
		 * @public (method)
		 * @param   {Function} [recursive] True to recursively collapse all the children
		 * @param   {Function} [callback]  The function to execute once all the children are collapsed
		 * @param   {object}   [scope]     The scope to run the callback in
		 * @returns {void}                 
		 */
		collapseChildren? (recursive?: ExtGlobalFunction, callback?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Returns true if this node is an ancestor (at any point) of the passed node.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.NodeInterface} node
		 * @returns {boolean}                     
		 */
		contains? (node: Ext.data.NodeInterface): boolean;
		/** 
		 * Creates a copy (clone) of this Node.
		 * @method
		 * @public (method)
		 * @param   {string}                   [id]      A new id, defaults to this Node's id.
		 * @param   {Ext.data.session.Session} [session] The session to which the new record belongs.
		 * @param   {boolean}                  [deep]
		 * True to recursively copy all child Nodes into the new Node.
		 * False to copy without child Nodes.
		 * @returns {Ext.data.NodeInterface}             A copy of this Node.
		 */
		copy? (id?: string, session?: Ext.data.session.Session, deep?: boolean): Ext.data.NodeInterface;
		/** 
		 * Ensures that the passed object is an instance of a Record with the NodeInterface applied
		 * @method
		 * @public (method)
		 * @param   {object}                 node
		 * @returns {Ext.data.NodeInterface}      
		 */
		createNode? (node: object): Ext.data.NodeInterface;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Iterates the child nodes of this node, calling the specified function
		 * with each node. The arguments to the function will be the args
		 * provided or the current node. If the function returns false at any
		 * point, the iteration stops.
		 * @method
		 * @public (method)
		 * @param   {Function} fn      The function to call
		 * @param   {object}   [scope]
		 * The scope (_this_ reference) in which the
		 * function is executed. Defaults to the Node on which eachChild is
		 * called.
		 * @param   {any[]}    [args]
		 * The args to call the function with. Defaults to
		 * passing the current Node.
		 * @returns {void}             
		 */
		eachChild? (fn: ExtGlobalFunction, scope?: object, args?: any[]): void;
		/** 
		 * Destroys the node.
		 * @method
		 * @public (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		erase? (options: object): void;
		/** 
		 * Expand this node.
		 * @method
		 * @public (method)
		 * @param   {boolean}  [recursive] True to recursively expand all the children
		 * @param   {Function} [callback]  The function to execute once the expand completes
		 * @param   {object}   [scope]     The scope to run the callback in
		 * @returns {void}                 
		 */
		expand? (recursive?: boolean, callback?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Expand all the children of this node.
		 * @method
		 * @public (method)
		 * @param   {boolean}  [recursive] True to recursively expand all the children
		 * @param   {Function} [callback]  The function to execute once all the children are expanded
		 * @param   {object}   [scope]     The scope to run the callback in
		 * @returns {void}                 
		 */
		expandChildren? (recursive?: boolean, callback?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Finds the first child that has the attribute with the specified value.
		 * @method
		 * @public (method)
		 * @param   {string}                 attribute The attribute name
		 * @param   {object}                 value     The value to search for
		 * @param   {boolean}                [deep]    True to search through nodes deeper than the immediate children
		 * @returns {Ext.data.NodeInterface}           The found child or null if none was found
		 */
		findChild? (attribute: string, value: object, deep?: boolean): Ext.data.NodeInterface;
		/** 
		 * Finds the first child by a custom function. The child matches if the function passed returns true.
		 * @method
		 * @public (method)
		 * @param   {Function}               fn      A function which must return true if the passed Node is the required Node.
		 * @param   {object}                 [scope] The scope (this reference) in which the function is executed. Defaults to the Node being tested.
		 * @param   {boolean}                [deep]  True to search through nodes deeper than the immediate children
		 * @returns {Ext.data.NodeInterface}         The found child or null if none was found
		 */
		findChildBy? (fn: ExtGlobalFunction, scope?: object, deep?: boolean): Ext.data.NodeInterface;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Returns the child node at the specified index.
		 * @method
		 * @public (method)
		 * @param   {number}                 index
		 * @returns {Ext.data.NodeInterface}       
		 */
		getChildAt? (index: number): Ext.data.NodeInterface;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns depth of this node (the root node has a depth of 0)
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getDepth? (): number;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the tree this node is in.
		 * @method
		 * @public (method)
		 * @returns {Ext.tree.Panel}  The tree panel which owns this node.
		 */
		getOwnerTree? (): Ext.tree.Panel;
		/** 
		 * Gets the hierarchical path from the root of the current node.
		 * @method
		 * @public (method)
		 * @param   {string} [field]     The field to construct the path from. Defaults to the model idProperty.
		 * @param   {string} [separator] A separator to use.
		 * @returns {string}             The node path
		 */
		getPath? (field?: string, separator?: string): string;
		/** 
		 * Returns the [Ext.data.TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) which owns this node.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.TreeStore}  The TreeStore which owns this node.
		 */
		getTreeStore? (): Ext.data.TreeStore;
		/** 
		 * Returns true if this node has one or more child nodes, else false.
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		hasChildNodes? (): boolean;
		/** 
		 * Returns the index of a child node
		 * @method
		 * @public (method)
		 * @param   {Ext.data.NodeInterface} node
		 * @returns {number}                      The index of the node or -1 if it was not found
		 */
		indexOf? (node: Ext.data.NodeInterface): number;
		/** 
		 * Returns the index of a child node that matches the id
		 * @method
		 * @public (method)
		 * @param   {string} id The id of the node to find
		 * @returns {number}    The index of the node or -1 if it was not found
		 */
		indexOfId? (id: string): number;
		/** 
		 * Inserts the first node before the second node in this nodes childNodes collection.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.NodeInterface|Ext.data.NodeInterface[]|object} node    The node to insert
		 * @param   {Ext.data.NodeInterface}                                 refNode The node to insert before (if null the node is appended)
		 * @returns {Ext.data.NodeInterface}                                         The inserted node
		 */
		insertBefore? (node: Ext.data.NodeInterface | Ext.data.NodeInterface[] | object, refNode: Ext.data.NodeInterface): Ext.data.NodeInterface;
		/** 
		 * Inserts a node into this node.
		 * @method
		 * @public (method)
		 * @param   {number}                        index The zero-based index to insert the node at
		 * @param   {Ext.data.NodeInterface|object} node  The node to insert
		 * @returns {Ext.data.NodeInterface}              The node you just inserted
		 */
		insertChild? (index: number, node: Ext.data.NodeInterface | object): Ext.data.NodeInterface;
		/** 
		 * Returns true if the passed node is an ancestor (at any point) of this node.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.NodeInterface} node
		 * @returns {boolean}                     
		 */
		isAncestor? (node: Ext.data.NodeInterface): boolean;
		/** 
		 * Returns true if this node is a branch node, and the entire branch is fully loaded.
		 * 
		 * Using this method, it is possible to ascertain whether an
		 * `expandAll()` call (_classic toolkit TreePanel method_) will have
		 * access to all descendant nodes without incurring a store load.
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		isBranchLoaded? (): boolean;
		/** 
		 * Returns true if this node has one or more child nodes, or if the <tt>expandable</tt>
		 * node attribute is explicitly specified as true, otherwise returns false.
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		isExpandable? (): boolean;
		/** 
		 * Returns `true` if this node is expanded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		isExpanded? (): boolean;
		/** 
		 * Returns true if this node is the first child of its parent
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		isFirst? (): boolean;
		/** 
		 * Returns true if this node is the last child of its parent
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		isLast? (): boolean;
		/** 
		 * Returns true if this node is a leaf
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		isLeaf? (): boolean;
		/** 
		 * Returns true if this node is loaded
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns true if this node is loading
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		isLoading? (): boolean;
		/** 
		 * Returns true if this node is the root node
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		isRoot? (): boolean;
		/** 
		 * Returns true if this node is visible. Note that visibility refers to
		 * the structure of the tree, the Ext.tree.Panel.rootVisible
		 * configuration is not taken into account here. If this method is called
		 * on the root node, it will always be visible.
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		isVisible? (): boolean;
		/** 
		 * Implement this method in a tree record subclass if it needs to track whenever it is registered
		 * with a [TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html).
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.data.TreeStore} treeStore The TreeStore to which the node is being registered.
		 * @returns {void}                         
		 */
		onRegisterTreeNode? (treeStore: Ext.data.TreeStore): void;
		/** 
		 * Implement this method in a tree record subclass if it needs to track whenever it is unregistered
		 * from a [TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html).
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.data.TreeStore} treeStore The TreeStore from which the node is being unregistered.
		 * @returns {void}                         
		 */
		onUnregisterTreeNode? (treeStore: Ext.data.TreeStore): void;
		/** 
		 * Removes this node from its parent.
		 * 
		 * **If** the node is not phantom (only added in the client side), then it may be marked for removal.
		 * 
		 * If the owning [tree store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) is set to [track removed](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved)
		 * then the node will be added to the stack of nodes due to be removed the next time the store is synced with the server.
		 * 
		 * If the owning [tree store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) is set to [auto synchronize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync)
		 * then the synchronize request will be initiated immediately.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                [erase]
		 * True to erase the node using the configured proxy. This is only needed when the
		 * owning [tree store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) is not taking care of synchronization operations.
		 * @returns {Ext.data.NodeInterface}         this
		 */
		remove? (erase?: boolean): Ext.data.NodeInterface;
		/** 
		 * Removes all child nodes from this node.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {boolean}                [erase]
		 * True to erase the node using the configured
		 * proxy.
		 * @returns {Ext.data.NodeInterface}         this
		 */
		removeAll? (erase?: boolean): Ext.data.NodeInterface;
		/** 
		 * Removes a child node from this node.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.NodeInterface} node    The node to remove
		 * @param   {boolean}                [erase]
		 * True to erase the record using the
		 * configured proxy.
		 * @returns {Ext.data.NodeInterface}         The removed node
		 */
		removeChild? (node: Ext.data.NodeInterface, erase?: boolean): Ext.data.NodeInterface;
		/** 
		 * Replaces one child node in this node with another.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.NodeInterface} newChild The replacement node
		 * @param   {Ext.data.NodeInterface} oldChild The node to replace
		 * @returns {Ext.data.NodeInterface}          The replaced node
		 */
		replaceChild? (newChild: Ext.data.NodeInterface, oldChild: Ext.data.NodeInterface): Ext.data.NodeInterface;
		/** 
		 * Creates an object representation of this node including its children.
		 * @method
		 * @public (method)
		 * @param   {object} writerParam
		 * @returns {void}               
		 */
		serialize? (writerParam: object): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                   name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                          [value] The value to set for the name parameter.
		 * @returns {Ext.data.NodeInterface|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.NodeInterface;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sorts this nodes children using the supplied sort function.
		 * @method
		 * @public (method)
		 * @param   {Function} [sortFn]
		 * A function which, when passed two Nodes, returns -1, 0 or 1 depending upon required sort order.
		 * 
		 * It omitted, the node is sorted according to the existing sorters in the owning [TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html).
		 * @param   {boolean}  [recursive]     True to apply this sort recursively
		 * @param   {boolean}  [suppressEvent] True to not fire a sort event.
		 * @returns {void}                     
		 */
		sort? (sortFn?: ExtGlobalFunction, recursive?: boolean, suppressEvent?: boolean): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                          config
		 * @returns {Ext.data.NodeInterface|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.NodeInterface;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Updates general data of this node like isFirst, isLast, depth. This
		 * method is internally called after a node is moved. This shouldn't
		 * have to be called by the developer unless they are creating custom
		 * Tree plugins.
		 * @method
		 * @protected (method)
		 * @param   {boolean}                                                    commit
		 * @param   {object|Ext.data.NodeInterface.methodParams.updateInfo.Info} info   The info to update. May contain any of the following
		 * @returns {string}                                                            []} The names of any persistent fields that were modified.
		 */
		updateInfo? (commit: boolean, info: object | Ext.data.NodeInterface.methodParams.updateInfo.Info): string;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.NodeInterface.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.NodeInterface.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                        names The names of the linked objects to destroy.
		 * @returns {Ext.data.NodeInterface|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.NodeInterface;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * Node Store
	 * @private (class)
	 */
	class NodeStore extends Ext.data.Store {}
	/** 
	 * Private class for use by only Store when configured `buffered: true`.
	 * @private (class)
	 */
	class PageMap extends Ext.util.LruCache {}
	/** 
	 * [Ext.data.ProxyStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html)
	 * ProxyStore is a superclass of [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) and [Ext.data.BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html). It's never used directly,
	 * but offers a set of methods used by both of those subclasses.
	 * 
	 * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
	 * you're probably looking for is [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html). If you're still interested, here's a brief description of what
	 * ProxyStore is and is not.
	 * 
	 * ProxyStore provides the basic configuration for anything that can be considered a Store. It expects to be
	 * given a [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) that represents the type of data in the Store. It also expects to be given a
	 * [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) that handles the loading of data into the Store.
	 * 
	 * ProxyStore provides a few helpful methods such as [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) and [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync), which load and save data
	 * respectively, passing the requests through the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
	 * 
	 * Built-in Store subclasses add extra behavior to each of these functions. Note also that each ProxyStore subclass
	 * has its own way of storing data - in [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) the data is saved as a flat [Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html),
	 * whereas in [BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html) we use a [Ext.data.PageMap](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.PageMap.html) to maintain a client side cache of pages of records.
	 * 
	 * The store provides filtering and sorting support. This sorting/filtering can happen on the client side
	 * or can be completed on the server. This is controlled by the [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) and
	 * [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteFilter) config options. For more information see the [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sort) and
	 * [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) methods.
	 */
	class ProxyStore extends Ext.data.AbstractStore {
		/** 
		 * Property to hold the last options from a [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method call. This object is used for the [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload)
		 * to reuse the same options. Please see [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) for a simple example on how to use the lastOptions property.
		 * @property
		 * @public (property)
		 * @type {object}
		 */
		lastOptions?: object;
		/** 
		 * Temporary cache in which removed model instances are kept until successfully
		 * synchronised with a Proxy, at which point this is cleared.
		 * 
		 * This cache is maintained unless you set `trackRemoved` to `false`.
		 * @property
		 * @protected (property)
		 * @default []
		 * @type {Ext.data.Model[]}
		 */
		removed?: Ext.data.Model[];
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.ProxyStore.Statics}
		 */
		self?: Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * A counter to track suspensions.
		 * @property
		 * @private (property)
		 * @default 0
		 * @type {number}
		 */
		autoSyncSuspended?: number;
		/** 
		 * The class name of the model that this store uses if no explicit [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model) is given
		 * @property
		 * @private (property)
		 * @default 'Ext.data.Model'
		 * @type {boolean}
		 */
		implicitModel?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members    The members to add to this class.
		 * @param   {boolean}                                             [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                             [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members
		 * @returns {Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.ProxyStore;
		static addStatics? (members: object): typeof Ext.data.AbstractStore;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              name
		 * @param   {object}                                              member
		 * @returns {Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		static addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              fn
		 * @param   {object}                                              scope
		 * @returns {Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * Adds a new Filter to this Store's [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {object[]|Ext.util.Filter[]} filters         The set of filters to add to the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters).
		 * @param   {boolean}                    [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                       
		 */
		addFilter? (filters: object[] | Ext.util.Filter[], suppressEvent?: boolean): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * This method may be called to indicate the start of multiple changes to the store.
		 * 
		 * Automatic synchronization as configured by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred
		 * until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple mutations can be coalesced
		 * into one synchronization operation.
		 * 
		 * Internally this method increments a counter that is decremented by `endUpdate`. It
		 * is important, therefore, that if you call `beginUpdate` directly you match that
		 * call with a call to `endUpdate` or you will prevent the collection from updating
		 * properly.
		 * 
		 * For example:
		 * 
		 *     var store = Ext.StoreManager.lookup({
		 *         //...
		 *         autoSync: true
		 *     });
		 *    
		 *     store.beginUpdate();
		 *    
		 *     record.set('fieldName', 'newValue');
		 *    
		 *     store.add(item);
		 *     // ...
		 *    
		 *     store.insert(index, otherItem);
		 *     //...
		 *    
		 *     // Interested parties will listen for the endupdate event
		 *     store.endUpdate();
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginUpdate? (): void;
		/** 
		 * Reverts to a view of the Record cache with no filtering applied.
		 * @method
		 * @public (method)
		 * @param   {boolean} [suppressEvent]
		 * If `true` the filter is cleared silently.
		 * 
		 * For a locally filtered Store, this means that the filter collection is cleared without firing the
		 * [datachanged](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-datachanged) event.
		 * 
		 * For a remotely filtered Store, this means that the filter collection is cleared, but the store
		 * is not reloaded from the server.
		 * @returns {void}                    
		 */
		clearFilter? (suppressEvent?: boolean): void;
		/** 
		 * Clear the store grouping
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearGrouping? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Checks if a record is in the current active data set.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record
		 * @returns {boolean}               `true` if the record is in the current active data set.
		 */
		contains? (record: Ext.data.Model): boolean;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * This method is called after modifications are complete on a store. For details
		 * see [`beginUpdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		endUpdate? (): void;
		/** 
		 * Filters the data in the Store by one or more fields. Example usage:
		 * 
		 *    //filter with a single field
		 *    myStore.filter('firstName', 'Don');
		 *    
		 *    //filtering with multiple filters
		 *    myStore.filter([
		 *        {
		 *            property : 'firstName',
		 *            value    : 'Don'
		 *        },
		 *        {
		 *            property : 'lastName',
		 *            value    : 'Griffin'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) instances, and delegates
		 * the actual filtering to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter[]} [filters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of filter configurations.
		 * @param   {string}                   [value]   The property value by which to filter. Only applicable if `filters` is a string.
		 * @returns {void}                               
		 */
		filter? (filters?: string | Ext.util.Filter[], value?: string): void;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of the Record field to test.
		 * @param   {string|RegExp} value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}        [startIndex]    The index to start searching at
		 * @param   {boolean}       [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}       [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {number}                        The matched index or -1
		 */
		find? (property: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string} fieldName    The name of the Record field to test.
		 * @param   {object} value        The value to match the field against.
		 * @param   {number} [startIndex] The index to start searching at
		 * @returns {number}              The matched index or -1
		 */
		findExact? (fieldName: string, value: object, startIndex?: number): number;
		/** 
		 * Finds the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}         fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}  value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}         [startIndex]    The index to start searching at
		 * @param   {boolean}        [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}        [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}        [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.Model}                 The matched record or null
		 */
		findRecord? (fieldName: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Called when the event handler which called the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method exits.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		flushLoad? (): void;
		/** 
		 * Returns the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAsynchronousLoad? (): boolean;
		/** 
		 * Get the Record at the specified index.
		 * 
		 * The index is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}         index The index of the Record to find.
		 * @returns {Ext.data.Model}       The Record at the passed index. Returns null if not found.
		 */
		getAt? (index: number): Ext.data.Model;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Returns the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean|object}  
		 */
		getAutoLoad? (): boolean | object;
		/** 
		 * Returns the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoSync? (): boolean;
		/** 
		 * Returns the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchUpdateMode? (): string;
		/** 
		 * Get the Record with the specified id.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            id The id of the Record to find.
		 * @returns {Ext.data.Model}    The Record with the passed id. Returns null if not found.
		 */
		getById? (id: any): Ext.data.Model;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Gets the number of records in store.
		 * 
		 * If using paging, this may not be the total size of the dataset. If the data object
		 * used by the Reader contains the dataset size, then the [Ext.data.ProxyStore.getTotalCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getTotalCount) function returns
		 * the dataset size.  **Note**: see the Important note in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load).
		 * 
		 * When store is filtered, it's the number of records matching the filter.
		 * @method
		 * @public (method)
		 * @returns {number}  The number of Records in the Store.
		 */
		getCount? (): number;
		/** 
		 * Returns the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @returns {object[]|string[]}  
		 */
		getFields? (): object[] | string[];
		/** 
		 * Gets the filters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.FilterCollection}            The filters
		 */
		getFilters? (autoCreate: object): Ext.util.FilterCollection;
		/** 
		 * Returns the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDir? (): string;
		/** 
		 * Returns the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @returns {object|Ext.util.Grouper}  
		 */
		getGrouper? (): object | Ext.util.Grouper;
		/** 
		 * Returns a collection of readonly sub-collections of your store's records
		 * with grouping applied. These sub-collections are maintained internally by
		 * the collection.
		 * 
		 * See [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField), [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir). Example for a store
		 * containing records with a color field:
		 * 
		 *    var myStore = Ext.create('Ext.data.Store', {
		 *        groupField: 'color',
		 *        groupDir  : 'DESC'
		 *    });
		 *    
		 *    myStore.getGroups();
		 * 
		 * The above should result in the following format:
		 * 
		 *    [
		 *        {
		 *            name: 'yellow',
		 *            children: [
		 *                // all records where the color field is 'yellow'
		 *            ]
		 *        },
		 *        {
		 *            name: 'red',
		 *            children: [
		 *                // all records where the color field is 'red'
		 *            ]
		 *        }
		 *    ]
		 * 
		 * Group contents are affected by filtering.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection}  The grouped data
		 */
		getGroups? (): Ext.util.Collection;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Gets all [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) added or updated since the last commit. Note that the order of records
		 * returned is not deterministic and does not indicate the order in which records were modified. Note also that
		 * removed records are not included (use [getRemovedRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getRemovedRecords) for that).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The added and updated Model instances
		 */
		getModifiedRecords? (): Ext.data.Model[];
		/** 
		 * Returns all [`phantom`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records in this store.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  A possibly empty array of `phantom` records.
		 */
		getNewRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getPageSize? (): number;
		/** 
		 * Returns the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.proxy.Proxy|object}  
		 */
		getProxy? (): string | Ext.data.proxy.Proxy | object;
		/** 
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}           start The starting index. Defaults to zero.
		 * @param   {number}           end   The ending index. Defaults to the last record. The end index **is included**.
		 * @returns {Ext.data.Model[]}       An array of records.
		 */
		getRange? (start: number, end: number): Ext.data.Model[];
		/** 
		 * Returns the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteFilter? (): boolean;
		/** 
		 * Returns the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteSort? (): boolean;
		/** 
		 * Returns any records that have been removed from the store but not yet destroyed on the proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]} 
		 * The removed Model instances. Note that this is a _copy_ of the store's
		 * array, so may be mutated.
		 */
		getRemovedRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSortOnLoad? (): boolean;
		/** 
		 * Gets the sorters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.SorterCollection}            The sorters
		 */
		getSorters? (autoCreate: object): Ext.util.SorterCollection;
		/** 
		 * Returns the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getStatefulFilters? (): boolean;
		/** 
		 * Returns the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStoreId? (): string;
		/** 
		 * Returns the total number of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances that the [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html)
		 * indicates exist. This will usually differ from [getCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getCount) when using paging - getCount returns the
		 * number of records loaded into the Store at the moment, getTotalCount returns the number of records that
		 * could be loaded into the Store if the Store contained all data
		 * @method
		 * @public (method)
		 * @returns {number} 
		 * The total number of Model instances available via the Proxy. 0 returned if
		 * no value has been set via the reader.
		 */
		getTotalCount? (): number;
		/** 
		 * Returns the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getTrackRemoved? (): boolean;
		/** 
		 * Returns all valid, non-phantom Model instances that have been updated in the Store but not yet synchronized with the Proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The updated Model instances
		 */
		getUpdatedRecords? (): Ext.data.Model[];
		/** 
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {string|object} grouper
		 * Either a string name of one of the fields in this Store's
		 * configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an object, or a [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Grouper.html) configuration object.
		 * @param   {string}        [direction] The overall direction to group the data by. Defaults to the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @returns {void}                      
		 */
		group? (grouper: string | object, direction?: string): void;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Tests whether the store currently has any active filters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is filtered.
		 */
		isFiltered? (): boolean;
		/** 
		 * Tests whether the store currently has an active grouper.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is grouped.
		 */
		isGrouped? (): boolean;
		/** 
		 * Returns `true` if the Store has been loaded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store has been loaded.
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns true if the Store is currently performing a load operation
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store is currently loading
		 */
		isLoading? (): boolean;
		/** 
		 * Tests whether the store currently has any active sorters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is sorted.
		 */
		isSorted? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Marks this store as needing a load. When the current executing event handler exits,
		 * this store will send a request to load using its configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * 
		 * Upon return of the data from whatever data source the proxy connected to, the retrieved
		 * [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) will be loaded into this store, and the optional callback will be called.
		 * Example usage:
		 * 
		 *    store.load({
		 *        scope: this,
		 *        callback: function(records, operation, success) {
		 *            // the operation object
		 *            // contains all of the details of the load operation
		 *            console.log(records);
		 *        }
		 *    });
		 * 
		 * If the callback scope does not need to be set, a function can simply be passed:
		 * 
		 *    store.load(function(records, operation, success) {
		 *        console.log('loaded records');
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {object|Ext.data.ProxyStore.methodParams.load.Options} [options]
		 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
		 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
		 * In addition to the options listed below, this object may contain properties to configure the
		 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
		 * @returns {Ext.data.Store}                                                 this
		 */
		load? (options?: object | Ext.data.ProxyStore.methodParams.load.Options): Ext.data.Store;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Reloads the store using the last options passed to the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method. You can use the reload method to reload the
		 * store using the parameters from the last load() call. For example:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload();
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution will pass the `userid` parameter in the request. The [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) execution
		 * will also send the same `userid` parameter in its request as it will reuse the `params` object from the last [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) call.
		 * 
		 * You can override a param by passing in the config object with the `params` object:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216,
		 *            foo    : 'bar'
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload({
		 *        params : {
		 *            userid : 1234
		 *        }
		 *    });
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution sends the `userid` and `foo` parameters but in the [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) it only sends
		 * the `userid` paramter because you are overriding the `params` config not just overriding the one param. To only change a single param
		 * but keep other params, you will have to get the last params from the [lastOptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#property-lastOptions) property:
		 * 
		 *    var lastOptions = store.lastOptions,
		 *        lastParams = Ext.clone(lastOptions.params); // make a copy of the last params so we don't affect future reload() calls
		 *    
		 *    lastParams.userid = 1234;
		 *    
		 *    store.reload({
		 *        params : lastParams
		 *    });
		 * 
		 * This will now send the `userid` parameter as `1234` and the `foo` param as `'bar'`.
		 * @method
		 * @public (method)
		 * @param   {object} [options]
		 * A config object which contains options which may override the options passed to the previous load call. See the
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method for valid configs.
		 * @returns {void}             
		 */
		reload? (options?: object): void;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Removes all records from the store. This method does a "fast remove",
		 * individual remove events are not called. The [clear](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-clear) event is
		 * fired upon completion.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAll? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an individual Filter from the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) using the passed Filter/Filter id and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter} toRemove        The id of a Filter to remove from the filter set, or a Filter instance to remove.
		 * @param   {boolean}                [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                   
		 */
		removeFilter? (toRemove: string | Ext.util.Filter, suppressEvent?: boolean): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @param   {boolean} syncNow
		 * Pass `true` to synchronize now. Only synchronizes with the Proxy if the suspension
		 * count has gone to zero (We are not under a higher level of suspension)
		 * @returns {void}            
		 */
		resumeAutoSync? (syncNow: boolean): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Saves all pending changes via the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy). Use [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) instead.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		save? (): void;
		/** 
		 * Sets the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} asynchronousLoad The new value.
		 * @returns {void}                     
		 */
		setAsynchronousLoad? (asynchronousLoad: boolean): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean|object} autoLoad The new value.
		 * @returns {void}                    
		 */
		setAutoLoad? (autoLoad: boolean | object): void;
		/** 
		 * Sets the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoSync The new value.
		 * @returns {void}             
		 */
		setAutoSync? (autoSync: boolean): void;
		/** 
		 * Sets the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @param   {string} batchUpdateMode The new value.
		 * @returns {void}                   
		 */
		setBatchUpdateMode? (batchUpdateMode: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                       name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                              [value] The value to set for the name parameter.
		 * @returns {Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.ProxyStore;
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @param   {object[]|string[]} fields The new value.
		 * @returns {void}                     
		 */
		setFields? (fields: object[] | string[]): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setFilters? (): void;
		/** 
		 * Sets the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @param   {string} groupDir The new value.
		 * @returns {void}            
		 */
		setGroupDir? (groupDir: string): void;
		/** 
		 * Sets the value of [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField).
		 * @method
		 * @public (method)
		 * @param   {string} groupField The new value.
		 * @returns {void}              
		 */
		setGroupField? (groupField: string): void;
		/** 
		 * Sets the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.util.Grouper} grouper The new value.
		 * @returns {void}                            
		 */
		setGrouper? (grouper: object | Ext.util.Grouper): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @param   {number} pageSize The new value.
		 * @returns {void}            
		 */
		setPageSize? (pageSize: number): void;
		/** 
		 * Sets the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.proxy.Proxy|object} proxy The new value.
		 * @returns {void}                                     
		 */
		setProxy? (proxy: string | Ext.data.proxy.Proxy | object): void;
		/** 
		 * Sets the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteFilter The new value.
		 * @returns {void}                 
		 */
		setRemoteFilter? (remoteFilter: boolean): void;
		/** 
		 * Sets the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteSort The new value.
		 * @returns {void}               
		 */
		setRemoteSort? (remoteSort: boolean): void;
		/** 
		 * Sets the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} sortOnLoad The new value.
		 * @returns {void}               
		 */
		setSortOnLoad? (sortOnLoad: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setSorters? (): void;
		/** 
		 * Sets the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @param   {boolean} statefulFilters The new value.
		 * @returns {void}                    
		 */
		setStatefulFilters? (statefulFilters: boolean): void;
		/** 
		 * Sets the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @param   {string} storeId The new value.
		 * @returns {void}           
		 */
		setStoreId? (storeId: string): void;
		/** 
		 * Sets the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @param   {boolean} trackRemoved The new value.
		 * @returns {void}                 
		 */
		setTrackRemoved? (trackRemoved: boolean): void;
		/** 
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction] The overall direction to sort the data by.
		 * @returns {Ext.util.Sorter[]}                    
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string): Ext.util.Sorter[];
		/** 
		 * Suspends automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendAutoSync? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Synchronizes the store with its [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy). This asks the proxy to batch together any new, updated
		 * and deleted records in the store, updating the store's internal representation of the records
		 * as each operation completes.
		 * @method
		 * @public (method)
		 * @param   {object|Ext.data.ProxyStore.methodParams.sync.Options} [options]
		 * Object containing one or more properties supported by the sync method (these get
		 * passed along to the underlying proxy's [batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-batch) method):
		 * @returns {Ext.data.Store}                                                 this
		 */
		sync? (options?: object | Ext.data.ProxyStore.methodParams.sync.Options): Ext.data.Store;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Destructor for classes that extend Observable.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		doDestroy? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                              config
		 * @returns {Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.ProxyStore;
		initConfig? (config: object): Ext.data.AbstractStore;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.ProxyStore.Statics;
		statics? (): Ext.data.AbstractStore.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorter
		 * @returns {void}          
		 */
		addFieldTransform? (sorter: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterCommit? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterErase? (record: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to..
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterReject? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} asynchronousLoad
		 * @returns {void}                    
		 */
		applyAsynchronousLoad? (asynchronousLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fields
		 * @returns {void}          
		 */
		applyFields? (fields: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @param   {object} filtersCollection
		 * @returns {void}                     
		 */
		applyFilters? (filters: object, filtersCollection: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} grouper
		 * @returns {void}           
		 */
		applyGrouper? (grouper: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @returns {void}         
		 */
		applyProxy? (proxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorters
		 * @param   {object} sortersCollection
		 * @returns {void}                     
		 */
		applySorters? (sorters: object, sortersCollection: object): void;
		/** 
		 * Restores state to the passed state
		 * @method
		 * @private (method)
		 * @param   {object} state
		 * @returns {void}         
		 */
		applyState? (state: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * to be implemented by subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearData? (): void;
		/** 
		 * saves any phantom records
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @param   {object} options
		 * @returns {void}           
		 */
		create? (data: object, options: object): void;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * tells the attached proxy to destroy the given records
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		erase? (options: object): void;
		/** 
		 * Filter function for new records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNew? (item: object): void;
		/** 
		 * Filter function for updated records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterUpdated? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		fireGroupChange? (): void;
		/** 
		 * Returns the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getAutoSort? (): boolean;
		/** 
		 * Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
		 * This is broken out into a separate function to allow for customisation of the listeners
		 * @method
		 * @private (method)
		 * @returns {object}  The listeners object
		 */
		getBatchListeners? (): object;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getGroupField? (): void;
		/** 
		 * Returns the array of records which have been removed since the last time this store was synced.
		 * 
		 * This is used internally, when purging removed records after a successful sync.
		 * This is overridden by TreeStore because TreeStore accumulates deleted records on removal
		 * of child nodes from their parent, _not_ on removal of records from its collection. The collection
		 * has records added on expand, and removed on collapse.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRawRemovedRecords? (): void;
		/** 
		 * Returns the grouping, sorting and filtered state of this Store.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getState? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Returns true if the store has a pending load task.
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the store has a pending load task.
		 */
		hasPendingLoad? (): boolean;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Attached as the 'complete' event listener to a proxy's Batch object. Iterates over the batch operations
		 * and updates the Store's internal data MixedCollection.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchComplete? (batch: object, operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchException? (batch: object, operation: object): void;
		/** 
		 * Attached as the 'operationcomplete' event listener to a proxy's Batch object. By default just calls through
		 * to onProxyWrite.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchOperationComplete? (batch: object, operation: object): void;
		/** 
		 * This is attached to the data Collection's beforesort event only if not remoteSort
		 * If remoteSort, the event is fired before the reload call in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-load).
		 * @method
		 * @private (method)
		 * @param   {object} store
		 * @param   {object} sorters
		 * @returns {void}           
		 */
		onBeforeCollectionSort? (store: object, sorters: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} cls
		 * @param   {object} data
		 * @param   {object} hooks
		 * @returns {void}         
		 */
		onClassExtended? (cls: object, data: object, hooks: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCreateRecords? (): void;
		/** 
		 * Removes any records when a write is returned from the server.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]}             records   The array of removed records
		 * @param   {Ext.data.operation.Operation} operation The operation that just completed
		 * @param   {boolean}                      success   True if the operation was successful
		 * @returns {void}                                   
		 */
		onDestroyRecords? (records: Ext.data.Model[], operation: Ext.data.operation.Operation, success: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onErase? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onFilterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} meta
		 * @returns {void}         
		 */
		onMetaChange? (proxy: object, meta: object): void;
		/** 
		 * Callback for any write Operation over the Proxy. Updates the Store's MixedCollection to reflect
		 * the updates provided by the Proxy
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyWrite? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onSorterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdate? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdateRecords? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Determines if the passed range is available in the page cache.
		 * @method
		 * @private (method)
		 * @param   {number} start The start index
		 * @param   {number} end   The end index in the range
		 * @returns {void}         
		 */
		rangeCached? (start: number, end: number): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * Sets the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @param   {boolean} autoSort The new value.
		 * @returns {void}             
		 */
		setAutoSort? (autoSort: boolean): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                            names The names of the linked objects to destroy.
		 * @returns {Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.ProxyStore;
		unlink? (names: string[]): Ext.data.AbstractStore;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		update? (options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoLoad
		 * @returns {void}            
		 */
		updateAutoLoad? (autoLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoSort
		 * @returns {void}            
		 */
		updateAutoSort? (autoSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} field
		 * @returns {void}         
		 */
		updateGroupField? (field: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} oldProxy
		 * @returns {void}            
		 */
		updateProxy? (proxy: object, oldProxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @returns {void}                
		 */
		updateRemoteFilter? (remoteFilter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @returns {void}              
		 */
		updateRemoteSort? (remoteSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} track
		 * @returns {void}         
		 */
		updateTrackRemoved? (track: object): void;
	}
	/** 
	 * [Ext.data.Request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html)
	 * Simple class that represents a Request that will be made by any [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Server.html) subclass.
	 * All this class does is standardize the representation of a Request as used by any ServerProxy subclass,
	 * it does not contain any actual logic or perform the request itself.
	 */
	class Request extends Ext.Base {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.Request.Statics}
		 */
		self?: Ext.data.Request.Statics | Ext.Base.Statics;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                    members    The members to add to this class.
		 * @param   {boolean}                   [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                   [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Request|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Request;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                    members
		 * @returns {Ext.data.Request|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.Request;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                    name
		 * @param   {object}                    member
		 * @returns {Ext.data.Request|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.Request;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                    fn
		 * @param   {object}                    scope
		 * @returns {Ext.data.Request|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.Request;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates the Request object.
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns the value of [action](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-action).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getAction? (): string;
		/** 
		 * Returns the value of [args](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-args).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getArgs? (): object;
		/** 
		 * Returns the value of [binary](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-binary).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getBinary? (): boolean;
		/** 
		 * Returns the value of [callback](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-callback).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getCallback? (): object;
		/** 
		 * Returns the value of [callbackKey](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-callbackKey).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getCallbackKey? (): string;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [directFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-directFn).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getDirectFn? (): object;
		/** 
		 * Returns the value of [disableCaching](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-disableCaching).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getDisableCaching? (): boolean;
		/** 
		 * Returns the value of [headers](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-headers).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getHeaders? (): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [jsonData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-jsonData).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getJsonData? (): object;
		/** 
		 * Returns the value of [method](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-method).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getMethod? (): string;
		/** 
		 * Returns the value of [operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-operation).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.operation.Operation}  
		 */
		getOperation? (): Ext.data.operation.Operation;
		/** 
		 * Gets a single param from the [params](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-params).
		 * @method
		 * @public (method)
		 * @param   {string} key The key for the param.
		 * @returns {object}     The value for the param. `undefined` if it does not exist.
		 */
		getParam? (key: string): object;
		/** 
		 * Returns the value of [params](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-params).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getParams? (): object;
		/** 
		 * Returns the value of [password](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-password).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getPassword? (): string;
		/** 
		 * Returns the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.proxy.Proxy}  
		 */
		getProxy? (): Ext.data.proxy.Proxy;
		/** 
		 * Returns the value of [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-records).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getRecords? (): object;
		/** 
		 * Returns the value of [scope](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-scope).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getScope? (): object;
		/** 
		 * Returns the value of [timeout](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getTimeout? (): number;
		/** 
		 * Returns the value of [url](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-url).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getUrl? (): string;
		/** 
		 * Returns the value of [useDefaultXhrHeader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-useDefaultXhrHeader).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getUseDefaultXhrHeader? (): object;
		/** 
		 * Returns the value of [username](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-username).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getUsername? (): string;
		/** 
		 * Returns the value of [withCredentials](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-withCredentials).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getWithCredentials? (): boolean;
		/** 
		 * Returns the value of [xmlData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-xmlData).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getXmlData? (): object;
		/** 
		 * Sets the value of [action](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-action).
		 * @method
		 * @public (method)
		 * @param   {string} action The new value.
		 * @returns {void}          
		 */
		setAction? (action: string): void;
		/** 
		 * Sets the value of [args](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-args).
		 * @method
		 * @public (method)
		 * @param   {object} args The new value.
		 * @returns {void}        
		 */
		setArgs? (args: object): void;
		/** 
		 * Sets the value of [binary](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-binary).
		 * @method
		 * @public (method)
		 * @param   {boolean} binary The new value.
		 * @returns {void}           
		 */
		setBinary? (binary: boolean): void;
		/** 
		 * Sets the value of [callback](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-callback).
		 * @method
		 * @public (method)
		 * @param   {object} callback The new value.
		 * @returns {void}            
		 */
		setCallback? (callback: object): void;
		/** 
		 * Sets the value of [callbackKey](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-callbackKey).
		 * @method
		 * @public (method)
		 * @param   {string} callbackKey The new value.
		 * @returns {void}               
		 */
		setCallbackKey? (callbackKey: string): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}             name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                    [value] The value to set for the name parameter.
		 * @returns {Ext.data.Request|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Request;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [directFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-directFn).
		 * @method
		 * @public (method)
		 * @param   {object} directFn The new value.
		 * @returns {void}            
		 */
		setDirectFn? (directFn: object): void;
		/** 
		 * Sets the value of [disableCaching](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-disableCaching).
		 * @method
		 * @public (method)
		 * @param   {boolean} disableCaching The new value.
		 * @returns {void}                   
		 */
		setDisableCaching? (disableCaching: boolean): void;
		/** 
		 * Sets the value of [headers](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-headers).
		 * @method
		 * @public (method)
		 * @param   {object} headers The new value.
		 * @returns {void}           
		 */
		setHeaders? (headers: object): void;
		/** 
		 * Sets the value of [jsonData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-jsonData).
		 * @method
		 * @public (method)
		 * @param   {object} jsonData The new value.
		 * @returns {void}            
		 */
		setJsonData? (jsonData: object): void;
		/** 
		 * Sets the value of [method](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-method).
		 * @method
		 * @public (method)
		 * @param   {string} method The new value.
		 * @returns {void}          
		 */
		setMethod? (method: string): void;
		/** 
		 * Sets the value of [operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-operation).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.operation.Operation} operation The new value.
		 * @returns {void}                                   
		 */
		setOperation? (operation: Ext.data.operation.Operation): void;
		/** 
		 * Sets a single param value in the [params](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-params).
		 * @method
		 * @public (method)
		 * @param   {string} key   The key to set.
		 * @param   {object} value The value to set.
		 * @returns {void}         
		 */
		setParam? (key: string, value: object): void;
		/** 
		 * Sets the value of [params](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-params).
		 * @method
		 * @public (method)
		 * @param   {object} params The new value.
		 * @returns {void}          
		 */
		setParams? (params: object): void;
		/** 
		 * Sets the value of [password](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-password).
		 * @method
		 * @public (method)
		 * @param   {string} password The new value.
		 * @returns {void}            
		 */
		setPassword? (password: string): void;
		/** 
		 * Sets the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.proxy.Proxy} proxy The new value.
		 * @returns {void}                       
		 */
		setProxy? (proxy: Ext.data.proxy.Proxy): void;
		/** 
		 * Sets the value of [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-records).
		 * @method
		 * @public (method)
		 * @param   {object} records The new value.
		 * @returns {void}           
		 */
		setRecords? (records: object): void;
		/** 
		 * Sets the value of [scope](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-scope).
		 * @method
		 * @public (method)
		 * @param   {object} scope The new value.
		 * @returns {void}         
		 */
		setScope? (scope: object): void;
		/** 
		 * Sets the value of [timeout](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-timeout).
		 * @method
		 * @public (method)
		 * @param   {number} timeout The new value.
		 * @returns {void}           
		 */
		setTimeout? (timeout: number): void;
		/** 
		 * Sets the value of [url](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-url).
		 * @method
		 * @public (method)
		 * @param   {string} url The new value.
		 * @returns {void}       
		 */
		setUrl? (url: string): void;
		/** 
		 * Sets the value of [useDefaultXhrHeader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-useDefaultXhrHeader).
		 * @method
		 * @public (method)
		 * @param   {object} useDefaultXhrHeader The new value.
		 * @returns {void}                       
		 */
		setUseDefaultXhrHeader? (useDefaultXhrHeader: object): void;
		/** 
		 * Sets the value of [username](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-username).
		 * @method
		 * @public (method)
		 * @param   {string} username The new value.
		 * @returns {void}            
		 */
		setUsername? (username: string): void;
		/** 
		 * Sets the value of [withCredentials](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-withCredentials).
		 * @method
		 * @public (method)
		 * @param   {boolean} withCredentials The new value.
		 * @returns {void}                    
		 */
		setWithCredentials? (withCredentials: boolean): void;
		/** 
		 * Sets the value of [xmlData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html#cfg-xmlData).
		 * @method
		 * @public (method)
		 * @param   {object} xmlData The new value.
		 * @returns {void}           
		 */
		setXmlData? (xmlData: object): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                    config
		 * @returns {Ext.data.Request|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.Request;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Request.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.Request.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                  names The names of the linked objects to destroy.
		 * @returns {Ext.data.Request|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.Request;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * [Ext.data.ResultSet](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html)
	 * Simple wrapper class that represents a set of records returned by a Proxy.
	 */
	class ResultSet extends Ext.Base {
		/** 
		 * Identifies this class as a result set.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isResultSet?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.ResultSet.Statics}
		 */
		self?: Ext.data.ResultSet.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                      members    The members to add to this class.
		 * @param   {boolean}                     [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                     [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.ResultSet|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ResultSet;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                      members
		 * @returns {Ext.data.ResultSet|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.ResultSet;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                      name
		 * @param   {object}                      member
		 * @returns {Ext.data.ResultSet|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.ResultSet;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                      fn
		 * @param   {object}                      scope
		 * @returns {Ext.data.ResultSet|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.ResultSet;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Creates the resultSet
		 * @method
		 * @public (method)
		 * @param   {object} [config] Config object.
		 */
		constructor (config?: object);
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [loaded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-loaded).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getLoaded? (): boolean;
		/** 
		 * Returns the value of [message](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-message).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getMessage? (): string;
		/** 
		 * Returns the value of [metadata](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-metadata).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getMetadata? (): object;
		/** 
		 * Returns the value of [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-records).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]|object[]}  
		 */
		getRecords? (): Ext.data.Model[] | object[];
		/** 
		 * Returns the value of [success](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-success).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSuccess? (): boolean;
		/** 
		 * Returns the value of [total](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-total).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getTotal? (): number;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.ResultSet|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.ResultSet;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [count](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-count).
		 * @method
		 * @public (method)
		 * @param   {number} count The new value.
		 * @returns {void}         
		 */
		setCount? (count: number): void;
		/** 
		 * Sets the value of [loaded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-loaded).
		 * @method
		 * @public (method)
		 * @param   {boolean} loaded The new value.
		 * @returns {void}           
		 */
		setLoaded? (loaded: boolean): void;
		/** 
		 * Sets the value of [message](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-message).
		 * @method
		 * @public (method)
		 * @param   {string} message The new value.
		 * @returns {void}           
		 */
		setMessage? (message: string): void;
		/** 
		 * Sets the value of [metadata](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-metadata).
		 * @method
		 * @public (method)
		 * @param   {object} metadata The new value.
		 * @returns {void}            
		 */
		setMetadata? (metadata: object): void;
		/** 
		 * Sets the value of [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-records).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} records The new value.
		 * @returns {void}                              
		 */
		setRecords? (records: Ext.data.Model[] | object[]): void;
		/** 
		 * Sets the value of [success](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-success).
		 * @method
		 * @public (method)
		 * @param   {boolean} success The new value.
		 * @returns {void}            
		 */
		setSuccess? (success: boolean): void;
		/** 
		 * Sets the value of [total](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-total).
		 * @method
		 * @public (method)
		 * @param   {number} total The new value.
		 * @returns {void}         
		 */
		setTotal? (total: number): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.data.ResultSet|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.ResultSet;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.ResultSet.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.ResultSet.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                    names The names of the linked objects to destroy.
		 * @returns {Ext.data.ResultSet|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.ResultSet;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * [Ext.data.Session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html)
	 * This class manages models and their associations. Instances of `Session` are typically
	 * associated with some `Component` (perhaps the Viewport or a Window) and then used by
	 * their [`view models`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.app.ViewModel.html) to enable data binding.
	 * 
	 * The primary job of a Session is to manage a collection of records of many different
	 * types and their associations. This often starts by loading records when requested (via
	 * bind - see below) and culminates when it is time to save to the server.
	 * 
	 * Because the Session tracks all records it loads, it ensures that for any given type of
	 * model, only one record exists with a given `id`. This means that all edits of that
	 * record are properly targeted at that one instance.
	 * 
	 * Similarly, when associations are loaded, the [`Ext.data.Store`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) created to hold the
	 * associated records is tracked by the Session. So all requests for the "OrderItems" of
	 * a particular Order id will result in the same Store. Adding and removing items from
	 * that Order then is sure to remain consistent.
	 * 
	 * # Data
	 * 
	 * Since the Session is managing all this data, there are several methods it provides
	 * to give convenient access to that data. The most important of these is `update` and
	 * `getChanges`.
	 * 
	 * The `update` and `getChanges` methods both operate on object that contains a summary
	 * of records and associations and different CRUD operations.
	 * 
	 * ## Saving
	 * 
	 * There are two basic ways to save the contents of a Session: `getChanges` and
	 * `getSaveBatch`. We've already seen `getChanges`. The data contained in the CRUD object
	 * can be translated into whatever shape is needed by the server.
	 * 
	 * To leverage the [`proxy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-proxy) facilities defined by each Model
	 * class, there is the `getSaveBatch` method. That method returns an [`Ext.data.Batch`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html)
	 * object populated with the necessary `create`, `update` and `destory` operations to
	 * save all of the changes in the Session.
	 */
	class Session extends Ext.Base {
		/** 
		 * This object holds a key for any event that has a listener. The listener may be set
		 * directly on the instance, or on its class or a super class (via [observe](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#static-method-observe)) or
		 * on the [MVC EventBus](https://docs.sencha.com/extjs/6.2.0/modern/Ext.app.EventBus.html). The values of this object are truthy
		 * (a non-zero number) and falsy (0 or undefined). They do not represent an exact count
		 * of listeners. The value for an event is truthy if the event must be fired and is
		 * falsy if there is no need to fire the event.
		 * 
		 * The intended use of this property is to avoid the expense of fireEvent calls when
		 * there are no listeners. This can be particularly helpful when one would otherwise
		 * have to call fireEvent hundreds or thousands of times. It is used like this:
		 * 
		 *     if (this.hasListeners.foo) {
		 *         this.fireEvent('foo', this, arg1);
		 *     }
		 * 
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		readonly hasListeners?: object;
		/** 
		 * `true` in this class to identify an object as an instantiated Observable, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isObservable?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.Session.Statics}
		 */
		self?: Ext.data.Session.Statics | Ext.Base.Statics;
		/** 
		 * ---
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                    members    The members to add to this class.
		 * @param   {boolean}                   [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                   [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Session|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Session;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                    members
		 * @returns {Ext.data.Session|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.Session;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                    name
		 * @param   {object}                    member
		 * @returns {Ext.data.Session|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.Session;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                    fn
		 * @param   {object}                    scope
		 * @returns {Ext.data.Session|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.Session;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} config
		 */
		constructor (config: object);
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                            eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                          [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                                   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.data.Session.methodParams.addListener.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                                   [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                                   
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addListener? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.data.Session.methodParams.addListener.Options, order?: string): object;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Adds an existing record instance to the session. The record
		 * may not belong to another session. The record cannot be a phantom record, instead
		 * use [createRecord](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-createRecord).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record to adopt.
		 * @returns {void}                  
		 */
		adopt? (record: Ext.data.Model): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Marks the session as "clean" by calling [Ext.data.Model.commit](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-commit) on each record
		 * that is known to the session.
		 * 
		 * - Phantom records will no longer be phantom.
		 * - Modified records will no longer be dirty.
		 * - Dropped records will be erased.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		commit? (): void;
		/** 
		 * Creates a new record and tracks it in this session.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.Class} type   The `entityName` or the actual class of record to create.
		 * @param   {object}           [data] The data for the record.
		 * @returns {Ext.data.Model}          The new record.
		 */
		createRecord? (type: string | Ext.Class, data?: object): Ext.data.Model;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Returns an object describing all of the modified fields, created or dropped records
		 * and many-to-many association changes maintained by this session.
		 * @method
		 * @public (method)
		 * @returns {object}  An object in the CRUD format (see the intro docs). `null` if there are no changes.
		 */
		getChanges? (): object;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the value of [crudProperties](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#cfg-crudProperties).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getCrudProperties? (): object;
		/** 
		 * Returns the value of [dirty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Dirty.html#cfg-dirty).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getDirty? (): boolean;
		/** 
		 * Transforms a list of ids into a list of records for a particular type.
		 * @method
		 * @public (method)
		 * @param   {Ext.Class}        entityType The entity type.
		 * @param   {object[]}         ids        The ids to transform.
		 * @returns {Ext.data.Model[]}            The models corresponding to the ids.
		 */
		getEntityList? (entityType: Ext.Class, ids: object[]): Ext.data.Model[];
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Gets a user friendly identifier for a Model.
		 * @method
		 * @public (method)
		 * @param   {Ext.Class} entityType The entity type.
		 * @param   {object}    id         The id of the entity.
		 * @returns {string}               The identifier.
		 */
		getModelIdentifier? (entityType: Ext.Class, id: object): string;
		/** 
		 * Returns the value of [parent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#cfg-parent).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Session}  
		 */
		getParent? (): Ext.data.Session;
		/** 
		 * Get a cached record from the session. If the record does not exist, it will
		 * be created. If the `autoLoad` parameter is not set to `false`, the record will
		 * be loaded via the [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-proxy) of the Model.
		 * 
		 * If this session is configured with a [`parent`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#cfg-parent) session, a _copy_ of any existing record
		 * in the `parent` will be adopted into this session. If the `parent` does not contain the record,
		 * the record will be created and _not_ inserted into the parent.
		 * 
		 * See also [peekRecord](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-peekRecord).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.Class|Ext.data.Model} type
		 * The `entityName` or the actual class of record to create.
		 * This may also be a record instance, where the type and id will be inferred from the record. If the record is
		 * not attached to a session, it will be adopted. If it exists in a parent, an appropriate copy will be made as
		 * described.
		 * @param   {object}                          id         The id of the record.
		 * @param   {boolean|object}                  [autoLoad]
		 * `false` to prevent the record from being loaded if
		 * it does not exist. If this parameter is an object, it will be passed to the [Ext.data.Model.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-load) call.
		 * @returns {Ext.data.Model}                             The record.
		 */
		getRecord? (type: string | Ext.Class | Ext.data.Model, id: object, autoLoad?: boolean | object): Ext.data.Model;
		/** 
		 * Returns an [`Ext.data.Batch`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html) containing the [`Ext.data.operation.Operation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) instances
		 * that are needed to save all of the changes in this session. This sorting is based
		 * on operation type, associations and foreign keys. Generally speaking the operations
		 * in the batch can be committed to a server sequentially and the server will never be
		 * sent a request with an invalid (client-generated) id in a foreign key field.
		 * @method
		 * @public (method)
		 * @param   {boolean}        [sort] Pass `false` to disable the batch operation sort.
		 * @returns {Ext.data.Batch}        
		 */
		getSaveBatch? (sort?: boolean): Ext.data.Batch;
		/** 
		 * Returns the value of [schema](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#cfg-schema).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.schema.Schema}  
		 */
		getSchema? (): string | Ext.data.schema.Schema;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Returns `true` if this object is `dirty`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		isDirty? (): void;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * The [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method is shorthand for
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * 
		 * Appends an event handler to this object.  For example:
		 * 
		 *    myGridPanel.on("itemclick", this.onItemClick, this);
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple events. For example:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: this.onCellClick,
		 *        select: this.onSelect,
		 *        viewready: this.onViewReady,
		 *        scope: this // Important. Ensure "this" is correct during handler execution
		 *    });
		 * 
		 * One can also specify options for each event handler separately:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: this.onCellClick, scope: this, single: true},
		 *        viewready: {fn: panel.onViewReady, scope: panel}
		 *    });
		 * 
		 * _Names_ of methods in a specified scope may also be used:
		 * 
		 *    myGridPanel.on({
		 *        cellclick: {fn: 'onCellClick', scope: this, single: true},
		 *        viewready: {fn: 'onViewReady', scope: panel}
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|object}                                   eventName
		 * The name of the event to listen for.
		 * May also be an object who's property names are event names.
		 * @param   {Function|string}                                 [fn]
		 * The method the event invokes or the _name_ of
		 * the method within the specified `scope`.  Will be called with arguments
		 * given to [Ext.util.Observable.fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) plus the `options` parameter described
		 * below.
		 * @param   {object}                                          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object|Ext.data.Session.methodParams.on.Options} [options]
		 * An object containing handler configuration.
		 * 
		 * **Note:** The options object will also be passed as the last argument to every
		 * event handler.
		 * 
		 * This object may contain any of the following properties:
		 * @param   {string}                                          [order]
		 * A shortcut for the `order` event option.  Provided for backward compatibility.
		 *   Please use the `priority` event option instead.
		 * 
		 * **Combining Options**
		 * 
		 * Using the options argument, it is possible to combine different types of listeners:
		 * 
		 * A delayed, one-time listener.
		 * 
		 *    myPanel.on('hide', this.handleClick, this, {
		 *        single: true,
		 *        delay: 100
		 *    });
		 * 
		 * **Attaching multiple handlers in 1 call**
		 * 
		 * The method also allows for a single argument to be passed which is a config object
		 * containing properties which specify multiple handlers and handler configs.
		 * 
		 *    grid.on({
		 *        itemclick: 'onItemClick',
		 *        itemcontextmenu: grid.onItemContextmenu,
		 *        destroy: {
		 *            fn: function () {
		 *                // function called within the 'altCmp' scope instead of grid
		 *            },
		 *            scope: altCmp // unique scope for the destroy handler
		 *        },
		 *        scope: grid       // default scope - provided for example clarity
		 *    });
		 * 
		 * **Delegate**
		 * 
		 * This is a configuration option that you can pass along when registering a handler for
		 * an event to assist with event delegation. By setting this configuration option
		 * to a simple selector, the target element will be filtered to look for a
		 * descendant of the target. For example:
		 * 
		 *    var panel = Ext.create({
		 *        xtype: 'panel',
		 *        renderTo: document.body,
		 *        title: 'Delegate Handler Example',
		 *        frame: true,
		 *        height: 220,
		 *        width: 220,
		 *        html: '&lt;h1 class="myTitle"&gt;BODY TITLE&lt;/h1&gt;Body content'
		 *    });
		 *    
		 *    // The click handler will only be called when the click occurs on the
		 *    // delegate: h1.myTitle ("h1" tag with class "myTitle")
		 *    panel.on({
		 *        click: function (e) {
		 *            console.log(e.getTarget().innerHTML);
		 *        },
		 *        element: 'body',
		 *        delegate: 'h1.myTitle'
		 *     });
		 * 
		 * @returns {object}                                          
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes
		 *  all listeners added in this call. For example:
		 * 
		 *    this.btnListeners =  = myButton.on({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		on? (eventName: string | object, fn?: ExtGlobalFunction | string, scope?: object, options?: object | Ext.data.Session.methodParams.on.Options, order?: string): object;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Gets an existing record from the session. The record will _not_ be created if it does
		 * not exist.
		 * 
		 * See also: [getRecord](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-getRecord).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.Class} type   The `entityName` or the actual class of record to create.
		 * @param   {object}           id     The id of the record.
		 * @param   {boolean}          [deep] `true` to consult
		 * @returns {Ext.data.Model}          The record, `null` if it does not exist.
		 */
		peekRecord? (type: string | Ext.Class, id: object, deep?: boolean): Ext.data.Model;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Save any changes in this session to a [parent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#cfg-parent) session.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		save? (): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}             name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                    [value] The value to set for the name parameter.
		 * @returns {Ext.data.Session|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Session;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the value of [crudProperties](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#cfg-crudProperties).
		 * @method
		 * @public (method)
		 * @param   {object} crudProperties The new value.
		 * @returns {void}                  
		 */
		setCrudProperties? (crudProperties: object): void;
		/** 
		 * Sets the value of [dirty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Dirty.html#cfg-dirty).
		 * @method
		 * @public (method)
		 * @param   {boolean} dirty The new value.
		 * @returns {void}          
		 */
		setDirty? (dirty: boolean): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [parent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#cfg-parent).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} parent The new value.
		 * @returns {void}                    
		 */
		setParent? (parent: Ext.data.Session): void;
		/** 
		 * Sets the value of [schema](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#cfg-schema).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.schema.Schema} schema The new value.
		 * @returns {void}                                 
		 */
		setSchema? (schema: string | Ext.data.schema.Schema): void;
		/** 
		 * Create a child session with this session as the [parent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#cfg-parent).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Session}  The copied session.
		 */
		spawn? (): Ext.data.Session;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Complete a bulk update for this session.
		 * @method
		 * @public (method)
		 * @param   {object} data Data in the CRUD format (see the intro docs).
		 * @returns {void}        
		 */
		update? (data: object): void;
		/** 
		 * Walks the internal data tracked by this session and calls methods on the provided
		 * `visitor` object. The visitor can then accumulate whatever data it finds important.
		 * The visitor object can provide a number of methods, but all are optional.
		 * 
		 * This method does not enumerate associations since these can be traversed given the
		 * records that are enumerated. For many-to-many associations, however, this method
		 * does enumerate the changes because these changes are not "owned" by either side of
		 * such associations.
		 * @method
		 * @public (method)
		 * @param   {object|Ext.data.Session.methodParams.visitData.Visitor} visitor
		 * @returns {object}                                                         The visitor instance
		 */
		visitData? (visitor: object | Ext.data.Session.methodParams.visitData.Visitor): object;
		/** 
		 * Template method, will be called by Model after a record is committed.
		 * @method
		 * @protected (method)
		 * @param   {Ext.data.Model} record The record.
		 * @returns {void}                  
		 */
		afterCommit? (record: Ext.data.Model): void;
		/** 
		 * Template method, will be called by Model after a record is dropped.
		 * @method
		 * @protected (method)
		 * @param   {Ext.data.Model} record The record.
		 * @returns {void}                  
		 */
		afterDrop? (record: Ext.data.Model): void;
		/** 
		 * Template method, will be called by Model after a record is edited.
		 * @method
		 * @protected (method)
		 * @param   {Ext.data.Model} record The record.
		 * @returns {void}                  
		 */
		afterEdit? (record: Ext.data.Model): void;
		/** 
		 * Template method, will be called by Model after a record is erased (a drop
		 * that is committed).
		 * @method
		 * @protected (method)
		 * @param   {Ext.data.Model} record The record.
		 * @returns {void}                  
		 */
		afterErase? (record: Ext.data.Model): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Clears all record state tracking. This state is maintained by `trackRecordState`
		 * and `untrackRecordState`.
		 * @method
		 * @protected (method)
		 * @returns {void}  
		 */
		clearRecordStates? (): void;
		/** 
		 * The same functionality as [getChanges](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-getChanges), however we also take into account our
		 * parent session.
		 * @method
		 * @protected (method)
		 * @returns {object}  An object in the CRUD format (see the intro docs). `null` if there are no changes.
		 */
		getChangesForParent? (): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                    config
		 * @returns {Ext.data.Session|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.Session;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Triggered when an associated item from [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-update) references a record
		 * that does not exist in the session.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.Class} entityType The entity type.
		 * @param   {object}    id         The id of the model.
		 * @returns {void}                 
		 */
		onInvalidAssociationEntity? (entityType: Ext.Class, id: object): void;
		/** 
		 * Triggered when an drop block from [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-update) tries to create a record
		 * that already exists.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.Class} entityType The entity type.
		 * @param   {object}    id         The id of the model.
		 * @returns {void}                 
		 */
		onInvalidEntityCreate? (entityType: Ext.Class, id: object): void;
		/** 
		 * Triggered when an drop block from [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-update) references a record
		 * that does not exist in the session.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.Class} entityType The entity type.
		 * @param   {object}    id         The id of the model.
		 * @returns {void}                 
		 */
		onInvalidEntityDrop? (entityType: Ext.Class, id: object): void;
		/** 
		 * Triggered when an drop block from [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-update) tries to create a record
		 * that already exists.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.Class} entityType The entity type.
		 * @param   {object}    id         The id of the model.
		 * @returns {void}                 
		 */
		onInvalidEntityRead? (entityType: Ext.Class, id: object): void;
		/** 
		 * Triggered when an update block from [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-update) references a record
		 * that does not exist in the session.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.Class} entityType The entity type.
		 * @param   {object}    id         The id of the model.
		 * @param   {boolean}   dropped    `true` if the record was dropped.
		 * @returns {void}                 
		 */
		onInvalidEntityUpdate? (entityType: Ext.Class, id: object, dropped: boolean): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * This method is called to track a given record in the total number of dirty records
		 * (modified, created or dropped). See `untrackRecordState` and `clearRecordStates`.
		 * @method
		 * @protected (method)
		 * @param   {Ext.data.Model} record  The record to track.
		 * @param   {boolean}        initial Pass `true` the first time a record is introduced.
		 * @returns {boolean}                Returns `true` if the state of dirty records has changed.
		 */
		trackRecordState? (record: Ext.data.Model, initial: boolean): boolean;
		/** 
		 * This method is called to remove the tracking of a given record from the total number
		 * of dirty records (modified, created or dropped). The record passed to this method
		 * must have been previously passed to `trackRecordState`.
		 * @method
		 * @protected (method)
		 * @param   {Ext.data.Model} record The record to stop tracking.
		 * @returns {boolean}               Returns `true` if the state of dirty records has changed.
		 */
		untrackRecordState? (record: Ext.data.Model): boolean;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Session.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.Session.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                  names The names of the linked objects to destroy.
		 * @returns {Ext.data.Session|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.Session;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * [Ext.data.SortTypes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.SortTypes.html)
	 * This class defines a series of static methods that are used on a
	 * [Ext.data.Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) for performing sorting. The methods cast the
	 * underlying values into a data type that is appropriate for sorting on
	 * that particular field.  If a [Ext.data.Field.type](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#property-type) is specified,
	 * the sortType will be set to a sane default if the sortType is not
	 * explicitly defined on the field. The sortType will make any necessary
	 * modifications to the value and return it.
	 * 
	 * - **`asText`** - Removes any tags and converts the value to a string
	 * - **`asUCText`** - Removes any tags and converts the value to an uppercase string
	 * - **`asUCText`** - Converts the value to an uppercase string
	 * - **`asDate`** - Converts the value into Unix epoch time
	 * - **`asFloat`** - Converts the value to a floating point number
	 * - **`asInt`** - Converts the value to an integer number
	 * 
	 * It is also possible to create a custom sortType that can be used throughout
	 * an application.
	 * 
	 *     Ext.apply(Ext.data.SortTypes, {
	 *         asPerson: function(person){
	 *             // expects an object with a first and last name property
	 *             return person.lastName.toUpperCase() + person.firstName.toLowerCase();
	 *         }
	 *     });
	 *    
	 *     Ext.define('Employee', {
	 *         extend: 'Ext.data.Model',
	 *         fields: [{
	 *             name: 'person',
	 *             sortType: 'asPerson'
	 *         }, {
	 *             name: 'salary',
	 *             type: 'float' // sortType set to asFloat
	 *         }]
	 *     });
	 * 
	 * @singleton (definition)
	 */
	interface SortTypes extends Ext.Base {
		/** 
		 * The regular expression used to strip commas
		 * @property
		 * @public (property)
		 * @default /,/g
		 * @type {RegExp}
		 */
		stripCommasRe?: RegExp;
		/** 
		 * The regular expression used to strip tags
		 * @property
		 * @public (property)
		 * @default /<\/?[^>]+>/gi
		 * @type {RegExp}
		 */
		stripTagsRE?: RegExp;
		/** 
		 * Date sorting
		 * @method
		 * @public (method)
		 * @param   {object} s The value being converted
		 * @returns {number}   The comparison value
		 */
		asDate? (s: object): number;
		/** 
		 * Float sorting
		 * @method
		 * @public (method)
		 * @param   {object} s The value being converted
		 * @returns {number}   The comparison value
		 */
		asFloat? (s: object): number;
		/** 
		 * Integer sorting
		 * @method
		 * @public (method)
		 * @param   {object} s The value being converted
		 * @returns {number}   The comparison value
		 */
		asInt? (s: object): number;
		/** 
		 * Strips all HTML tags to sort on text only
		 * @method
		 * @public (method)
		 * @param   {object} s The value being converted
		 * @returns {string}   The comparison value
		 */
		asText? (s: object): string;
		/** 
		 * Case insensitive string
		 * @method
		 * @public (method)
		 * @param   {object} s The value being converted
		 * @returns {string}   The comparison value
		 */
		asUCString? (s: object): string;
		/** 
		 * Strips all HTML tags to sort on text only - Case insensitive
		 * @method
		 * @public (method)
		 * @param   {object} s The value being converted
		 * @returns {string}   The comparison value
		 */
		asUCText? (s: object): string;
		/** 
		 * Default sort that does nothing
		 * @method
		 * @public (method)
		 * @param   {object} s The value being converted
		 * @returns {object}   The comparison value
		 */
		none? (s: object): object;
	}
	/** 
	 * [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
	 * The Store class encapsulates a client side cache of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) objects. Stores load data via a
	 * [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html), and also provide functions for [sorting](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort), [filtering](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter)
	 * and querying the [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances contained within it.
	 * 
	 * Creating a Store is easy - we just tell it the Model and the Proxy to use for loading and saving its data:
	 * 
	 *     // Set up a model to use in our Store
	 *     Ext.define('User', {
	 *         extend: 'Ext.data.Model',
	 *         fields: [
	 *             {name: 'firstName', type: 'string'},
	 *             {name: 'lastName',  type: 'string'},
	 *             {name: 'age',       type: 'int'},
	 *             {name: 'eyeColor',  type: 'string'}
	 *         ]
	 *     });
	 *    
	 *     var myStore = Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         proxy: {
	 *             type: 'ajax',
	 *             url: '/users.json',
	 *             reader: {
	 *                 type: 'json',
	 *                 rootProperty: 'users'
	 *             }
	 *         },
	 *         autoLoad: true
	 *     });
	 * 
	 * In the example above we configured an AJAX proxy to load data from the url '/users.json'. We told our Proxy to use a
	 * [JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) to parse the response from the server into Model object - [see the docs on JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) for details.
	 * 
	 * ## Inline data
	 * 
	 * Stores can also load data inline. Internally, Store converts each of the objects we pass in as [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-data) into
	 * Model instances:
	 * 
	 *     Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         data : [
	 *             {firstName: 'Peter',   lastName: 'Venkman'},
	 *             {firstName: 'Egon',    lastName: 'Spengler'},
	 *             {firstName: 'Ray',     lastName: 'Stantz'},
	 *             {firstName: 'Winston', lastName: 'Zeddemore'}
	 *         ]
	 *     });
	 * 
	 * Loading inline data using the method above is great if the data is in the correct format already (e.g. it doesn't
	 * need to be processed by a [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html)). If your inline data requires processing to decode
	 * the data structure, use a [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) instead (see the [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) docs for an example).
	 * 
	 * Additional data can also be loaded locally using [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
	 * 
	 * ## Dynamic Loading
	 * 
	 * Stores can be dynamically updated by calling the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load) method:
	 * 
	 *    store.load({
	 *        params: {
	 *            group: 3,
	 *            type: 'user'
	 *        },
	 *        callback: function(records, operation, success) {
	 *            // do something after the load finishes
	 *        },
	 *        scope: this
	 *    });
	 * 
	 * Here a bunch of arbitrary parameters is passed along with the load request and a callback function is set
	 * up to do something after the loading is over.
	 * 
	 * ## Loading Nested Data
	 * 
	 * Applications often need to load sets of associated data - for example a CRM system might load a User and her Orders.
	 * Instead of issuing an AJAX request for the User and a series of additional AJAX requests for each Order, we can load
	 * a nested dataset and allow the Reader to automatically populate the associated models. Below is a brief example, see
	 * the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) intro docs for a full explanation:
	 * 
	 *     var store = Ext.create('Ext.data.Store', {
	 *         autoLoad: true,
	 *         model: "User",
	 *         proxy: {
	 *             type: 'ajax',
	 *             url: 'users.json',
	 *             reader: {
	 *                 type: 'json',
	 *                 rootProperty: 'users'
	 *             }
	 *         }
	 *     });
	 * 
	 * Which would consume a response like this:
	 * 
	 *     {
	 *         "users": [{
	 *             "id": 1,
	 *             "name": "Peter",
	 *             "orders": [{
	 *                 "id": 10,
	 *                 "total": 10.76,
	 *                 "status": "invoiced"
	 *            },{
	 *                 "id": 11,
	 *                 "total": 13.45,
	 *                 "status": "shipped"
	 *            }]
	 *         }]
	 *     }
	 * 
	 * See the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) intro docs for a full explanation.
	 * 
	 * ## Filtering and Sorting
	 * 
	 * Stores can be sorted and filtered - in both cases either remotely or locally. The [sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-sorters) and
	 * [filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-filters) are held inside [Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) instances to make them easy to manage.
	 * Usually it is sufficient to either just specify sorters and filters in the Store configuration or call [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort)
	 * or [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter):
	 * 
	 *     var store = Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         sorters: [{
	 *             property: 'age',
	 *             direction: 'DESC'
	 *         }, {
	 *             property: 'firstName',
	 *             direction: 'ASC'
	 *         }],
	 *    
	 *         filters: [{
	 *             property: 'firstName',
	 *             value: /Peter/
	 *         }]
	 *     });
	 * 
	 * The new Store will keep the configured sorters and filters in the Collection instances mentioned above. By
	 * default, sorting and filtering are both performed locally by the Store - see [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) and
	 * [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteFilter) to allow the server to perform these operations instead.
	 * 
	 * Filtering and sorting after the Store has been instantiated is also easy. Calling [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) adds another filter
	 * to the Store and automatically filters the dataset (calling [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) with no arguments simply re-applies all
	 * existing filters).
	 * 
	 *    store.filter('eyeColor', 'Brown');
	 * 
	 * Change the sorting at any time by calling [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort):
	 * 
	 *    store.sort('height', 'ASC');
	 * 
	 * Note that all existing sorters will be removed in favor of the new sorter data (if [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort) is called with no
	 * arguments, the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new
	 * ones, just add them to the Collection:
	 * 
	 *    store.sorters.add(new Ext.util.Sorter({
	 *        property : 'shoeSize',
	 *        direction: 'ASC'
	 *    }));
	 *    
	 *    store.sort();
	 * 
	 * ## Registering with StoreManager
	 * 
	 * Any Store that is instantiated with a [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-storeId) will automatically be registered with the [StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html). This makes it easy to reuse the same store in multiple views:
	 * 
	 *    //this store can be used several times
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        storeId: 'usersStore'
	 *    });
	 *    
	 *    new Ext.List({
	 *        store: 'usersStore',
	 *        //other config goes here
	 *    });
	 *    
	 *    new Ext.view.View({
	 *        store: 'usersStore',
	 *        //other config goes here
	 *    });
	 * 
	 * ## Further Reading
	 * 
	 * Stores are backed up by an ecosystem of classes that enables their operation. To gain a full understanding of these
	 * pieces and how they fit together, see:
	 * 
	 * - [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) - overview of what Proxies are and how they are used
	 * - [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) - the core class in the data package
	 * - [Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) - used by any subclass of [ServerProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Server.html) to read a response
	 */
	class Store extends Ext.data.ProxyStore {
		/** 
		 * The number of times records have been loaded into the store. This includes loads via
		 * [loadData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadData) &amp; [loadRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRecords).
		 * @property
		 * @public (property)
		 * @readonly
		 * @default 0
		 * @type {number}
		 */
		readonly loadCount?: number;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.Store.Statics}
		 */
		self?: Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * Used as a parameter to loadRecords
		 * @property
		 * @private (property)
		 * @default {addRecords: true}
		 * @type {object}
		 */
		addRecordsOptions?: object;
		/** 
		 * `true` once the store has loaded data from the server.
		 * @property
		 * @private (property)
		 * @default false
		 * @type {boolean}
		 */
		complete?: boolean;
		/** 
		 * The `data` property is a `Collection` which holds this store's local cache of records.
		 * @property
		 * @private (property)
		 * @readonly
		 * @type {Ext.util.Collection}
		 */
		readonly data?: Ext.util.Collection;
		/** 
		 * @property
		 * @private (property)
		 * @default {id: 'localstore'}
		 * @type {object}
		 */
		mixinConfig?: object;
		/** 
		 * @property
		 * @private (property)
		 * @default 0
		 * @type {number}
		 */
		moveMapCount?: number;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                             members    The members to add to this class.
		 * @param   {boolean}                                                            [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                            [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                             members
		 * @returns {Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.Store;
		static addStatics? (members: object): typeof Ext.data.ProxyStore;
		static addStatics? (members: object): typeof Ext.data.AbstractStore;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                             name
		 * @param   {object}                                                             member
		 * @returns {Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.Store;
		static addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		static addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                             fn
		 * @param   {object}                                                             scope
		 * @returns {Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		static onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                The model instances that were added
		 */
		add? (model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {...Ext.data.Model|...object} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                  The model instances that were added
		 */
		add? (...model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * Adds a new Filter to this Store's [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {object[]|Ext.util.Filter[]} filters         The set of filters to add to the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters).
		 * @param   {boolean}                    [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                       
		 */
		addFilter? (filters: object[] | Ext.util.Filter[], suppressEvent?: boolean): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * (Local sort only) Inserts the passed Record into the Store at the index where it
		 * should go based on the current sort information.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Record} record
		 * @returns {void}                   
		 */
		addSorted? (record: Ext.data.Record): void;
		/** 
		 * Runs the aggregate function for all the records in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {Function} fn
		 * The function to execute. The function is called with a single parameter,
		 * an array of records for that group.
		 * @param   {object}   scope   The scope to execute the function in. Defaults to the store.
		 * @param   {boolean}  grouped
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @param   {string}   field   The field to get the value from
		 * @returns {object}           An object literal with the group names and their appropriate values.
		 */
		aggregate? (fn: ExtGlobalFunction, scope: object, grouped: boolean, field: string): object;
		/** 
		 * Gets the average value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The average value, if no items exist, 0.
		 */
		average? (field: string, grouped?: boolean): object;
		/** 
		 * This method may be called to indicate the start of multiple changes to the store.
		 * 
		 * Automatic synchronization as configured by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred
		 * until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple mutations can be coalesced
		 * into one synchronization operation.
		 * 
		 * Internally this method increments a counter that is decremented by `endUpdate`. It
		 * is important, therefore, that if you call `beginUpdate` directly you match that
		 * call with a call to `endUpdate` or you will prevent the collection from updating
		 * properly.
		 * 
		 * For example:
		 * 
		 *     var store = Ext.StoreManager.lookup({
		 *         //...
		 *         autoSync: true
		 *     });
		 *    
		 *     store.beginUpdate();
		 *    
		 *     record.set('fieldName', 'newValue');
		 *    
		 *     store.add(item);
		 *     // ...
		 *    
		 *     store.insert(index, otherItem);
		 *     //...
		 *    
		 *     // Interested parties will listen for the endupdate event
		 *     store.endUpdate();
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginUpdate? (): void;
		/** 
		 * Reverts to a view of the Record cache with no filtering applied.
		 * @method
		 * @public (method)
		 * @param   {boolean} [suppressEvent]
		 * If `true` the filter is cleared silently.
		 * 
		 * For a locally filtered Store, this means that the filter collection is cleared without firing the
		 * [datachanged](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-datachanged) event.
		 * 
		 * For a remotely filtered Store, this means that the filter collection is cleared, but the store
		 * is not reloaded from the server.
		 * @returns {void}                    
		 */
		clearFilter? (suppressEvent?: boolean): void;
		/** 
		 * Clear the store grouping
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearGrouping? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Collects unique values for a particular dataIndex from this store.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * 
		 *    var store = Ext.create('Ext.data.Store', {
		 *        fields: ['name'],
		 *        data: [{
		 *            name: 'Larry'
		 *        }, {
		 *            name: 'Darryl'
		 *        }, {
		 *            name: 'Darryl'
		 *        }]
		 *    });
		 *    
		 *    store.collect('name');
		 *    // returns ["Larry", "Darryl"]
		 * 
		 * @method
		 * @public (method)
		 * @param   {string}                                                    property         The property to collect
		 * @param   {object|Ext.data.Store.methodParams.collect.IncludeOptions} [includeOptions] An object which contains options which modify how the store is traversed.
		 * @returns {object[]}                                                                   An array of the unique values
		 */
		collect? (property: string, includeOptions?: object | Ext.data.Store.methodParams.collect.IncludeOptions): object[];
		/** 
		 * Commits all Records with [outstanding changes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords). To handle updates for changes,
		 * subscribe to the Store's [update event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-update), and perform updating when the third parameter is
		 * [Ext.data.Record.COMMIT](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#static-property-COMMIT).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		commitChanges? (): void;
		/** 
		 * Gets the count of items in the store.
		 * 
		 * When store is filtered, only items within the filter are counted.
		 * @method
		 * @public (method)
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the count for each group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            the count
		 */
		count? (grouped?: boolean): number;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Calls the specified function for each [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in the store.
		 * 
		 * When store is filtered, only loops over the filtered records.
		 * @method
		 * @public (method)
		 * @param   {Function}                                               fn
		 * The function to call. The [Record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) is passed as the first parameter.
		 * Returning `false` aborts and exits the iteration.
		 * @param   {object}                                                 [scope]
		 * The scope (`this` reference) in which the function is executed.
		 * Defaults to the current [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in the iteration.
		 * @param   {object|Ext.data.Store.methodParams.each.IncludeOptions} [includeOptions] An object which contains options which modify how the store is traversed.
		 * @returns {void}                                                                    
		 */
		each? (fn: ExtGlobalFunction, scope?: object, includeOptions?: object | Ext.data.Store.methodParams.each.IncludeOptions): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * This method is called after modifications are complete on a store. For details
		 * see [`beginUpdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		endUpdate? (): void;
		/** 
		 * Filters the data in the Store by one or more fields. Example usage:
		 * 
		 *    //filter with a single field
		 *    myStore.filter('firstName', 'Don');
		 *    
		 *    //filtering with multiple filters
		 *    myStore.filter([
		 *        {
		 *            property : 'firstName',
		 *            value    : 'Don'
		 *        },
		 *        {
		 *            property : 'lastName',
		 *            value    : 'Griffin'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) instances, and delegates
		 * the actual filtering to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter[]} [filters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of filter configurations.
		 * @param   {string}                   [value]   The property value by which to filter. Only applicable if `filters` is a string.
		 * @returns {void}                               
		 */
		filter? (filters?: string | Ext.util.Filter[], value?: string): void;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of the Record field to test.
		 * @param   {string|RegExp} value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}        [startIndex]    The index to start searching at
		 * @param   {boolean}       [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}       [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {number}                        The matched index or -1
		 */
		find? (property: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string} fieldName    The name of the Record field to test.
		 * @param   {object} value        The value to match the field against.
		 * @param   {number} [startIndex] The index to start searching at
		 * @returns {number}              The matched index or -1
		 */
		findExact? (fieldName: string, value: object, startIndex?: number): number;
		/** 
		 * Finds the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}         fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}  value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}         [startIndex]    The index to start searching at
		 * @param   {boolean}        [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}        [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}        [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.Model}                 The matched record or null
		 */
		findRecord? (fieldName: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Convenience function for getting the first model instance in the store.
		 * 
		 * When store is filtered, will return first item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the first record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The first model instance in the store, or undefined
		 */
		first? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Called when the event handler which called the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method exits.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		flushLoad? (): void;
		/** 
		 * Returns the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAsynchronousLoad? (): boolean;
		/** 
		 * Get the Record at the specified index.
		 * 
		 * The index is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}         index The index of the Record to find.
		 * @returns {Ext.data.Model}       The Record at the passed index. Returns null if not found.
		 */
		getAt? (index: number): Ext.data.Model;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Returns the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean|object}  
		 */
		getAutoLoad? (): boolean | object;
		/** 
		 * Returns the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoSync? (): boolean;
		/** 
		 * Returns the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchUpdateMode? (): string;
		/** 
		 * Get the Record with the specified id.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            id The id of the Record to find.
		 * @returns {Ext.data.Model}    The Record with the passed id. Returns null if not found.
		 */
		getById? (id: any): Ext.data.Model;
		/** 
		 * Get the Record with the specified internalId.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            internalId The id of the Record to find.
		 * @returns {Ext.data.Model}            The Record with the passed internalId. Returns null if not found.
		 */
		getByInternalId? (internalId: any): Ext.data.Model;
		/** 
		 * Returns the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearOnPageLoad? (): boolean;
		/** 
		 * Returns the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearRemovedOnLoad? (): boolean;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Gets the number of records in store.
		 * 
		 * If using paging, this may not be the total size of the dataset. If the data object
		 * used by the Reader contains the dataset size, then the [Ext.data.ProxyStore.getTotalCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getTotalCount) function returns
		 * the dataset size.  **Note**: see the Important note in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load).
		 * 
		 * When store is filtered, it's the number of records matching the filter.
		 * @method
		 * @public (method)
		 * @returns {number}  The number of Records in the Store.
		 */
		getCount? (): number;
		/** 
		 * Returns the store's records.
		 * 
		 * **Note:** If your store has been filtered, getData() will return a filtered
		 * collection.  Use `getData().[getSource()`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#method-getSource) to
		 * fetch all unfiltered records.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection} 
		 * An [Ext.util.Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) of records
		 * (an empty Collection if no records are held by the store).
		 */
		getData? (): Ext.util.Collection;
		/** 
		 * Returns the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraKeys? (): object;
		/** 
		 * Returns the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @returns {object[]|string[]}  
		 */
		getFields? (): object[] | string[];
		/** 
		 * Gets the filters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.FilterCollection}            The filters
		 */
		getFilters? (autoCreate: object): Ext.util.FilterCollection;
		/** 
		 * Returns the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDir? (): string;
		/** 
		 * Returns the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @returns {object|Ext.util.Grouper}  
		 */
		getGrouper? (): object | Ext.util.Grouper;
		/** 
		 * Returns a collection of readonly sub-collections of your store's records
		 * with grouping applied. These sub-collections are maintained internally by
		 * the collection.
		 * 
		 * See [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField), [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir). Example for a store
		 * containing records with a color field:
		 * 
		 *    var myStore = Ext.create('Ext.data.Store', {
		 *        groupField: 'color',
		 *        groupDir  : 'DESC'
		 *    });
		 *    
		 *    myStore.getGroups();
		 * 
		 * The above should result in the following format:
		 * 
		 *    [
		 *        {
		 *            name: 'yellow',
		 *            children: [
		 *                // all records where the color field is 'yellow'
		 *            ]
		 *        },
		 *        {
		 *            name: 'red',
		 *            children: [
		 *                // all records where the color field is 'red'
		 *            ]
		 *        }
		 *    ]
		 * 
		 * Group contents are affected by filtering.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection}  The grouped data
		 */
		getGroups? (): Ext.util.Collection;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Gets all [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) added or updated since the last commit. Note that the order of records
		 * returned is not deterministic and does not indicate the order in which records were modified. Note also that
		 * removed records are not included (use [getRemovedRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getRemovedRecords) for that).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The added and updated Model instances
		 */
		getModifiedRecords? (): Ext.data.Model[];
		/** 
		 * Returns all [`phantom`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records in this store.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  A possibly empty array of `phantom` records.
		 */
		getNewRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getPageSize? (): number;
		/** 
		 * Returns the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.proxy.Proxy|object}  
		 */
		getProxy? (): string | Ext.data.proxy.Proxy | object;
		/** 
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}           start The starting index. Defaults to zero.
		 * @param   {number}           end   The ending index. Defaults to the last record. The end index **is included**.
		 * @returns {Ext.data.Model[]}       An array of records.
		 */
		getRange? (start: number, end: number): Ext.data.Model[];
		/** 
		 * Returns the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteFilter? (): boolean;
		/** 
		 * Returns the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteSort? (): boolean;
		/** 
		 * Returns any records that have been removed from the store but not yet destroyed on the proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]} 
		 * The removed Model instances. Note that this is a _copy_ of the store's
		 * array, so may be mutated.
		 */
		getRemovedRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Session}  
		 */
		getSession? (): Ext.data.Session;
		/** 
		 * Returns the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSortOnLoad? (): boolean;
		/** 
		 * Gets the sorters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.SorterCollection}            The sorters
		 */
		getSorters? (autoCreate: object): Ext.util.SorterCollection;
		/** 
		 * Returns the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getStatefulFilters? (): boolean;
		/** 
		 * Returns the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStoreId? (): string;
		/** 
		 * Returns the total number of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances that the [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html)
		 * indicates exist. This will usually differ from [getCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getCount) when using paging - getCount returns the
		 * number of records loaded into the Store at the moment, getTotalCount returns the number of records that
		 * could be loaded into the Store if the Store contained all data
		 * @method
		 * @public (method)
		 * @returns {number} 
		 * The total number of Model instances available via the Proxy. 0 returned if
		 * no value has been set via the reader.
		 */
		getTotalCount? (): number;
		/** 
		 * Returns the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getTrackRemoved? (): boolean;
		/** 
		 * Returns all valid, non-phantom Model instances that have been updated in the Store but not yet synchronized with the Proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The updated Model instances
		 */
		getUpdatedRecords? (): Ext.data.Model[];
		/** 
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {string|object} grouper
		 * Either a string name of one of the fields in this Store's
		 * configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an object, or a [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Grouper.html) configuration object.
		 * @param   {string}        [direction] The overall direction to group the data by. Defaults to the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @returns {void}                      
		 */
		group? (grouper: string | object, direction?: string): void;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Get the index of the record within the store.
		 * 
		 * When store is filtered, records outside of filter will not be found.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) object to find.
		 * @returns {number}                The index of the passed Record. Returns -1 if not found.
		 */
		indexOf? (record: Ext.data.Model): number;
		/** 
		 * Get the index within the store of the Record with the passed id.
		 * 
		 * Like [indexOf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-indexOf), this method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {string} id The id of the Record to find.
		 * @returns {number}    The index of the Record. Returns -1 if not found.
		 */
		indexOfId? (id: string): number;
		/** 
		 * Inserts Model instances into the Store at the given index and fires the add event.
		 * See also [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
		 * @method
		 * @public (method)
		 * @param   {number}                                          index   The start index at which to insert the passed Records.
		 * @param   {Ext.data.Model|Ext.data.Model[]|object|object[]} records
		 * An [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instance, the
		 * data needed to populate an instance or an array of either of these.
		 * @returns {Ext.data.Model[]}                                        records The added records
		 */
		insert? (index: number, records: Ext.data.Model | Ext.data.Model[] | object | object[]): Ext.data.Model[];
		/** 
		 * Tests whether the store currently has any active filters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is filtered.
		 */
		isFiltered? (): boolean;
		/** 
		 * Tests whether the store currently has an active grouper.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is grouped.
		 */
		isGrouped? (): boolean;
		/** 
		 * Returns `true` if the Store has been loaded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store has been loaded.
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns true if the Store is currently performing a load operation
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store is currently loading
		 */
		isLoading? (): boolean;
		/** 
		 * Tests whether the store currently has any active sorters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is sorted.
		 */
		isSorted? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Convenience function for getting the last model instance in the store.
		 * 
		 * When store is filtered, will return last item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the last record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The last model instance in the store, or undefined
		 */
		last? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Loads an array of data straight into the Store.
		 * 
		 * Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
		 * processed by a reader). If your data requires processing to decode the data structure, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @param   {boolean}                   [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {void}                               
		 */
		loadData? (data: Ext.data.Model[] | object[], append?: boolean): void;
		/** 
		 * Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
		 * load operation, passing in calculated 'start' and 'limit' params.
		 * @method
		 * @public (method)
		 * @param   {number} page      The number of the page to load.
		 * @param   {object} [options] See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		loadPage? (page: number, options?: object): void;
		/** 
		 * Loads data via the bound Proxy's reader
		 * 
		 * Use this method if you are attempting to load data and want to utilize the configured data reader.
		 * 
		 * As of 4.2, this method will no longer fire the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-load) event.
		 * @method
		 * @public (method)
		 * @param   {object[]} data     The full JSON object you'd like to load into the Data store.
		 * @param   {boolean}  [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {boolean}  
		 * `true` if the reader processed the records correctly. See [Ext.data.reader.Reader.successProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-successProperty).
		 * If the reader did not process the records, nothing will be added.
		 */
		loadRawData? (data: object[], append?: boolean): boolean;
		/** 
		 * Loads an array of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances into the store, fires the datachanged event. This should only usually
		 * be called internally when loading from the [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html), when adding records manually use [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add) instead
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]}                                       records The array of records to load
		 * @param   {object|Ext.data.Store.methodParams.loadRecords.Options} options
		 * @returns {void}                                                           
		 */
		loadRecords? (records: Ext.data.Model[], options: object | Ext.data.Store.methodParams.loadRecords.Options): void;
		/** 
		 * Gets the maximum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the maximum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The maximum value, if no items exist, undefined.
		 */
		max? (field: string, grouped?: boolean): object;
		/** 
		 * Gets the minimum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the minimum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The minimum value, if no items exist, undefined.
		 */
		min? (field: string, grouped?: boolean): object;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Loads the next 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		nextPage? (options: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Loads the previous 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		previousPage? (options: object): void;
		/** 
		 * Query all the cached records in this Store by name/value pair.
		 * The parameters will be used to generated a filter function that is given
		 * to the queryBy method.
		 * 
		 * This method complements queryBy by generating the query function automatically.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @public (method)
		 * @param   {string}              property        The property to create the filter function for
		 * @param   {string|RegExp}       value           The string/regex to compare the property value to
		 * @param   {boolean}             [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}             [caseSensitive] `true` to create a case-sensitive regex.
		 * @param   {boolean}             [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.util.Collection}                 The matched records
		 */
		query? (property: string, value: string | RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.util.Collection;
		/** 
		 * Query all the cached records in this Store using a filtering function. The specified function
		 * will be called with each record in this Store. If the function returns `true` the record is
		 * included in the results.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @public (method)
		 * @param   {Function}            fn          The function to be called. It will be passed the following parameters:
		 * @param   {Ext.data.Model}      [fn.record]
		 * The record to test for filtering. Access field values
		 *  using [Ext.data.Model.get](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-get).
		 * @param   {object}              [fn.id]     The ID of the Record passed.
		 * @param   {void}                fn.returns
		 * @param   {object}              [scope]
		 * The scope (this reference) in which the function is executed
		 * Defaults to this Store.
		 * @returns {Ext.util.Collection}             The matched records
		 */
		queryBy? (fn: ((record?: Ext.data.Model, id?: object) => void) | ExtGlobalFunction, scope?: object): Ext.util.Collection;
		/** 
		 * [Rejects](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-reject) outstanding changes on all [modified records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords)
		 * and re-insert any records that were removed locally. Any phantom records will be removed.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		rejectChanges? (): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Reloads the store using the last options passed to the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method. You can use the reload method to reload the
		 * store using the parameters from the last load() call. For example:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload();
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution will pass the `userid` parameter in the request. The [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) execution
		 * will also send the same `userid` parameter in its request as it will reuse the `params` object from the last [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) call.
		 * 
		 * You can override a param by passing in the config object with the `params` object:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216,
		 *            foo    : 'bar'
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload({
		 *        params : {
		 *            userid : 1234
		 *        }
		 *    });
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution sends the `userid` and `foo` parameters but in the [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) it only sends
		 * the `userid` paramter because you are overriding the `params` config not just overriding the one param. To only change a single param
		 * but keep other params, you will have to get the last params from the [lastOptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#property-lastOptions) property:
		 * 
		 *    var lastOptions = store.lastOptions,
		 *        lastParams = Ext.clone(lastOptions.params); // make a copy of the last params so we don't affect future reload() calls
		 *    
		 *    lastParams.userid = 1234;
		 *    
		 *    store.reload({
		 *        params : lastParams
		 *    });
		 * 
		 * This will now send the `userid` parameter as `1234` and the `foo` param as `'bar'`.
		 * @method
		 * @public (method)
		 * @param   {object} [options]
		 * A config object which contains options which may override the options passed to the previous load call. See the
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method for valid configs.
		 * @returns {void}             
		 */
		reload? (options?: object): void;
		/** 
		 * Removes the specified record(s) from the Store, firing the [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove)
		 * event for the removed records.
		 * 
		 * After all records have been removed a single `datachanged` is fired.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model|Ext.data.Model[]|number|number[]} records
		 * Model instance or
		 * array of instances to remove or an array of indices from which to remove records.
		 * @param   {object}                                          isMove  (private)
		 * @param   {object}                                          silent  (private)
		 * @returns {void}                                                    
		 */
		remove? (records: Ext.data.Model | Ext.data.Model[] | number | number[], isMove: object, silent: object): void;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Removes all items from the store.
		 * 
		 * Individual record [`remove`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events are not fired by this method.
		 * @method
		 * @public (method)
		 * @param   {boolean}          [silent]
		 * Pass `true` to prevent the [`clear`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-clear) event from being fired.
		 * 
		 * This method is affected by filtering.
		 * @returns {Ext.data.Model[]}          The removed records.
		 */
		removeAll? (silent?: boolean): Ext.data.Model[];
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-removeAll).
		 * Removes all records from the store. This method does a "fast remove",
		 * individual remove events are not called. The [clear](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-clear) event is
		 * fired upon completion.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]|void}  
		 */
		removeAll? (): void;
		/** 
		 * Removes the model instance(s) at the given index
		 * @method
		 * @public (method)
		 * @param   {number} index   The record index
		 * @param   {number} [count] The number of records to delete
		 * @returns {void}           
		 */
		removeAt? (index: number, count?: number): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an individual Filter from the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) using the passed Filter/Filter id and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter} toRemove        The id of a Filter to remove from the filter set, or a Filter instance to remove.
		 * @param   {boolean}                [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                   
		 */
		removeFilter? (toRemove: string | Ext.util.Filter, suppressEvent?: boolean): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @param   {boolean} syncNow
		 * Pass `true` to synchronize now. Only synchronizes with the Proxy if the suspension
		 * count has gone to zero (We are not under a higher level of suspension)
		 * @returns {void}            
		 */
		resumeAutoSync? (syncNow: boolean): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Saves all pending changes via the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy). Use [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) instead.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		save? (): void;
		/** 
		 * Sets the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} asynchronousLoad The new value.
		 * @returns {void}                     
		 */
		setAsynchronousLoad? (asynchronousLoad: boolean): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean|object} autoLoad The new value.
		 * @returns {void}                    
		 */
		setAutoLoad? (autoLoad: boolean | object): void;
		/** 
		 * Sets the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoSync The new value.
		 * @returns {void}             
		 */
		setAutoSync? (autoSync: boolean): void;
		/** 
		 * Sets the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @param   {string} batchUpdateMode The new value.
		 * @returns {void}                   
		 */
		setBatchUpdateMode? (batchUpdateMode: string): void;
		/** 
		 * Sets the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearOnPageLoad The new value.
		 * @returns {void}                    
		 */
		setClearOnPageLoad? (clearOnPageLoad: boolean): void;
		/** 
		 * Sets the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearRemovedOnLoad The new value.
		 * @returns {void}                       
		 */
		setClearRemovedOnLoad? (clearRemovedOnLoad: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                      name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                             [value] The value to set for the name parameter.
		 * @returns {Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Store;
		setConfig? (name: string | object, value?: object): Ext.data.ProxyStore;
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Loads an array of data directly into the Store.
		 * 
		 * setData() is ideal if your data's format is already in its appropriate format (e.g. it doesn't need to be
		 * processed by a reader). If your data's structure requires processing, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * 
		 * Use [loadData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadData), [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add), or [insert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-insert) if records need to be
		 * appended to the current recordset.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @returns {void}                           
		 */
		setData? (data: Ext.data.Model[] | object[]): void;
		/** 
		 * Sets the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @param   {object} extraKeys The new value.
		 * @returns {void}             
		 */
		setExtraKeys? (extraKeys: object): void;
		/** 
		 * Sets the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @param   {object[]|string[]} fields The new value.
		 * @returns {void}                     
		 */
		setFields? (fields: object[] | string[]): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setFilters? (): void;
		/** 
		 * Sets the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @param   {string} groupDir The new value.
		 * @returns {void}            
		 */
		setGroupDir? (groupDir: string): void;
		/** 
		 * Sets the value of [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField).
		 * @method
		 * @public (method)
		 * @param   {string} groupField The new value.
		 * @returns {void}              
		 */
		setGroupField? (groupField: string): void;
		/** 
		 * Sets the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.util.Grouper} grouper The new value.
		 * @returns {void}                            
		 */
		setGrouper? (grouper: object | Ext.util.Grouper): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @param   {number} pageSize The new value.
		 * @returns {void}            
		 */
		setPageSize? (pageSize: number): void;
		/** 
		 * Sets the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.proxy.Proxy|object} proxy The new value.
		 * @returns {void}                                     
		 */
		setProxy? (proxy: string | Ext.data.proxy.Proxy | object): void;
		/** 
		 * Sets the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteFilter The new value.
		 * @returns {void}                 
		 */
		setRemoteFilter? (remoteFilter: boolean): void;
		/** 
		 * Sets the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteSort The new value.
		 * @returns {void}               
		 */
		setRemoteSort? (remoteSort: boolean): void;
		/** 
		 * Sets the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} session The new value.
		 * @returns {void}                     
		 */
		setSession? (session: Ext.data.Session): void;
		/** 
		 * Sets the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} sortOnLoad The new value.
		 * @returns {void}               
		 */
		setSortOnLoad? (sortOnLoad: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setSorters? (): void;
		/** 
		 * Sets the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @param   {boolean} statefulFilters The new value.
		 * @returns {void}                    
		 */
		setStatefulFilters? (statefulFilters: boolean): void;
		/** 
		 * Sets the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @param   {string} storeId The new value.
		 * @returns {void}           
		 */
		setStoreId? (storeId: string): void;
		/** 
		 * Sets the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @param   {boolean} trackRemoved The new value.
		 * @returns {void}                 
		 */
		setTrackRemoved? (trackRemoved: boolean): void;
		/** 
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction] The overall direction to sort the data by.
		 * @returns {Ext.util.Sorter[]}                    
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string): Ext.util.Sorter[];
		/** 
		 * Sums the value of `field` for each [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in store
		 * and returns the result.
		 * 
		 * When store is filtered, only sums items within the filter.
		 * @method
		 * @public (method)
		 * @param   {string}  field     A field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the sum for that group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            The sum
		 */
		sum? (field: string, grouped?: boolean): number;
		/** 
		 * Suspends automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendAutoSync? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Inherit docs
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		contains? (record: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.contains](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-contains).
		 * Checks if a record is in the current active data set.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record
		 * @returns {void|boolean}          `true` if the record is in the current active data set.
		 */
		contains? (record: Ext.data.Model): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		doDestroy? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                             config
		 * @returns {Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.Store;
		initConfig? (config: object): Ext.data.ProxyStore;
		initConfig? (config: object): Ext.data.AbstractStore;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Called internally when a Proxy has completed a load request
		 * @method
		 * @protected (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyLoad? (operation: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.Store.Statics;
		statics? (): Ext.data.ProxyStore.Statics;
		statics? (): Ext.data.AbstractStore.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorter
		 * @returns {void}          
		 */
		addFieldTransform? (sorter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		addObserver? (observer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @param   {object} type
		 * @returns {void}                      
		 */
		afterChange? (record: object, modifiedFieldNames: object, type: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterCommit? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterDrop? (record: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @returns {void}                      
		 */
		afterEdit? (record: object, modifiedFieldNames: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterErase? (record: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to..
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterReject? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} asynchronousLoad
		 * @returns {void}                    
		 */
		applyAsynchronousLoad? (asynchronousLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} extraKeys
		 * @returns {void}             
		 */
		applyExtraKeys? (extraKeys: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fields
		 * @returns {void}          
		 */
		applyFields? (fields: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @param   {object} filtersCollection
		 * @returns {void}                     
		 */
		applyFilters? (filters: object, filtersCollection: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} grouper
		 * @returns {void}           
		 */
		applyGrouper? (grouper: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @returns {void}         
		 */
		applyProxy? (proxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorters
		 * @param   {object} sortersCollection
		 * @returns {void}                     
		 */
		applySorters? (sorters: object, sortersCollection: object): void;
		/** 
		 * Restores state to the passed state
		 * @method
		 * @private (method)
		 * @param   {object} state
		 * @returns {void}         
		 */
		applyState? (state: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} args
		 * @returns {void}          
		 */
		callObservers? (action: object, args: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} isLoad
		 * @returns {void}          
		 */
		clearData? (isLoad: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.clearData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-clearData).
		 * to be implemented by subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearData? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		constructDataCollection? (): void;
		/** 
		 * saves any phantom records
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @param   {object} options
		 * @returns {void}           
		 */
		create? (data: object, options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createFiltersCollection? (): void;
		/** 
		 * Converts a literal to a model, if it's not a model already
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model|object} record The record to create
		 * @returns {Ext.data.Model}               
		 */
		createModel? (record: Ext.data.Model | object): Ext.data.Model;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createSortersCollection? (): void;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * tells the attached proxy to destroy the given records
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		erase? (options: object): void;
		/** 
		 * Similar to a load, however no records are added to the store. This is useful
		 * in allowing the developer to decide what to do with the new records.
		 * @method
		 * @private (method)
		 * @param   {object} [options] See [load options](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		fetch? (options?: object): void;
		/** 
		 * private
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @returns {void}      
		 */
		filterDataSource? (fn: object): void;
		/** 
		 * Filter function for new records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNew? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNewOnly? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterRejects? (item: object): void;
		/** 
		 * Filter function for updated records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterUpdated? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		fireGroupChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		forceLocalSort? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @param   {object} scope
		 * @param   {object} records
		 * @param   {object} field
		 * @returns {void}           
		 */
		getAggregate? (fn: object, scope: object, records: object, field: object): void;
		/** 
		 * Returns the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.Model}  
		 */
		getAssociatedEntity? (): Ext.data.Model;
		/** 
		 * Returns the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getAutoSort? (): boolean;
		/** 
		 * Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
		 * This is broken out into a separate function to allow for customisation of the listeners
		 * @method
		 * @private (method)
		 * @returns {object}  The listeners object
		 */
		getBatchListeners? (): object;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Returns the complete unfiltered collection.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getDataSource? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getGroupField? (): void;
		/** 
		 * Returns the array of records which have been removed since the last time this store was synced.
		 * 
		 * This is used internally, when purging removed records after a successful sync.
		 * This is overridden by TreeStore because TreeStore accumulates deleted records on removal
		 * of child nodes from their parent, _not_ on removal of records from its collection. The collection
		 * has records added on expand, and removed on collapse.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRawRemovedRecords? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRejectRecords? (): void;
		/** 
		 * Returns the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.schema.Role}  
		 */
		getRole? (): Ext.data.schema.Role;
		/** 
		 * Returns the grouping, sorting and filtered state of this Store.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getState? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Returns true if the store has a pending load task.
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the store has a pending load task.
		 */
		hasPendingLoad? (): boolean;
		/** 
		 * Checks whether records are being moved within the store. This can be used in conjunction with the
		 * [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-add) and [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events to determine whether the records are being removed/added
		 * or just having the position changed.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]|Ext.data.Model} [records] The record(s).
		 * @returns {number}                          
		 * The number of records being moved. `0` if no records are moving. If records are passed
		 * the number will refer to how many of the passed records are moving.
		 */
		isMoving? (records?: Ext.data.Model[] | Ext.data.Model): number;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @returns {void}        
		 */
		loadInlineData? (data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		notifySorterChange? (): void;
		/** 
		 * Attached as the 'complete' event listener to a proxy's Batch object. Iterates over the batch operations
		 * and updates the Store's internal data MixedCollection.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchComplete? (batch: object, operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchException? (batch: object, operation: object): void;
		/** 
		 * Attached as the 'operationcomplete' event listener to a proxy's Batch object. By default just calls through
		 * to onProxyWrite.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchOperationComplete? (batch: object, operation: object): void;
		/** 
		 * This is attached to the data Collection's beforesort event only if not remoteSort
		 * If remoteSort, the event is fired before the reload call in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-load).
		 * @method
		 * @private (method)
		 * @param   {object} store
		 * @param   {object} sorters
		 * @returns {void}           
		 */
		onBeforeCollectionSort? (store: object, sorters: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} cls
		 * @param   {object} data
		 * @param   {object} hooks
		 * @returns {void}         
		 */
		onClassExtended? (cls: object, data: object, hooks: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} records
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionAddItems? (collection: object, records: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionBeforeItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionBeginUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionEndUpdate? (): void;
		/** 
		 * When the collection informs us that it has filtered, this LocalStore must react.
		 * AbstractStore#onFilterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilter? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} items
		 * @returns {void}              
		 */
		onCollectionFilterAdd? (collection: object, items: object): void;
		/** 
		 * If our source collection informs us that a filtered out item has changed, we must still fire the events...
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilteredItemChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionRemove? (collection: object, info: object): void;
		/** 
		 * When the collection informs us that it has sorted, this LocalStore must react.
		 * AbstractStore#onSorterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionSort? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCreateRecords? (): void;
		/** 
		 * Removes any records when a write is returned from the server.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]}             records   The array of removed records
		 * @param   {Ext.data.operation.Operation} operation The operation that just completed
		 * @param   {boolean}                      success   True if the operation was successful
		 * @returns {void}                                   
		 */
		onDestroyRecords? (records: Ext.data.Model[], operation: Ext.data.operation.Operation, success: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onErase? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onFilterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} rec
		 * @param   {object} oldId
		 * @param   {object} newId
		 * @returns {void}         
		 */
		onIdChanged? (rec: object, oldId: object, newId: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} meta
		 * @returns {void}         
		 */
		onMetaChange? (proxy: object, meta: object): void;
		/** 
		 * Callback for any write Operation over the Proxy. Updates the Store's MixedCollection to reflect
		 * the updates provided by the Proxy
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyWrite? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onSorterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdate? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdateRecords? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Query all the cached records in this Store by field.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @private (method)
		 * @param   {string}           field The field from each record to use.
		 * @param   {object}           value The value to match.
		 * @returns {Ext.data.Model[]}       The matched records.
		 */
		queryRecords? (field: string, value: object): Ext.data.Model[];
		/** 
		 * Query all the cached records in this Store using a filtering function. The specified function
		 * will be called with each record in this Store. If the function returns `true` the record is
		 * included in the results.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @private (method)
		 * @param   {Function}         fn          The function to be called. It will be passed the following parameters:
		 * @param   {Ext.data.Model}   [fn.record] The record to test for filtering.
		 * @param   {void}             fn.returns
		 * @param   {object}           [scope]
		 * The scope (this reference) in which the function is executed
		 * Defaults to this Store.
		 * @returns {Ext.data.Model[]}             The matched records.
		 */
		queryRecordsBy? (fn: ((record?: Ext.data.Model) => void) | ExtGlobalFunction, scope?: object): Ext.data.Model[];
		/** 
		 * Determines if the passed range is available in the page cache.
		 * @method
		 * @private (method)
		 * @param   {number} start The start index
		 * @param   {number} end   The end index in the range
		 * @returns {void}         
		 */
		rangeCached? (start: number, end: number): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		removeObserver? (observer: object): void;
		/** 
		 * Sets the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} associatedEntity The new value.
		 * @returns {void}                            
		 */
		setAssociatedEntity? (associatedEntity: Ext.data.Model): void;
		/** 
		 * Sets the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @param   {boolean} autoSort The new value.
		 * @returns {void}             
		 */
		setAutoSort? (autoSort: boolean): void;
		/** 
		 * Make a set of records be current in the store. This means that unneeded records
		 * will be removed and new records will be added.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]} records The records to be current in the store.
		 * @returns {void}                     
		 */
		setRecords? (records: Ext.data.Model[]): void;
		/** 
		 * Sets the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.schema.Role} role The new value.
		 * @returns {void}                      
		 */
		setRole? (role: Ext.data.schema.Role): void;
		/** 
		 * This method is basically the same as the JavaScript Array splice method.
		 * 
		 * Negative indexes are interpreted starting at the end of the collection. That is,
		 * a value of -1 indicates the last item, or equivalent to `length - 1`.
		 * @method
		 * @private (method)
		 * @param   {number}          index    The index at which to add or remove items.
		 * @param   {number|object[]} toRemove
		 * The number of items to remove or an array of the
		 * items to remove.
		 * @param   {object[]}        [toAdd]  The items to insert at the given `index`.
		 * @returns {void}                     
		 */
		splice? (index: number, toRemove: number | object[], toAdd?: object[]): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                           names The names of the linked objects to destroy.
		 * @returns {Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.Store;
		unlink? (names: string[]): Ext.data.ProxyStore;
		unlink? (names: string[]): Ext.data.AbstractStore;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		update? (options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoLoad
		 * @returns {void}            
		 */
		updateAutoLoad? (autoLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoSort
		 * @returns {void}            
		 */
		updateAutoSort? (autoSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} field
		 * @returns {void}         
		 */
		updateGroupField? (field: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} oldProxy
		 * @returns {void}            
		 */
		updateProxy? (proxy: object, oldProxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @returns {void}                
		 */
		updateRemoteFilter? (remoteFilter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @returns {void}              
		 */
		updateRemoteSort? (remoteSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} track
		 * @returns {void}         
		 */
		updateTrackRemoved? (track: object): void;
	}
	/** 
	 * [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html)
	 * Contains a collection of all stores that are created that have an identifier. An identifier can be assigned by
	 * setting the [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId) property. When a store is in the StoreManager, it can be
	 * referred to via it's identifier:
	 * 
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'SomeModel',
	 *        storeId: 'myStore'
	 *    });
	 *    
	 *    var store = Ext.data.StoreManager.lookup('myStore');
	 * 
	 * Also note that the [lookup](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html#method-lookup) method is aliased to [Ext.getStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-getStore) for convenience.
	 * 
	 * If a store is registered with the StoreManager, you can also refer to the store by it's identifier when registering
	 * it with any Component that consumes data from a store:
	 * 
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'SomeModel',
	 *        storeId: 'myStore'
	 *    });
	 *    
	 *    Ext.create('Ext.view.View', {
	 *        store: 'myStore',
	 *        // other configuration here
	 *    });
	 * 
	 * @singleton (definition)
	 */
	interface StoreManager extends Ext.util.MixedCollection {
		/** 
		 * Gets a registered Store by id
		 * @method
		 * @public (method)
		 * @param   {string|object}  store         The id of the Store, or a Store instance, or a store configuration
		 * @param   {string}         [defaultType]
		 * The store type to create when used with store configuration and there
		 * is no type specified on the config.
		 * @returns {Ext.data.Store}               
		 */
		lookup? (store: string | object, defaultType?: string): Ext.data.Store;
		/** 
		 * Registers one or more Stores with the StoreManager. You do not normally need to register stores manually. Any
		 * store initialized with a [Ext.data.Store.storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-storeId) will be auto-registered.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		register? (): void;
		/** 
		 * Registers one or more Stores with the StoreManager. You do not normally need to register stores manually. Any
		 * store initialized with a [Ext.data.Store.storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-storeId) will be auto-registered.
		 * @method
		 * @public (method)
		 * @param   {...Ext.data.Store} stores Any number of Store instances
		 * @returns {void}                     
		 */
		register? (...stores: Ext.data.Store[]): void;
		/** 
		 * Unregisters one or more Stores with the StoreManager
		 * @method
		 * @public (method)
		 * @param   {string} stores Any number of Store instances or ID-s
		 * @returns {void}          
		 */
		unregister? (stores: string): void;
		/** 
		 * Unregisters one or more Stores with the StoreManager
		 * @method
		 * @public (method)
		 * @param   {...object} stores Any number of Store instances or ID-s
		 * @returns {void}             
		 */
		unregister? (...stores: object[]): void;
	}
	/** 
	 * [Ext.data.TreeModel](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html)
	 * This class is used as a base class from which to derive Models used in Trees.
	 */
	class TreeModel extends Ext.data.Model {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default 'memory'
		 * @type {string}
		 */
		static defaultProxy?: string;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.TreeModel.Statics}
		 */
		self?: Ext.data.TreeModel.Statics | Ext.data.Model.Statics | Ext.Base.Statics;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                     members    The members to add to this class.
		 * @param   {boolean}                                    [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                    [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.TreeModel|Ext.data.Model|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.TreeModel;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Model;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                     members
		 * @returns {Ext.data.TreeModel|Ext.data.Model|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.TreeModel;
		static addStatics? (members: object): typeof Ext.data.Model;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Returns the configured Proxy for this Model.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {Ext.data.proxy.Proxy}  The proxy
		 */
		static getProxy? (): Ext.data.proxy.Proxy;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * Sets the Proxy to use for this model. Accepts any options that can be accepted by
		 * [Ext.createByAlias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-createByAlias).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object|Ext.data.proxy.Proxy} proxy The proxy
		 * @returns {Ext.data.proxy.Proxy}                     
		 */
		static setProxy? (proxy: string | object | Ext.data.proxy.Proxy): Ext.data.proxy.Proxy;
		/** 
		 * This method adds the given set of fields to this model class.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {string[]|object[]} newFields
		 * The new fields to add. Based on the `name`
		 * of a field this may replace a previous field definition.
		 * @returns {void}                        
		 */
		static addFields? (newFields: string[] | object[]): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Removes the given set of fields from this model.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {boolean|string[]} removeFields
		 * The names of fields to remove or `true`
		 * to remove all existing fields. Removes are processed first followed by adds so
		 * if a field name appears in `newFields` as well that field will effectively be
		 * added (however, in that case there is no need to include the field in this
		 * array).
		 * @returns {void}                          
		 */
		static removeFields? (removeFields: boolean | string[]): void;
		/** 
		 * This method replaces the specified set of fields with a given set of new fields.
		 * Fields should normally be considered immutable, but if the timing is right (that
		 * is, before derived classes are declared), it is permissible to change the fields
		 * collection.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {string[]|object[]} newFields
		 * The new fields to add. Based on the `name`
		 * of a field this may replace a previous field definition.
		 * @param   {boolean|string[]}  removeFields
		 * The names of fields to remove or `true`
		 * to remove all existing fields. Removes are processed first followed by adds so
		 * if a field name appears in `newFields` as well that field will effectively be
		 * added (however, in that case there is no need to include the field in this
		 * array).
		 * @returns {void}                           
		 */
		static replaceFields? (newFields: string[] | object[], removeFields: boolean | string[]): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                     name
		 * @param   {object}                                     member
		 * @returns {Ext.data.TreeModel|Ext.data.Model|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.TreeModel;
		static addMember? (name: object, member: object): typeof Ext.data.Model;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} id
		 * @param   {object} data
		 * @param   {object} session
		 * @returns {void}           
		 */
		static createWithId? (id: object, data: object, session: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @returns {void}        
		 */
		static getField? (name: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static getFields? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static getFieldsMap? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} data
		 * @returns {void}        
		 */
		static getIdFromData? (data: object): void;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                     fn
		 * @param   {object}                                     scope
		 * @returns {Ext.data.TreeModel|Ext.data.Model|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.TreeModel;
		static onExtended? (fn: object, scope: object): typeof Ext.data.Model;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object} data
		 * @param   {object} session
		 */
		constructor (data: object, session: object);
		/** 
		 * Aborts a pending [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-load) operation. If the record is not loading, this does nothing.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		abort? (): void;
		/** 
		 * Begins an edit. While in edit mode, no events (e.g.. the `update` event) are
		 * relayed to the containing store. When an edit has begun, it must be followed by
		 * either `endEdit` or `cancelEdit`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginEdit? (): void;
		/** 
		 * Cancels all changes made in the current edit operation.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		cancelEdit? (): void;
		/** 
		 * Retrieves the first direct child of this container which matches the passed selector or component.
		 * The passed in selector must comply with an [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.2.0/modern/Ext.ComponentQuery.html) selector, or it can be an actual [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.Component} [selector]
		 * An [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.2.0/modern/Ext.ComponentQuery.html) selector. If no selector is
		 * specified, the first child will be returned.
		 * @returns {Ext.Component}                   The matching child [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) (or `null` if no match was found).
		 */
		child? (selector?: string | Ext.Component): Ext.Component;
		/** 
		 * Creates a clone of this record. States like `dropped`, `phantom` and `dirty` are
		 * all preserved in the cloned record.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} [session]
		 * The session to which the new record
		 * belongs.
		 * @returns {Ext.data.Model}             The cloned record.
		 */
		clone? (session?: Ext.data.Session): Ext.data.Model;
		/** 
		 * Usually called by the [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) which owns the model instance. Commits all changes made to the
		 * instance since either creation or the last commit operation.
		 * 
		 * Developers should subscribe to the [Ext.data.Store.update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-update) event to have their code notified of commit
		 * operations.
		 * @method
		 * @public (method)
		 * @param   {boolean}  [silent]             Pass `true` to skip notification of the owning store of the change.
		 * @param   {string[]} [modifiedFieldNames]
		 * Array of field names changed during sync with server if known.
		 * Omit or pass `null` if unknown. An empty array means that it is known that no fields were modified
		 * by the server's response.
		 * Defaults to false.
		 * @returns {void}                          
		 */
		commit? (silent?: boolean, modifiedFieldNames?: string[]): void;
		/** 
		 * Creates a clean copy of this record. The returned record will not consider any its
		 * fields as modified.
		 * 
		 * To generate a phantom instance with a new id pass `null`:
		 * 
		 *    var rec = record.copy(null); // clone the record but no id (one is generated)
		 * 
		 * @method
		 * @public (method)
		 * @param   {string}           [newId]
		 * A new id, defaults to the id of the instance being copied.
		 * See [`idProperty`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty).
		 * @param   {Ext.data.Session} [session]
		 * The session to which the new record
		 * belongs.
		 * @returns {Ext.data.Model}             
		 */
		copy? (newId?: string, session?: Ext.data.Session): Ext.data.Model;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Retrieves the first descendant of this container which matches the passed selector.
		 * The passed in selector must comply with an [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.2.0/modern/Ext.ComponentQuery.html) selector, or it can be an actual [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.Component} [selector]
		 * An [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.2.0/modern/Ext.ComponentQuery.html) selector or [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html). If no selector is
		 * specified, the first child will be returned.
		 * @returns {Ext.Component}                   The matching descendant [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) (or `null` if no match was found).
		 */
		down? (selector?: string | Ext.Component): Ext.Component;
		/** 
		 * Marks this record as `dropped` and waiting to be deleted on the server. When a
		 * record is dropped, it is automatically removed from all association stores and
		 * any child records associated to this record are also dropped (a "cascade delete")
		 * depending on the `cascade` parameter.
		 * @method
		 * @public (method)
		 * @param   {boolean} [cascade]
		 * Pass `false` to disable the cascade to drop child
		 * records.
		 * @returns {void}              
		 */
		drop? (cascade?: boolean): void;
		/** 
		 * Ends an edit. If any data was modified, the containing store is notified
		 * (ie, the store's `update` event will fire).
		 * @method
		 * @public (method)
		 * @param   {boolean}  [silent]             True to not notify any stores of the change.
		 * @param   {string[]} [modifiedFieldNames] Array of field names changed during edit.
		 * @returns {void}                          
		 */
		endEdit? (silent?: boolean, modifiedFieldNames?: string[]): void;
		/** 
		 * Returns the value of the given field.
		 * @method
		 * @public (method)
		 * @param   {string} fieldName The name of the field.
		 * @returns {object}           The value of the specified field.
		 */
		get? (fieldName: string): object;
		/** 
		 * Gets an object of only the fields that have been modified since this record was
		 * created or committed. Only persistent fields are tracked in the `modified` set so
		 * this method will only return changes to persistent fields.
		 * 
		 * For more control over the returned data, see [`getData`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-getData).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getChanges? (): object;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the array of fields that are declared as critical (must always send).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.field.Field[]}  
		 */
		getCriticalFields? (): Ext.data.field.Field[];
		/** 
		 * Get the fields array for this model.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.field.Field[]}  The fields array
		 */
		getFields? (): Ext.data.field.Field[];
		/** 
		 * Returns the unique ID allocated to this model instance as defined by `idProperty`.
		 * @method
		 * @public (method)
		 * @returns {number|string}  The id
		 */
		getId? (): number | string;
		/** 
		 * Get the idProperty for this model.
		 * @method
		 * @public (method)
		 * @returns {string}  The idProperty
		 */
		getIdProperty? (): string;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the original value of a modified field. If there is no modified value,
		 * `undefined` will be return. Also see [isModified](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-isModified).
		 * @method
		 * @public (method)
		 * @param   {string} fieldName The name of the field for which to return the original value.
		 * @returns {object}           modified
		 */
		getModified? (fieldName: string): object;
		/** 
		 * This method returns the value of a field given its name prior to its most recent
		 * change.
		 * @method
		 * @public (method)
		 * @param   {string} fieldName The field's [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name).
		 * @returns {object} 
		 * The value of the given field prior to its current value. `undefined`
		 * if there is no previous value;
		 */
		getPrevious? (fieldName: string): object;
		/** 
		 * Returns the configured Proxy for this Model.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.proxy.Proxy}  The proxy
		 */
		getProxy? (): Ext.data.proxy.Proxy;
		/** 
		 * Returns the array of fields that are declared as non-persist or "transient".
		 * @method
		 * @public (method)
		 * @returns {Ext.data.field.Field[]}  
		 */
		getTransientFields? (): Ext.data.field.Field[];
		/** 
		 * Returns the [`Ext.data.Validation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html) record holding the results of this record's
		 * `validators`. This record is lazily created on first request and is then kept on
		 * this record to be updated later.
		 * 
		 * See the class description for more about `validators`.
		 * @method
		 * @public (method)
		 * @param   {boolean}             [refresh]
		 * Pass `false` to not call the `refresh` method on the
		 * validation instance prior to returning it. Pass `true` to force a `refresh` of the
		 * validation instance. By default the returned record is only refreshed if changes
		 * have been made to this record.
		 * @returns {Ext.data.Validation}           The `Validation` record for this record.
		 */
		getValidation? (refresh?: boolean): Ext.data.Validation;
		/** 
		 * Checks whether this model is loading data from the [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if in a loading state.
		 */
		isLoading? (): boolean;
		/** 
		 * Returns true if the passed field name has been [`modified`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-modified) since the load or last commit.
		 * @method
		 * @public (method)
		 * @param   {string}  fieldName The field's [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name).
		 * @returns {boolean}           
		 */
		isModified? (fieldName: string): boolean;
		/** 
		 * Checks if the model is valid. See [getValidation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-getValidation).
		 * @method
		 * @public (method)
		 * @returns {boolean}  True if the model is valid.
		 */
		isValid? (): boolean;
		/** 
		 * Tells this model instance that an observer is looking at it.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Store} item The store to which this model has been added.
		 * @returns {void}                
		 */
		join? (item: Ext.data.Store): void;
		/** 
		 * Called when the model id is changed.
		 * @method
		 * @public (method)
		 * @param   {object} id    The new id.
		 * @param   {object} oldId The old id.
		 * @returns {void}         
		 */
		onIdChanged? (id: object, oldId: object): void;
		/** 
		 * Retrieves all descendant components which match the passed selector.
		 * Executes an [Ext.ComponentQuery.query](https://docs.sencha.com/extjs/6.2.0/modern/Ext.ComponentQuery.html#method-query) using this container as its root.
		 * @method
		 * @public (method)
		 * @param   {string}          [selector]
		 * Selector complying to an [Ext.ComponentQuery](https://docs.sencha.com/extjs/6.2.0/modern/Ext.ComponentQuery.html) selector.
		 * If no selector is specified all items will be returned.
		 * @returns {Ext.Component[]}            Components which matched the selector
		 */
		query? (selector?: string): Ext.Component[];
		/** 
		 * Retrieves all descendant components which match the passed function.
		 * The function should return false for components that are to be
		 * excluded from the selection.
		 * @method
		 * @public (method)
		 * @param   {Function}        fn
		 * The matcher function. It will be called with a single argument,
		 * the component being tested.
		 * @param   {object}          [scope]
		 * The scope in which to run the function. If not specified,
		 * it will default to the active component.
		 * @returns {Ext.Component[]}         Components matched by the passed function
		 */
		queryBy? (fn: ExtGlobalFunction, scope?: object): Ext.Component[];
		/** 
		 * Finds a component at any level under this container matching the id/itemId.
		 * This is a shorthand for calling ct.down('#' + id);
		 * @method
		 * @public (method)
		 * @param   {string}        id The id to find
		 * @returns {Ext.Component}    The matching id, null if not found
		 */
		queryById? (id: string): Ext.Component;
		/** 
		 * Usually called by the [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) to which this model instance has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join). Rejects
		 * all changes made to the model instance since either creation, or the last commit operation. Modified fields are
		 * reverted to their original values.
		 * 
		 * Developers should subscribe to the [Ext.data.Store.update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-update) event to have their code notified of reject
		 * operations.
		 * @method
		 * @public (method)
		 * @param   {boolean} [silent] `true` to skip notification of the owning store of the change.
		 * @returns {void}             
		 */
		reject? (silent?: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                              name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                     [value] The value to set for the name parameter.
		 * @returns {Ext.data.TreeModel|Ext.data.Model|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.TreeModel;
		setConfig? (name: string | object, value?: object): Ext.data.Model;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Sets the model instance's id field to the given id.
		 * @method
		 * @public (method)
		 * @param   {number|string} id        The new id.
		 * @param   {object}        [options] See [set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-set).
		 * @returns {void}                    
		 */
		setId? (id: number | string, options?: object): void;
		/** 
		 * Set the session for this record.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} session The session
		 * @returns {void}                     
		 */
		setSession? (session: Ext.data.Session): void;
		/** 
		 * Returns a url-suitable string for this model instance. By default this just returns the name of the Model class
		 * followed by the instance ID - for example an instance of MyApp.model.User with ID 123 will return 'user/123'.
		 * @method
		 * @public (method)
		 * @returns {string}  The url string for this model instance.
		 */
		toUrl? (): string;
		/** 
		 * Tells this model instance that it has been removed from the store.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Store} store The store from which this model has been removed.
		 * @returns {void}                 
		 */
		unjoin? (store: Ext.data.Store): void;
		/** 
		 * Validates the current data against all of its configured [validators](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-validators). The
		 * returned collection holds an object for each reported problem from a `validator`.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.ErrorCollection}  The errors collection.
		 */
		validate? (): Ext.data.ErrorCollection;
		/** 
		 * Traverses the tree rooted at this node in post-order mode, calling the passed function on the nodes at each level.
		 * That is the function is called upon each node **after** being called on its children).
		 * 
		 * This method is used at each level down the cascade. Currently [Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)s
		 * and [TreeModel](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html)s are queryable.
		 * 
		 * If you have tree-structured data, you can make your nodes queryable, and use ComponentQuery on them.
		 * @method
		 * @public (method)
		 * @param   {object}   selector
		 * A ComponentQuery selector used to filter candidate nodes before calling the function.
		 * An empty string matches any node.
		 * @param   {Function} fn          The function to call. Return `false` to aborl the traverse.
		 * @param   {object}   [fn.node]   The node being visited.
		 * @param   {void}     fn.returns
		 * @param   {object}   [scope]     The context (`this` reference) in which the function is executed.
		 * @param   {any[]}    [extraArgs]
		 * A set of arguments to be appended to the function's argument list to pass down extra data known to the caller
		 * **after** the node being visited.
		 * @returns {void}                 
		 */
		visitPostOrder? (selector: object, fn: ((node?: object) => void) | ExtGlobalFunction, scope?: object, extraArgs?: any[]): void;
		/** 
		 * Traverses the tree rooted at this node in pre-order mode, calling the passed function on the nodes at each level.
		 * That is the function is called upon each node **before** being called on its children).
		 * 
		 * This method is used at each level down the cascade. Currently [Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)s
		 * and [TreeModel](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html)s are queryable.
		 * 
		 * If you have tree-structured data, you can make your nodes queryable, and use ComponentQuery on them.
		 * @method
		 * @public (method)
		 * @param   {object}   selector
		 * A ComponentQuery selector used to filter candidate nodes before calling the function.
		 * An empty string matches any node.
		 * @param   {Function} fn          The function to call. Return `false` to aborl the traverse.
		 * @param   {object}   [fn.node]   The node being visited.
		 * @param   {void}     fn.returns
		 * @param   {object}   [scope]     The context (`this` reference) in which the function is executed.
		 * @param   {any[]}    [extraArgs]
		 * A set of arguments to be appended to the function's argument list to pass down extra data known to the caller
		 * **after** the node being visited.
		 * @returns {void}                 
		 */
		visitPreOrder? (selector: object, fn: ((node?: object) => void) | ExtGlobalFunction, scope?: object, extraArgs?: any[]): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Return a unique observable ID. Model is not observable but tree nodes ([`Ext.data.NodeInterface`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html)) are, so
		 * they must be globally unique within the [observableType](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-observableType).
		 * @method
		 * @protected (method)
		 * @returns {void}  
		 */
		getObservableId? (): void;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                     config
		 * @returns {Ext.data.TreeModel|Ext.data.Model|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.TreeModel;
		initConfig? (config: object): Ext.data.Model;
		initConfig? (config: object): Ext.Base;
		/** 
		 * This method is called by the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) after loading a model from
		 * the server. This is after processing any inline associations that are available.
		 * @method
		 * @protected (method)
		 * @template
		 * @returns {void}  
		 */
		onLoad? (): void;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.TreeModel.Statics|Ext.data.Model.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.TreeModel.Statics;
		statics? (): Ext.data.Model.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * Helper function used by afterEdit, afterReject and afterCommit. Calls the given
		 * method on the [`Ext.data.Store`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) that this instance has [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join), if any.
		 * The store function will always be called with the model instance as its single
		 * argument. If this model is joined to a [Ext.data.NodeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeStore.html), then this method calls
		 * the given method on the NodeStore and the associated [Ext.data.TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html).
		 * @method
		 * @private (method)
		 * @param   {string} funcName The name function to call on each store.
		 * @param   {any[]}  [args]
		 * The arguments to pass to the method. This instance is
		 * always inserted as the first argument.
		 * @returns {void}            
		 */
		callJoined? (funcName: string, args?: any[]): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearState? (): void;
		/** 
		 * Copies data from the passed record into this record. If the passed record is undefined, does nothing.
		 * 
		 * If this is a phantom record (represented only in the client, with no corresponding database entry), and
		 * the source record is not a phantom, then this record acquires the id of the source record.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} sourceRecord The record to copy data from.
		 * @returns {string[]}                    The names of the fields which changed value.
		 */
		copyFrom? (sourceRecord: Ext.data.Model): string[];
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} name
		 * @returns {void}        
		 */
		getField? (name: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getFieldsMap? (): void;
		/** 
		 * Gets the names of all the fields that were modified during an edit.
		 * @method
		 * @private (method)
		 * @param   {object}   [old] The saved data from `beginEdit`.
		 * @returns {string[]}       The array of modified field names.
		 */
		getModifiedFieldNames? (old?: object): string[];
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Checks if two values are equal, taking into account certain special factors, for
		 * example dates.
		 * @method
		 * @private (method)
		 * @param   {object}  lhs The first value.
		 * @param   {object}  rhs The second value.
		 * @returns {boolean}     True if the values are equal.
		 */
		isEqual? (lhs: object, rhs: object): boolean;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * This method produces the `initializeFn` for this class. If there are no fields
		 * requiring [conversion](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-convert) and no fields requiring
		 * a [default value](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-defaultValue) then this method will
		 * return `null`.
		 * @method
		 * @private (method)
		 * @param   {object}   cls
		 * @returns {Function}     The `initializeFn` for this class (or null).
		 */
		makeInitializeFn? (cls: object): ExtGlobalFunction;
		/** 
		 * Called when an associated record instance has been set.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model}       record The record.
		 * @param   {Ext.data.schema.Role} role   The role.
		 * @returns {void}                        
		 */
		onAssociatedRecordSet? (record: Ext.data.Model, role: Ext.data.schema.Role): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		setErased? (): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                   names The names of the linked objects to destroy.
		 * @returns {Ext.data.TreeModel|Ext.data.Model|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.TreeModel;
		unlink? (names: string[]): Ext.data.Model;
		unlink? (names: string[]): Ext.Base;
	}
	/** 
	 * [Ext.data.TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html)
	 * The TreeStore is a store implementation that owns the [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root) of
	 * a tree, and provides methods to load either local or remote data as child nodes of the root
	 * and any descendant non-leaf node.
	 * 
	 * The TreeStore must be used as the store of a tree panel.
	 * 
	 * This class also relays many node events from the underlying node structure.
	 * 
	 * # Using Models
	 * 
	 * If no Model is specified, an implicit model will be created that extends [Ext.data.TreeModel](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html).
	 * The standard Tree fields will also be copied onto the Model for maintaining their state. These fields are listed
	 * in the [Ext.data.NodeInterface](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html) documentation.
	 * 
	 * # Reading Nested Data
	 * 
	 * For the tree to read nested data, the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) must be configured with a root property,
	 * so the reader can find nested data for each node (if a root is not specified, it will default to
	 * 'children'). This will tell the tree to look for any nested tree nodes by the same keyword, i.e., 'children'.
	 * If a root is specified in the config make sure that any nested nodes with children have the same name.
	 * 
	 * **Note:** Setting [defaultRootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-defaultRootProperty) accomplishes the same thing.
	 * 
	 * # rootProperty as a Function
	 * 
	 * You can pass a function as the data reader's rootProperty when the tree's dataset has
	 * mixed root properties. Child nodes can then be programmatically determined at read time.
	 * 
	 * For example, the child nodes may be passed via the 'children' property
	 * name, though you may have a top-level root property of 'items'.
	 * 
	 * See [rootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-rootProperty) for more information.
	 * 
	 * # Filtering
	 * 
	 * Filtering of nodes in a TreeStore is hierarchically top down by default. This means that if a non-leaf node does not
	 * pass the filter, then it, and all its descendants are filtered _out_ of the store.
	 * 
	 * To reverse this, so that any node which passes the filter causes all its ancestors to be visible, configure
	 * the `TreeStore` with '[filterer: 'bottomup'`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-filterer)
	 * 
	 * You may also programatically filter individual tree nodes by setting their `'visible'` field.
	 * 
	 * Setting this to `false` filters the node out so that it will not appear in the UI. Setting it to `true`
	 * filters the node in.
	 * 
	 * Note that if performing several filter operations, it is best to [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-suspendEvents)
	 * on the store first, and when all nodes have been modified, [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-resumeEvents) and fire the
	 * [refresh](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#event-refresh) event on the store.
	 */
	class TreeStore extends Ext.data.Store {
		/** 
		 * `true` in this class to identify an object as an instantiated TreeStore, or subclass thereof.
		 * @property
		 * @public (property)
		 * @default true
		 * @type {boolean}
		 */
		isTreeStore?: boolean;
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.TreeStore.Statics}
		 */
		self?: Ext.data.TreeStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @default {5: {properties: {tree: null}}}
		 * @type {object}
		 */
		deprecated?: object;
		/** 
		 * The class name of the model that this store uses if no explicit [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-model) is given
		 * @property
		 * @private (property)
		 * @default 'Ext.data.TreeModel'
		 * @type {boolean}
		 */
		implicitModel?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                members    The members to add to this class.
		 * @param   {boolean}                                                                               [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                               [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.TreeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.TreeStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                members
		 * @returns {Ext.data.TreeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.TreeStore;
		static addStatics? (members: object): typeof Ext.data.Store;
		static addStatics? (members: object): typeof Ext.data.ProxyStore;
		static addStatics? (members: object): typeof Ext.data.AbstractStore;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                name
		 * @param   {object}                                                                                member
		 * @returns {Ext.data.TreeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.TreeStore;
		static addMember? (name: object, member: object): typeof Ext.data.Store;
		static addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		static addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                fn
		 * @param   {object}                                                                                scope
		 * @returns {Ext.data.TreeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.TreeStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		static onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                The model instances that were added
		 */
		add? (model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {...Ext.data.Model|...object} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                  The model instances that were added
		 */
		add? (...model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * Adds a new Filter to this Store's [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {object[]|Ext.util.Filter[]} filters         The set of filters to add to the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters).
		 * @param   {boolean}                    [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                       
		 */
		addFilter? (filters: object[] | Ext.util.Filter[], suppressEvent?: boolean): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * (Local sort only) Inserts the passed Record into the Store at the index where it
		 * should go based on the current sort information.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Record} record
		 * @returns {void}                   
		 */
		addSorted? (record: Ext.data.Record): void;
		/** 
		 * Runs the aggregate function for all the records in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {Function} fn
		 * The function to execute. The function is called with a single parameter,
		 * an array of records for that group.
		 * @param   {object}   scope   The scope to execute the function in. Defaults to the store.
		 * @param   {boolean}  grouped
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @param   {string}   field   The field to get the value from
		 * @returns {object}           An object literal with the group names and their appropriate values.
		 */
		aggregate? (fn: ExtGlobalFunction, scope: object, grouped: boolean, field: string): object;
		/** 
		 * Gets the average value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The average value, if no items exist, 0.
		 */
		average? (field: string, grouped?: boolean): object;
		/** 
		 * This method may be called to indicate the start of multiple changes to the store.
		 * 
		 * Automatic synchronization as configured by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred
		 * until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple mutations can be coalesced
		 * into one synchronization operation.
		 * 
		 * Internally this method increments a counter that is decremented by `endUpdate`. It
		 * is important, therefore, that if you call `beginUpdate` directly you match that
		 * call with a call to `endUpdate` or you will prevent the collection from updating
		 * properly.
		 * 
		 * For example:
		 * 
		 *     var store = Ext.StoreManager.lookup({
		 *         //...
		 *         autoSync: true
		 *     });
		 *    
		 *     store.beginUpdate();
		 *    
		 *     record.set('fieldName', 'newValue');
		 *    
		 *     store.add(item);
		 *     // ...
		 *    
		 *     store.insert(index, otherItem);
		 *     //...
		 *    
		 *     // Interested parties will listen for the endupdate event
		 *     store.endUpdate();
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginUpdate? (): void;
		/** 
		 * Reverts to a view of the Record cache with no filtering applied.
		 * @method
		 * @public (method)
		 * @param   {boolean} [suppressEvent]
		 * If `true` the filter is cleared silently.
		 * 
		 * For a locally filtered Store, this means that the filter collection is cleared without firing the
		 * [datachanged](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-datachanged) event.
		 * 
		 * For a remotely filtered Store, this means that the filter collection is cleared, but the store
		 * is not reloaded from the server.
		 * @returns {void}                    
		 */
		clearFilter? (suppressEvent?: boolean): void;
		/** 
		 * Clear the store grouping
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearGrouping? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Commits all Records with [outstanding changes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-getModifiedRecords). To handle updates for changes,
		 * subscribe to the Store's [update event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#event-update), and perform updating when the third parameter is
		 * [Ext.data.Record.COMMIT](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#static-property-COMMIT).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		commitChanges? (): void;
		/** 
		 * Gets the count of items in the store.
		 * 
		 * When store is filtered, only items within the filter are counted.
		 * @method
		 * @public (method)
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the count for each group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            the count
		 */
		count? (grouped?: boolean): number;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * This method is called after modifications are complete on a store. For details
		 * see [`beginUpdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		endUpdate? (): void;
		/** 
		 * Filters the data in the Store by one or more fields. Example usage:
		 * 
		 *    //filter with a single field
		 *    myStore.filter('firstName', 'Don');
		 *    
		 *    //filtering with multiple filters
		 *    myStore.filter([
		 *        {
		 *            property : 'firstName',
		 *            value    : 'Don'
		 *        },
		 *        {
		 *            property : 'lastName',
		 *            value    : 'Griffin'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) instances, and delegates
		 * the actual filtering to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter[]} [filters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of filter configurations.
		 * @param   {string}                   [value]   The property value by which to filter. Only applicable if `filters` is a string.
		 * @returns {void}                               
		 */
		filter? (filters?: string | Ext.util.Filter[], value?: string): void;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of the Record field to test.
		 * @param   {string|RegExp} value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}        [startIndex]    The index to start searching at
		 * @param   {boolean}       [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}       [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {number}                        The matched index or -1
		 */
		find? (property: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string} fieldName    The name of the Record field to test.
		 * @param   {object} value        The value to match the field against.
		 * @param   {number} [startIndex] The index to start searching at
		 * @returns {number}              The matched index or -1
		 */
		findExact? (fieldName: string, value: object, startIndex?: number): number;
		/** 
		 * Finds the first matching node in the tree by a specific field value regardless of visibility
		 * due to collapsed states; all nodes present in the tree structure are searched.
		 * @method
		 * @public (method)
		 * @param   {string}                 fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}          value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {boolean}                [anyMatch]
		 * False to match any part of the string, not just
		 * the beginning.
		 * @param   {boolean}                [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}                [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.NodeInterface}                 The matched node or null
		 */
		findNode? (fieldName: string, value: string | RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.NodeInterface;
		/** 
		 * Finds the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}         fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}  value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}         [startIndex]    The index to start searching at
		 * @param   {boolean}        [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}        [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}        [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.Model}                 The matched record or null
		 */
		findRecord? (fieldName: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Convenience function for getting the first model instance in the store.
		 * 
		 * When store is filtered, will return first item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the first record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The first model instance in the store, or undefined
		 */
		first? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Called when the event handler which called the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-load) method exits.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		flushLoad? (): void;
		/** 
		 * Returns the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAsynchronousLoad? (): boolean;
		/** 
		 * Get the Record at the specified index.
		 * 
		 * The index is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}         index The index of the Record to find.
		 * @returns {Ext.data.Model}       The Record at the passed index. Returns null if not found.
		 */
		getAt? (index: number): Ext.data.Model;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Returns the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean|object}  
		 */
		getAutoLoad? (): boolean | object;
		/** 
		 * Returns the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoSync? (): boolean;
		/** 
		 * Returns the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchUpdateMode? (): string;
		/** 
		 * Get the Record with the specified id.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            id The id of the Record to find.
		 * @returns {Ext.data.Model}    The Record with the passed id. Returns null if not found.
		 */
		getById? (id: any): Ext.data.Model;
		/** 
		 * Get the Record with the specified internalId.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            internalId The id of the Record to find.
		 * @returns {Ext.data.Model}            The Record with the passed internalId. Returns null if not found.
		 */
		getByInternalId? (internalId: any): Ext.data.Model;
		/** 
		 * Returns the value of [clearOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-clearOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearOnLoad? (): boolean;
		/** 
		 * Returns the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearOnPageLoad? (): boolean;
		/** 
		 * Returns the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearRemovedOnLoad? (): boolean;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Gets the number of records in store.
		 * 
		 * If using paging, this may not be the total size of the dataset. If the data object
		 * used by the Reader contains the dataset size, then the [Ext.data.ProxyStore.getTotalCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getTotalCount) function returns
		 * the dataset size.  **Note**: see the Important note in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load).
		 * 
		 * When store is filtered, it's the number of records matching the filter.
		 * @method
		 * @public (method)
		 * @returns {number}  The number of Records in the Store.
		 */
		getCount? (): number;
		/** 
		 * Returns the store's records.
		 * 
		 * **Note:** If your store has been filtered, getData() will return a filtered
		 * collection.  Use `getData().[getSource()`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#method-getSource) to
		 * fetch all unfiltered records.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection} 
		 * An [Ext.util.Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) of records
		 * (an empty Collection if no records are held by the store).
		 */
		getData? (): Ext.util.Collection;
		/** 
		 * Returns the value of [defaultRootId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-defaultRootId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDefaultRootId? (): string;
		/** 
		 * Returns the value of [defaultRootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-defaultRootProperty).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDefaultRootProperty? (): string;
		/** 
		 * Returns the value of [defaultRootText](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-defaultRootText).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getDefaultRootText? (): string;
		/** 
		 * Returns the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraKeys? (): object;
		/** 
		 * Returns the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @returns {object[]|string[]}  
		 */
		getFields? (): object[] | string[];
		/** 
		 * Gets the filters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.FilterCollection}            The filters
		 */
		getFilters? (autoCreate: object): Ext.util.FilterCollection;
		/** 
		 * Returns the value of [folderSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-folderSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getFolderSort? (): boolean;
		/** 
		 * Returns the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDir? (): string;
		/** 
		 * Returns the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @returns {object|Ext.util.Grouper}  
		 */
		getGrouper? (): object | Ext.util.Grouper;
		/** 
		 * Returns a collection of readonly sub-collections of your store's records
		 * with grouping applied. These sub-collections are maintained internally by
		 * the collection.
		 * 
		 * See [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField), [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir). Example for a store
		 * containing records with a color field:
		 * 
		 *    var myStore = Ext.create('Ext.data.Store', {
		 *        groupField: 'color',
		 *        groupDir  : 'DESC'
		 *    });
		 *    
		 *    myStore.getGroups();
		 * 
		 * The above should result in the following format:
		 * 
		 *    [
		 *        {
		 *            name: 'yellow',
		 *            children: [
		 *                // all records where the color field is 'yellow'
		 *            ]
		 *        },
		 *        {
		 *            name: 'red',
		 *            children: [
		 *                // all records where the color field is 'red'
		 *            ]
		 *        }
		 *    ]
		 * 
		 * Group contents are affected by filtering.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection}  The grouped data
		 */
		getGroups? (): Ext.util.Collection;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Gets all [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) added or updated since the last commit. Note that the order of records
		 * returned is not deterministic and does not indicate the order in which records were modified. Note also that
		 * removed records are not included (use [getRemovedRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getRemovedRecords) for that).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The added and updated Model instances
		 */
		getModifiedRecords? (): Ext.data.Model[];
		/** 
		 * Returns all [`phantom`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records in this store.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  A possibly empty array of `phantom` records.
		 */
		getNewRecords? (): Ext.data.Model[];
		/** 
		 * Returns the record node by id regardless of visibility due to collapsed states;
		 * all nodes present in the tree structure are available.
		 * @method
		 * @public (method)
		 * @param   {string}                 id The id of the node to get.
		 * @returns {Ext.data.NodeInterface}    
		 */
		getNodeById? (id: string): Ext.data.NodeInterface;
		/** 
		 * Returns the value of [nodeParam](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-nodeParam).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getNodeParam? (): string;
		/** 
		 * Returns the value of [parentIdProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-parentIdProperty).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getParentIdProperty? (): string;
		/** 
		 * Returns the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.proxy.Proxy|object}  
		 */
		getProxy? (): string | Ext.data.proxy.Proxy | object;
		/** 
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}           start The starting index. Defaults to zero.
		 * @param   {number}           end   The ending index. Defaults to the last record. The end index **is included**.
		 * @returns {Ext.data.Model[]}       An array of records.
		 */
		getRange? (start: number, end: number): Ext.data.Model[];
		/** 
		 * Returns the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteFilter? (): boolean;
		/** 
		 * Returns the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteSort? (): boolean;
		/** 
		 * Returns any records that have been removed from the store but not yet destroyed on the proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]} 
		 * The removed Model instances. Note that this is a _copy_ of the store's
		 * array, so may be mutated.
		 */
		getRemovedRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [root](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.TreeModel|Ext.data.NodeInterface|object}  
		 */
		getRoot? (): Ext.data.TreeModel | Ext.data.NodeInterface | object;
		/** 
		 * Returns the root node for this tree.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.NodeInterface}  
		 */
		getRootNode? (): Ext.data.NodeInterface;
		/** 
		 * Returns the value of [rootVisible](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-rootVisible).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRootVisible? (): boolean;
		/** 
		 * Returns the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Session}  
		 */
		getSession? (): Ext.data.Session;
		/** 
		 * Returns the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSortOnLoad? (): boolean;
		/** 
		 * Gets the sorters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.SorterCollection}            The sorters
		 */
		getSorters? (autoCreate: object): Ext.util.SorterCollection;
		/** 
		 * Returns the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getStatefulFilters? (): boolean;
		/** 
		 * Returns the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStoreId? (): string;
		/** 
		 * Returns the total number of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances that the [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html)
		 * indicates exist. This will usually differ from [getCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-getCount) when using paging - getCount returns the
		 * number of records loaded into the Store at the moment, getTotalCount returns the number of records that
		 * could be loaded into the Store if the Store contained all data
		 * @method
		 * @public (method)
		 * @returns {number} 
		 * The total number of Model instances available via the Proxy. 0 returned if
		 * no value has been set via the reader.
		 */
		getTotalCount? (): number;
		/** 
		 * Returns the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getTrackRemoved? (): boolean;
		/** 
		 * Returns all valid, non-phantom Model instances that have been updated in the Store but not yet synchronized with the Proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The updated Model instances
		 */
		getUpdatedRecords? (): Ext.data.Model[];
		/** 
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {string|object} grouper
		 * Either a string name of one of the fields in this Store's
		 * configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an object, or a [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Grouper.html) configuration object.
		 * @param   {string}        [direction] The overall direction to group the data by. Defaults to the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @returns {void}                      
		 */
		group? (grouper: string | object, direction?: string): void;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Get the index of the record within the store.
		 * 
		 * When store is filtered, records outside of filter will not be found.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) object to find.
		 * @returns {number}                The index of the passed Record. Returns -1 if not found.
		 */
		indexOf? (record: Ext.data.Model): number;
		/** 
		 * Get the index within the store of the Record with the passed id.
		 * 
		 * Like [indexOf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-indexOf), this method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {string} id The id of the Record to find.
		 * @returns {number}    The index of the Record. Returns -1 if not found.
		 */
		indexOfId? (id: string): number;
		/** 
		 * Inserts Model instances into the Store at the given index and fires the add event.
		 * See also [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
		 * @method
		 * @public (method)
		 * @param   {number}                                          index   The start index at which to insert the passed Records.
		 * @param   {Ext.data.Model|Ext.data.Model[]|object|object[]} records
		 * An [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instance, the
		 * data needed to populate an instance or an array of either of these.
		 * @returns {Ext.data.Model[]}                                        records The added records
		 */
		insert? (index: number, records: Ext.data.Model | Ext.data.Model[] | object | object[]): Ext.data.Model[];
		/** 
		 * Tests whether the store currently has any active filters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is filtered.
		 */
		isFiltered? (): boolean;
		/** 
		 * Tests whether the store currently has an active grouper.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is grouped.
		 */
		isGrouped? (): boolean;
		/** 
		 * Returns `true` if the Store has been loaded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store has been loaded.
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns true if the Store is currently performing a load operation
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store is currently loading
		 */
		isLoading? (): boolean;
		/** 
		 * Tests whether the store currently has any active sorters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is sorted.
		 */
		isSorted? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * @method
		 * @public (method)
		 * @param   {object}  node
		 * @returns {boolean}      
		 */
		isVisible? (node: object): boolean;
		/** 
		 * Convenience function for getting the last model instance in the store.
		 * 
		 * When store is filtered, will return last item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the last record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The last model instance in the store, or undefined
		 */
		last? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Marks this store as needing a load. When the current executing event handler exits,
		 * this store will send a request to load using its configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-proxy).
		 * 
		 * **Be aware that it is not usually valid for a developer to call this method on a TreeStore.**
		 * 
		 * TreeStore loads are triggered by a load request from an existing [tree node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html),
		 * when the node is expanding, and it has no locally defined children in its data.
		 * 
		 * _Note:_ Even for synchronous Proxy types such as [memory proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html),
		 * the result will _NOT_ be available in the following line of code. You must use a callback
		 * in the load options, or a [load listener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#event-load).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.data.TreeStore.methodParams.load.Options} [options]
		 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
		 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
		 * The options can also contain a node, which indicates which node is to be loaded. If not specified, it will
		 * default to the root node.
		 * @returns {void}                                                          
		 */
		load? (options?: object | Ext.data.TreeStore.methodParams.load.Options): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load).
		 * Marks this store as needing a load. When the current executing event handler exits,
		 * this store will send a request to load using its configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * 
		 * Upon return of the data from whatever data source the proxy connected to, the retrieved
		 * [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) will be loaded into this store, and the optional callback will be called.
		 * Example usage:
		 * 
		 *    store.load({
		 *        scope: this,
		 *        callback: function(records, operation, success) {
		 *            // the operation object
		 *            // contains all of the details of the load operation
		 *            console.log(records);
		 *        }
		 *    });
		 * 
		 * If the callback scope does not need to be set, a function can simply be passed:
		 * 
		 *    store.load(function(records, operation, success) {
		 *        console.log('loaded records');
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {object|Ext.data.Store.methodParams.load.Options} [options]
		 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
		 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
		 * In addition to the options listed below, this object may contain properties to configure the
		 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
		 * @returns {void|Ext.data.Store}                                       this
		 */
		load? (options?: object | Ext.data.Store.methodParams.load.Options): Ext.data.Store;
		/** 
		 * Loads an array of data straight into the Store.
		 * 
		 * Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
		 * processed by a reader). If your data requires processing to decode the data structure, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @param   {boolean}                   [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {void}                               
		 */
		loadData? (data: Ext.data.Model[] | object[], append?: boolean): void;
		/** 
		 * Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
		 * load operation, passing in calculated 'start' and 'limit' params.
		 * @method
		 * @public (method)
		 * @param   {number} page      The number of the page to load.
		 * @param   {object} [options] See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		loadPage? (page: number, options?: object): void;
		/** 
		 * Loads data via the bound Proxy's reader
		 * 
		 * Use this method if you are attempting to load data and want to utilize the configured data reader.
		 * 
		 * As of 4.2, this method will no longer fire the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-load) event.
		 * @method
		 * @public (method)
		 * @param   {object[]} data     The full JSON object you'd like to load into the Data store.
		 * @param   {boolean}  [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {boolean}  
		 * `true` if the reader processed the records correctly. See [Ext.data.reader.Reader.successProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-successProperty).
		 * If the reader did not process the records, nothing will be added.
		 */
		loadRawData? (data: object[], append?: boolean): boolean;
		/** 
		 * Gets the maximum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the maximum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The maximum value, if no items exist, undefined.
		 */
		max? (field: string, grouped?: boolean): object;
		/** 
		 * Gets the minimum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the minimum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The minimum value, if no items exist, undefined.
		 */
		min? (field: string, grouped?: boolean): object;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Loads the next 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		nextPage? (options: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Loads the previous 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		previousPage? (options: object): void;
		/** 
		 * Query all the cached records in this Store by name/value pair.
		 * The parameters will be used to generated a filter function that is given
		 * to the queryBy method.
		 * 
		 * This method complements queryBy by generating the query function automatically.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @public (method)
		 * @param   {string}              property        The property to create the filter function for
		 * @param   {string|RegExp}       value           The string/regex to compare the property value to
		 * @param   {boolean}             [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}             [caseSensitive] `true` to create a case-sensitive regex.
		 * @param   {boolean}             [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.util.Collection}                 The matched records
		 */
		query? (property: string, value: string | RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.util.Collection;
		/** 
		 * [Rejects](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-reject) outstanding changes on all [modified records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords)
		 * and re-insert any records that were removed locally. Any phantom records will be removed.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		rejectChanges? (): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Removes the specified record(s) from the Store, firing the [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove)
		 * event for the removed records.
		 * 
		 * After all records have been removed a single `datachanged` is fired.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model|Ext.data.Model[]|number|number[]} records
		 * Model instance or
		 * array of instances to remove or an array of indices from which to remove records.
		 * @param   {object}                                          isMove  (private)
		 * @param   {object}                                          silent  (private)
		 * @returns {void}                                                    
		 */
		remove? (records: Ext.data.Model | Ext.data.Model[] | number | number[], isMove: object, silent: object): void;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Removes all items from the store.
		 * 
		 * Individual record [`remove`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#event-remove) events are not fired by this method.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]|void}  The removed records.
		 */
		removeAll? (): Ext.data.Model[];
		removeAll? (): void;
		/** 
		 * Removes the model instance(s) at the given index
		 * @method
		 * @public (method)
		 * @param   {number} index   The record index
		 * @param   {number} [count] The number of records to delete
		 * @returns {void}           
		 */
		removeAt? (index: number, count?: number): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an individual Filter from the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) using the passed Filter/Filter id and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter} toRemove        The id of a Filter to remove from the filter set, or a Filter instance to remove.
		 * @param   {boolean}                [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                   
		 */
		removeFilter? (toRemove: string | Ext.util.Filter, suppressEvent?: boolean): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @param   {boolean} syncNow
		 * Pass `true` to synchronize now. Only synchronizes with the Proxy if the suspension
		 * count has gone to zero (We are not under a higher level of suspension)
		 * @returns {void}            
		 */
		resumeAutoSync? (syncNow: boolean): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Saves all pending changes via the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy). Use [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) instead.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		save? (): void;
		/** 
		 * Sets the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} asynchronousLoad The new value.
		 * @returns {void}                     
		 */
		setAsynchronousLoad? (asynchronousLoad: boolean): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean|object} autoLoad The new value.
		 * @returns {void}                    
		 */
		setAutoLoad? (autoLoad: boolean | object): void;
		/** 
		 * Sets the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoSync The new value.
		 * @returns {void}             
		 */
		setAutoSync? (autoSync: boolean): void;
		/** 
		 * Sets the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @param   {string} batchUpdateMode The new value.
		 * @returns {void}                   
		 */
		setBatchUpdateMode? (batchUpdateMode: string): void;
		/** 
		 * Sets the value of [clearOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-clearOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearOnLoad The new value.
		 * @returns {void}                
		 */
		setClearOnLoad? (clearOnLoad: boolean): void;
		/** 
		 * Sets the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearOnPageLoad The new value.
		 * @returns {void}                    
		 */
		setClearOnPageLoad? (clearOnPageLoad: boolean): void;
		/** 
		 * Sets the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearRemovedOnLoad The new value.
		 * @returns {void}                       
		 */
		setClearRemovedOnLoad? (clearRemovedOnLoad: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                                         name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                                [value] The value to set for the name parameter.
		 * @returns {Ext.data.TreeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.TreeStore;
		setConfig? (name: string | object, value?: object): Ext.data.Store;
		setConfig? (name: string | object, value?: object): Ext.data.ProxyStore;
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Loads an array of data directly into the Store.
		 * 
		 * setData() is ideal if your data's format is already in its appropriate format (e.g. it doesn't need to be
		 * processed by a reader). If your data's structure requires processing, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * 
		 * Use [loadData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadData), [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add), or [insert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-insert) if records need to be
		 * appended to the current recordset.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @returns {void}                           
		 */
		setData? (data: Ext.data.Model[] | object[]): void;
		/** 
		 * Sets the value of [defaultRootId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-defaultRootId).
		 * @method
		 * @public (method)
		 * @param   {string} defaultRootId The new value.
		 * @returns {void}                 
		 */
		setDefaultRootId? (defaultRootId: string): void;
		/** 
		 * Sets the value of [defaultRootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-defaultRootProperty).
		 * @method
		 * @public (method)
		 * @param   {string} defaultRootProperty The new value.
		 * @returns {void}                       
		 */
		setDefaultRootProperty? (defaultRootProperty: string): void;
		/** 
		 * Sets the value of [defaultRootText](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-defaultRootText).
		 * @method
		 * @public (method)
		 * @param   {string} defaultRootText The new value.
		 * @returns {void}                   
		 */
		setDefaultRootText? (defaultRootText: string): void;
		/** 
		 * Sets the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @param   {object} extraKeys The new value.
		 * @returns {void}             
		 */
		setExtraKeys? (extraKeys: object): void;
		/** 
		 * Sets the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @param   {object[]|string[]} fields The new value.
		 * @returns {void}                     
		 */
		setFields? (fields: object[] | string[]): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setFilters? (): void;
		/** 
		 * Sets the value of [folderSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-folderSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} folderSort The new value.
		 * @returns {void}               
		 */
		setFolderSort? (folderSort: boolean): void;
		/** 
		 * Sets the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @param   {string} groupDir The new value.
		 * @returns {void}            
		 */
		setGroupDir? (groupDir: string): void;
		/** 
		 * Sets the value of [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField).
		 * @method
		 * @public (method)
		 * @param   {string} groupField The new value.
		 * @returns {void}              
		 */
		setGroupField? (groupField: string): void;
		/** 
		 * Sets the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.util.Grouper} grouper The new value.
		 * @returns {void}                            
		 */
		setGrouper? (grouper: object | Ext.util.Grouper): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [nodeParam](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-nodeParam).
		 * @method
		 * @public (method)
		 * @param   {string} nodeParam The new value.
		 * @returns {void}             
		 */
		setNodeParam? (nodeParam: string): void;
		/** 
		 * Sets the value of [parentIdProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-parentIdProperty).
		 * @method
		 * @public (method)
		 * @param   {string} parentIdProperty The new value.
		 * @returns {void}                    
		 */
		setParentIdProperty? (parentIdProperty: string): void;
		/** 
		 * Sets the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteFilter The new value.
		 * @returns {void}                 
		 */
		setRemoteFilter? (remoteFilter: boolean): void;
		/** 
		 * Sets the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteSort The new value.
		 * @returns {void}               
		 */
		setRemoteSort? (remoteSort: boolean): void;
		/** 
		 * Sets the value of [root](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.TreeModel|Ext.data.NodeInterface|object} root The new value.
		 * @returns {void}                                                  
		 */
		setRoot? (root: Ext.data.TreeModel | Ext.data.NodeInterface | object): void;
		/** 
		 * Sets the root node for this store.  See also the [root](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root) config option.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.TreeModel|Ext.data.NodeInterface|object} root
		 * @returns {Ext.data.NodeInterface}                                The new root
		 */
		setRootNode? (root: Ext.data.TreeModel | Ext.data.NodeInterface | object): Ext.data.NodeInterface;
		/** 
		 * Sets the value of [rootVisible](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-rootVisible).
		 * @method
		 * @public (method)
		 * @param   {boolean} rootVisible The new value.
		 * @returns {void}                
		 */
		setRootVisible? (rootVisible: boolean): void;
		/** 
		 * Sets the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} session The new value.
		 * @returns {void}                     
		 */
		setSession? (session: Ext.data.Session): void;
		/** 
		 * Sets the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} sortOnLoad The new value.
		 * @returns {void}               
		 */
		setSortOnLoad? (sortOnLoad: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setSorters? (): void;
		/** 
		 * Sets the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @param   {boolean} statefulFilters The new value.
		 * @returns {void}                    
		 */
		setStatefulFilters? (statefulFilters: boolean): void;
		/** 
		 * Sets the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @param   {string} storeId The new value.
		 * @returns {void}           
		 */
		setStoreId? (storeId: string): void;
		/** 
		 * Sets the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @param   {boolean} trackRemoved The new value.
		 * @returns {void}                 
		 */
		setTrackRemoved? (trackRemoved: boolean): void;
		/** 
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction] The overall direction to sort the data by.
		 * @returns {Ext.util.Sorter[]}                    
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string): Ext.util.Sorter[];
		/** 
		 * Sums the value of `field` for each [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in store
		 * and returns the result.
		 * 
		 * When store is filtered, only sums items within the filter.
		 * @method
		 * @public (method)
		 * @param   {string}  field     A field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the sum for that group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            The sum
		 */
		sum? (field: string, grouped?: boolean): number;
		/** 
		 * Suspends automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendAutoSync? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Inherit docs
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		contains? (record: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.contains](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-contains).
		 * Checks if a record is in the current active data set.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record
		 * @returns {void|boolean}          `true` if the record is in the current active data set.
		 */
		contains? (record: Ext.data.Model): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		doDestroy? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                                config
		 * @returns {Ext.data.TreeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.TreeStore;
		initConfig? (config: object): Ext.data.Store;
		initConfig? (config: object): Ext.data.ProxyStore;
		initConfig? (config: object): Ext.data.AbstractStore;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Called internally when a Proxy has completed a load request
		 * @method
		 * @protected (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyLoad? (operation: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.TreeStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.TreeStore.Statics;
		statics? (): Ext.data.Store.Statics;
		statics? (): Ext.data.ProxyStore.Statics;
		statics? (): Ext.data.AbstractStore.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorter
		 * @returns {void}          
		 */
		addFieldTransform? (sorter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		addObserver? (observer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @param   {object} type
		 * @returns {void}                      
		 */
		afterChange? (record: object, modifiedFieldNames: object, type: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to.
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @returns {void}                      
		 */
		afterCommit? (record: object, modifiedFieldNames: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.Store.afterCommit](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-afterCommit).
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterCommit? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterErase? (record: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to..
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterReject? (record: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.Store.afterReject](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-afterReject).
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to..
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterReject? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} asynchronousLoad
		 * @returns {void}                    
		 */
		applyAsynchronousLoad? (asynchronousLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} extraKeys
		 * @returns {void}             
		 */
		applyExtraKeys? (extraKeys: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fields
		 * @returns {void}          
		 */
		applyFields? (fields: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @param   {object} filtersCollection
		 * @returns {void}                     
		 */
		applyFilters? (filters: object, filtersCollection: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} grouper
		 * @returns {void}           
		 */
		applyGrouper? (grouper: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @returns {void}         
		 */
		applyProxy? (proxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorters
		 * @param   {object} sortersCollection
		 * @returns {void}                     
		 */
		applySorters? (sorters: object, sortersCollection: object): void;
		/** 
		 * Restores state to the passed state
		 * @method
		 * @private (method)
		 * @param   {object} state
		 * @returns {void}         
		 */
		applyState? (state: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} args
		 * @returns {void}          
		 */
		callObservers? (action: object, args: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} isLoad
		 * @returns {void}          
		 */
		clearData? (isLoad: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.clearData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-clearData).
		 * to be implemented by subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearData? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		constructDataCollection? (): void;
		/** 
		 * saves any phantom records
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @param   {object} options
		 * @returns {void}           
		 */
		create? (data: object, options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createFiltersCollection? (): void;
		/** 
		 * Converts a literal to a model, if it's not a model already
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model|object} record The record to create
		 * @returns {Ext.data.Model}               
		 */
		createModel? (record: Ext.data.Model | object): Ext.data.Model;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createSortersCollection? (): void;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * tells the attached proxy to destroy the given records
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		erase? (options: object): void;
		/** 
		 * Similar to a load, however no records are added to the store. This is useful
		 * in allowing the developer to decide what to do with the new records.
		 * @method
		 * @private (method)
		 * @param   {object} [options] See [load options](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		fetch? (options?: object): void;
		/** 
		 * private
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @returns {void}      
		 */
		filterDataSource? (fn: object): void;
		/** 
		 * Filter function for new records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNew? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNewOnly? (item: object): void;
		/** 
		 * Filter function for rejected records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterRejects? (item: object): void;
		/** 
		 * Filter function for updated records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterUpdated? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		fireGroupChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		forceLocalSort? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @param   {object} scope
		 * @param   {object} records
		 * @param   {object} field
		 * @returns {void}           
		 */
		getAggregate? (fn: object, scope: object, records: object, field: object): void;
		/** 
		 * Returns the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.Model}  
		 */
		getAssociatedEntity? (): Ext.data.Model;
		/** 
		 * Returns the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getAutoSort? (): boolean;
		/** 
		 * Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
		 * This is broken out into a separate function to allow for customisation of the listeners
		 * @method
		 * @private (method)
		 * @returns {object}  The listeners object
		 */
		getBatchListeners? (): object;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Returns the complete unfiltered collection.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getDataSource? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getGroupField? (): void;
		/** 
		 * Returns the array of nodes which have been removed since the last time this store was synced.
		 * 
		 * This is used internally, when purging removed records after a successful sync.
		 * This is overridden by TreeStore because TreeStore accumulates deleted records on removal
		 * of child nodes from their parent, _not_ on removal of records from its collection. The collection
		 * has records added on expand, and removed on collapse.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRawRemovedRecords? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRejectRecords? (): void;
		/** 
		 * Returns the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.schema.Role}  
		 */
		getRole? (): Ext.data.schema.Role;
		/** 
		 * Returns the grouping, sorting and filtered state of this Store.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getState? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Returns true if the store has a pending load task.
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the store has a pending load task.
		 */
		hasPendingLoad? (): boolean;
		/** 
		 * Checks whether records are being moved within the store. This can be used in conjunction with the
		 * [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-add) and [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events to determine whether the records are being removed/added
		 * or just having the position changed.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]|Ext.data.Model} [records] The record(s).
		 * @returns {number}                          
		 * The number of records being moved. `0` if no records are moving. If records are passed
		 * the number will refer to how many of the passed records are moving.
		 */
		isMoving? (records?: Ext.data.Model[] | Ext.data.Model): number;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @returns {void}        
		 */
		loadInlineData? (data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		notifySorterChange? (): void;
		/** 
		 * Attached as the 'complete' event listener to a proxy's Batch object. Iterates over the batch operations
		 * and updates the Store's internal data MixedCollection.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchComplete? (batch: object, operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchException? (batch: object, operation: object): void;
		/** 
		 * Attached as the 'operationcomplete' event listener to a proxy's Batch object. By default just calls through
		 * to onProxyWrite.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchOperationComplete? (batch: object, operation: object): void;
		/** 
		 * This is attached to the data Collection's beforesort event only if not remoteSort
		 * If remoteSort, the event is fired before the reload call in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-load).
		 * @method
		 * @private (method)
		 * @param   {object} store
		 * @param   {object} sorters
		 * @returns {void}           
		 */
		onBeforeCollectionSort? (store: object, sorters: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} cls
		 * @param   {object} data
		 * @param   {object} hooks
		 * @returns {void}         
		 */
		onClassExtended? (cls: object, data: object, hooks: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} records
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionAddItems? (collection: object, records: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionBeforeItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionBeginUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionEndUpdate? (): void;
		/** 
		 * When the collection informs us that it has filtered, this LocalStore must react.
		 * AbstractStore#onFilterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilter? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} items
		 * @returns {void}              
		 */
		onCollectionFilterAdd? (collection: object, items: object): void;
		/** 
		 * If our source collection informs us that a filtered out item has changed, we must still fire the events...
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilteredItemChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionRemove? (collection: object, info: object): void;
		/** 
		 * When the collection informs us that it has sorted, this LocalStore must react.
		 * AbstractStore#onSorterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionSort? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCreateRecords? (): void;
		/** 
		 * Removes any records when a write is returned from the server.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]}             records   The array of removed records
		 * @param   {Ext.data.operation.Operation} operation The operation that just completed
		 * @param   {boolean}                      success   True if the operation was successful
		 * @returns {void}                                   
		 */
		onDestroyRecords? (records: Ext.data.Model[], operation: Ext.data.operation.Operation, success: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onErase? (): void;
		/** 
		 * We add listeners to the FilterCollection and do the filtering in a hierarchical
		 * way. We are not interested in notifications as an observer on the data collection.
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @returns {void}           
		 */
		onFilterEndUpdate? (filters: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.Store.onFilterEndUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-onFilterEndUpdate).
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onFilterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} meta
		 * @returns {void}         
		 */
		onMetaChange? (proxy: object, meta: object): void;
		/** 
		 * Callback for any write Operation over the Proxy. Updates the Store's MixedCollection to reflect
		 * the updates provided by the Proxy
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyWrite? (operation: object): void;
		/** 
		 * TreeStore has to do right things upon SorterCollection update
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onSorterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdate? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdateRecords? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Query all the cached records in this Store by field.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @private (method)
		 * @param   {string}           field The field from each record to use.
		 * @param   {object}           value The value to match.
		 * @returns {Ext.data.Model[]}       The matched records.
		 */
		queryRecords? (field: string, value: object): Ext.data.Model[];
		/** 
		 * Determines if the passed range is available in the page cache.
		 * @method
		 * @private (method)
		 * @param   {number} start The start index
		 * @param   {number} end   The end index in the range
		 * @returns {void}         
		 */
		rangeCached? (start: number, end: number): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		removeObserver? (observer: object): void;
		/** 
		 * Sets the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} associatedEntity The new value.
		 * @returns {void}                            
		 */
		setAssociatedEntity? (associatedEntity: Ext.data.Model): void;
		/** 
		 * Sets the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @param   {boolean} autoSort The new value.
		 * @returns {void}             
		 */
		setAutoSort? (autoSort: boolean): void;
		/** 
		 * Make a set of records be current in the store. This means that unneeded records
		 * will be removed and new records will be added.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]} records The records to be current in the store.
		 * @returns {void}                     
		 */
		setRecords? (records: Ext.data.Model[]): void;
		/** 
		 * Sets the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.schema.Role} role The new value.
		 * @returns {void}                      
		 */
		setRole? (role: Ext.data.schema.Role): void;
		/** 
		 * This method is basically the same as the JavaScript Array splice method.
		 * 
		 * Negative indexes are interpreted starting at the end of the collection. That is,
		 * a value of -1 indicates the last item, or equivalent to `length - 1`.
		 * @method
		 * @private (method)
		 * @param   {number}          index    The index at which to add or remove items.
		 * @param   {number|object[]} toRemove
		 * The number of items to remove or an array of the
		 * items to remove.
		 * @param   {object[]}        [toAdd]  The items to insert at the given `index`.
		 * @returns {void}                     
		 */
		splice? (index: number, toRemove: number | object[], toAdd?: object[]): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                              names The names of the linked objects to destroy.
		 * @returns {Ext.data.TreeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.TreeStore;
		unlink? (names: string[]): Ext.data.Store;
		unlink? (names: string[]): Ext.data.ProxyStore;
		unlink? (names: string[]): Ext.data.AbstractStore;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		update? (options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoLoad
		 * @returns {void}            
		 */
		updateAutoLoad? (autoLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoSort
		 * @returns {void}            
		 */
		updateAutoSort? (autoSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} field
		 * @returns {void}         
		 */
		updateGroupField? (field: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @returns {void}                
		 */
		updateRemoteFilter? (remoteFilter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @returns {void}              
		 */
		updateRemoteSort? (remoteSort: object): void;
	}
	/** 
	 * [Ext.data.Types](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Types.html)
	 * @singleton (definition)
	 * @deprecated
	 */
	interface Types extends Ext.Base {
		/** 
		 * This data type means that no conversion is applied to the raw data before it is placed into a Record.
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		AUTO?: object;
		/** 
		 * This data type means that the raw data is converted into a boolean before it is placed into
		 * a Record. The string "true" and the number 1 are converted to boolean true.
		 * 
		 * The synonym `BOOLEAN` is equivalent.
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		BOOL?: object;
		/** 
		 * This data type means that the raw data is converted into a boolean before it is placed into
		 * a Record. The string "true" and the number 1 are converted to boolean `true`.
		 * 
		 * The synonym `BOOL` is equivalent.
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		BOOLEAN?: object;
		/** 
		 * This data type means that the raw data is converted into a Date before it is placed into a Record.
		 * The date format is specified in the constructor of the [Ext.data.Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) to which this type is
		 * being applied.
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		DATE?: object;
		/** 
		 * This data type means that the raw data is converted into a number before it is placed into a Record.
		 * 
		 * The synonym `NUMBER` is equivalent.
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		FLOAT?: object;
		/** 
		 * This data type means that the raw data is converted into an integer before it is placed into a Record.
		 * 
		 * The synonym `INTEGER` is equivalent.
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		INT?: object;
		/** 
		 * This data type means that the raw data is converted into an integer before it is placed into a Record.
		 * 
		 * The synonym `INT` is equivalent.
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		INTEGER?: object;
		/** 
		 * This data type means that the raw data is converted into a number before it is placed into a Record.
		 * 
		 * The synonym `FLOAT` is equivalent.
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		NUMBER?: object;
		/** 
		 * This data type means that the raw data is converted into a String before it is placed into a Record.
		 * @property
		 * @public (property)
		 * @readonly
		 * @type {object}
		 */
		STRING?: object;
		/** 
		 * A regular expression for stripping non-numeric characters from a numeric value.
		 * This should be overridden for localization.
		 * @property
		 * @public (property)
		 * @default /[\$,%]/g
		 * @type {RegExp}
		 */
		stripRe?: RegExp;
	}
	/** 
	 * This class is used to hold validation errors for a record. The results of the record's
	 * [`validators`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-validators) are stored as the field values of this
	 * record. The first failed validation is all that is stored per field unless the Model
	 * class has defined a `validationSeparator` config.
	 * 
	 * Application code will not need to interact with this class specifically but rather just
	 * view the validation as a record.
	 * @private (class)
	 */
	class Validation extends Ext.data.Model {}
	/** 
	 * [Ext.data.XmlStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from XML data easier.
	 * A XmlStore will be automatically configured with a [Ext.data.reader.Xml](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Xml.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.XmlStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *        url: 'sheldon.xml', // automatically configures a HttpProxy
	 *        // reader configs
	 *        record: 'Item', // records will have an "Item" tag
	 *        idPath: 'ASIN',
	 *        totalRecords: '@TotalResults'
	 *        fields: [
	 *            // set up the fields mapping into the xml doc
	 *            // The first needs mapping, the others are very basic
	 *            {name: 'Author', mapping: 'ItemAttributes > Author'},
	 *            'Title', 'Manufacturer', 'ProductGroup'
	 *        ]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    &#60?xml version="1.0" encoding="UTF-8"?>
	 *    &#60ItemSearchResponse xmlns="http://webservices.amazon.com/AWSECommerceService/2009-05-15">
	 *        &#60Items>
	 *            &#60Request>
	 *                &#60IsValid>True&#60/IsValid>
	 *                &#60ItemSearchRequest>
	 *                    &#60Author>Sidney Sheldon&#60/Author>
	 *                    &#60SearchIndex>Books&#60/SearchIndex>
	 *                &#60/ItemSearchRequest>
	 *            &#60/Request>
	 *            &#60TotalResults>203&#60/TotalResults>
	 *            &#60TotalPages>21&#60/TotalPages>
	 *            &#60Item>
	 *                &#60ASIN>0446355453&#60/ASIN>
	 *                &#60DetailPageURL>
	 *                    http://www.amazon.com/
	 *                &#60/DetailPageURL>
	 *                &#60ItemAttributes>
	 *                    &#60Author>Sidney Sheldon&#60/Author>
	 *                    &#60Manufacturer>Warner Books&#60/Manufacturer>
	 *                    &#60ProductGroup>Book&#60/ProductGroup>
	 *                    &#60Title>Master of the Game&#60/Title>
	 *                &#60/ItemAttributes>
	 *            &#60/Item>
	 *        &#60/Items>
	 *    &#60/ItemSearchResponse>
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#cfg-data) config option.
	 * 
	 * **Note:** This class accepts all of the configuration options of
	 * **[XmlReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Xml.html)**.
	 */
	class XmlStore extends Ext.data.Store {
		/** 
		 * Get the reference to the current class from which this object was instantiated. Unlike [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics),
		 * `this.self` is scope-dependent and it's meant to be used for dynamic inheritance. See [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-statics)
		 * for a detailed comparison
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            alert(this.self.speciesName); // dependent on 'this'
		 *        },
		 *    
		 *        clone: function() {
		 *            return new this.self();
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *        statics: {
		 *            speciesName: 'Snow Leopard'         // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                     // alerts 'Cat'
		 *    var snowLeopard = new My.SnowLeopard();     // alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));             // alerts 'My.SnowLeopard'
		 * 
		 * @property
		 * @protected (property)
		 * @default Ext.Base
		 * @type {Ext.data.XmlStore.Statics}
		 */
		self?: Ext.data.XmlStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics;
		/** 
		 * The value `true` causes `config` values to be stored on instances using a
		 * property name prefixed with an underscore ("_") character. A value of `false`
		 * stores `config` values as properties using their exact name (no prefix).
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configPrefixed?: boolean;
		/** 
		 * The value `true` instructs the `initConfig` method to only honor values for
		 * properties declared in the `config` block of a class. When `false`, properties
		 * that are not declared in a `config` block will be placed on the instance.
		 * @property
		 * @private (property)
		 * @default true
		 * @type {boolean}
		 */
		$configStrict?: boolean;
		/** 
		 * @property
		 * @private (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                               members    The members to add to this class.
		 * @param   {boolean}                                                                              [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                              [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.XmlStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.XmlStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		static addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                               members
		 * @returns {Ext.data.XmlStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		static addStatics? (members: object): typeof Ext.data.XmlStore;
		static addStatics? (members: object): typeof Ext.data.Store;
		static addStatics? (members: object): typeof Ext.data.ProxyStore;
		static addStatics? (members: object): typeof Ext.data.AbstractStore;
		static addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		static create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		static createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		static getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		static override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		static callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		static addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		static addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                               name
		 * @param   {object}                                                                               member
		 * @returns {Ext.data.XmlStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		static addMember? (name: object, member: object): typeof Ext.data.XmlStore;
		static addMember? (name: object, member: object): typeof Ext.data.Store;
		static addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		static addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		static addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		static borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		static extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		static getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		static mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                               fn
		 * @param   {object}                                                                               scope
		 * @returns {Ext.data.XmlStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		static onExtended? (fn: object, scope: object): typeof Ext.data.XmlStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		static onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		static onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		static onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		static triggerExtended? (): void;
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                The model instances that were added
		 */
		add? (model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Adds Model instance to the Store. This method accepts either:
		 * 
		 * - An array of Model instances or Model configuration objects.
		 * - Any number of Model instance or Model configuration object arguments.
		 * 
		 * The new Model instances will be added at the end of the existing collection.
		 * 
		 * Sample usage:
		 * 
		 *    myStore.add({some: 'data'}, {some: 'other data'});
		 * 
		 * Note that if this Store is sorted, the new Model instances will be inserted
		 * at the correct point in the Store to maintain the sort order.
		 * @method
		 * @public (method)
		 * @param   {...Ext.data.Model|...object} model
		 * An array of Model instances
		 * or Model configuration objects, or variable number of Model instance or config arguments.
		 * @returns {Ext.data.Model[]}                  The model instances that were added
		 */
		add? (...model: Ext.data.Model[] | object[]): Ext.data.Model[];
		/** 
		 * Alias for [onAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addAfterListener? (): void;
		/** 
		 * Alias for [onBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-onBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		addBeforeListener? (): void;
		/** 
		 * Adds a new Filter to this Store's [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {object[]|Ext.util.Filter[]} filters         The set of filters to add to the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters).
		 * @param   {boolean}                    [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                       
		 */
		addFilter? (filters: object[] | Ext.util.Filter[], suppressEvent?: boolean): void;
		/** 
		 * The addManagedListener method is used when some object (call it "A") is listening
		 * to an event on another observable object ("B") and you want to remove that listener
		 * from "B" when "A" is destroyed. This is not an issue when "B" is destroyed because
		 * all of its listeners will be removed at that time.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Foo', {
		 *        extend: 'Ext.Component',
		 *    
		 *        initComponent: function () {
		 *            this.addManagedListener(MyApp.SomeGlobalSharedMenu, 'show', this.doSomething);
		 *            this.callParent();
		 *        }
		 *    });
		 * 
		 * As you can see, when an instance of Foo is destroyed, it ensures that the 'show'
		 * listener on the menu (`MyApp.SomeGlobalSharedMenu`) is also removed.
		 * 
		 * As of version 5.1 it is no longer necessary to use this method in most cases because
		 * listeners are automatically managed if the scope object provided to
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) is an Observable instance.
		 * However, if the observable instance and scope are not the same object you
		 * still need to use `mon` or `addManagedListener` if you want the listener to be
		 * managed.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		addManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * (Local sort only) Inserts the passed Record into the Store at the index where it
		 * should go based on the current sort information.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Record} record
		 * @returns {void}                   
		 */
		addSorted? (record: Ext.data.Record): void;
		/** 
		 * Runs the aggregate function for all the records in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {Function} fn
		 * The function to execute. The function is called with a single parameter,
		 * an array of records for that group.
		 * @param   {object}   scope   The scope to execute the function in. Defaults to the store.
		 * @param   {boolean}  grouped
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @param   {string}   field   The field to get the value from
		 * @returns {object}           An object literal with the group names and their appropriate values.
		 */
		aggregate? (fn: ExtGlobalFunction, scope: object, grouped: boolean, field: string): object;
		/** 
		 * Gets the average value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the group average being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The average value, if no items exist, 0.
		 */
		average? (field: string, grouped?: boolean): object;
		/** 
		 * This method may be called to indicate the start of multiple changes to the store.
		 * 
		 * Automatic synchronization as configured by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred
		 * until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple mutations can be coalesced
		 * into one synchronization operation.
		 * 
		 * Internally this method increments a counter that is decremented by `endUpdate`. It
		 * is important, therefore, that if you call `beginUpdate` directly you match that
		 * call with a call to `endUpdate` or you will prevent the collection from updating
		 * properly.
		 * 
		 * For example:
		 * 
		 *     var store = Ext.StoreManager.lookup({
		 *         //...
		 *         autoSync: true
		 *     });
		 *    
		 *     store.beginUpdate();
		 *    
		 *     record.set('fieldName', 'newValue');
		 *    
		 *     store.add(item);
		 *     // ...
		 *    
		 *     store.insert(index, otherItem);
		 *     //...
		 *    
		 *     // Interested parties will listen for the endupdate event
		 *     store.endUpdate();
		 * 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		beginUpdate? (): void;
		/** 
		 * Reverts to a view of the Record cache with no filtering applied.
		 * @method
		 * @public (method)
		 * @param   {boolean} [suppressEvent]
		 * If `true` the filter is cleared silently.
		 * 
		 * For a locally filtered Store, this means that the filter collection is cleared without firing the
		 * [datachanged](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-datachanged) event.
		 * 
		 * For a remotely filtered Store, this means that the filter collection is cleared, but the store
		 * is not reloaded from the server.
		 * @returns {void}                    
		 */
		clearFilter? (suppressEvent?: boolean): void;
		/** 
		 * Clear the store grouping
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearGrouping? (): void;
		/** 
		 * Removes all listeners for this object including the managed listeners
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearListeners? (): void;
		/** 
		 * Removes all managed listeners for this object.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		clearManagedListeners? (): void;
		/** 
		 * Commits all Records with [outstanding changes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords). To handle updates for changes,
		 * subscribe to the Store's [update event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-update), and perform updating when the third parameter is
		 * [Ext.data.Record.COMMIT](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#static-property-COMMIT).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		commitChanges? (): void;
		/** 
		 * Gets the count of items in the store.
		 * 
		 * When store is filtered, only items within the filter are counted.
		 * @method
		 * @public (method)
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the count for each group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            the count
		 */
		count? (grouped?: boolean): number;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Enables events fired by this Observable to bubble up an owner hierarchy by calling `this.getBubbleTarget()` if
		 * present. There is no implementation in the Observable base class.
		 * 
		 * This is commonly used by Ext.Components to bubble events to owner Containers.
		 * See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget). The default implementation in [Ext.Component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) returns the
		 * Component's immediate owner. But if a known target is required, this can be overridden to access the
		 * required target more quickly.
		 * 
		 * Example:
		 * 
		 *    Ext.define('Ext.overrides.form.field.Base', {
		 *        override: 'Ext.form.field.Base',
		 *    
		 *        //  Add functionality to Field's initComponent to enable the change event to bubble
		 *        initComponent: function () {
		 *            this.callParent();
		 *            this.enableBubble('change');
		 *        }
		 *    });
		 *    
		 *    var myForm = Ext.create('Ext.form.Panel', {
		 *        title: 'User Details',
		 *        items: [{
		 *            ...
		 *        }],
		 *        listeners: {
		 *            change: function() {
		 *                // Title goes red if form has been modified.
		 *                myForm.header.setStyle('color', 'red');
		 *            }
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|string[]} eventNames The event name to bubble, or an Array of event names.
		 * @returns {void}                       
		 */
		enableBubble? (eventNames: string | string[]): void;
		/** 
		 * This method is called after modifications are complete on a store. For details
		 * see [`beginUpdate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		endUpdate? (): void;
		/** 
		 * Filters the data in the Store by one or more fields. Example usage:
		 * 
		 *    //filter with a single field
		 *    myStore.filter('firstName', 'Don');
		 *    
		 *    //filtering with multiple filters
		 *    myStore.filter([
		 *        {
		 *            property : 'firstName',
		 *            value    : 'Don'
		 *        },
		 *        {
		 *            property : 'lastName',
		 *            value    : 'Griffin'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) instances, and delegates
		 * the actual filtering to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter[]} [filters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of filter configurations.
		 * @param   {string}                   [value]   The property value by which to filter. Only applicable if `filters` is a string.
		 * @returns {void}                               
		 */
		filter? (filters?: string | Ext.util.Filter[], value?: string): void;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}        property        The name of the Record field to test.
		 * @param   {string|RegExp} value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}        [startIndex]    The index to start searching at
		 * @param   {boolean}       [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}       [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}       [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {number}                        The matched index or -1
		 */
		find? (property: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): number;
		/** 
		 * Finds the index of the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string} fieldName    The name of the Record field to test.
		 * @param   {object} value        The value to match the field against.
		 * @param   {number} [startIndex] The index to start searching at
		 * @returns {number}              The matched index or -1
		 */
		findExact? (fieldName: string, value: object, startIndex?: number): number;
		/** 
		 * Finds the first matching Record in this store by a specific field value.
		 * 
		 * When store is filtered, finds records only within filter.
		 * 
		 * **IMPORTANT
		 * 
		 * If this store is [Buffered](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html), this can ONLY find records which happen to be cached in the page cache.
		 * This will be parts of the dataset around the currently visible zone, or recently visited zones if the pages
		 * have not yet been purged from the cache.**
		 * @method
		 * @public (method)
		 * @param   {string}         fieldName       The name of the Record field to test.
		 * @param   {string|RegExp}  value
		 * Either a string that the field value
		 * should begin with, or a RegExp to test against the field.
		 * @param   {number}         [startIndex]    The index to start searching at
		 * @param   {boolean}        [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}        [caseSensitive] True for case sensitive comparison
		 * @param   {boolean}        [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.data.Model}                 The matched record or null
		 */
		findRecord? (fieldName: string, value: string | RegExp, startIndex?: number, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.data.Model;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * By default, the action function will be executed after any "before" event handlers
		 * (as specified using the `order` option of
		 * [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)), but before any other
		 * handlers are fired.  This gives the "before" handlers an opportunity to
		 * cancel the event by returning `false`, and prevent the action function from
		 * being called.
		 * 
		 * The action can also be configured to run after normal handlers, but before any "after"
		 * handlers (as specified using the `order` event option) by passing `'after'`
		 * as the `order` parameter.  This configuration gives any event handlers except
		 * for "after" handlers the opportunity to cancel the event and prevent the action
		 * function from being called.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {any[]}    args      Arguments to pass to handlers and to the action function.
		 * @param   {Function} fn        The action function.
		 * @param   {object}   [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {object}   [options]
		 * Event options for the action function.  Accepts any
		 * of the options of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * @param   {string}   [order]
		 * The order to call the action function relative
		 * too the event handlers (`'before'` or `'after'`).  Note that this option is
		 * simply used to sort the action function relative to the event handlers by "priority".
		 * An order of `'before'` is equivalent to a priority of `99.5`, while an order of
		 * `'after'` is equivalent to a priority of `-99.5`.  See the `priority` option
		 * of [`addListener`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) for more details.
		 * @returns {void}               
		 */
		fireAction? (eventName: string, args: any[], fn: ExtGlobalFunction, scope?: object, options?: object, order?: string): void;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to fire.
		 * @returns {boolean}           returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string): boolean;
		/** 
		 * Fires the specified event with the passed parameters (minus the event name, plus the `options` object passed
		 * to [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)).
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}    eventName The name of the event to fire.
		 * @param   {...object} args      Variable number of parameters are passed to handlers.
		 * @returns {boolean}             returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEvent? (eventName: string, ...args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameter list.
		 * 
		 * An event may be set to bubble up an Observable parent hierarchy (See [Ext.Component.getBubbleTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html#method-getBubbleTarget)) by
		 * calling [enableBubble](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-enableBubble).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The name of the event to fire.
		 * @param   {object[]} args      An array of parameters which are passed to handlers.
		 * @returns {boolean}            returns false if any of the handlers return false otherwise it returns true.
		 */
		fireEventArgs? (eventName: string, args: object[]): boolean;
		/** 
		 * Fires the specified event with the passed parameters and executes a function (action).
		 * Evented Actions will automatically dispatch a 'before' event passing. This event will
		 * be given a special controller that allows for pausing/resuming of the event flow.
		 * 
		 * By pausing the controller the updater and events will not run until resumed. Pausing,
		 * however, will not stop the processing of any other before events.
		 * @method
		 * @public (method)
		 * @param   {string}          eventName The name of the event to fire.
		 * @param   {any[]}           args      Arguments to pass to handlers and to the action function.
		 * @param   {Function|string} fn        The action function.
		 * @param   {object}          [scope]
		 * The scope (`this` reference) in which the handler function is
		 * executed. **If omitted, defaults to the object which fired the event.**
		 * @param   {any[]|boolean}   [fnArgs]
		 * Optional arguments for the action `fn`. If not
		 * given, the normal `args` will be used to call `fn`. If `false` is passed, the
		 * `args` are used but if the first argument is this instance it will be removed
		 * from the args passed to the action function.
		 * @returns {void}                      
		 */
		fireEventedAction? (eventName: string, args: any[], fn: ExtGlobalFunction | string, scope?: object, fnArgs?: any[] | boolean): void;
		/** 
		 * Convenience function for getting the first model instance in the store.
		 * 
		 * When store is filtered, will return first item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the first record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The first model instance in the store, or undefined
		 */
		first? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Called when the event handler which called the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method exits.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		flushLoad? (): void;
		/** 
		 * Returns the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAsynchronousLoad? (): boolean;
		/** 
		 * Get the Record at the specified index.
		 * 
		 * The index is effected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}         index The index of the Record to find.
		 * @returns {Ext.data.Model}       The Record at the passed index. Returns null if not found.
		 */
		getAt? (index: number): Ext.data.Model;
		/** 
		 * Returns the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoDestroy? (): boolean;
		/** 
		 * Returns the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean|object}  
		 */
		getAutoLoad? (): boolean | object;
		/** 
		 * Returns the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getAutoSync? (): boolean;
		/** 
		 * Returns the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getBatchUpdateMode? (): string;
		/** 
		 * Get the Record with the specified id.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            id The id of the Record to find.
		 * @returns {Ext.data.Model}    The Record with the passed id. Returns null if not found.
		 */
		getById? (id: any): Ext.data.Model;
		/** 
		 * Get the Record with the specified internalId.
		 * 
		 * This method is not affected by filtering, lookup will be performed from all records
		 * inside the store, filtered or not.
		 * @method
		 * @public (method)
		 * @param   {any}            internalId The id of the Record to find.
		 * @returns {Ext.data.Model}            The Record with the passed internalId. Returns null if not found.
		 */
		getByInternalId? (internalId: any): Ext.data.Model;
		/** 
		 * Returns the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearOnPageLoad? (): boolean;
		/** 
		 * Returns the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getClearRemovedOnLoad? (): boolean;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Gets the number of records in store.
		 * 
		 * If using paging, this may not be the total size of the dataset. If the data object
		 * used by the Reader contains the dataset size, then the [Ext.data.ProxyStore.getTotalCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getTotalCount) function returns
		 * the dataset size.  **Note**: see the Important note in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load).
		 * 
		 * When store is filtered, it's the number of records matching the filter.
		 * @method
		 * @public (method)
		 * @returns {number}  The number of Records in the Store.
		 */
		getCount? (): number;
		/** 
		 * Returns the store's records.
		 * 
		 * **Note:** If your store has been filtered, getData() will return a filtered
		 * collection.  Use `getData().[getSource()`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#method-getSource) to
		 * fetch all unfiltered records.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection} 
		 * An [Ext.util.Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) of records
		 * (an empty Collection if no records are held by the store).
		 */
		getData? (): Ext.util.Collection;
		/** 
		 * Returns the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @returns {object}  
		 */
		getExtraKeys? (): object;
		/** 
		 * Returns the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @returns {object[]|string[]}  
		 */
		getFields? (): object[] | string[];
		/** 
		 * Gets the filters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.FilterCollection}            The filters
		 */
		getFilters? (autoCreate: object): Ext.util.FilterCollection;
		/** 
		 * Returns the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getGroupDir? (): string;
		/** 
		 * Returns the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @returns {object|Ext.util.Grouper}  
		 */
		getGrouper? (): object | Ext.util.Grouper;
		/** 
		 * Returns a collection of readonly sub-collections of your store's records
		 * with grouping applied. These sub-collections are maintained internally by
		 * the collection.
		 * 
		 * See [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField), [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir). Example for a store
		 * containing records with a color field:
		 * 
		 *    var myStore = Ext.create('Ext.data.Store', {
		 *        groupField: 'color',
		 *        groupDir  : 'DESC'
		 *    });
		 *    
		 *    myStore.getGroups();
		 * 
		 * The above should result in the following format:
		 * 
		 *    [
		 *        {
		 *            name: 'yellow',
		 *            children: [
		 *                // all records where the color field is 'yellow'
		 *            ]
		 *        },
		 *        {
		 *            name: 'red',
		 *            children: [
		 *                // all records where the color field is 'red'
		 *            ]
		 *        }
		 *    ]
		 * 
		 * Group contents are affected by filtering.
		 * @method
		 * @public (method)
		 * @returns {Ext.util.Collection}  The grouped data
		 */
		getGroups? (): Ext.util.Collection;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Returns the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.Model}  
		 */
		getModel? (): string | Ext.data.Model;
		/** 
		 * Gets all [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) added or updated since the last commit. Note that the order of records
		 * returned is not deterministic and does not indicate the order in which records were modified. Note also that
		 * removed records are not included (use [getRemovedRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getRemovedRecords) for that).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The added and updated Model instances
		 */
		getModifiedRecords? (): Ext.data.Model[];
		/** 
		 * Returns all [`phantom`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records in this store.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  A possibly empty array of `phantom` records.
		 */
		getNewRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @returns {number}  
		 */
		getPageSize? (): number;
		/** 
		 * Returns the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @returns {string|Ext.data.proxy.Proxy|object}  
		 */
		getProxy? (): string | Ext.data.proxy.Proxy | object;
		/** 
		 * Gathers a range of Records between specified indices.
		 * 
		 * This method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {number}           start The starting index. Defaults to zero.
		 * @param   {number}           end   The ending index. Defaults to the last record. The end index **is included**.
		 * @returns {Ext.data.Model[]}       An array of records.
		 */
		getRange? (start: number, end: number): Ext.data.Model[];
		/** 
		 * Returns the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteFilter? (): boolean;
		/** 
		 * Returns the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getRemoteSort? (): boolean;
		/** 
		 * Returns any records that have been removed from the store but not yet destroyed on the proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]} 
		 * The removed Model instances. Note that this is a _copy_ of the store's
		 * array, so may be mutated.
		 */
		getRemovedRecords? (): Ext.data.Model[];
		/** 
		 * Returns the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Session}  
		 */
		getSession? (): Ext.data.Session;
		/** 
		 * Returns the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getSortOnLoad? (): boolean;
		/** 
		 * Gets the sorters for this store.
		 * @method
		 * @public (method)
		 * @param   {object}                    autoCreate
		 * @returns {Ext.util.SorterCollection}            The sorters
		 */
		getSorters? (autoCreate: object): Ext.util.SorterCollection;
		/** 
		 * Returns the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getStatefulFilters? (): boolean;
		/** 
		 * Returns the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @returns {string}  
		 */
		getStoreId? (): string;
		/** 
		 * Returns the total number of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances that the [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html)
		 * indicates exist. This will usually differ from [getCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-getCount) when using paging - getCount returns the
		 * number of records loaded into the Store at the moment, getTotalCount returns the number of records that
		 * could be loaded into the Store if the Store contained all data
		 * @method
		 * @public (method)
		 * @returns {number} 
		 * The total number of Model instances available via the Proxy. 0 returned if
		 * no value has been set via the reader.
		 */
		getTotalCount? (): number;
		/** 
		 * Returns the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @returns {boolean}  
		 */
		getTrackRemoved? (): boolean;
		/** 
		 * Returns all valid, non-phantom Model instances that have been updated in the Store but not yet synchronized with the Proxy.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]}  The updated Model instances
		 */
		getUpdatedRecords? (): Ext.data.Model[];
		/** 
		 * Groups data inside the store.
		 * @method
		 * @public (method)
		 * @param   {string|object} grouper
		 * Either a string name of one of the fields in this Store's
		 * configured [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an object, or a [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Grouper.html) configuration object.
		 * @param   {string}        [direction] The overall direction to group the data by. Defaults to the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @returns {void}                      
		 */
		group? (grouper: string | object, direction?: string): void;
		/** 
		 * Checks to see if this object has any listeners for a specified event, or whether the event bubbles. The answer
		 * indicates whether the event needs firing or not.
		 * @method
		 * @public (method)
		 * @param   {string}  eventName The name of the event to check for
		 * @returns {boolean}           `true` if the event is being listened for or bubbles, else `false`
		 */
		hasListener? (eventName: string): boolean;
		/** 
		 * Get the index of the record within the store.
		 * 
		 * When store is filtered, records outside of filter will not be found.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) object to find.
		 * @returns {number}                The index of the passed Record. Returns -1 if not found.
		 */
		indexOf? (record: Ext.data.Model): number;
		/** 
		 * Get the index within the store of the Record with the passed id.
		 * 
		 * Like [indexOf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-indexOf), this method is affected by filtering.
		 * @method
		 * @public (method)
		 * @param   {string} id The id of the Record to find.
		 * @returns {number}    The index of the Record. Returns -1 if not found.
		 */
		indexOfId? (id: string): number;
		/** 
		 * Inserts Model instances into the Store at the given index and fires the add event.
		 * See also [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
		 * @method
		 * @public (method)
		 * @param   {number}                                          index   The start index at which to insert the passed Records.
		 * @param   {Ext.data.Model|Ext.data.Model[]|object|object[]} records
		 * An [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instance, the
		 * data needed to populate an instance or an array of either of these.
		 * @returns {Ext.data.Model[]}                                        records The added records
		 */
		insert? (index: number, records: Ext.data.Model | Ext.data.Model[] | object | object[]): Ext.data.Model[];
		/** 
		 * Tests whether the store currently has any active filters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is filtered.
		 */
		isFiltered? (): boolean;
		/** 
		 * Tests whether the store currently has an active grouper.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is grouped.
		 */
		isGrouped? (): boolean;
		/** 
		 * Returns `true` if the Store has been loaded.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store has been loaded.
		 */
		isLoaded? (): boolean;
		/** 
		 * Returns true if the Store is currently performing a load operation
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the Store is currently loading
		 */
		isLoading? (): boolean;
		/** 
		 * Tests whether the store currently has any active sorters.
		 * @method
		 * @public (method)
		 * @returns {boolean}  `true` if the store is sorted.
		 */
		isSorted? (): boolean;
		/** 
		 * Checks if all events, or a specific event, is suspended.
		 * @method
		 * @public (method)
		 * @param   {string}  [event] The name of the specific event to check
		 * @returns {boolean}         `true` if events are suspended
		 */
		isSuspended? (event?: string): boolean;
		/** 
		 * Convenience function for getting the last model instance in the store.
		 * 
		 * When store is filtered, will return last item within the filter.
		 * @method
		 * @public (method)
		 * @param   {boolean}                  [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the last record being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {Ext.data.Model|undefined}           The last model instance in the store, or undefined
		 */
		last? (grouped?: boolean): Ext.data.Model | undefined;
		/** 
		 * Loads an array of data straight into the Store.
		 * 
		 * Using this method is great if the data is in the correct format already (e.g. it doesn't need to be
		 * processed by a reader). If your data requires processing to decode the data structure, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @param   {boolean}                   [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {void}                               
		 */
		loadData? (data: Ext.data.Model[] | object[], append?: boolean): void;
		/** 
		 * Loads a given 'page' of data by setting the start and limit values appropriately. Internally this just causes a normal
		 * load operation, passing in calculated 'start' and 'limit' params.
		 * @method
		 * @public (method)
		 * @param   {number} page      The number of the page to load.
		 * @param   {object} [options] See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		loadPage? (page: number, options?: object): void;
		/** 
		 * Loads data via the bound Proxy's reader
		 * 
		 * Use this method if you are attempting to load data and want to utilize the configured data reader.
		 * 
		 * As of 4.2, this method will no longer fire the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-load) event.
		 * @method
		 * @public (method)
		 * @param   {object[]} data     The full JSON object you'd like to load into the Data store.
		 * @param   {boolean}  [append]
		 * `true` to add the records to the existing records in the store, `false`
		 * to remove the old ones first.
		 * @returns {boolean}  
		 * `true` if the reader processed the records correctly. See [Ext.data.reader.Reader.successProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-successProperty).
		 * If the reader did not process the records, nothing will be added.
		 */
		loadRawData? (data: object[], append?: boolean): boolean;
		/** 
		 * Gets the maximum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the maximum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The maximum value, if no items exist, undefined.
		 */
		max? (field: string, grouped?: boolean): object;
		/** 
		 * Gets the minimum value in the store.
		 * 
		 * When store is filtered, only items within the filter are aggregated.
		 * @method
		 * @public (method)
		 * @param   {string}  field     The field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the minimum in the group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {object}            The minimum value, if no items exist, undefined.
		 */
		min? (field: string, grouped?: boolean): object;
		/** 
		 * Shorthand for [addManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-addManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item      The item to which to add a listener/listeners.
		 * @param   {object|string}                       ename     The event name, or an object containing event name properties.
		 * @param   {Function|string}                     [fn]
		 * If the `ename` parameter was an event
		 * name, this is the handler function or the name of a method on the specified
		 * `scope`.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @param   {object}                              [options]
		 * If the `ename` parameter was an event name, this is the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) options.
		 * @returns {object}                              
		 * **Only when the `destroyable` option is specified. **
		 * 
		 *  A `Destroyable` object. An object which implements the `destroy` method which removes all listeners added in this call. For example:
		 * 
		 *    this.btnListeners = myButton.mon({
		 *        destroyable: true
		 *        mouseover:   function() { console.log('mouseover'); },
		 *        mouseout:    function() { console.log('mouseout'); },
		 *        click:       function() { console.log('click'); }
		 *    });
		 * 
		 * And when those listeners need to be removed:
		 * 
		 *    Ext.destroy(this.btnListeners);
		 * 
		 * or
		 * 
		 *    this.btnListeners.destroy();
		 * 
		 */
		mon? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction | string, scope?: object, options?: object): object;
		/** 
		 * Shorthand for [removeManagedListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeManagedListener).
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		mun? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Loads the next 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		nextPage? (options: object): void;
		/** 
		 * Appends an after-event handler.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Appends a before-event handler.  Returning `false` from the handler will stop the event.
		 * 
		 * Same as [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) with `order` set
		 * to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event to listen for.
		 * @param   {Function|string}        fn        The method the event invokes.
		 * @param   {object}                 [scope]   The scope for `fn`.
		 * @param   {object}                 [options] An object containing handler configuration.
		 * @returns {void}                             
		 */
		onBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Loads the previous 'page' in the current data set
		 * @method
		 * @public (method)
		 * @param   {object} options See options for [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
		 * @returns {void}           
		 */
		previousPage? (options: object): void;
		/** 
		 * Query all the cached records in this Store by name/value pair.
		 * The parameters will be used to generated a filter function that is given
		 * to the queryBy method.
		 * 
		 * This method complements queryBy by generating the query function automatically.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @public (method)
		 * @param   {string}              property        The property to create the filter function for
		 * @param   {string|RegExp}       value           The string/regex to compare the property value to
		 * @param   {boolean}             [anyMatch]
		 * True to match any part of the string, not just the
		 * beginning.
		 * @param   {boolean}             [caseSensitive] `true` to create a case-sensitive regex.
		 * @param   {boolean}             [exactMatch]
		 * True to force exact match (^ and $ characters
		 * added to the regex). Ignored if `anyMatch` is `true`.
		 * @returns {Ext.util.Collection}                 The matched records
		 */
		query? (property: string, value: string | RegExp, anyMatch?: boolean, caseSensitive?: boolean, exactMatch?: boolean): Ext.util.Collection;
		/** 
		 * [Rejects](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-reject) outstanding changes on all [modified records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-getModifiedRecords)
		 * and re-insert any records that were removed locally. Any phantom records will be removed.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		rejectChanges? (): void;
		/** 
		 * Relays selected events from the specified Observable as if the events were fired by `this`.
		 * 
		 * For example if you are extending Grid, you might decide to forward some events from store.
		 * So you can do this inside your initComponent:
		 * 
		 *    this.relayEvents(this.getStore(), ['load']);
		 * 
		 * The grid instance will then have an observable 'load' event which will be passed
		 * the parameters of the store's load event and any function fired with the grid's
		 * load event would have access to the grid using the this keyword (unless the event
		 * is handled by a controller's control/listen event listener in which case 'this'
		 * will be the controller rather than the grid).
		 * @method
		 * @public (method)
		 * @param   {object}          origin   The Observable whose events this object is to relay.
		 * @param   {string[]|object} events
		 * Array of event names to relay or an Object with key/value
		 * pairs translating to ActualEventName/NewEventName respectively. For example:
		 *     this.relayEvents(this, {add:'push', remove:'pop'});
		 * 
		 * Would now redispatch the add event of this as a push event and the remove event as a pop event.
		 * @param   {string}          [prefix]
		 * A common prefix to prepend to the event names. For example:
		 * 
		 *    this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Now the grid will forward 'load' and 'clear' events of store as 'storeload' and 'storeclear'.
		 * @returns {object}          
		 * A `Destroyable` object. An object which implements the `destroy` method which, when destroyed, removes all relayers. For example:
		 * 
		 *    this.storeRelayers = this.relayEvents(this.getStore(), ['load', 'clear'], 'store');
		 * 
		 * Can be undone by calling
		 * 
		 *    Ext.destroy(this.storeRelayers);
		 * 
		 * or
		 *     this.store.relayers.destroy();
		 */
		relayEvents? (origin: object, events: string[] | object, prefix?: string): object;
		/** 
		 * Reloads the store using the last options passed to the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method. You can use the reload method to reload the
		 * store using the parameters from the last load() call. For example:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload();
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution will pass the `userid` parameter in the request. The [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) execution
		 * will also send the same `userid` parameter in its request as it will reuse the `params` object from the last [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) call.
		 * 
		 * You can override a param by passing in the config object with the `params` object:
		 * 
		 *    store.load({
		 *        params : {
		 *            userid : 22216,
		 *            foo    : 'bar'
		 *        }
		 *    });
		 *    
		 *    //...
		 *    
		 *    store.reload({
		 *        params : {
		 *            userid : 1234
		 *        }
		 *    });
		 * 
		 * The initial [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) execution sends the `userid` and `foo` parameters but in the [reload](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-reload) it only sends
		 * the `userid` paramter because you are overriding the `params` config not just overriding the one param. To only change a single param
		 * but keep other params, you will have to get the last params from the [lastOptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#property-lastOptions) property:
		 * 
		 *    var lastOptions = store.lastOptions,
		 *        lastParams = Ext.clone(lastOptions.params); // make a copy of the last params so we don't affect future reload() calls
		 *    
		 *    lastParams.userid = 1234;
		 *    
		 *    store.reload({
		 *        params : lastParams
		 *    });
		 * 
		 * This will now send the `userid` parameter as `1234` and the `foo` param as `'bar'`.
		 * @method
		 * @public (method)
		 * @param   {object} [options]
		 * A config object which contains options which may override the options passed to the previous load call. See the
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) method for valid configs.
		 * @returns {void}             
		 */
		reload? (options?: object): void;
		/** 
		 * Removes the specified record(s) from the Store, firing the [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove)
		 * event for the removed records.
		 * 
		 * After all records have been removed a single `datachanged` is fired.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model|Ext.data.Model[]|number|number[]} records
		 * Model instance or
		 * array of instances to remove or an array of indices from which to remove records.
		 * @param   {object}                                          isMove  (private)
		 * @param   {object}                                          silent  (private)
		 * @returns {void}                                                    
		 */
		remove? (records: Ext.data.Model | Ext.data.Model[] | number | number[], isMove: object, silent: object): void;
		/** 
		 * Alias for [unAfter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unAfter).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeAfterListener? (): void;
		/** 
		 * Removes all items from the store.
		 * 
		 * Individual record [`remove`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events are not fired by this method.
		 * @method
		 * @public (method)
		 * @param   {boolean}          [silent]
		 * Pass `true` to prevent the [`clear`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-clear) event from being fired.
		 * 
		 * This method is affected by filtering.
		 * @returns {Ext.data.Model[]}          The removed records.
		 */
		removeAll? (silent?: boolean): Ext.data.Model[];
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-removeAll).
		 * Removes all records from the store. This method does a "fast remove",
		 * individual remove events are not called. The [clear](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-clear) event is
		 * fired upon completion.
		 * @method
		 * @public (method)
		 * @returns {Ext.data.Model[]|void}  
		 */
		removeAll? (): void;
		/** 
		 * Removes the model instance(s) at the given index
		 * @method
		 * @public (method)
		 * @param   {number} index   The record index
		 * @param   {number} [count] The number of records to delete
		 * @returns {void}           
		 */
		removeAt? (index: number, count?: number): void;
		/** 
		 * Alias for [unBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-unBefore).
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		removeBeforeListener? (): void;
		/** 
		 * Removes an individual Filter from the current [filter set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-filters) using the passed Filter/Filter id and
		 * by default, applies the updated filter set to the Store's unfiltered dataset.
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Filter} toRemove        The id of a Filter to remove from the filter set, or a Filter instance to remove.
		 * @param   {boolean}                [suppressEvent] If `true` the filter is cleared silently.
		 * @returns {void}                                   
		 */
		removeFilter? (toRemove: string | Ext.util.Filter, suppressEvent?: boolean): void;
		/** 
		 * Removes an event handler.
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		removeListener? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes listeners that were added by the [mon](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-mon) method.
		 * @method
		 * @public (method)
		 * @param   {Ext.util.Observable|Ext.dom.Element} item    The item from which to remove a listener/listeners.
		 * @param   {object|string}                       ename   The event name, or an object containing event name properties.
		 * @param   {Function}                            [fn]    If the `ename` parameter was an event name, this is the handler function.
		 * @param   {object}                              [scope]
		 * If the `ename` parameter was an event name, this is the scope (`this` reference)
		 * in which the handler function is executed.
		 * @returns {void}                                        
		 */
		removeManagedListener? (item: Ext.util.Observable | Ext.dom.Element, ename: object | string, fn?: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Resumes automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @param   {boolean} syncNow
		 * Pass `true` to synchronize now. Only synchronizes with the Proxy if the suspension
		 * count has gone to zero (We are not under a higher level of suspension)
		 * @returns {void}            
		 */
		resumeAutoSync? (syncNow: boolean): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		resumeEvent? (): void;
		/** 
		 * Resumes firing of the named event(s).
		 * 
		 * After calling this method to resume events, the events will fire when requested to fire.
		 * 
		 * **Note that if the [suspendEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvent) method is called multiple times for a certain event,
		 * this converse method will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to resume.
		 * @returns {void}                
		 */
		resumeEvent? (...eventName: string[]): void;
		/** 
		 * Resumes firing events (see [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents)).
		 * 
		 * If events were suspended using the `queueSuspended` parameter, then all events fired
		 * during event suspension will be sent to any listeners now.
		 * @method
		 * @public (method)
		 * @param   {boolean} [discardQueue]
		 * `true` to prevent any previously queued events from firing
		 * while we were suspended. See [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-suspendEvents).
		 * @returns {void}                   
		 */
		resumeEvents? (discardQueue?: boolean): void;
		/** 
		 * Saves all pending changes via the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy). Use [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) instead.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		save? (): void;
		/** 
		 * Sets the value of [asynchronousLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-asynchronousLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} asynchronousLoad The new value.
		 * @returns {void}                     
		 */
		setAsynchronousLoad? (asynchronousLoad: boolean): void;
		/** 
		 * Sets the value of [autoDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoDestroy).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoDestroy The new value.
		 * @returns {void}                
		 */
		setAutoDestroy? (autoDestroy: boolean): void;
		/** 
		 * Sets the value of [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean|object} autoLoad The new value.
		 * @returns {void}                    
		 */
		setAutoLoad? (autoLoad: boolean | object): void;
		/** 
		 * Sets the value of [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync).
		 * @method
		 * @public (method)
		 * @param   {boolean} autoSync The new value.
		 * @returns {void}             
		 */
		setAutoSync? (autoSync: boolean): void;
		/** 
		 * Sets the value of [batchUpdateMode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-batchUpdateMode).
		 * @method
		 * @public (method)
		 * @param   {string} batchUpdateMode The new value.
		 * @returns {void}                   
		 */
		setBatchUpdateMode? (batchUpdateMode: string): void;
		/** 
		 * Sets the value of [clearOnPageLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearOnPageLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearOnPageLoad The new value.
		 * @returns {void}                    
		 */
		setClearOnPageLoad? (clearOnPageLoad: boolean): void;
		/** 
		 * Sets the value of [clearRemovedOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-clearRemovedOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} clearRemovedOnLoad The new value.
		 * @returns {void}                       
		 */
		setClearRemovedOnLoad? (clearRemovedOnLoad: boolean): void;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                                                                        name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                                                                               [value] The value to set for the name parameter.
		 * @returns {Ext.data.XmlStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.XmlStore;
		setConfig? (name: string | object, value?: object): Ext.data.Store;
		setConfig? (name: string | object, value?: object): Ext.data.ProxyStore;
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore;
		setConfig? (name: string | object, value?: object): Ext.Base;
		/** 
		 * Loads an array of data directly into the Store.
		 * 
		 * setData() is ideal if your data's format is already in its appropriate format (e.g. it doesn't need to be
		 * processed by a reader). If your data's structure requires processing, use a
		 * [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) or [loadRawData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRawData).
		 * 
		 * Use [loadData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadData), [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add), or [insert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-insert) if records need to be
		 * appended to the current recordset.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model[]|object[]} data
		 * Array of data to load. Any non-model instances will be cast
		 * into model instances first.
		 * @returns {void}                           
		 */
		setData? (data: Ext.data.Model[] | object[]): void;
		/** 
		 * Sets the value of [extraKeys](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#cfg-extraKeys).
		 * @method
		 * @public (method)
		 * @param   {object} extraKeys The new value.
		 * @returns {void}             
		 */
		setExtraKeys? (extraKeys: object): void;
		/** 
		 * Sets the value of [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields).
		 * @method
		 * @public (method)
		 * @param   {object[]|string[]} fields The new value.
		 * @returns {void}                     
		 */
		setFields? (fields: object[] | string[]): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setFilters? (): void;
		/** 
		 * Sets the value of [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir).
		 * @method
		 * @public (method)
		 * @param   {string} groupDir The new value.
		 * @returns {void}            
		 */
		setGroupDir? (groupDir: string): void;
		/** 
		 * Sets the value of [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField).
		 * @method
		 * @public (method)
		 * @param   {string} groupField The new value.
		 * @returns {void}              
		 */
		setGroupField? (groupField: string): void;
		/** 
		 * Sets the value of [grouper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-grouper).
		 * @method
		 * @public (method)
		 * @param   {object|Ext.util.Grouper} grouper The new value.
		 * @returns {void}                            
		 */
		setGrouper? (grouper: object | Ext.util.Grouper): void;
		/** 
		 * An alias for [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).  In
		 * versions prior to 5.1, [listeners](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#cfg-listeners) had a generated setter which could
		 * be called to add listeners.  In 5.1 the listeners config is not processed
		 * using the config system and has no generated setter, so this method is
		 * provided for backward compatibility.  The preferred way of adding listeners
		 * is to use the [on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-on) method.
		 * @method
		 * @public (method)
		 * @param   {object} listeners The listeners
		 * @returns {void}             
		 */
		setListeners? (listeners: object): void;
		/** 
		 * Sets the value of [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-model).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.Model} model The new value.
		 * @returns {void}                        
		 */
		setModel? (model: string | Ext.data.Model): void;
		/** 
		 * Sets the value of [pageSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-pageSize).
		 * @method
		 * @public (method)
		 * @param   {number} pageSize The new value.
		 * @returns {void}            
		 */
		setPageSize? (pageSize: number): void;
		/** 
		 * Sets the value of [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
		 * @method
		 * @public (method)
		 * @param   {string|Ext.data.proxy.Proxy|object} proxy The new value.
		 * @returns {void}                                     
		 */
		setProxy? (proxy: string | Ext.data.proxy.Proxy | object): void;
		/** 
		 * Sets the value of [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteFilter).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteFilter The new value.
		 * @returns {void}                 
		 */
		setRemoteFilter? (remoteFilter: boolean): void;
		/** 
		 * Sets the value of [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort).
		 * @method
		 * @public (method)
		 * @param   {boolean} remoteSort The new value.
		 * @returns {void}               
		 */
		setRemoteSort? (remoteSort: boolean): void;
		/** 
		 * Sets the value of [session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-session).
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Session} session The new value.
		 * @returns {void}                     
		 */
		setSession? (session: Ext.data.Session): void;
		/** 
		 * Sets the value of [sortOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-sortOnLoad).
		 * @method
		 * @public (method)
		 * @param   {boolean} sortOnLoad The new value.
		 * @returns {void}               
		 */
		setSortOnLoad? (sortOnLoad: boolean): void;
		/** 
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		setSorters? (): void;
		/** 
		 * Sets the value of [statefulFilters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-statefulFilters).
		 * @method
		 * @public (method)
		 * @param   {boolean} statefulFilters The new value.
		 * @returns {void}                    
		 */
		setStatefulFilters? (statefulFilters: boolean): void;
		/** 
		 * Sets the value of [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId).
		 * @method
		 * @public (method)
		 * @param   {string} storeId The new value.
		 * @returns {void}           
		 */
		setStoreId? (storeId: string): void;
		/** 
		 * Sets the value of [trackRemoved](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-trackRemoved).
		 * @method
		 * @public (method)
		 * @param   {boolean} trackRemoved The new value.
		 * @returns {void}                 
		 */
		setTrackRemoved? (trackRemoved: boolean): void;
		/** 
		 * Sorts the data in the Store by one or more of its properties. Example usage:
		 * 
		 *    //sort by a single field
		 *    myStore.sort('myField', 'DESC');
		 *    
		 *    //sorting by multiple fields
		 *    myStore.sort([
		 *        {
		 *            property : 'age',
		 *            direction: 'ASC'
		 *        },
		 *        {
		 *            property : 'name',
		 *            direction: 'DESC'
		 *        }
		 *    ]);
		 * 
		 * Internally, Store converts the passed arguments into an array of [Ext.util.Sorter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html) instances, and delegates
		 * the actual sorting to its internal [Ext.util.MixedCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html).
		 * 
		 * When passing a single string argument to sort, Store maintains a ASC/DESC toggler per field, so this code:
		 * 
		 *    store.sort('myField');
		 *    store.sort('myField');
		 * 
		 * Is equivalent to this code, because Store handles the toggling automatically:
		 * 
		 *    store.sort('myField', 'ASC');
		 *    store.sort('myField', 'DESC');
		 * 
		 * @method
		 * @public (method)
		 * @param   {string|Ext.util.Sorter[]} [sorters]
		 * Either a string name of one of the fields in this Store's configured
		 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html), or an array of sorter configurations.
		 * @param   {string}                   [direction] The overall direction to sort the data by.
		 * @returns {Ext.util.Sorter[]}                    
		 */
		sort? (sorters?: string | Ext.util.Sorter[], direction?: string): Ext.util.Sorter[];
		/** 
		 * Sums the value of `field` for each [record](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) in store
		 * and returns the result.
		 * 
		 * When store is filtered, only sums items within the filter.
		 * @method
		 * @public (method)
		 * @param   {string}  field     A field in each record
		 * @param   {boolean} [grouped]
		 * True to perform the operation for each group
		 * in the store. The value returned will be an object literal with the key being the group
		 * name and the sum for that group being the value. The grouped parameter is only honored if
		 * the store has a groupField.
		 * @returns {number}            The sum
		 */
		sum? (field: string, grouped?: boolean): number;
		/** 
		 * Suspends automatically syncing the Store with its Proxy.  Only applicable if [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) is `true`
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendAutoSync? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		suspendEvent? (): void;
		/** 
		 * Suspends firing of the named event(s).
		 * 
		 * After calling this method to suspend events, the events will no longer fire when requested to fire.
		 * 
		 * **Note that if this is called multiple times for a certain event, the converse method
		 * [resumeEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvent) will have to be called the same number of times for it to resume firing.**
		 * @method
		 * @public (method)
		 * @param   {...string} eventName Multiple event names to suspend.
		 * @returns {void}                
		 */
		suspendEvent? (...eventName: string[]): void;
		/** 
		 * Suspends the firing of all events. (see [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents))
		 * @method
		 * @public (method)
		 * @param   {boolean} queueSuspended
		 * `true` to queue up suspended events to be fired
		 * after the [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-resumeEvents) call instead of discarding all suspended events.
		 * @returns {void}                   
		 */
		suspendEvents? (queueSuspended: boolean): void;
		/** 
		 * Shorthand for [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener).
		 * @method
		 * @public (method)
		 * @param   {string}   eventName The type of event the handler was associated with.
		 * @param   {Function} fn
		 * The handler to remove. **This must be a reference to the function
		 * passed into the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) call.**
		 * @param   {object}   [scope]
		 * The scope originally specified for the handler. It
		 * must be the same as the scope argument specified in the original call to
		 * [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) or the listener will not be removed.
		 * 
		 * **Convenience Syntax**
		 * 
		 * You can use the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener)
		 * `destroyable: true` config option in place of calling un().  For example:
		 * 
		 *    var listeners = cmp.on({
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide,
		 *        destroyable: true
		 *    });
		 *    
		 *    // Remove listeners
		 *    listeners.destroy();
		 *    // or
		 *    cmp.un(
		 *        scope: cmp,
		 *        afterrender: cmp.onAfterrender,
		 *        beforehide: cmp.onBeforeHide
		 *    );
		 * 
		 * **Exception - DOM event handlers using the element config option**
		 * 
		 * You must go directly through the element to detach an event handler attached using
		 * the [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) _element_ option.
		 * 
		 *    panel.on({
		 *        element: 'body',
		 *        click: 'onBodyCLick'
		 *    });
		 *    
		 *    panel.body.un({
		 *        click: 'onBodyCLick'
		 *    });
		 * 
		 * @returns {void}               
		 */
		un? (eventName: string, fn: ExtGlobalFunction, scope?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'after'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unAfter? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Removes a before-event handler.
		 * 
		 * Same as [removeListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html#method-removeListener) with `order` set to `'before'`.
		 * @method
		 * @public (method)
		 * @param   {string|string[]|object} eventName The name of the event the handler was associated with.
		 * @param   {Function|string}        fn        The handler to remove.
		 * @param   {object}                 [scope]   The scope originally specified for `fn`.
		 * @param   {object}                 [options] Extra options object.
		 * @returns {void}                             
		 */
		unBefore? (eventName: string | string[] | object, fn: ExtGlobalFunction | string, scope?: object, options?: object): void;
		/** 
		 * Inherit docs
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		contains? (record: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.AbstractStore.contains](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-contains).
		 * Checks if a record is in the current active data set.
		 * @method
		 * @public (method)
		 * @param   {Ext.data.Model} record The record
		 * @returns {void|boolean}          `true` if the record is in the current active data set.
		 */
		contains? (record: Ext.data.Model): boolean;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		doDestroy? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                                                                               config
		 * @returns {Ext.data.XmlStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        this
		 */
		initConfig? (config: object): Ext.data.XmlStore;
		initConfig? (config: object): Ext.data.Store;
		initConfig? (config: object): Ext.data.ProxyStore;
		initConfig? (config: object): Ext.data.AbstractStore;
		initConfig? (config: object): Ext.Base;
		/** 
		 * Called internally when a Proxy has completed a load request
		 * @method
		 * @protected (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyLoad? (operation: object): void;
		/** 
		 * Gets the default scope for firing late bound events (string names with
		 * no scope attached) at runtime.
		 * @method
		 * @protected (method)
		 * @param   {object} [defaultScope] The default scope to return if none is found.
		 * @returns {object}                The default event scope
		 */
		resolveListenerScope? (defaultScope?: object): object;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.XmlStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 */
		statics? (): Ext.data.XmlStore.Statics;
		statics? (): Ext.data.Store.Statics;
		statics? (): Ext.data.ProxyStore.Statics;
		statics? (): Ext.data.AbstractStore.Statics;
		statics? (): Ext.Base.Statics;
		/** 
		 * Adds declarative listeners as nested arrays of listener objects.
		 * @method
		 * @private (method)
		 * @param   {any[]}   listeners
		 * @returns {boolean}           `true` if any listeners were added
		 */
		_addDeclaredListeners? (listeners: any[]): boolean;
		/** 
		 * This method applies a versioned, deprecation declaration to this class. This
		 * is typically called by the `deprecated` config.
		 * @method
		 * @private (method)
		 * @param   {object} deprecations
		 * @returns {void}                
		 */
		addDeprecations? (deprecations: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorter
		 * @returns {void}          
		 */
		addFieldTransform? (sorter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		addObserver? (observer: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @param   {object} type
		 * @returns {void}                      
		 */
		afterChange? (record: object, modifiedFieldNames: object, type: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterCommit? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterDrop? (record: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @param   {object} modifiedFieldNames
		 * @returns {void}                      
		 */
		afterEdit? (record: object, modifiedFieldNames: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} record
		 * @returns {void}          
		 */
		afterErase? (record: object): void;
		/** 
		 * A model instance should call this method on the Store it has been [joined](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-join) to..
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} record The model instance that was edited
		 * @returns {void}                  
		 */
		afterReject? (record: Ext.data.Model): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} asynchronousLoad
		 * @returns {void}                    
		 */
		applyAsynchronousLoad? (asynchronousLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} extraKeys
		 * @returns {void}             
		 */
		applyExtraKeys? (extraKeys: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fields
		 * @returns {void}          
		 */
		applyFields? (fields: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} filters
		 * @param   {object} filtersCollection
		 * @returns {void}                     
		 */
		applyFilters? (filters: object, filtersCollection: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} grouper
		 * @returns {void}           
		 */
		applyGrouper? (grouper: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} model
		 * @returns {void}         
		 */
		applyModel? (model: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @returns {void}         
		 */
		applyProxy? (proxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} sorters
		 * @param   {object} sortersCollection
		 * @returns {void}                     
		 */
		applySorters? (sorters: object, sortersCollection: object): void;
		/** 
		 * Restores state to the passed state
		 * @method
		 * @private (method)
		 * @param   {object} state
		 * @returns {void}         
		 */
		applyState? (state: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} action
		 * @param   {object} args
		 * @returns {void}          
		 */
		callObservers? (action: object, args: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} o
		 * @param   {object} fn
		 * @param   {object} scope
		 * @returns {void}         
		 */
		captureArgs? (o: object, fn: object, scope: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} isLoad
		 * @returns {void}          
		 */
		clearData? (isLoad: object): void;
		/** 
		 * @compatible DO NOT USE THIS METHOD VARIANT. It's only compatibility for class [Ext.data.ProxyStore.clearData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-clearData).
		 * to be implemented by subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		clearData? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		constructDataCollection? (): void;
		/** 
		 * saves any phantom records
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @param   {object} options
		 * @returns {void}           
		 */
		create? (data: object, options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createFiltersCollection? (): void;
		/** 
		 * Converts a literal to a model, if it's not a model already
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model|object} record The record to create
		 * @returns {Ext.data.Model}               
		 */
		createModel? (record: Ext.data.Model | object): Ext.data.Model;
		/** 
		 * Creates an event handling function which re-fires the event from this object as the passed event name.
		 * @method
		 * @private (method)
		 * @param   {string}   newName    The name under which to re-fire the passed parameters.
		 * @param   {any[]}    [beginEnd] The caller can specify on which indices to slice.
		 * @returns {Function}            
		 */
		createRelayer? (newName: string, beginEnd?: any[]): ExtGlobalFunction;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		createSortersCollection? (): void;
		/** 
		 * Continue to fire event.
		 * @method
		 * @private (method)
		 * @param   {string}  eventName
		 * @param   {any[]}   args
		 * @param   {boolean} bubbles
		 * @returns {void}              
		 */
		doFireEvent? (eventName: string, args: any[], bubbles: boolean): void;
		/** 
		 * tells the attached proxy to destroy the given records
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		erase? (options: object): void;
		/** 
		 * Similar to a load, however no records are added to the store. This is useful
		 * in allowing the developer to decide what to do with the new records.
		 * @method
		 * @private (method)
		 * @param   {object} [options] See [load options](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load).
		 * @returns {void}             
		 */
		fetch? (options?: object): void;
		/** 
		 * private
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @returns {void}      
		 */
		filterDataSource? (fn: object): void;
		/** 
		 * Filter function for new records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNew? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterNewOnly? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterRejects? (item: object): void;
		/** 
		 * Filter function for updated records.
		 * @method
		 * @private (method)
		 * @param   {object} item
		 * @returns {void}        
		 */
		filterUpdated? (item: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		fireGroupChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		forceLocalSort? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} fn
		 * @param   {object} scope
		 * @param   {object} records
		 * @param   {object} field
		 * @returns {void}           
		 */
		getAggregate? (fn: object, scope: object, records: object, field: object): void;
		/** 
		 * Returns the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.Model}  
		 */
		getAssociatedEntity? (): Ext.data.Model;
		/** 
		 * Returns the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @returns {boolean}  
		 */
		getAutoSort? (): boolean;
		/** 
		 * Returns an object which is passed in as the listeners argument to proxy.batch inside this.sync.
		 * This is broken out into a separate function to allow for customisation of the listeners
		 * @method
		 * @private (method)
		 * @returns {object}  The listeners object
		 */
		getBatchListeners? (): object;
		/** 
		 * Gets the bubbling parent for an Observable
		 * @method
		 * @private (method)
		 * @returns {Ext.util.Observable}  The bubble parent. null is returned if no bubble target exists
		 */
		getBubbleParent? (): Ext.util.Observable;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getCurrentConfig? (): void;
		/** 
		 * Returns the complete unfiltered collection.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getDataSource? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getGroupField? (): void;
		/** 
		 * Returns the array of records which have been removed since the last time this store was synced.
		 * 
		 * This is used internally, when purging removed records after a successful sync.
		 * This is overridden by TreeStore because TreeStore accumulates deleted records on removal
		 * of child nodes from their parent, _not_ on removal of records from its collection. The collection
		 * has records added on expand, and removed on collapse.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRawRemovedRecords? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getRejectRecords? (): void;
		/** 
		 * Returns the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @returns {Ext.data.schema.Role}  
		 */
		getRole? (): Ext.data.schema.Role;
		/** 
		 * Returns the grouping, sorting and filtered state of this Store.
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		getState? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} config
		 * @returns {void}          
		 */
		hasConfig? (config: object): void;
		/** 
		 * Returns true if the store has a pending load task.
		 * @method
		 * @private (method)
		 * @returns {boolean}  `true` if the store has a pending load task.
		 */
		hasPendingLoad? (): boolean;
		/** 
		 * Checks whether records are being moved within the store. This can be used in conjunction with the
		 * [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-add) and [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#event-remove) events to determine whether the records are being removed/added
		 * or just having the position changed.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]|Ext.data.Model} [records] The record(s).
		 * @returns {number}                          
		 * The number of records being moved. `0` if no records are moving. If records are passed
		 * the number will refer to how many of the passed records are moving.
		 */
		isMoving? (records?: Ext.data.Model[] | Ext.data.Model): number;
		/** 
		 * Adds a "destroyable" object to an internal list of objects that will be destroyed
		 * when this instance is destroyed (via [`destroy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-destroy)).
		 * @method
		 * @private (method)
		 * @param   {string} name
		 * @param   {object} value
		 * @returns {object}       The `value` passed.
		 */
		link? (name: string, value: object): object;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} data
		 * @returns {void}        
		 */
		loadInlineData? (data: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		notifySorterChange? (): void;
		/** 
		 * Attached as the 'complete' event listener to a proxy's Batch object. Iterates over the batch operations
		 * and updates the Store's internal data MixedCollection.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchComplete? (batch: object, operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchException? (batch: object, operation: object): void;
		/** 
		 * Attached as the 'operationcomplete' event listener to a proxy's Batch object. By default just calls through
		 * to onProxyWrite.
		 * @method
		 * @private (method)
		 * @param   {object} batch
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onBatchOperationComplete? (batch: object, operation: object): void;
		/** 
		 * This is attached to the data Collection's beforesort event only if not remoteSort
		 * If remoteSort, the event is fired before the reload call in [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#event-load).
		 * @method
		 * @private (method)
		 * @param   {object} store
		 * @param   {object} sorters
		 * @returns {void}           
		 */
		onBeforeCollectionSort? (store: object, sorters: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} cls
		 * @param   {object} data
		 * @param   {object} hooks
		 * @returns {void}         
		 */
		onClassExtended? (cls: object, data: object, hooks: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} targetClass
		 * @returns {void}               
		 */
		onClassMixedIn? (targetClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} records
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionAddItems? (collection: object, records: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionBeforeItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionBeginUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionEndUpdate? (): void;
		/** 
		 * When the collection informs us that it has filtered, this LocalStore must react.
		 * AbstractStore#onFilterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilter? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} items
		 * @returns {void}              
		 */
		onCollectionFilterAdd? (collection: object, items: object): void;
		/** 
		 * If our source collection informs us that a filtered out item has changed, we must still fire the events...
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionFilteredItemChange? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionItemChange? (collection: object, info: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} collection
		 * @param   {object} info
		 * @returns {void}              
		 */
		onCollectionRemove? (collection: object, info: object): void;
		/** 
		 * When the collection informs us that it has sorted, this LocalStore must react.
		 * AbstractStore#onSorterEndUpdate does the correct thing (fires a refresh) if remote sorting is false
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCollectionSort? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onCreateRecords? (): void;
		/** 
		 * Removes any records when a write is returned from the server.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]}             records   The array of removed records
		 * @param   {Ext.data.operation.Operation} operation The operation that just completed
		 * @param   {boolean}                      success   True if the operation was successful
		 * @returns {void}                                   
		 */
		onDestroyRecords? (records: Ext.data.Model[], operation: Ext.data.operation.Operation, success: boolean): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onErase? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onFilterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} rec
		 * @param   {object} oldId
		 * @param   {object} newId
		 * @returns {void}         
		 */
		onIdChanged? (rec: object, oldId: object, newId: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} meta
		 * @returns {void}         
		 */
		onMetaChange? (proxy: object, meta: object): void;
		/** 
		 * Callback for any write Operation over the Proxy. Updates the Store's MixedCollection to reflect
		 * the updates provided by the Proxy
		 * @method
		 * @private (method)
		 * @param   {object} operation
		 * @returns {void}             
		 */
		onProxyWrite? (operation: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onSorterEndUpdate? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdate? (): void;
		/** 
		 * may be implemented by store subclasses
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		onUpdateRecords? (): void;
		/** 
		 * Prepares a given class for observable instances. This method is called when a
		 * class derives from this class or uses this class as a mixin.
		 * @method
		 * @private (method)
		 * @param   {Function}            T     The class constructor to prepare.
		 * @param   {Ext.util.Observable} mixin The mixin if being used as a mixin.
		 * @param   {object}              data  The raw class creation data if this is an extend.
		 * @returns {void}                      
		 */
		prepareClass? (T: ExtGlobalFunction, mixin: Ext.util.Observable, data: object): void;
		/** 
		 * Query all the cached records in this Store by field.
		 * 
		 * This method is not affected by filtering, it will always search _all_ records in the store
		 * regardless of filtering.
		 * @method
		 * @private (method)
		 * @param   {string}           field The field from each record to use.
		 * @param   {object}           value The value to match.
		 * @returns {Ext.data.Model[]}       The matched records.
		 */
		queryRecords? (field: string, value: object): Ext.data.Model[];
		/** 
		 * Determines if the passed range is available in the page cache.
		 * @method
		 * @private (method)
		 * @param   {number} start The start index
		 * @param   {number} end   The end index in the range
		 * @returns {void}         
		 */
		rangeCached? (start: number, end: number): void;
		/** 
		 * @method
		 * @private (method)
		 * @returns {void}  
		 */
		read? (): void;
		/** 
		 * Remove a single managed listener item
		 * @method
		 * @private (method)
		 * @param   {boolean} isClear         True if this is being called during a clear
		 * @param   {object}  managedListener
		 * The managed listener item
		 * See removeManagedListener for other args
		 * @returns {void}                    
		 */
		removeManagedListenerItem? (isClear: boolean, managedListener: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} observer
		 * @returns {void}            
		 */
		removeObserver? (observer: object): void;
		/** 
		 * Sets the value of [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model} associatedEntity The new value.
		 * @returns {void}                            
		 */
		setAssociatedEntity? (associatedEntity: Ext.data.Model): void;
		/** 
		 * Sets the value of [autoSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-autoSort).
		 * @method
		 * @private (method)
		 * @param   {boolean} autoSort The new value.
		 * @returns {void}             
		 */
		setAutoSort? (autoSort: boolean): void;
		/** 
		 * Make a set of records be current in the store. This means that unneeded records
		 * will be removed and new records will be added.
		 * @method
		 * @private (method)
		 * @param   {Ext.data.Model[]} records The records to be current in the store.
		 * @returns {void}                     
		 */
		setRecords? (records: Ext.data.Model[]): void;
		/** 
		 * Sets the value of [role](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-role).
		 * @method
		 * @private (method)
		 * @param   {Ext.data.schema.Role} role The new value.
		 * @returns {void}                      
		 */
		setRole? (role: Ext.data.schema.Role): void;
		/** 
		 * This method is basically the same as the JavaScript Array splice method.
		 * 
		 * Negative indexes are interpreted starting at the end of the collection. That is,
		 * a value of -1 indicates the last item, or equivalent to `length - 1`.
		 * @method
		 * @private (method)
		 * @param   {number}          index    The index at which to add or remove items.
		 * @param   {number|object[]} toRemove
		 * The number of items to remove or an array of the
		 * items to remove.
		 * @param   {object[]}        [toAdd]  The items to insert at the given `index`.
		 * @returns {void}                     
		 */
		splice? (index: number, toRemove: number | object[], toAdd?: object[]): void;
		/** 
		 * Destroys a given set of [`linked`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-link) objects. This is only needed if
		 * the linked object is being destroyed before this instance.
		 * @method
		 * @private (method)
		 * @chainable
		 * @param   {string[]}                                                                             names The names of the linked objects to destroy.
		 * @returns {Ext.data.XmlStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       this
		 */
		unlink? (names: string[]): Ext.data.XmlStore;
		unlink? (names: string[]): Ext.data.Store;
		unlink? (names: string[]): Ext.data.ProxyStore;
		unlink? (names: string[]): Ext.data.AbstractStore;
		unlink? (names: string[]): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} options
		 * @returns {void}           
		 */
		update? (options: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoLoad
		 * @returns {void}            
		 */
		updateAutoLoad? (autoLoad: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} autoSort
		 * @returns {void}            
		 */
		updateAutoSort? (autoSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} field
		 * @returns {void}         
		 */
		updateGroupField? (field: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} proxy
		 * @param   {object} oldProxy
		 * @returns {void}            
		 */
		updateProxy? (proxy: object, oldProxy: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteFilter
		 * @returns {void}                
		 */
		updateRemoteFilter? (remoteFilter: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} remoteSort
		 * @returns {void}              
		 */
		updateRemoteSort? (remoteSort: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @param   {object} track
		 * @returns {void}         
		 */
		updateTrackRemoved? (track: object): void;
	}
}
declare namespace Ext {
	class data {
		/** 
		 * [Ext.data.JsonP](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html)
		 * This class is used to create JSONP requests. JSONP is a mechanism that allows for making
		 * requests for data cross domain. JSONP is basically a `&lt;script&gt;` node with the source of the url executing
		 * a function that was created by [Ext.data.JsonP](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html). Once the resource has loaded, the `&lt;script&gt;` node will be destroyed.
		 * 
		 * If you have a request such as:
		 * 
		 *    Ext.data.JsonP.request({
		 *        url : 'foo.php'
		 *    });
		 * 
		 * [Ext.data.JsonP](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html) will create a `&lt;script&gt;` node in the `&lt;head&gt;` with the `src` attribute pointing to
		 * `foo.php?callback=Ext.data.JsonP.callback1`. The `foo.php` script will have to detect the `callback` URL parameter
		 * and return valid JavaScript:
		 * 
		 *    Ext.data.JsonP.callback1({"foo":"bar"});
		 * 
		 * A simple PHP example would look like:
		 * 
		 *    &lt;?php
		 *    
		 *    $data = array('foo' =&gt; 'bar');
		 *    
		 *    if (!empty($_REQUEST['callback'])) {
		 *        header('Content-Type: application/javascript');
		 *        echo $_REQUEST['callback'] . '(';
		 *    }
		 *    
		 *    echo json_encode($data);
		 *    
		 *    if (!empty($_REQUEST['callback']) {
		 *        echo ');';
		 *    }
		 *    
		 *    ?&gt;
		 * 
		 * More information is available [here](http://en.wikipedia.org/wiki/JSONP). You can also use [JSONPLint](http://www.jsonplint.com) to test your JSONP.
		 * @singleton (instance)
		 */
		static readonly JsonP?: Ext.data.JsonP;
		/** 
		 * [Ext.data.ModelManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ModelManager.html)
		 * This class has been deprecated. Use [`Ext.data.schema.Schema`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Schema.html) instead.
		 * @singleton (instance)
		 */
		static readonly ModelManager?: Ext.data.ModelManager;
		/** 
		 * [Ext.data.SortTypes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.SortTypes.html)
		 * This class defines a series of static methods that are used on a
		 * [Ext.data.Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) for performing sorting. The methods cast the
		 * underlying values into a data type that is appropriate for sorting on
		 * that particular field.  If a [Ext.data.Field.type](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#property-type) is specified,
		 * the sortType will be set to a sane default if the sortType is not
		 * explicitly defined on the field. The sortType will make any necessary
		 * modifications to the value and return it.
		 * 
		 * - **`asText`** - Removes any tags and converts the value to a string
		 * - **`asUCText`** - Removes any tags and converts the value to an uppercase string
		 * - **`asUCText`** - Converts the value to an uppercase string
		 * - **`asDate`** - Converts the value into Unix epoch time
		 * - **`asFloat`** - Converts the value to a floating point number
		 * - **`asInt`** - Converts the value to an integer number
		 * 
		 * It is also possible to create a custom sortType that can be used throughout
		 * an application.
		 * 
		 *     Ext.apply(Ext.data.SortTypes, {
		 *         asPerson: function(person){
		 *             // expects an object with a first and last name property
		 *             return person.lastName.toUpperCase() + person.firstName.toLowerCase();
		 *         }
		 *     });
		 *    
		 *     Ext.define('Employee', {
		 *         extend: 'Ext.data.Model',
		 *         fields: [{
		 *             name: 'person',
		 *             sortType: 'asPerson'
		 *         }, {
		 *             name: 'salary',
		 *             type: 'float' // sortType set to asFloat
		 *         }]
		 *     });
		 * 
		 * @singleton (instance)
		 */
		static readonly SortTypes?: Ext.data.SortTypes;
		/** 
		 * [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html)
		 * Contains a collection of all stores that are created that have an identifier. An identifier can be assigned by
		 * setting the [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId) property. When a store is in the StoreManager, it can be
		 * referred to via it's identifier:
		 * 
		 *    Ext.create('Ext.data.Store', {
		 *        model: 'SomeModel',
		 *        storeId: 'myStore'
		 *    });
		 *    
		 *    var store = Ext.data.StoreManager.lookup('myStore');
		 * 
		 * Also note that the [lookup](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html#method-lookup) method is aliased to [Ext.getStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-getStore) for convenience.
		 * 
		 * If a store is registered with the StoreManager, you can also refer to the store by it's identifier when registering
		 * it with any Component that consumes data from a store:
		 * 
		 *    Ext.create('Ext.data.Store', {
		 *        model: 'SomeModel',
		 *        storeId: 'myStore'
		 *    });
		 *    
		 *    Ext.create('Ext.view.View', {
		 *        store: 'myStore',
		 *        // other configuration here
		 *    });
		 * 
		 * @singleton (instance)
		 */
		static readonly StoreManager?: Ext.data.StoreManager;
		/** 
		 * [Ext.data.Types](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Types.html)
		 * @singleton (instance)
		 * @deprecated
		 */
		static readonly Types?: Ext.data.Types;
	}
}
declare namespace Ext.data {
	class Errors extends Ext.data.ErrorCollection {}
	class Record extends Ext.data.Model {}
	class SimpleStore extends Ext.data.ArrayStore {}
	interface StoreMgr extends Ext.data.StoreManager {}
}
declare namespace Ext {
	interface ModelMgr extends Ext.data.ModelManager {}
	interface StoreManager extends Ext.data.StoreManager {}
	interface StoreMgr extends Ext.data.StoreManager {}
}
declare namespace Ext.data.AbstractStore {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.AbstractStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html)
	 * AbstractStore is a superclass of [Ext.data.ProxyStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html) and [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html). It's never used directly,
	 * but offers a set of methods used by both of those subclasses.
	 * 
	 * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
	 * you're probably looking for is [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
	 */
	interface Def extends Ext.data.AbstractStore {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.AbstractStore.Cfg}
		 */
		config?: Ext.data.AbstractStore.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.AbstractStore.Statics}
		 */
		statics?: (() => Ext.data.AbstractStore.Statics | Ext.Base.Statics) | Ext.data.AbstractStore.Statics | any;
	}
}
declare namespace Ext.data.ArrayStore {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.ArrayStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from Array data easier. An ArrayStore will be
	 * automatically configured with a [Ext.data.reader.Array](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Array.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = Ext.create('Ext.data.ArrayStore', {
	 *        // store configs
	 *        storeId: 'myStore',
	 *        // reader configs
	 *        fields: [
	 *           'company',
	 *           {name: 'price', type: 'float'},
	 *           {name: 'change', type: 'float'},
	 *           {name: 'pctChange', type: 'float'},
	 *           {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
	 *        ]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    var myData = [
	 *        ['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
	 *        ['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
	 *        ['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
	 *        ['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
	 *        ['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
	 *    ];
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#cfg-data) config option.
	 */
	interface Def extends Ext.data.ArrayStore {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.ArrayStore.Cfg}
		 */
		config?: Ext.data.ArrayStore.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.ArrayStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.ArrayStore.Statics}
		 */
		statics?: (() => Ext.data.ArrayStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics) | Ext.data.ArrayStore.Statics | any;
	}
}
declare namespace Ext.data.Batch {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html)
	 * Provides a mechanism to run one or more [operations](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * in a given order. Fires the `operationcomplete` event after the completion of each
	 * Operation, and the `complete` event when all Operations have been successfully executed.
	 * Fires an `exception` event if any of the Operations encounter an exception.
	 * 
	 * Usually these are only used internally by [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) classes.
	 */
	interface Def extends Ext.data.Batch {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.Batch.Cfg}
		 */
		config?: Ext.data.Batch.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.Batch.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.Batch.Statics}
		 */
		statics?: (() => Ext.data.Batch.Statics | Ext.Base.Statics) | Ext.data.Batch.Statics | any;
	}
}
declare namespace Ext.data.BufferedStore {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html)
	 * A BufferedStore maintains a sparsely populated map of pages corresponding to an extremely large server-side dataset.
	 * 
	 * Use a BufferedStore when the dataset size is so large that the database and network latency, and client memory requirements
	 * preclude caching the entire dataset in a regular [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
	 * 
	 * When using a BufferedStore _not all of the dataset is present in the client_. Only pages which have been
	 * requested by the UI (usually a GridPanel) and surrounding pages will be present. Retention
	 * of viewed pages in the BufferedStore after they have been scrolled out of view is configurable. See [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone),
	 * [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone) and [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount).
	 * 
	 * To use a BufferedStore, initiate the loading process by loading the first page. The number of rows rendered are
	 * determined automatically, and the range of pages needed to keep the cache primed for scrolling is
	 * requested and cached.
	 * Example:
	 * 
	 *    myBufferedStore.loadPage(1); // Load page 1
	 * 
	 * A BufferedRenderer is instantiated which will monitor the scrolling in the grid, and
	 * refresh the view's rows from the page cache as needed. It will also pull new data into the page
	 * cache when scrolling of the view draws upon data near either end of the prefetched data.
	 * 
	 * The margins which trigger view refreshing from the prefetched data are Ext.grid.plugin.BufferedRenderer.numFromEdge,
	 * Ext.grid.plugin.BufferedRenderer.leadingBufferZone and Ext.grid.plugin.BufferedRenderer.trailingBufferZone.
	 * 
	 * The margins which trigger loading more data into the page cache are, [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone) and
	 * [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone).
	 * 
	 * By default, only 5 pages of data (in addition to the pages which over the visible region) are cached in the page cache,
	 * with old pages being evicted from the cache as the view moves down through the dataset. This is controlled by the
	 * [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount) setting.
	 * 
	 * Setting this value to zero means that no pages are _ever_ scrolled out of the page cache, and
	 * that eventually the whole dataset may become present in the page cache. This is sometimes desirable
	 * as long as datasets do not reach astronomical proportions.
	 * 
	 * Selection state may be maintained across page boundaries by configuring the SelectionModel not to discard
	 * records from its collection when those Records cycle out of the Store's primary collection. This is done
	 * by configuring the SelectionModel like this:
	 * 
	 *    selModel: {
	 *        pruneRemoved: false
	 *    }
	 * 
	 */
	interface Def extends Ext.data.BufferedStore {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.BufferedStore.Cfg}
		 */
		config?: Ext.data.BufferedStore.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.BufferedStore.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.BufferedStore.Statics}
		 */
		statics?: (() => Ext.data.BufferedStore.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics) | Ext.data.BufferedStore.Statics | any;
	}
}
declare namespace Ext.data.Connection {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.Connection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html)
	 * The Connection class encapsulates a connection to the page's originating domain, allowing requests to be made either
	 * to a configured URL, or to a URL specified at request time.
	 * 
	 * Requests made by this class are asynchronous, and will return immediately. No data from the server will be available
	 * to the statement immediately following the [request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-request) call. To process returned data, use a success callback
	 * in the request options object, or an [event listener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#event-requestcomplete).
	 * 
	 * # File Uploads
	 * 
	 * File uploads are not performed using normal "Ajax" techniques, that is they are not performed using XMLHttpRequests.
	 * Instead the form is submitted in the standard manner with the DOM &lt;form&gt; element temporarily modified to have its
	 * target set to refer to a dynamically generated, hidden &lt;iframe&gt; which is inserted into the document but removed
	 * after the return data has been gathered.
	 * 
	 * The server response is parsed by the browser to create the document for the IFRAME. If the server is using JSON to
	 * send the return object, then the Content-Type header must be set to "text/html" in order to tell the browser to
	 * insert the text unchanged into the document body.
	 * 
	 * Characters which are significant to an HTML parser must be sent as HTML entities, so encode `&lt;` as `&amp;lt;`, `&amp;` as
	 * `&amp;amp;` etc.
	 * 
	 * The response text is retrieved from the document, and a fake XMLHttpRequest object is created containing a
	 * responseText property in order to conform to the requirements of event handlers and callbacks.
	 * 
	 * Be aware that file upload packets are sent with the content type multipart/form and some server technologies
	 * (notably JEE) may require some custom processing in order to retrieve parameter names and parameter values from the
	 * packet content.
	 * 
	 * Also note that it's not possible to check the response code of the hidden iframe, so the success handler will ALWAYS fire.
	 * 
	 * # Binary Posts
	 * 
	 * The class supports posting binary data to the server by using native browser capabilities, or a flash polyfill plugin in browsers that do not support native binary posting (e.g. Internet Explorer version 9 or less). A number of limitations exist when the polyfill is used:
	 * 
	 * - Only asynchronous connections are supported.
	 * - Only the POST method can be used.
	 * - The return data can only be binary for now. Set the [binary](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-binary) parameter to <tt>true</tt>.
	 * - Only the 0, 1 and 4 (complete) readyState values will be reported to listeners.
	 * - The flash object will be injected at the bottom of the document and should be invisible.
	 * - Important: See note about packaing the flash plugin with the app in the documenetation of [BinaryXhr](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.flash.BinaryXhr.html).
	 */
	interface Def extends Ext.data.Connection {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.Connection.Cfg}
		 */
		config?: Ext.data.Connection.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.Connection.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.Connection.Statics}
		 */
		statics?: (() => Ext.data.Connection.Statics | Ext.Base.Statics) | Ext.data.Connection.Statics | any;
	}
}
declare namespace Ext.data.DirectStore {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.DirectStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html)
	 * Small helper class to create an [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) configured with an [Ext.data.proxy.Direct](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html)
	 * and [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) to make interacting with an [Ext.direct.Manager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.direct.Manager.html) server-side
	 * [Provider](https://docs.sencha.com/extjs/6.2.0/modern/Ext.direct.Provider.html) easier. To create a different proxy/reader combination create a basic
	 * [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) configured as needed.
	 * 
	 * **Note:** Although they are not listed, this class inherits all of the config options of:
	 * 
	 * - **[Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)**
	 * - **[JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html)**
	 *   <ul>
	 *   <li>**[rootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html#cfg-rootProperty)**
	 * - **[totalProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html#cfg-totalProperty)**
	 * 
	 * </li>
	 * <li>
	 * 
	 * **[DirectProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html)**
	 * 
	 * - **[directFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-directFn)**
	 * - **[paramOrder](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-paramOrder)**
	 * - **[paramsAsHash](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-paramsAsHash)**
	 * 
	 * </li>
	 * </ul>
	 */
	interface Def extends Ext.data.DirectStore {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.DirectStore.Cfg}
		 */
		config?: Ext.data.DirectStore.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.DirectStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.DirectStore.Statics}
		 */
		statics?: (() => Ext.data.DirectStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics) | Ext.data.DirectStore.Statics | any;
	}
}
declare namespace Ext.data.Error {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.Error](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Error.html)
	 * This class hols the results of a validator for an [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html). These objects are
	 * placed in an [`Ext.data.ErrorCollection`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html) and returned by [`Ext.data.Model.validate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate).
	 * 
	 * Usually this class does not need to be instantiated directly - instances are instead created
	 * automatically when [validate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate) on a model instance.
	 */
	interface Def extends Ext.data.Error {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.Error.Cfg}
		 */
		config?: Ext.data.Error.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.Error.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.Error.Statics}
		 */
		statics?: (() => Ext.data.Error.Statics | Ext.Base.Statics) | Ext.data.Error.Statics | any;
	}
}
declare namespace Ext.data.ErrorCollection {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.ErrorCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html)
	 * Wraps a collection of validation error responses and provides convenient functions for
	 * accessing and errors for specific fields.
	 * 
	 * Usually this class does not need to be instantiated directly - instances are instead
	 * created automatically when [validate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate) on a model instance:
	 * 
	 *     // Validate some existing model instance - in this case it returned 2 failures
	 *     // messages
	 *    
	 *     var errors = myModel.validate();
	 *     errors.isValid(); //false
	 *    
	 *     errors.length; //2
	 *     errors.getByField('name');  // [{field: 'name',  message: 'must be present'}]
	 *     errors.getByField('title'); // [{field: 'title', message: 'is too short'}]
	 * 
	 */
	interface Def extends Ext.data.ErrorCollection {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.ErrorCollection.Cfg}
		 */
		config?: Ext.data.ErrorCollection.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.ErrorCollection.Statics|Ext.util.MixedCollection.Statics|Ext.util.AbstractMixedCollection.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.ErrorCollection.Statics}
		 */
		statics?: (() => Ext.data.ErrorCollection.Statics | Ext.util.MixedCollection.Statics | Ext.util.AbstractMixedCollection.Statics | Ext.Base.Statics) | Ext.data.ErrorCollection.Statics | any;
	}
}
declare namespace Ext.data.ChainedStore {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html)
	 * A chained store is a store that is a "view" of an existing store. The data comes from the
	 * [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source), however this view of the store may be sorted &amp; filtered independently without
	 * having any impact on the [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source) store.
	 */
	interface Def extends Ext.data.ChainedStore {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.ChainedStore.Cfg}
		 */
		config?: Ext.data.ChainedStore.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.ChainedStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.ChainedStore.Statics}
		 */
		statics?: (() => Ext.data.ChainedStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics) | Ext.data.ChainedStore.Statics | any;
	}
}
declare namespace Ext.data.JsonPStore {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.JsonPStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from different domain JSON data easier.
	 * A JsonPStore will be automatically configured with a [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) and a [JsonPProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.JsonP.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.JsonPStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *    
	 *        // proxy configs
	 *        url: 'get-images.php',
	 *    
	 *        // reader configs
	 *        root: 'images',
	 *        fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    stcCallback({
	 *        images: [
	 *            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
	 *            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
	 *        ]
	 *    })
	 * 
	 * Where stcCallback is the callback name passed in the request to the remote domain. See [JsonPProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.JsonP.html)
	 * for details of how this works.
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#cfg-data) config option.
	 */
	interface Def extends Ext.data.JsonPStore {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.JsonPStore.Cfg}
		 */
		config?: Ext.data.JsonPStore.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.JsonPStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.JsonPStore.Statics}
		 */
		statics?: (() => Ext.data.JsonPStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics) | Ext.data.JsonPStore.Statics | any;
	}
}
declare namespace Ext.data.JsonStore {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.JsonStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from JSON data easier.
	 * A JsonStore will be automatically configured with a [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.JsonStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *    
	 *        proxy: {
	 *            type: 'ajax',
	 *            url: 'get-images.php',
	 *            reader: {
	 *                type: 'json',
	 *                rootProperty: 'images'
	 *            }
	 *        },
	 *    
	 *        //alternatively, a Model name can be given (see Ext.data.Store for an example)
	 *        fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    {
	 *        images: [
	 *            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
	 *            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
	 *        ]
	 *    }
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#cfg-data) config option.
	 */
	interface Def extends Ext.data.JsonStore {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.JsonStore.Cfg}
		 */
		config?: Ext.data.JsonStore.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.JsonStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.JsonStore.Statics}
		 */
		statics?: (() => Ext.data.JsonStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics) | Ext.data.JsonStore.Statics | any;
	}
}
declare namespace Ext.data.Model {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html)
	 * A Model or Entity represents some object that your application manages. For example, one
	 * might define a Model for Users, Products, Cars, or other real-world object that we want
	 * to model in the system. Models are used by [stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html), which are in
	 * turn used by many of the data-bound components in Ext.
	 * 
	 * # Fields
	 * 
	 * Models are defined as a set of fields and any arbitrary methods and properties relevant
	 * to the model. For example:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            {name: 'name',  type: 'string'},
	 *            {name: 'age',   type: 'int', convert: null},
	 *            {name: 'phone', type: 'string'},
	 *            {name: 'alive', type: 'boolean', defaultValue: true, convert: null}
	 *        ],
	 *    
	 *        changeName: function() {
	 *            var oldName = this.get('name'),
	 *                newName = oldName + " The Barbarian";
	 *    
	 *            this.set('name', newName);
	 *        }
	 *    });
	 * 
	 * Now we can create instances of our User model and call any model logic we defined:
	 * 
	 *    var user = Ext.create('User', {
	 *        id   : 'ABCD12345',
	 *        name : 'Conan',
	 *        age  : 24,
	 *        phone: '555-555-5555'
	 *    });
	 *    
	 *    user.changeName();
	 *    user.get('name'); //returns "Conan The Barbarian"
	 * 
	 * By default, the built in field types such as number and boolean coerce string values
	 * in the raw data by virtue of their [Ext.data.field.Field.convert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#method-convert) method.
	 * When the server can be relied upon to send data in a format that does not need to be
	 * converted, disabling this can improve performance. The [Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html)
	 * and [Array](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Array.html) readers are likely candidates for this
	 * optimization. To disable field conversions you simply specify `null` for the field's
	 * [convert config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-convert).
	 * 
	 * ## The "id" Field and `idProperty`
	 * 
	 * A Model definition always has an _identifying field_ which should yield a unique key
	 * for each instance. By default, a field named "id" will be created with a
	 * [mapping](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-mapping) of "id". This happens because of the default
	 * [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) provided in Model definitions.
	 * 
	 * To alter which field is the identifying field, use the [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) config.
	 * 
	 * # Validators
	 * 
	 * Models have built-in support for field validators. Validators are added to models as in
	 * the follow example:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            { name: 'name',     type: 'string' },
	 *            { name: 'age',      type: 'int' },
	 *            { name: 'phone',    type: 'string' },
	 *            { name: 'gender',   type: 'string' },
	 *            { name: 'username', type: 'string' },
	 *            { name: 'alive',    type: 'boolean', defaultValue: true }
	 *        ],
	 *    
	 *        validators: {
	 *            age: 'presence',
	 *            name: { type: 'length', min: 2 },
	 *            gender: { type: 'inclusion', list: ['Male', 'Female'] },
	 *            username: [
	 *                { type: 'exclusion', list: ['Admin', 'Operator'] },
	 *                { type: 'format', matcher: /([a-z]+)[0-9]{2,3}/i }
	 *            ]
	 *        }
	 *    });
	 * 
	 * The derived type of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) can also provide validation. If `validators`
	 * need to be duplicated on multiple fields, instead consider creating a custom field type.
	 * 
	 * ## Validation
	 * 
	 * The results of the validators can be retrieved via the "associated" validation record:
	 * 
	 *    var instance = Ext.create('User', {
	 *        name: 'Ed',
	 *        gender: 'Male',
	 *        username: 'edspencer'
	 *    });
	 *    
	 *    var validation = instance.getValidation();
	 * 
	 * The returned object is an instance of [`Ext.data.Validation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html) and has as its fields the
	 * result of the field `validators`. The validation object is "dirty" if there are one or
	 * more validation errors present.
	 * 
	 * This record is also available when using data binding as a "pseudo-association" called
	 * "validation". This pseudo-association can be hidden by an explicitly declared
	 * association by the same name (for compatibility reasons), but doing so is not
	 * recommended.
	 * 
	 * The `Ext.Component.modelValidation` config can be used to enable automatic
	 * binding from the "validation" of a record to the form fields that may be bound to its
	 * values.
	 * 
	 * # Associations
	 * 
	 * Models often have associations with other Models. These associations can be defined by
	 * fields (often called "foreign keys") or by other data such as a many-to-many (or "matrix").
	 * See [Ext.data.schema.Association](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Association.html) for information about configuring and using associations.
	 * 
	 * # Using a Proxy
	 * 
	 * Models are great for representing types of data and relationships, but sooner or later we're going to want to load or
	 * save that data somewhere. All loading and saving of data is handled via a [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html), which
	 * can be set directly on the Model:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email'],
	 *    
	 *        proxy: {
	 *            type: 'rest',
	 *            url : '/users'
	 *        }
	 *    });
	 * 
	 * Here we've set up a [Rest Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Rest.html), which knows how to load and save data to and from a
	 * RESTful backend. Let's see how this works:
	 * 
	 *    var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
	 *    
	 *    user.save(); //POST /users
	 * 
	 * Calling [save](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-save) on the new Model instance tells the configured RestProxy that we wish to persist this Model's
	 * data onto our server. RestProxy figures out that this Model hasn't been saved before because it doesn't have an id,
	 * and performs the appropriate action - in this case issuing a POST request to the url we configured (/users). We
	 * configure any Proxy on any Model and always follow this API - see [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) for a full list.
	 * 
	 * Loading data via the Proxy is accomplished with the static `load` method:
	 * 
	 *    //Uses the configured RestProxy to make a GET request to /users/123
	 *    User.load(123, {
	 *        success: function(user) {
	 *            console.log(user.getId()); //logs 123
	 *        }
	 *    });
	 * 
	 * Models can also be updated and destroyed easily:
	 * 
	 *    //the user Model we loaded in the last snippet:
	 *    user.set('name', 'Edward Spencer');
	 *    
	 *    //tells the Proxy to save the Model. In this case it will perform a PUT request to /users/123 as this Model already has an id
	 *    user.save({
	 *        success: function() {
	 *            console.log('The User was updated');
	 *        }
	 *    });
	 *    
	 *    //tells the Proxy to destroy the Model. Performs a DELETE request to /users/123
	 *    user.erase({
	 *        success: function() {
	 *            console.log('The User was destroyed!');
	 *        }
	 *    });
	 * 
	 * # HTTP Parameter names when using a [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html)
	 * 
	 * By default, the model ID is specified in an HTTP parameter named `id`. To change the
	 * name of this parameter use the Proxy's [idParam](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-idParam)
	 * configuration.
	 * 
	 * Parameters for other commonly passed values such as
	 * [page number](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-pageParam) or
	 * [start row](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-startParam) may also be configured.
	 * 
	 * # Usage in Stores
	 * 
	 * It is very common to want to load a set of Model instances to be displayed and manipulated in the UI. We do this by
	 * creating a [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html):
	 * 
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User'
	 *    });
	 *    
	 *    //uses the Proxy we set up on Model to load the Store data
	 *    store.load();
	 * 
	 * A Store is just a collection of Model instances - usually loaded from a server somewhere. Store can also maintain a
	 * set of added, updated and removed Model instances to be synchronized with the server via the Proxy. See the [Store docs](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) for more information on Stores.
	 */
	interface Def extends Ext.data.Model {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.Model.Cfg}
		 */
		config?: Ext.data.Model.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.Model.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.Model.Statics}
		 */
		statics?: (() => Ext.data.Model.Statics | Ext.Base.Statics) | Ext.data.Model.Statics | any;
	}
}
declare namespace Ext.data.NodeInterface {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.NodeInterface](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html)
	 * This class is used as a set of methods that are applied to the prototype of a
	 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) to decorate it with a Node API. This means that models
	 * used in conjunction with a tree will have all of the tree related methods available
	 * on the model. In general, this class will not be used directly by the developer.
	 * 
	 * This class also creates extra [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) on the model, if they do
	 * not exist, to help maintain the tree state and UI. These fields are documented as
	 * config options.
	 * 
	 * The data fields used to render a tree node are: [text](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-text), [leaf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-leaf),
	 * [children](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-children), and [expanded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-expanded).  Once a node is loaded to the tree store
	 * you can use [get()](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-get) to fetch the value of a given field
	 * name (provided there is not a convenience accessor on the Node for that field).
	 * 
	 *    Ext.tip.QuickTipManager.init(); // not required when using Ext.application()
	 *    
	 *    var root = {
	 *        expanded: true,
	 *        children: [{
	 *            text: "Leaf node (&lt;i&gt;no folder/arrow icon&lt;/i&gt;)",
	 *            leaf: true,
	 *            qtitle: 'Sample Tip Title',
	 *            qtip: 'Tip body'
	 *        }, {
	 *            text: "Parent node expanded",
	 *            expanded: true,
	 *            children: [{
	 *                text: "Expanded leaf node 1",
	 *                leaf: true
	 *            }, {
	 *                text: "Expanded leaf node 2",
	 *                leaf: true
	 *            }]
	 *        }, {
	 *            text: "Parent node collapsed",
	 *            children: [{
	 *                text: "Collapsed leaf node 1",
	 *                leaf: true
	 *            }, {
	 *                text: "Collapsed leaf node 2",
	 *                leaf: true
	 *            }]
	 *        }]
	 *    };
	 *    
	 *    var tree = Ext.create('Ext.tree.Panel', {
	 *        title: 'TreePanel',
	 *        width: 260,
	 *        height: 200,
	 *        root: root,
	 *        rootVisible: false,
	 *        renderTo: document.body,
	 *        bbar: ['The first node ', {
	 *            text: 'is a leaf?',
	 *            handler: function () {
	 *                var firstChild = tree.getRootNode().getChildAt(0);
	 *                Ext.Msg.alert('Is Leaf?', firstChild.isLeaf());
	 *            }
	 *        }, {
	 *            text: 'has text?',
	 *            handler: function () {
	 *                var firstChild = tree.getRootNode().getChildAt(0);
	 *                Ext.Msg.alert('Has Text:', firstChild.get('text'));
	 *            }
	 *        }]
	 *    });
	 * 
	 * The following configs have methods used to set the value / state of the node at
	 * runtime:
	 * 
	 * **[children](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-children) / [leaf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-leaf)**
	 * 
	 * - [appendChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-appendChild)
	 * - [hasChildNodes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-hasChildNodes)
	 * - [insertBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertBefore)
	 * - [insertChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertChild)
	 * - [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-remove)
	 * - [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-removeAll)
	 * - [removeChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-removeChild)
	 * - [replaceChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-replaceChild)
	 * 
	 * **[expanded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-expanded)**
	 * 
	 * - [expand](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-expand)
	 * - [expandChildren](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-expandChildren)
	 * - [collapse](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-collapse)
	 * - [collapseChildren](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-collapseChildren)
	 * 
	 * The remaining configs may be set using [set()](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-set).
	 * 
	 *    node.set('text', 'Changed Text'); // example showing how to change the node label
	 * 
	 * The [qtip](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtip), [qtitle](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtitle), and [qshowDelay](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qshowDelay) use QuickTips and
	 * requires initializing Ext.tip.QuickTipManager unless the application is
	 * created using [Ext.application](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-application).
	 * 
	 *    Ext.tip.QuickTipManager.init();
	 * 
	 * For additional information and examples see the description for
	 * Ext.tree.Panel.
	 */
	interface Def extends Ext.data.NodeInterface {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.NodeInterface.Cfg}
		 */
		config?: Ext.data.NodeInterface.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.NodeInterface.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.NodeInterface.Statics}
		 */
		statics?: (() => Ext.data.NodeInterface.Statics | Ext.Base.Statics) | Ext.data.NodeInterface.Statics | any;
	}
}
declare namespace Ext.data.ProxyStore {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.ProxyStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html)
	 * ProxyStore is a superclass of [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) and [Ext.data.BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html). It's never used directly,
	 * but offers a set of methods used by both of those subclasses.
	 * 
	 * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
	 * you're probably looking for is [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html). If you're still interested, here's a brief description of what
	 * ProxyStore is and is not.
	 * 
	 * ProxyStore provides the basic configuration for anything that can be considered a Store. It expects to be
	 * given a [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) that represents the type of data in the Store. It also expects to be given a
	 * [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) that handles the loading of data into the Store.
	 * 
	 * ProxyStore provides a few helpful methods such as [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) and [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync), which load and save data
	 * respectively, passing the requests through the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
	 * 
	 * Built-in Store subclasses add extra behavior to each of these functions. Note also that each ProxyStore subclass
	 * has its own way of storing data - in [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) the data is saved as a flat [Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html),
	 * whereas in [BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html) we use a [Ext.data.PageMap](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.PageMap.html) to maintain a client side cache of pages of records.
	 * 
	 * The store provides filtering and sorting support. This sorting/filtering can happen on the client side
	 * or can be completed on the server. This is controlled by the [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) and
	 * [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteFilter) config options. For more information see the [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sort) and
	 * [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) methods.
	 */
	interface Def extends Ext.data.ProxyStore {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.ProxyStore.Cfg}
		 */
		config?: Ext.data.ProxyStore.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.ProxyStore.Statics}
		 */
		statics?: (() => Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics) | Ext.data.ProxyStore.Statics | any;
	}
}
declare namespace Ext.data.Request {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.Request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html)
	 * Simple class that represents a Request that will be made by any [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Server.html) subclass.
	 * All this class does is standardize the representation of a Request as used by any ServerProxy subclass,
	 * it does not contain any actual logic or perform the request itself.
	 */
	interface Def extends Ext.data.Request {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.Request.Cfg}
		 */
		config?: Ext.data.Request.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.Request.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.Request.Statics}
		 */
		statics?: (() => Ext.data.Request.Statics | Ext.Base.Statics) | Ext.data.Request.Statics | any;
	}
}
declare namespace Ext.data.ResultSet {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.ResultSet](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html)
	 * Simple wrapper class that represents a set of records returned by a Proxy.
	 */
	interface Def extends Ext.data.ResultSet {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.ResultSet.Cfg}
		 */
		config?: Ext.data.ResultSet.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * The `privates` config is a list of methods intended to be used internally by the
		 * framework.  Methods are placed in a `privates` block to prevent developers from
		 * accidentally overriding framework methods in custom classes.
		 * 
		 *    Ext.define('Computer', {
		 *        privates: {
		 *            runFactory: function(brand) {
		 *                // internal only processing of brand passed to factory
		 *                this.factory(brand);
		 *            }
		 *        },
		 *    
		 *        factory: function (brand) {}
		 *    });
		 * 
		 * In order to override a method from a `privates` block, the overridden method must
		 * also be placed in a `privates` block within the override class.
		 * 
		 *    Ext.define('Override.Computer', {
		 *        override: 'Computer',
		 *        privates: {
		 *            runFactory: function() {
		 *                // overriding logic
		 *            }
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		privates?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.ResultSet.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.ResultSet.Statics}
		 */
		statics?: (() => Ext.data.ResultSet.Statics | Ext.Base.Statics) | Ext.data.ResultSet.Statics | any;
	}
}
declare namespace Ext.data.Session {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.Session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html)
	 * This class manages models and their associations. Instances of `Session` are typically
	 * associated with some `Component` (perhaps the Viewport or a Window) and then used by
	 * their [`view models`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.app.ViewModel.html) to enable data binding.
	 * 
	 * The primary job of a Session is to manage a collection of records of many different
	 * types and their associations. This often starts by loading records when requested (via
	 * bind - see below) and culminates when it is time to save to the server.
	 * 
	 * Because the Session tracks all records it loads, it ensures that for any given type of
	 * model, only one record exists with a given `id`. This means that all edits of that
	 * record are properly targeted at that one instance.
	 * 
	 * Similarly, when associations are loaded, the [`Ext.data.Store`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) created to hold the
	 * associated records is tracked by the Session. So all requests for the "OrderItems" of
	 * a particular Order id will result in the same Store. Adding and removing items from
	 * that Order then is sure to remain consistent.
	 * 
	 * # Data
	 * 
	 * Since the Session is managing all this data, there are several methods it provides
	 * to give convenient access to that data. The most important of these is `update` and
	 * `getChanges`.
	 * 
	 * The `update` and `getChanges` methods both operate on object that contains a summary
	 * of records and associations and different CRUD operations.
	 * 
	 * ## Saving
	 * 
	 * There are two basic ways to save the contents of a Session: `getChanges` and
	 * `getSaveBatch`. We've already seen `getChanges`. The data contained in the CRUD object
	 * can be translated into whatever shape is needed by the server.
	 * 
	 * To leverage the [`proxy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-proxy) facilities defined by each Model
	 * class, there is the `getSaveBatch` method. That method returns an [`Ext.data.Batch`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html)
	 * object populated with the necessary `create`, `update` and `destory` operations to
	 * save all of the changes in the Session.
	 */
	interface Def extends Ext.data.Session {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.Session.Cfg}
		 */
		config?: Ext.data.Session.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.Session.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.Session.Statics}
		 */
		statics?: (() => Ext.data.Session.Statics | Ext.Base.Statics) | Ext.data.Session.Statics | any;
	}
}
declare namespace Ext.data.Store {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
	 * The Store class encapsulates a client side cache of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) objects. Stores load data via a
	 * [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html), and also provide functions for [sorting](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort), [filtering](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter)
	 * and querying the [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances contained within it.
	 * 
	 * Creating a Store is easy - we just tell it the Model and the Proxy to use for loading and saving its data:
	 * 
	 *     // Set up a model to use in our Store
	 *     Ext.define('User', {
	 *         extend: 'Ext.data.Model',
	 *         fields: [
	 *             {name: 'firstName', type: 'string'},
	 *             {name: 'lastName',  type: 'string'},
	 *             {name: 'age',       type: 'int'},
	 *             {name: 'eyeColor',  type: 'string'}
	 *         ]
	 *     });
	 *    
	 *     var myStore = Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         proxy: {
	 *             type: 'ajax',
	 *             url: '/users.json',
	 *             reader: {
	 *                 type: 'json',
	 *                 rootProperty: 'users'
	 *             }
	 *         },
	 *         autoLoad: true
	 *     });
	 * 
	 * In the example above we configured an AJAX proxy to load data from the url '/users.json'. We told our Proxy to use a
	 * [JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) to parse the response from the server into Model object - [see the docs on JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) for details.
	 * 
	 * ## Inline data
	 * 
	 * Stores can also load data inline. Internally, Store converts each of the objects we pass in as [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-data) into
	 * Model instances:
	 * 
	 *     Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         data : [
	 *             {firstName: 'Peter',   lastName: 'Venkman'},
	 *             {firstName: 'Egon',    lastName: 'Spengler'},
	 *             {firstName: 'Ray',     lastName: 'Stantz'},
	 *             {firstName: 'Winston', lastName: 'Zeddemore'}
	 *         ]
	 *     });
	 * 
	 * Loading inline data using the method above is great if the data is in the correct format already (e.g. it doesn't
	 * need to be processed by a [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html)). If your inline data requires processing to decode
	 * the data structure, use a [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) instead (see the [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) docs for an example).
	 * 
	 * Additional data can also be loaded locally using [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
	 * 
	 * ## Dynamic Loading
	 * 
	 * Stores can be dynamically updated by calling the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load) method:
	 * 
	 *    store.load({
	 *        params: {
	 *            group: 3,
	 *            type: 'user'
	 *        },
	 *        callback: function(records, operation, success) {
	 *            // do something after the load finishes
	 *        },
	 *        scope: this
	 *    });
	 * 
	 * Here a bunch of arbitrary parameters is passed along with the load request and a callback function is set
	 * up to do something after the loading is over.
	 * 
	 * ## Loading Nested Data
	 * 
	 * Applications often need to load sets of associated data - for example a CRM system might load a User and her Orders.
	 * Instead of issuing an AJAX request for the User and a series of additional AJAX requests for each Order, we can load
	 * a nested dataset and allow the Reader to automatically populate the associated models. Below is a brief example, see
	 * the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) intro docs for a full explanation:
	 * 
	 *     var store = Ext.create('Ext.data.Store', {
	 *         autoLoad: true,
	 *         model: "User",
	 *         proxy: {
	 *             type: 'ajax',
	 *             url: 'users.json',
	 *             reader: {
	 *                 type: 'json',
	 *                 rootProperty: 'users'
	 *             }
	 *         }
	 *     });
	 * 
	 * Which would consume a response like this:
	 * 
	 *     {
	 *         "users": [{
	 *             "id": 1,
	 *             "name": "Peter",
	 *             "orders": [{
	 *                 "id": 10,
	 *                 "total": 10.76,
	 *                 "status": "invoiced"
	 *            },{
	 *                 "id": 11,
	 *                 "total": 13.45,
	 *                 "status": "shipped"
	 *            }]
	 *         }]
	 *     }
	 * 
	 * See the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) intro docs for a full explanation.
	 * 
	 * ## Filtering and Sorting
	 * 
	 * Stores can be sorted and filtered - in both cases either remotely or locally. The [sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-sorters) and
	 * [filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-filters) are held inside [Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) instances to make them easy to manage.
	 * Usually it is sufficient to either just specify sorters and filters in the Store configuration or call [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort)
	 * or [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter):
	 * 
	 *     var store = Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         sorters: [{
	 *             property: 'age',
	 *             direction: 'DESC'
	 *         }, {
	 *             property: 'firstName',
	 *             direction: 'ASC'
	 *         }],
	 *    
	 *         filters: [{
	 *             property: 'firstName',
	 *             value: /Peter/
	 *         }]
	 *     });
	 * 
	 * The new Store will keep the configured sorters and filters in the Collection instances mentioned above. By
	 * default, sorting and filtering are both performed locally by the Store - see [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) and
	 * [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteFilter) to allow the server to perform these operations instead.
	 * 
	 * Filtering and sorting after the Store has been instantiated is also easy. Calling [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) adds another filter
	 * to the Store and automatically filters the dataset (calling [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) with no arguments simply re-applies all
	 * existing filters).
	 * 
	 *    store.filter('eyeColor', 'Brown');
	 * 
	 * Change the sorting at any time by calling [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort):
	 * 
	 *    store.sort('height', 'ASC');
	 * 
	 * Note that all existing sorters will be removed in favor of the new sorter data (if [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort) is called with no
	 * arguments, the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new
	 * ones, just add them to the Collection:
	 * 
	 *    store.sorters.add(new Ext.util.Sorter({
	 *        property : 'shoeSize',
	 *        direction: 'ASC'
	 *    }));
	 *    
	 *    store.sort();
	 * 
	 * ## Registering with StoreManager
	 * 
	 * Any Store that is instantiated with a [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-storeId) will automatically be registered with the [StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html). This makes it easy to reuse the same store in multiple views:
	 * 
	 *    //this store can be used several times
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        storeId: 'usersStore'
	 *    });
	 *    
	 *    new Ext.List({
	 *        store: 'usersStore',
	 *        //other config goes here
	 *    });
	 *    
	 *    new Ext.view.View({
	 *        store: 'usersStore',
	 *        //other config goes here
	 *    });
	 * 
	 * ## Further Reading
	 * 
	 * Stores are backed up by an ecosystem of classes that enables their operation. To gain a full understanding of these
	 * pieces and how they fit together, see:
	 * 
	 * - [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) - overview of what Proxies are and how they are used
	 * - [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) - the core class in the data package
	 * - [Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) - used by any subclass of [ServerProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Server.html) to read a response
	 */
	interface Def extends Ext.data.Store {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.Store.Cfg}
		 */
		config?: Ext.data.Store.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.Store.Statics}
		 */
		statics?: (() => Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics) | Ext.data.Store.Statics | any;
	}
}
declare namespace Ext.data.TreeModel {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.TreeModel](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html)
	 * This class is used as a base class from which to derive Models used in Trees.
	 */
	interface Def extends Ext.data.TreeModel {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.TreeModel.Cfg}
		 */
		config?: Ext.data.TreeModel.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.TreeModel.Statics|Ext.data.Model.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.TreeModel.Statics}
		 */
		statics?: (() => Ext.data.TreeModel.Statics | Ext.data.Model.Statics | Ext.Base.Statics) | Ext.data.TreeModel.Statics | any;
	}
}
declare namespace Ext.data.TreeStore {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html)
	 * The TreeStore is a store implementation that owns the [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root) of
	 * a tree, and provides methods to load either local or remote data as child nodes of the root
	 * and any descendant non-leaf node.
	 * 
	 * The TreeStore must be used as the store of a tree panel.
	 * 
	 * This class also relays many node events from the underlying node structure.
	 * 
	 * # Using Models
	 * 
	 * If no Model is specified, an implicit model will be created that extends [Ext.data.TreeModel](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html).
	 * The standard Tree fields will also be copied onto the Model for maintaining their state. These fields are listed
	 * in the [Ext.data.NodeInterface](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html) documentation.
	 * 
	 * # Reading Nested Data
	 * 
	 * For the tree to read nested data, the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) must be configured with a root property,
	 * so the reader can find nested data for each node (if a root is not specified, it will default to
	 * 'children'). This will tell the tree to look for any nested tree nodes by the same keyword, i.e., 'children'.
	 * If a root is specified in the config make sure that any nested nodes with children have the same name.
	 * 
	 * **Note:** Setting [defaultRootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-defaultRootProperty) accomplishes the same thing.
	 * 
	 * # rootProperty as a Function
	 * 
	 * You can pass a function as the data reader's rootProperty when the tree's dataset has
	 * mixed root properties. Child nodes can then be programmatically determined at read time.
	 * 
	 * For example, the child nodes may be passed via the 'children' property
	 * name, though you may have a top-level root property of 'items'.
	 * 
	 * See [rootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-rootProperty) for more information.
	 * 
	 * # Filtering
	 * 
	 * Filtering of nodes in a TreeStore is hierarchically top down by default. This means that if a non-leaf node does not
	 * pass the filter, then it, and all its descendants are filtered _out_ of the store.
	 * 
	 * To reverse this, so that any node which passes the filter causes all its ancestors to be visible, configure
	 * the `TreeStore` with '[filterer: 'bottomup'`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-filterer)
	 * 
	 * You may also programatically filter individual tree nodes by setting their `'visible'` field.
	 * 
	 * Setting this to `false` filters the node out so that it will not appear in the UI. Setting it to `true`
	 * filters the node in.
	 * 
	 * Note that if performing several filter operations, it is best to [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-suspendEvents)
	 * on the store first, and when all nodes have been modified, [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-resumeEvents) and fire the
	 * [refresh](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#event-refresh) event on the store.
	 */
	interface Def extends Ext.data.TreeStore {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.TreeStore.Cfg}
		 */
		config?: Ext.data.TreeStore.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.TreeStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.TreeStore.Statics}
		 */
		statics?: (() => Ext.data.TreeStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics) | Ext.data.TreeStore.Statics | any;
	}
}
declare namespace Ext.data.XmlStore {
	/** 
	 * @definitions
	 * Config interface to declare class: 
	 * [Ext.data.XmlStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from XML data easier.
	 * A XmlStore will be automatically configured with a [Ext.data.reader.Xml](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Xml.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.XmlStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *        url: 'sheldon.xml', // automatically configures a HttpProxy
	 *        // reader configs
	 *        record: 'Item', // records will have an "Item" tag
	 *        idPath: 'ASIN',
	 *        totalRecords: '@TotalResults'
	 *        fields: [
	 *            // set up the fields mapping into the xml doc
	 *            // The first needs mapping, the others are very basic
	 *            {name: 'Author', mapping: 'ItemAttributes > Author'},
	 *            'Title', 'Manufacturer', 'ProductGroup'
	 *        ]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    &#60?xml version="1.0" encoding="UTF-8"?>
	 *    &#60ItemSearchResponse xmlns="http://webservices.amazon.com/AWSECommerceService/2009-05-15">
	 *        &#60Items>
	 *            &#60Request>
	 *                &#60IsValid>True&#60/IsValid>
	 *                &#60ItemSearchRequest>
	 *                    &#60Author>Sidney Sheldon&#60/Author>
	 *                    &#60SearchIndex>Books&#60/SearchIndex>
	 *                &#60/ItemSearchRequest>
	 *            &#60/Request>
	 *            &#60TotalResults>203&#60/TotalResults>
	 *            &#60TotalPages>21&#60/TotalPages>
	 *            &#60Item>
	 *                &#60ASIN>0446355453&#60/ASIN>
	 *                &#60DetailPageURL>
	 *                    http://www.amazon.com/
	 *                &#60/DetailPageURL>
	 *                &#60ItemAttributes>
	 *                    &#60Author>Sidney Sheldon&#60/Author>
	 *                    &#60Manufacturer>Warner Books&#60/Manufacturer>
	 *                    &#60ProductGroup>Book&#60/ProductGroup>
	 *                    &#60Title>Master of the Game&#60/Title>
	 *                &#60/ItemAttributes>
	 *            &#60/Item>
	 *        &#60/Items>
	 *    &#60/ItemSearchResponse>
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#cfg-data) config option.
	 * 
	 * **Note:** This class accepts all of the configuration options of
	 * **[XmlReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Xml.html)**.
	 */
	interface Def extends Ext.data.XmlStore {
		/** 
		 * List of short aliases for class names. An alias consists of a namespace and a name
		 * concatenated by a period as &#60;namespace&#62;.&#60;name&#62;
		 * 
		 * - **namespace** - The namespace describes what kind of alias this is and must be
		 *   all lowercase.
		 * - **name** - The name of the alias which allows the lazy-instantiation via the
		 *   alias. The name shouldn't contain any periods.
		 * 
		 * A list of namespaces and the usages are:
		 * 
		 * - **feature** - Grid features
		 * - **plugin** - Plugins
		 * - **store** - [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
		 * - **widget** - Components
		 * 
		 * Most useful for defining xtypes for widgets:
		 * 
		 *    Ext.define('MyApp.CoolPanel', {
		 *        extend: 'Ext.panel.Panel',
		 *        alias: ['widget.coolpanel'],
		 *        title: 'Yeah!'
		 *    });
		 *    
		 *    // Using Ext.create
		 *    Ext.create('widget.coolpanel');
		 *    
		 *    // Using the shorthand for defining widgets by xtype
		 *    Ext.widget('panel', {
		 *        items: [
		 *            {xtype: 'coolpanel', html: 'Foo'},
		 *            {xtype: 'coolpanel', html: 'Bar'}
		 *        ]
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alias?: string | string[];
		/** 
		 * Defines alternate names for this class.  For example:
		 * 
		 *    Ext.define('Developer', {
		 *        alternateClassName: ['Coder', 'Hacker'],
		 *        code: function(msg) {
		 *            alert('Typing... ' + msg);
		 *        }
		 *    });
		 *    
		 *    var joe = Ext.create('Developer');
		 *    joe.code('stackoverflow');
		 *    
		 *    var rms = Ext.create('Hacker');
		 *    rms.code('hack hack');
		 * 
		 * @property
		 * @protected (property)
		 * @type {string|string[]}
		 */
		alternateClassName?: string | string[];
		/** 
		 * This configuration works in a very similar manner to the [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config) option.
		 * The difference is that the configurations are only ever processed when the first instance
		 * of that class is created. The processed value is then stored on the class prototype and
		 * will not be processed on subsequent instances of the class. Getters/setters will be generated
		 * in exactly the same way as [config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-config).
		 * 
		 * This option is useful for expensive objects that can be shared across class instances.
		 * The class itself ensures that the creation only occurs once.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		cachedConfig?: object;
		/** 
		 * List of configuration options with their default values.
		 * 
		 * **Note:** You need to make sure [Ext.Base.initConfig](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig) is called from your constructor if you are defining
		 * your own class or singleton, unless you are extending a Component. Otherwise the generated getter and setter
		 * methods will not be initialized.
		 * 
		 * Each config item will have its own setter and getter method automatically generated inside the class prototype
		 * during class creation time, if the class does not have those methods explicitly defined.
		 * 
		 * As an example, let's convert the name property of a Person class to be a config item, then add extra age and
		 * gender items.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            name: 'Mr. Unknown',
		 *            age: 0,
		 *            gender: 'Male'
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *    
		 *            return this;
		 *        }
		 *    
		 *        // ...
		 *    });
		 * 
		 * Within the class, this.name still has the default value of "Mr. Unknown". However, it's now publicly accessible
		 * without sacrificing encapsulation, via setter and getter methods.
		 * 
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 35
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 35
		 *    alert(jacky.getGender());   // alerts "Male"
		 *    
		 *    jacky.walk(10);             // alerts "Jacky is walking 10 steps"
		 *    
		 *    jacky.setName("Mr. Nguyen");
		 *    alert(jacky.getName());     // alerts "Mr. Nguyen"
		 *    
		 *    jacky.walk(10);             // alerts "Mr. Nguyen is walking 10 steps"
		 * 
		 * Notice that we changed the class constructor to invoke this.initConfig() and pass in the provided config object.
		 * Two key things happened:
		 * 
		 * - The provided config object when the class is instantiated is recursively merged with the default config object.
		 * - All corresponding setter methods are called with the merged values.
		 * 
		 * Beside storing the given values, throughout the frameworks, setters generally have two key responsibilities:
		 * 
		 * - Filtering / validation / transformation of the given value before it's actually stored within the instance.
		 * - Notification (such as firing events) / post-processing after the value has been set, or changed from a
		 *   previous value.
		 * 
		 * By standardize this common pattern, the default generated setters provide two extra template methods that you
		 * can put your own custom logics into, i.e: an "applyFoo" and "updateFoo" method for a "foo" config item, which are
		 * executed before and after the value is actually set, respectively. Back to the example class, let's validate that
		 * age must be a valid positive number, and fire an 'agechange' if the value is modified.
		 * 
		 *    Ext.define('My.sample.Person', {
		 *        config: {
		 *            // ...
		 *        },
		 *    
		 *        constructor: {
		 *            // ...
		 *        },
		 *    
		 *        applyAge: function(age) {
		 *            if (typeof age !== 'number' || age &lt; 0) {
		 *                console.warn("Invalid age, must be a positive number");
		 *                return;
		 *            }
		 *    
		 *            return age;
		 *        },
		 *    
		 *        updateAge: function(newAge, oldAge) {
		 *            // age has changed from "oldAge" to "newAge"
		 *            this.fireEvent('agechange', this, newAge, oldAge);
		 *        }
		 *    
		 *        // ...
		 *    });
		 *    
		 *    var jacky = new Person({
		 *        name: "Jacky",
		 *        age: 'invalid'
		 *    });
		 *    
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(-100));  // alerts 0
		 *    alert(jacky.getAge());      // alerts 0
		 *    
		 *    alert(jacky.setAge(35));    // alerts 0
		 *    alert(jacky.getAge());      // alerts 35
		 * 
		 * In other words, when leveraging the config feature, you mostly never need to define setter and getter methods
		 * explicitly. Instead, "apply_" and "update_" methods should be implemented where necessary. Your code will be
		 * consistent throughout and only contain the minimal logic that you actually care about.
		 * 
		 * When it comes to inheritance, the default config of the parent class is automatically, recursively merged with
		 * the child's default config. The same applies for mixins.
		 * @property
		 * @protected (property)
		 * @type {Ext.data.XmlStore.Cfg}
		 */
		config?: Ext.data.XmlStore.Cfg;
		/** 
		 * The parent class that this class extends. For example:
		 * 
		 *    Ext.define('Person', {
		 *        say: function(text) { alert(text); }
		 *    });
		 *    
		 *    Ext.define('Developer', {
		 *        extend: 'Person',
		 *        say: function(text) { this.callParent(["print "+text]); }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		extend?: string;
		/** 
		 * List of inheritable static methods for this class.
		 * Otherwise just like [statics](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-statics) but subclasses inherit these methods.
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		inheritableStatics?: object;
		/** 
		 * List of classes to mix into this class. For example:
		 * 
		 *    Ext.define('CanSing', {
		 *         sing: function() {
		 *             alert("For he's a jolly good fellow...")
		 *         }
		 *    });
		 *    
		 *    Ext.define('Musician', {
		 *         mixins: ['CanSing']
		 *    })
		 * 
		 * In this case the Musician class will get a `sing` method from CanSing mixin.
		 * 
		 * But what if the Musician already has a `sing` method? Or you want to mix
		 * in two classes, both of which define `sing`?  In such a cases it's good
		 * to define mixins as an object, where you assign a name to each mixin:
		 * 
		 *    Ext.define('Musician', {
		 *         mixins: {
		 *             canSing: 'CanSing'
		 *         },
		 *    
		 *         sing: function() {
		 *             // delegate singing operation to mixin
		 *             this.mixins.canSing.sing.call(this);
		 *         }
		 *    })
		 * 
		 * In this case the `sing` method of Musician will overwrite the
		 * mixed in `sing` method. But you can access the original mixed in method
		 * through special `mixins` property.
		 * @property
		 * @protected (property)
		 * @type {string[]|object}
		 */
		mixins?: string[] | object;
		/** 
		 * Overrides members of the specified `target` class.
		 * 
		 * **NOTE:** the overridden class must have been defined using
		 * [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) in order to use the `override` config.
		 * 
		 * Methods defined on the overriding class will not automatically call the methods of
		 * the same name in the ancestor class chain.  To call the parent's method of the
		 * same name you must call [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).  To skip the
		 * method of the overridden class and call its parent you will instead call
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper).
		 * 
		 * See [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define) for additional usage examples.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		override?: string;
		/** 
		 * Allows setting config values for a class based on specific platforms. The value
		 * of this config is an object whose properties are "rules" and whose values are
		 * objects containing config values.
		 * 
		 * For example:
		 * 
		 *     Ext.define('App.view.Foo', {
		 *         extend: 'Ext.panel.Panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * In the above, "desktop" and "!desktop" are (mutually exclusive) rules. Whichever
		 * evaluates to `true` will have its configs applied to the class. In this case, only
		 * the "title" property, but the object can contain any number of config properties.
		 * In this case, the `platformConfig` is evaluated as part of the class and there is
		 * no cost for each instance created.
		 * 
		 * The rules are evaluated expressions in the context of the platform tags contained
		 * in [`Ext.platformTags`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#property-platformTags). Any properties of that object are
		 * implicitly usable (as shown above).
		 * 
		 * If a `platformConfig` specifies a config value, it will replace any values declared
		 * on the class itself.
		 * 
		 * Use of `platformConfig` on instances is handled by the config system when classes
		 * call [`initConfig`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-initConfig). For example:
		 * 
		 *     Ext.create({
		 *         xtype: 'panel',
		 *    
		 *         platformConfig: {
		 *             desktop: {
		 *                 title: 'Some Rather Descriptive Title'
		 *             },
		 *    
		 *             '!desktop': {
		 *                 title: 'Short Title'
		 *             }
		 *         }
		 *     });
		 * 
		 * The following is equivalent to the above:
		 * 
		 *     if (Ext.platformTags.desktop) {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Some Rather Descriptive Title'
		 *         });
		 *     } else {
		 *         Ext.create({
		 *             xtype: 'panel',
		 *             title: 'Short Title'
		 *         });
		 *     }
		 * 
		 * To adjust configs based on dynamic conditions, see [`Ext.mixin.Responsive`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Responsive.html).
		 * @property
		 * @protected (property)
		 * @type {object}
		 */
		platformConfig?: object;
		/** 
		 * List of classes that have to be loaded before instantiating this class.
		 * For example:
		 * 
		 *    Ext.define('Mother', {
		 *        requires: ['Child'],
		 *        giveBirth: function() {
		 *            // we can be sure that child class is available.
		 *            return new Child();
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		requires?: string[];
		/** 
		 * When set to true, the class will be instantiated as singleton.  For example:
		 * 
		 *    Ext.define('Logger', {
		 *        singleton: true,
		 *        log: function(msg) {
		 *            console.log(msg);
		 *        }
		 *    });
		 *    
		 *    Logger.log('Hello');
		 * 
		 * @property
		 * @protected (property)
		 * @type {boolean}
		 */
		singleton?: boolean;
		/** 
		 * List of optional classes to load together with this class. These aren't neccessarily loaded before
		 * this class is created, but are guaranteed to be available before [Ext.onReady](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-onReady) listeners are
		 * invoked. For example:
		 * 
		 *    Ext.define('Mother', {
		 *        uses: ['Child'],
		 *        giveBirth: function() {
		 *            // This code might, or might not work:
		 *            // return new Child();
		 *    
		 *            // Instead use Ext.create() to load the class at the spot if not loaded already:
		 *            return Ext.create('Child');
		 *        }
		 *    });
		 * 
		 * @property
		 * @protected (property)
		 * @type {string[]}
		 */
		uses?: string[];
		/** 
		 * The `xtype` configuration option can be used to optimize Component creation and rendering. It serves as a
		 * shortcut to the full component name. For example, the component `Ext.button.Button` has an xtype of `button`.
		 * 
		 * You can define your own xtype on a custom [component](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) by specifying the
		 * [alias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Class.html#cfg-alias) config option with a prefix of `widget`. For example:
		 * 
		 *    Ext.define('PressMeButton', {
		 *        extend: 'Ext.button.Button',
		 *        alias: 'widget.pressmebutton',
		 *        text: 'Press Me'
		 *    });
		 * 
		 * Any Component can be created implicitly as an object config with an xtype specified, allowing it to be
		 * declared and passed into the rendering pipeline without actually being instantiated as an object. Not only is
		 * rendering deferred, but the actual creation of the object itself is also deferred, saving memory and resources
		 * until they are actually needed. In complex, nested layouts containing many Components, this can make a
		 * noticeable improvement in performance.
		 * 
		 *    // Explicit creation of contained Components:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [
		 *          Ext.create('Ext.button.Button', {
		 *             text: 'OK'
		 *          })
		 *       ]
		 *    });
		 *    
		 *    // Implicit creation using xtype:
		 *    var panel = new Ext.Panel({
		 *       // ...
		 *       items: [{
		 *          xtype: 'button',
		 *          text: 'OK'
		 *       }]
		 *    });
		 * 
		 * In the first example, the button will always be created immediately during the panel's initialization. With
		 * many added Components, this approach could potentially slow the rendering of the page. In the second example,
		 * the button will not be created or rendered until the panel is actually displayed in the browser. If the panel
		 * is never displayed (for example, if it is a tab that remains hidden) then the button will never be created and
		 * will never consume any resources whatsoever.
		 * @property
		 * @protected (property)
		 * @type {string}
		 */
		xtype?: string;
		/** 
		 * @mixed
		 * @method
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @configuration
		 * List of static methods for this class. For example:
		 * 
		 *    Ext.define('Computer', {
		 *         statics: {
		 *             factory: function(brand) {
		 *                 // 'this' in static methods refer to the class itself
		 *                 return new this(brand);
		 *             }
		 *         },
		 *    
		 *         constructor: function() { ... }
		 *    });
		 *    
		 *    var dellComputer = Computer.factory('Dell');
		 * 
		 * @protected (method+configuration)
		 * @returns {Ext.data.XmlStore.Statics|Ext.data.Store.Statics|Ext.data.ProxyStore.Statics|Ext.data.AbstractStore.Statics|Ext.Base.Statics}  
		 * @type {Ext.data.XmlStore.Statics}
		 */
		statics?: (() => Ext.data.XmlStore.Statics | Ext.data.Store.Statics | Ext.data.ProxyStore.Statics | Ext.data.AbstractStore.Statics | Ext.Base.Statics) | Ext.data.XmlStore.Statics | any;
	}
}
declare namespace Ext.data.AbstractStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.AbstractStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html)
	 * AbstractStore is a superclass of [Ext.data.ProxyStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html) and [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html). It's never used directly,
	 * but offers a set of methods used by both of those subclasses.
	 * 
	 * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
	 * you're probably looking for is [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members    The members to add to this class.
		 * @param   {boolean}                         [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                         [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members
		 * @returns {Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          name
		 * @param   {object}                          member
		 * @returns {Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          fn
		 * @param   {object}                          scope
		 * @returns {Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.ArrayStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.ArrayStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from Array data easier. An ArrayStore will be
	 * automatically configured with a [Ext.data.reader.Array](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Array.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = Ext.create('Ext.data.ArrayStore', {
	 *        // store configs
	 *        storeId: 'myStore',
	 *        // reader configs
	 *        fields: [
	 *           'company',
	 *           {name: 'price', type: 'float'},
	 *           {name: 'change', type: 'float'},
	 *           {name: 'pctChange', type: 'float'},
	 *           {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
	 *        ]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    var myData = [
	 *        ['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
	 *        ['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
	 *        ['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
	 *        ['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
	 *        ['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
	 *    ];
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#cfg-data) config option.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 members    The members to add to this class.
		 * @param   {boolean}                                                                                [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.ArrayStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ArrayStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 members
		 * @returns {Ext.data.ArrayStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.ArrayStore;
		addStatics? (members: object): typeof Ext.data.Store;
		addStatics? (members: object): typeof Ext.data.ProxyStore;
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 name
		 * @param   {object}                                                                                 member
		 * @returns {Ext.data.ArrayStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.ArrayStore;
		addMember? (name: object, member: object): typeof Ext.data.Store;
		addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 fn
		 * @param   {object}                                                                                 scope
		 * @returns {Ext.data.ArrayStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.ArrayStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.Batch {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html)
	 * Provides a mechanism to run one or more [operations](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * in a given order. Fires the `operationcomplete` event after the completion of each
	 * Operation, and the `complete` event when all Operations have been successfully executed.
	 * Fires an `exception` event if any of the Operations encounter an exception.
	 * 
	 * Usually these are only used internally by [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) classes.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members    The members to add to this class.
		 * @param   {boolean}                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Batch|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Batch;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members
		 * @returns {Ext.data.Batch|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.Batch;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  name
		 * @param   {object}                  member
		 * @returns {Ext.data.Batch|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.Batch;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  fn
		 * @param   {object}                  scope
		 * @returns {Ext.data.Batch|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.Batch;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.BufferedStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html)
	 * A BufferedStore maintains a sparsely populated map of pages corresponding to an extremely large server-side dataset.
	 * 
	 * Use a BufferedStore when the dataset size is so large that the database and network latency, and client memory requirements
	 * preclude caching the entire dataset in a regular [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
	 * 
	 * When using a BufferedStore _not all of the dataset is present in the client_. Only pages which have been
	 * requested by the UI (usually a GridPanel) and surrounding pages will be present. Retention
	 * of viewed pages in the BufferedStore after they have been scrolled out of view is configurable. See [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone),
	 * [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone) and [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount).
	 * 
	 * To use a BufferedStore, initiate the loading process by loading the first page. The number of rows rendered are
	 * determined automatically, and the range of pages needed to keep the cache primed for scrolling is
	 * requested and cached.
	 * Example:
	 * 
	 *    myBufferedStore.loadPage(1); // Load page 1
	 * 
	 * A BufferedRenderer is instantiated which will monitor the scrolling in the grid, and
	 * refresh the view's rows from the page cache as needed. It will also pull new data into the page
	 * cache when scrolling of the view draws upon data near either end of the prefetched data.
	 * 
	 * The margins which trigger view refreshing from the prefetched data are Ext.grid.plugin.BufferedRenderer.numFromEdge,
	 * Ext.grid.plugin.BufferedRenderer.leadingBufferZone and Ext.grid.plugin.BufferedRenderer.trailingBufferZone.
	 * 
	 * The margins which trigger loading more data into the page cache are, [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone) and
	 * [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone).
	 * 
	 * By default, only 5 pages of data (in addition to the pages which over the visible region) are cached in the page cache,
	 * with old pages being evicted from the cache as the view moves down through the dataset. This is controlled by the
	 * [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount) setting.
	 * 
	 * Setting this value to zero means that no pages are _ever_ scrolled out of the page cache, and
	 * that eventually the whole dataset may become present in the page cache. This is sometimes desirable
	 * as long as datasets do not reach astronomical proportions.
	 * 
	 * Selection state may be maintained across page boundaries by configuring the SelectionModel not to discard
	 * records from its collection when those Records cycle out of the Store's primary collection. This is done
	 * by configuring the SelectionModel like this:
	 * 
	 *    selModel: {
	 *        pruneRemoved: false
	 *    }
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                     members    The members to add to this class.
		 * @param   {boolean}                                                                    [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                    [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.BufferedStore|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.BufferedStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                     members
		 * @returns {Ext.data.BufferedStore|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.BufferedStore;
		addStatics? (members: object): typeof Ext.data.ProxyStore;
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                     name
		 * @param   {object}                                                                     member
		 * @returns {Ext.data.BufferedStore|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.BufferedStore;
		addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                     fn
		 * @param   {object}                                                                     scope
		 * @returns {Ext.data.BufferedStore|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.BufferedStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.Connection {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.Connection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html)
	 * The Connection class encapsulates a connection to the page's originating domain, allowing requests to be made either
	 * to a configured URL, or to a URL specified at request time.
	 * 
	 * Requests made by this class are asynchronous, and will return immediately. No data from the server will be available
	 * to the statement immediately following the [request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-request) call. To process returned data, use a success callback
	 * in the request options object, or an [event listener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#event-requestcomplete).
	 * 
	 * # File Uploads
	 * 
	 * File uploads are not performed using normal "Ajax" techniques, that is they are not performed using XMLHttpRequests.
	 * Instead the form is submitted in the standard manner with the DOM &lt;form&gt; element temporarily modified to have its
	 * target set to refer to a dynamically generated, hidden &lt;iframe&gt; which is inserted into the document but removed
	 * after the return data has been gathered.
	 * 
	 * The server response is parsed by the browser to create the document for the IFRAME. If the server is using JSON to
	 * send the return object, then the Content-Type header must be set to "text/html" in order to tell the browser to
	 * insert the text unchanged into the document body.
	 * 
	 * Characters which are significant to an HTML parser must be sent as HTML entities, so encode `&lt;` as `&amp;lt;`, `&amp;` as
	 * `&amp;amp;` etc.
	 * 
	 * The response text is retrieved from the document, and a fake XMLHttpRequest object is created containing a
	 * responseText property in order to conform to the requirements of event handlers and callbacks.
	 * 
	 * Be aware that file upload packets are sent with the content type multipart/form and some server technologies
	 * (notably JEE) may require some custom processing in order to retrieve parameter names and parameter values from the
	 * packet content.
	 * 
	 * Also note that it's not possible to check the response code of the hidden iframe, so the success handler will ALWAYS fire.
	 * 
	 * # Binary Posts
	 * 
	 * The class supports posting binary data to the server by using native browser capabilities, or a flash polyfill plugin in browsers that do not support native binary posting (e.g. Internet Explorer version 9 or less). A number of limitations exist when the polyfill is used:
	 * 
	 * - Only asynchronous connections are supported.
	 * - Only the POST method can be used.
	 * - The return data can only be binary for now. Set the [binary](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-binary) parameter to <tt>true</tt>.
	 * - Only the 0, 1 and 4 (complete) readyState values will be reported to listeners.
	 * - The flash object will be injected at the bottom of the document and should be invisible.
	 * - Important: See note about packaing the flash plugin with the app in the documenetation of [BinaryXhr](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.flash.BinaryXhr.html).
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                       members    The members to add to this class.
		 * @param   {boolean}                      [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                      [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Connection|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Connection;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                       members
		 * @returns {Ext.data.Connection|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.Connection;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                       name
		 * @param   {object}                       member
		 * @returns {Ext.data.Connection|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.Connection;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                       fn
		 * @param   {object}                       scope
		 * @returns {Ext.data.Connection|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.Connection;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.DirectStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.DirectStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html)
	 * Small helper class to create an [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) configured with an [Ext.data.proxy.Direct](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html)
	 * and [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) to make interacting with an [Ext.direct.Manager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.direct.Manager.html) server-side
	 * [Provider](https://docs.sencha.com/extjs/6.2.0/modern/Ext.direct.Provider.html) easier. To create a different proxy/reader combination create a basic
	 * [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) configured as needed.
	 * 
	 * **Note:** Although they are not listed, this class inherits all of the config options of:
	 * 
	 * - **[Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)**
	 * - **[JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html)**
	 *   <ul>
	 *   <li>**[rootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html#cfg-rootProperty)**
	 * - **[totalProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html#cfg-totalProperty)**
	 * 
	 * </li>
	 * <li>
	 * 
	 * **[DirectProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html)**
	 * 
	 * - **[directFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-directFn)**
	 * - **[paramOrder](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-paramOrder)**
	 * - **[paramsAsHash](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-paramsAsHash)**
	 * 
	 * </li>
	 * </ul>
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                  members    The members to add to this class.
		 * @param   {boolean}                                                                                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.DirectStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.DirectStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                  members
		 * @returns {Ext.data.DirectStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.DirectStore;
		addStatics? (members: object): typeof Ext.data.Store;
		addStatics? (members: object): typeof Ext.data.ProxyStore;
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                  name
		 * @param   {object}                                                                                  member
		 * @returns {Ext.data.DirectStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.DirectStore;
		addMember? (name: object, member: object): typeof Ext.data.Store;
		addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                  fn
		 * @param   {object}                                                                                  scope
		 * @returns {Ext.data.DirectStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.DirectStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.Error {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.Error](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Error.html)
	 * This class hols the results of a validator for an [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html). These objects are
	 * placed in an [`Ext.data.ErrorCollection`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html) and returned by [`Ext.data.Model.validate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate).
	 * 
	 * Usually this class does not need to be instantiated directly - instances are instead created
	 * automatically when [validate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate) on a model instance.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members    The members to add to this class.
		 * @param   {boolean}                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Error|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Error;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members
		 * @returns {Ext.data.Error|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.Error;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  name
		 * @param   {object}                  member
		 * @returns {Ext.data.Error|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.Error;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  fn
		 * @param   {object}                  scope
		 * @returns {Ext.data.Error|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.Error;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.ErrorCollection {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.ErrorCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html)
	 * Wraps a collection of validation error responses and provides convenient functions for
	 * accessing and errors for specific fields.
	 * 
	 * Usually this class does not need to be instantiated directly - instances are instead
	 * created automatically when [validate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate) on a model instance:
	 * 
	 *     // Validate some existing model instance - in this case it returned 2 failures
	 *     // messages
	 *    
	 *     var errors = myModel.validate();
	 *     errors.isValid(); //false
	 *    
	 *     errors.length; //2
	 *     errors.getByField('name');  // [{field: 'name',  message: 'must be present'}]
	 *     errors.getByField('title'); // [{field: 'title', message: 'is too short'}]
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      members    The members to add to this class.
		 * @param   {boolean}                                                                                     [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                     [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.ErrorCollection|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ErrorCollection;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.util.MixedCollection;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.util.AbstractMixedCollection;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      members
		 * @returns {Ext.data.ErrorCollection|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.ErrorCollection;
		addStatics? (members: object): typeof Ext.util.MixedCollection;
		addStatics? (members: object): typeof Ext.util.AbstractMixedCollection;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      name
		 * @param   {object}                                                                                      member
		 * @returns {Ext.data.ErrorCollection|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.ErrorCollection;
		addMember? (name: object, member: object): typeof Ext.util.MixedCollection;
		addMember? (name: object, member: object): typeof Ext.util.AbstractMixedCollection;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                      fn
		 * @param   {object}                                                                                      scope
		 * @returns {Ext.data.ErrorCollection|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.ErrorCollection;
		onExtended? (fn: object, scope: object): typeof Ext.util.MixedCollection;
		onExtended? (fn: object, scope: object): typeof Ext.util.AbstractMixedCollection;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.ChainedStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html)
	 * A chained store is a store that is a "view" of an existing store. The data comes from the
	 * [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source), however this view of the store may be sorted &amp; filtered independently without
	 * having any impact on the [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source) store.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                members    The members to add to this class.
		 * @param   {boolean}                                               [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                               [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.ChainedStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ChainedStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                members
		 * @returns {Ext.data.ChainedStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.ChainedStore;
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                name
		 * @param   {object}                                                member
		 * @returns {Ext.data.ChainedStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.ChainedStore;
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                fn
		 * @param   {object}                                                scope
		 * @returns {Ext.data.ChainedStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.ChainedStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.JsonP {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.JsonP](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html)
	 * This class is used to create JSONP requests. JSONP is a mechanism that allows for making
	 * requests for data cross domain. JSONP is basically a `&lt;script&gt;` node with the source of the url executing
	 * a function that was created by [Ext.data.JsonP](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html). Once the resource has loaded, the `&lt;script&gt;` node will be destroyed.
	 * 
	 * If you have a request such as:
	 * 
	 *    Ext.data.JsonP.request({
	 *        url : 'foo.php'
	 *    });
	 * 
	 * [Ext.data.JsonP](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonP.html) will create a `&lt;script&gt;` node in the `&lt;head&gt;` with the `src` attribute pointing to
	 * `foo.php?callback=Ext.data.JsonP.callback1`. The `foo.php` script will have to detect the `callback` URL parameter
	 * and return valid JavaScript:
	 * 
	 *    Ext.data.JsonP.callback1({"foo":"bar"});
	 * 
	 * A simple PHP example would look like:
	 * 
	 *    &lt;?php
	 *    
	 *    $data = array('foo' =&gt; 'bar');
	 *    
	 *    if (!empty($_REQUEST['callback'])) {
	 *        header('Content-Type: application/javascript');
	 *        echo $_REQUEST['callback'] . '(';
	 *    }
	 *    
	 *    echo json_encode($data);
	 *    
	 *    if (!empty($_REQUEST['callback']) {
	 *        echo ');';
	 *    }
	 *    
	 *    ?&gt;
	 * 
	 * More information is available [here](http://en.wikipedia.org/wiki/JSONP). You can also use [JSONPLint](http://www.jsonplint.com) to test your JSONP.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members    The members to add to this class.
		 * @param   {boolean}                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.JsonP|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.JsonP;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members
		 * @returns {Ext.data.JsonP|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.JsonP;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  name
		 * @param   {object}                  member
		 * @returns {Ext.data.JsonP|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.JsonP;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  fn
		 * @param   {object}                  scope
		 * @returns {Ext.data.JsonP|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.JsonP;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.JsonPStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.JsonPStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from different domain JSON data easier.
	 * A JsonPStore will be automatically configured with a [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) and a [JsonPProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.JsonP.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.JsonPStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *    
	 *        // proxy configs
	 *        url: 'get-images.php',
	 *    
	 *        // reader configs
	 *        root: 'images',
	 *        fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    stcCallback({
	 *        images: [
	 *            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
	 *            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
	 *        ]
	 *    })
	 * 
	 * Where stcCallback is the callback name passed in the request to the remote domain. See [JsonPProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.JsonP.html)
	 * for details of how this works.
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#cfg-data) config option.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 members    The members to add to this class.
		 * @param   {boolean}                                                                                [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.JsonPStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.JsonPStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 members
		 * @returns {Ext.data.JsonPStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.JsonPStore;
		addStatics? (members: object): typeof Ext.data.Store;
		addStatics? (members: object): typeof Ext.data.ProxyStore;
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 name
		 * @param   {object}                                                                                 member
		 * @returns {Ext.data.JsonPStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.JsonPStore;
		addMember? (name: object, member: object): typeof Ext.data.Store;
		addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                 fn
		 * @param   {object}                                                                                 scope
		 * @returns {Ext.data.JsonPStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.JsonPStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.JsonStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.JsonStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from JSON data easier.
	 * A JsonStore will be automatically configured with a [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.JsonStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *    
	 *        proxy: {
	 *            type: 'ajax',
	 *            url: 'get-images.php',
	 *            reader: {
	 *                type: 'json',
	 *                rootProperty: 'images'
	 *            }
	 *        },
	 *    
	 *        //alternatively, a Model name can be given (see Ext.data.Store for an example)
	 *        fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    {
	 *        images: [
	 *            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
	 *            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
	 *        ]
	 *    }
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#cfg-data) config option.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                members    The members to add to this class.
		 * @param   {boolean}                                                                               [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                               [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.JsonStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.JsonStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                members
		 * @returns {Ext.data.JsonStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.JsonStore;
		addStatics? (members: object): typeof Ext.data.Store;
		addStatics? (members: object): typeof Ext.data.ProxyStore;
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                name
		 * @param   {object}                                                                                member
		 * @returns {Ext.data.JsonStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.JsonStore;
		addMember? (name: object, member: object): typeof Ext.data.Store;
		addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                fn
		 * @param   {object}                                                                                scope
		 * @returns {Ext.data.JsonStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.JsonStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.LocalStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.LocalStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html)
	 * A mixin that provides common store methods for [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) &amp; [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html).
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                 members    The members to add to this class.
		 * @param   {boolean}                                [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.LocalStore|Ext.Mixin|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.LocalStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Mixin;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                 members
		 * @returns {Ext.data.LocalStore|Ext.Mixin|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.LocalStore;
		addStatics? (members: object): typeof Ext.Mixin;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                 name
		 * @param   {object}                                 member
		 * @returns {Ext.data.LocalStore|Ext.Mixin|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.LocalStore;
		addMember? (name: object, member: object): typeof Ext.Mixin;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                 fn
		 * @param   {object}                                 scope
		 * @returns {Ext.data.LocalStore|Ext.Mixin|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.LocalStore;
		onExtended? (fn: object, scope: object): typeof Ext.Mixin;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.Model {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html)
	 * A Model or Entity represents some object that your application manages. For example, one
	 * might define a Model for Users, Products, Cars, or other real-world object that we want
	 * to model in the system. Models are used by [stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html), which are in
	 * turn used by many of the data-bound components in Ext.
	 * 
	 * # Fields
	 * 
	 * Models are defined as a set of fields and any arbitrary methods and properties relevant
	 * to the model. For example:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            {name: 'name',  type: 'string'},
	 *            {name: 'age',   type: 'int', convert: null},
	 *            {name: 'phone', type: 'string'},
	 *            {name: 'alive', type: 'boolean', defaultValue: true, convert: null}
	 *        ],
	 *    
	 *        changeName: function() {
	 *            var oldName = this.get('name'),
	 *                newName = oldName + " The Barbarian";
	 *    
	 *            this.set('name', newName);
	 *        }
	 *    });
	 * 
	 * Now we can create instances of our User model and call any model logic we defined:
	 * 
	 *    var user = Ext.create('User', {
	 *        id   : 'ABCD12345',
	 *        name : 'Conan',
	 *        age  : 24,
	 *        phone: '555-555-5555'
	 *    });
	 *    
	 *    user.changeName();
	 *    user.get('name'); //returns "Conan The Barbarian"
	 * 
	 * By default, the built in field types such as number and boolean coerce string values
	 * in the raw data by virtue of their [Ext.data.field.Field.convert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#method-convert) method.
	 * When the server can be relied upon to send data in a format that does not need to be
	 * converted, disabling this can improve performance. The [Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html)
	 * and [Array](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Array.html) readers are likely candidates for this
	 * optimization. To disable field conversions you simply specify `null` for the field's
	 * [convert config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-convert).
	 * 
	 * ## The "id" Field and `idProperty`
	 * 
	 * A Model definition always has an _identifying field_ which should yield a unique key
	 * for each instance. By default, a field named "id" will be created with a
	 * [mapping](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-mapping) of "id". This happens because of the default
	 * [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) provided in Model definitions.
	 * 
	 * To alter which field is the identifying field, use the [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) config.
	 * 
	 * # Validators
	 * 
	 * Models have built-in support for field validators. Validators are added to models as in
	 * the follow example:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            { name: 'name',     type: 'string' },
	 *            { name: 'age',      type: 'int' },
	 *            { name: 'phone',    type: 'string' },
	 *            { name: 'gender',   type: 'string' },
	 *            { name: 'username', type: 'string' },
	 *            { name: 'alive',    type: 'boolean', defaultValue: true }
	 *        ],
	 *    
	 *        validators: {
	 *            age: 'presence',
	 *            name: { type: 'length', min: 2 },
	 *            gender: { type: 'inclusion', list: ['Male', 'Female'] },
	 *            username: [
	 *                { type: 'exclusion', list: ['Admin', 'Operator'] },
	 *                { type: 'format', matcher: /([a-z]+)[0-9]{2,3}/i }
	 *            ]
	 *        }
	 *    });
	 * 
	 * The derived type of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) can also provide validation. If `validators`
	 * need to be duplicated on multiple fields, instead consider creating a custom field type.
	 * 
	 * ## Validation
	 * 
	 * The results of the validators can be retrieved via the "associated" validation record:
	 * 
	 *    var instance = Ext.create('User', {
	 *        name: 'Ed',
	 *        gender: 'Male',
	 *        username: 'edspencer'
	 *    });
	 *    
	 *    var validation = instance.getValidation();
	 * 
	 * The returned object is an instance of [`Ext.data.Validation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html) and has as its fields the
	 * result of the field `validators`. The validation object is "dirty" if there are one or
	 * more validation errors present.
	 * 
	 * This record is also available when using data binding as a "pseudo-association" called
	 * "validation". This pseudo-association can be hidden by an explicitly declared
	 * association by the same name (for compatibility reasons), but doing so is not
	 * recommended.
	 * 
	 * The `Ext.Component.modelValidation` config can be used to enable automatic
	 * binding from the "validation" of a record to the form fields that may be bound to its
	 * values.
	 * 
	 * # Associations
	 * 
	 * Models often have associations with other Models. These associations can be defined by
	 * fields (often called "foreign keys") or by other data such as a many-to-many (or "matrix").
	 * See [Ext.data.schema.Association](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Association.html) for information about configuring and using associations.
	 * 
	 * # Using a Proxy
	 * 
	 * Models are great for representing types of data and relationships, but sooner or later we're going to want to load or
	 * save that data somewhere. All loading and saving of data is handled via a [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html), which
	 * can be set directly on the Model:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email'],
	 *    
	 *        proxy: {
	 *            type: 'rest',
	 *            url : '/users'
	 *        }
	 *    });
	 * 
	 * Here we've set up a [Rest Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Rest.html), which knows how to load and save data to and from a
	 * RESTful backend. Let's see how this works:
	 * 
	 *    var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
	 *    
	 *    user.save(); //POST /users
	 * 
	 * Calling [save](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-save) on the new Model instance tells the configured RestProxy that we wish to persist this Model's
	 * data onto our server. RestProxy figures out that this Model hasn't been saved before because it doesn't have an id,
	 * and performs the appropriate action - in this case issuing a POST request to the url we configured (/users). We
	 * configure any Proxy on any Model and always follow this API - see [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) for a full list.
	 * 
	 * Loading data via the Proxy is accomplished with the static `load` method:
	 * 
	 *    //Uses the configured RestProxy to make a GET request to /users/123
	 *    User.load(123, {
	 *        success: function(user) {
	 *            console.log(user.getId()); //logs 123
	 *        }
	 *    });
	 * 
	 * Models can also be updated and destroyed easily:
	 * 
	 *    //the user Model we loaded in the last snippet:
	 *    user.set('name', 'Edward Spencer');
	 *    
	 *    //tells the Proxy to save the Model. In this case it will perform a PUT request to /users/123 as this Model already has an id
	 *    user.save({
	 *        success: function() {
	 *            console.log('The User was updated');
	 *        }
	 *    });
	 *    
	 *    //tells the Proxy to destroy the Model. Performs a DELETE request to /users/123
	 *    user.erase({
	 *        success: function() {
	 *            console.log('The User was destroyed!');
	 *        }
	 *    });
	 * 
	 * # HTTP Parameter names when using a [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html)
	 * 
	 * By default, the model ID is specified in an HTTP parameter named `id`. To change the
	 * name of this parameter use the Proxy's [idParam](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-idParam)
	 * configuration.
	 * 
	 * Parameters for other commonly passed values such as
	 * [page number](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-pageParam) or
	 * [start row](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-startParam) may also be configured.
	 * 
	 * # Usage in Stores
	 * 
	 * It is very common to want to load a set of Model instances to be displayed and manipulated in the UI. We do this by
	 * creating a [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html):
	 * 
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User'
	 *    });
	 *    
	 *    //uses the Proxy we set up on Model to load the Store data
	 *    store.load();
	 * 
	 * A Store is just a collection of Model instances - usually loaded from a server somewhere. Store can also maintain a
	 * set of added, updated and removed Model instances to be synchronized with the server via the Proxy. See the [Store docs](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) for more information on Stores.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * The default proxy to use for instances of this Model when no proxy is configured
		 * on the instance.  When specified, the model will use this proxy instead of
		 * requesting one from the [Session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html).
		 * 
		 * Can be a string "type", or a [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) config object.
		 * 
		 * This proxy is not inherited by subclasses.
		 * @property
		 * @protected (property)
		 * @static
		 * @default 'memory'
		 * @type {string|object}
		 */
		defaultProxy?: string | object;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members    The members to add to this class.
		 * @param   {boolean}                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Model|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Model;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members
		 * @returns {Ext.data.Model|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.Model;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Returns the configured Proxy for this Model.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {Ext.data.proxy.Proxy}  The proxy
		 */
		getProxy? (): Ext.data.proxy.Proxy;
		/** 
		 * Asynchronously loads a model instance by id. Any processing of the loaded
		 * record should be done in a callback.
		 * 
		 * Sample usage:
		 * 
		 *    Ext.define('MyApp.User', {
		 *        extend: 'Ext.data.Model',
		 *        fields: [
		 *            {name: 'id', type: 'int'},
		 *            {name: 'name', type: 'string'}
		 *        ]
		 *    });
		 *    
		 *    MyApp.User.load(10, {
		 *        scope: this,
		 *        failure: function(record, operation) {
		 *            //do something if the load failed
		 *        },
		 *        success: function(record, operation) {
		 *            //do something if the load succeeded
		 *        },
		 *        callback: function(record, operation, success) {
		 *            //do something whether the load succeeded or failed
		 *        }
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {number|string}                                         id
		 * The ID of the model to load.
		 * **NOTE:** The model returned must have an ID matching the param in the load
		 * request.
		 * @param   {object|Ext.data.Model.staticMethodParams.load.Options} [options]
		 * The options param is an
		 * [Ext.data.operation.Read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) config object containing success, failure and
		 * callback functions, plus optional scope.
		 * @param   {Ext.data.Session}                                      [session] The session for this record.
		 * @returns {Ext.data.Model}                                        
		 * The newly created model. Note that the model will
		 * (probably) still be loading once it is returned from this method. To do any
		 * post-processing on the data, the appropriate place to do see is in the
		 * callback.
		 */
		load? (id: number | string, options?: object | Ext.data.Model.staticMethodParams.load.Options, session?: Ext.data.Session): Ext.data.Model;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * Sets the Proxy to use for this model. Accepts any options that can be accepted by
		 * [Ext.createByAlias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-createByAlias).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object|Ext.data.proxy.Proxy} proxy The proxy
		 * @returns {Ext.data.proxy.Proxy}                     
		 */
		setProxy? (proxy: string | object | Ext.data.proxy.Proxy): Ext.data.proxy.Proxy;
		/** 
		 * This method adds the given set of fields to this model class.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {string[]|object[]} newFields
		 * The new fields to add. Based on the `name`
		 * of a field this may replace a previous field definition.
		 * @returns {void}                        
		 */
		addFields? (newFields: string[] | object[]): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Removes the given set of fields from this model.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {boolean|string[]} removeFields
		 * The names of fields to remove or `true`
		 * to remove all existing fields. Removes are processed first followed by adds so
		 * if a field name appears in `newFields` as well that field will effectively be
		 * added (however, in that case there is no need to include the field in this
		 * array).
		 * @returns {void}                          
		 */
		removeFields? (removeFields: boolean | string[]): void;
		/** 
		 * This method replaces the specified set of fields with a given set of new fields.
		 * Fields should normally be considered immutable, but if the timing is right (that
		 * is, before derived classes are declared), it is permissible to change the fields
		 * collection.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {string[]|object[]} newFields
		 * The new fields to add. Based on the `name`
		 * of a field this may replace a previous field definition.
		 * @param   {boolean|string[]}  removeFields
		 * The names of fields to remove or `true`
		 * to remove all existing fields. Removes are processed first followed by adds so
		 * if a field name appears in `newFields` as well that field will effectively be
		 * added (however, in that case there is no need to include the field in this
		 * array).
		 * @returns {void}                           
		 */
		replaceFields? (newFields: string[] | object[], removeFields: boolean | string[]): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  name
		 * @param   {object}                  member
		 * @returns {Ext.data.Model|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.Model;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} id
		 * @param   {object} data
		 * @param   {object} session
		 * @returns {void}           
		 */
		createWithId? (id: object, data: object, session: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @returns {void}        
		 */
		getField? (name: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		getFields? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		getFieldsMap? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} data
		 * @returns {void}        
		 */
		getIdFromData? (data: object): void;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  fn
		 * @param   {object}                  scope
		 * @returns {Ext.data.Model|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.Model;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.ModelManager {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.ModelManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ModelManager.html)
	 * This class has been deprecated. Use [`Ext.data.schema.Schema`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Schema.html) instead.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                         members    The members to add to this class.
		 * @param   {boolean}                        [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                        [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.ModelManager|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ModelManager;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                         members
		 * @returns {Ext.data.ModelManager|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.ModelManager;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                         name
		 * @param   {object}                         member
		 * @returns {Ext.data.ModelManager|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.ModelManager;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                         fn
		 * @param   {object}                         scope
		 * @returns {Ext.data.ModelManager|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.ModelManager;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.NodeInterface {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.NodeInterface](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html)
	 * This class is used as a set of methods that are applied to the prototype of a
	 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) to decorate it with a Node API. This means that models
	 * used in conjunction with a tree will have all of the tree related methods available
	 * on the model. In general, this class will not be used directly by the developer.
	 * 
	 * This class also creates extra [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) on the model, if they do
	 * not exist, to help maintain the tree state and UI. These fields are documented as
	 * config options.
	 * 
	 * The data fields used to render a tree node are: [text](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-text), [leaf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-leaf),
	 * [children](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-children), and [expanded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-expanded).  Once a node is loaded to the tree store
	 * you can use [get()](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-get) to fetch the value of a given field
	 * name (provided there is not a convenience accessor on the Node for that field).
	 * 
	 *    Ext.tip.QuickTipManager.init(); // not required when using Ext.application()
	 *    
	 *    var root = {
	 *        expanded: true,
	 *        children: [{
	 *            text: "Leaf node (&lt;i&gt;no folder/arrow icon&lt;/i&gt;)",
	 *            leaf: true,
	 *            qtitle: 'Sample Tip Title',
	 *            qtip: 'Tip body'
	 *        }, {
	 *            text: "Parent node expanded",
	 *            expanded: true,
	 *            children: [{
	 *                text: "Expanded leaf node 1",
	 *                leaf: true
	 *            }, {
	 *                text: "Expanded leaf node 2",
	 *                leaf: true
	 *            }]
	 *        }, {
	 *            text: "Parent node collapsed",
	 *            children: [{
	 *                text: "Collapsed leaf node 1",
	 *                leaf: true
	 *            }, {
	 *                text: "Collapsed leaf node 2",
	 *                leaf: true
	 *            }]
	 *        }]
	 *    };
	 *    
	 *    var tree = Ext.create('Ext.tree.Panel', {
	 *        title: 'TreePanel',
	 *        width: 260,
	 *        height: 200,
	 *        root: root,
	 *        rootVisible: false,
	 *        renderTo: document.body,
	 *        bbar: ['The first node ', {
	 *            text: 'is a leaf?',
	 *            handler: function () {
	 *                var firstChild = tree.getRootNode().getChildAt(0);
	 *                Ext.Msg.alert('Is Leaf?', firstChild.isLeaf());
	 *            }
	 *        }, {
	 *            text: 'has text?',
	 *            handler: function () {
	 *                var firstChild = tree.getRootNode().getChildAt(0);
	 *                Ext.Msg.alert('Has Text:', firstChild.get('text'));
	 *            }
	 *        }]
	 *    });
	 * 
	 * The following configs have methods used to set the value / state of the node at
	 * runtime:
	 * 
	 * **[children](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-children) / [leaf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-leaf)**
	 * 
	 * - [appendChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-appendChild)
	 * - [hasChildNodes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-hasChildNodes)
	 * - [insertBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertBefore)
	 * - [insertChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertChild)
	 * - [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-remove)
	 * - [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-removeAll)
	 * - [removeChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-removeChild)
	 * - [replaceChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-replaceChild)
	 * 
	 * **[expanded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-expanded)**
	 * 
	 * - [expand](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-expand)
	 * - [expandChildren](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-expandChildren)
	 * - [collapse](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-collapse)
	 * - [collapseChildren](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-collapseChildren)
	 * 
	 * The remaining configs may be set using [set()](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-set).
	 * 
	 *    node.set('text', 'Changed Text'); // example showing how to change the node label
	 * 
	 * The [qtip](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtip), [qtitle](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtitle), and [qshowDelay](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qshowDelay) use QuickTips and
	 * requires initializing Ext.tip.QuickTipManager unless the application is
	 * created using [Ext.application](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-application).
	 * 
	 *    Ext.tip.QuickTipManager.init();
	 * 
	 * For additional information and examples see the description for
	 * Ext.tree.Panel.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members    The members to add to this class.
		 * @param   {boolean}                         [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                         [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.NodeInterface|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.NodeInterface;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                          members
		 * @returns {Ext.data.NodeInterface|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.NodeInterface;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * This method allows you to decorate a Model's class to implement the NodeInterface.
		 * This adds a set of methods, new events, new properties and new fields on every Record.
		 * @method
		 * @public (method)
		 * @static
		 * @param   {Ext.Class|Ext.data.Model} model
		 * The Model class or an instance of the Model class you want to
		 * decorate the prototype of.
		 * @returns {void}                           
		 */
		decorate? (model: Ext.Class | Ext.data.Model): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          name
		 * @param   {object}                          member
		 * @returns {Ext.data.NodeInterface|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.NodeInterface;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                          fn
		 * @param   {object}                          scope
		 * @returns {Ext.data.NodeInterface|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.NodeInterface;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.NodeStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.NodeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeStore.html)
	 * Node Store
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                members    The members to add to this class.
		 * @param   {boolean}                                                                               [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                               [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.NodeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.NodeStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                members
		 * @returns {Ext.data.NodeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.NodeStore;
		addStatics? (members: object): typeof Ext.data.Store;
		addStatics? (members: object): typeof Ext.data.ProxyStore;
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                name
		 * @param   {object}                                                                                member
		 * @returns {Ext.data.NodeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.NodeStore;
		addMember? (name: object, member: object): typeof Ext.data.Store;
		addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                fn
		 * @param   {object}                                                                                scope
		 * @returns {Ext.data.NodeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.NodeStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.PageMap {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.PageMap](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.PageMap.html)
	 * Private class for use by only Store when configured `buffered: true`.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                       members    The members to add to this class.
		 * @param   {boolean}                                                      [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                      [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.PageMap|Ext.util.LruCache|Ext.util.HashMap|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.PageMap;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.util.LruCache;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.util.HashMap;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                       members
		 * @returns {Ext.data.PageMap|Ext.util.LruCache|Ext.util.HashMap|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.PageMap;
		addStatics? (members: object): typeof Ext.util.LruCache;
		addStatics? (members: object): typeof Ext.util.HashMap;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                       name
		 * @param   {object}                                                       member
		 * @returns {Ext.data.PageMap|Ext.util.LruCache|Ext.util.HashMap|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.PageMap;
		addMember? (name: object, member: object): typeof Ext.util.LruCache;
		addMember? (name: object, member: object): typeof Ext.util.HashMap;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                       fn
		 * @param   {object}                                                       scope
		 * @returns {Ext.data.PageMap|Ext.util.LruCache|Ext.util.HashMap|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.PageMap;
		onExtended? (fn: object, scope: object): typeof Ext.util.LruCache;
		onExtended? (fn: object, scope: object): typeof Ext.util.HashMap;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.ProxyStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.ProxyStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html)
	 * ProxyStore is a superclass of [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) and [Ext.data.BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html). It's never used directly,
	 * but offers a set of methods used by both of those subclasses.
	 * 
	 * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
	 * you're probably looking for is [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html). If you're still interested, here's a brief description of what
	 * ProxyStore is and is not.
	 * 
	 * ProxyStore provides the basic configuration for anything that can be considered a Store. It expects to be
	 * given a [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) that represents the type of data in the Store. It also expects to be given a
	 * [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) that handles the loading of data into the Store.
	 * 
	 * ProxyStore provides a few helpful methods such as [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) and [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync), which load and save data
	 * respectively, passing the requests through the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
	 * 
	 * Built-in Store subclasses add extra behavior to each of these functions. Note also that each ProxyStore subclass
	 * has its own way of storing data - in [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) the data is saved as a flat [Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html),
	 * whereas in [BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html) we use a [Ext.data.PageMap](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.PageMap.html) to maintain a client side cache of pages of records.
	 * 
	 * The store provides filtering and sorting support. This sorting/filtering can happen on the client side
	 * or can be completed on the server. This is controlled by the [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) and
	 * [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteFilter) config options. For more information see the [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sort) and
	 * [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) methods.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members    The members to add to this class.
		 * @param   {boolean}                                             [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                             [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              members
		 * @returns {Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.ProxyStore;
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              name
		 * @param   {object}                                              member
		 * @returns {Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                              fn
		 * @param   {object}                                              scope
		 * @returns {Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.Request {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.Request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html)
	 * Simple class that represents a Request that will be made by any [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Server.html) subclass.
	 * All this class does is standardize the representation of a Request as used by any ServerProxy subclass,
	 * it does not contain any actual logic or perform the request itself.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                    members    The members to add to this class.
		 * @param   {boolean}                   [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                   [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Request|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Request;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                    members
		 * @returns {Ext.data.Request|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.Request;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                    name
		 * @param   {object}                    member
		 * @returns {Ext.data.Request|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.Request;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                    fn
		 * @param   {object}                    scope
		 * @returns {Ext.data.Request|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.Request;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.ResultSet {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.ResultSet](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html)
	 * Simple wrapper class that represents a set of records returned by a Proxy.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                      members    The members to add to this class.
		 * @param   {boolean}                     [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                     [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.ResultSet|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ResultSet;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                      members
		 * @returns {Ext.data.ResultSet|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.ResultSet;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                      name
		 * @param   {object}                      member
		 * @returns {Ext.data.ResultSet|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.ResultSet;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                      fn
		 * @param   {object}                      scope
		 * @returns {Ext.data.ResultSet|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.ResultSet;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.Session {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.Session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html)
	 * This class manages models and their associations. Instances of `Session` are typically
	 * associated with some `Component` (perhaps the Viewport or a Window) and then used by
	 * their [`view models`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.app.ViewModel.html) to enable data binding.
	 * 
	 * The primary job of a Session is to manage a collection of records of many different
	 * types and their associations. This often starts by loading records when requested (via
	 * bind - see below) and culminates when it is time to save to the server.
	 * 
	 * Because the Session tracks all records it loads, it ensures that for any given type of
	 * model, only one record exists with a given `id`. This means that all edits of that
	 * record are properly targeted at that one instance.
	 * 
	 * Similarly, when associations are loaded, the [`Ext.data.Store`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) created to hold the
	 * associated records is tracked by the Session. So all requests for the "OrderItems" of
	 * a particular Order id will result in the same Store. Adding and removing items from
	 * that Order then is sure to remain consistent.
	 * 
	 * # Data
	 * 
	 * Since the Session is managing all this data, there are several methods it provides
	 * to give convenient access to that data. The most important of these is `update` and
	 * `getChanges`.
	 * 
	 * The `update` and `getChanges` methods both operate on object that contains a summary
	 * of records and associations and different CRUD operations.
	 * 
	 * ## Saving
	 * 
	 * There are two basic ways to save the contents of a Session: `getChanges` and
	 * `getSaveBatch`. We've already seen `getChanges`. The data contained in the CRUD object
	 * can be translated into whatever shape is needed by the server.
	 * 
	 * To leverage the [`proxy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-proxy) facilities defined by each Model
	 * class, there is the `getSaveBatch` method. That method returns an [`Ext.data.Batch`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html)
	 * object populated with the necessary `create`, `update` and `destory` operations to
	 * save all of the changes in the Session.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                    members    The members to add to this class.
		 * @param   {boolean}                   [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                   [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Session|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Session;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                    members
		 * @returns {Ext.data.Session|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.Session;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                    name
		 * @param   {object}                    member
		 * @returns {Ext.data.Session|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.Session;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                    fn
		 * @param   {object}                    scope
		 * @returns {Ext.data.Session|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.Session;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.SortTypes {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.SortTypes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.SortTypes.html)
	 * This class defines a series of static methods that are used on a
	 * [Ext.data.Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) for performing sorting. The methods cast the
	 * underlying values into a data type that is appropriate for sorting on
	 * that particular field.  If a [Ext.data.Field.type](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#property-type) is specified,
	 * the sortType will be set to a sane default if the sortType is not
	 * explicitly defined on the field. The sortType will make any necessary
	 * modifications to the value and return it.
	 * 
	 * - **`asText`** - Removes any tags and converts the value to a string
	 * - **`asUCText`** - Removes any tags and converts the value to an uppercase string
	 * - **`asUCText`** - Converts the value to an uppercase string
	 * - **`asDate`** - Converts the value into Unix epoch time
	 * - **`asFloat`** - Converts the value to a floating point number
	 * - **`asInt`** - Converts the value to an integer number
	 * 
	 * It is also possible to create a custom sortType that can be used throughout
	 * an application.
	 * 
	 *     Ext.apply(Ext.data.SortTypes, {
	 *         asPerson: function(person){
	 *             // expects an object with a first and last name property
	 *             return person.lastName.toUpperCase() + person.firstName.toLowerCase();
	 *         }
	 *     });
	 *    
	 *     Ext.define('Employee', {
	 *         extend: 'Ext.data.Model',
	 *         fields: [{
	 *             name: 'person',
	 *             sortType: 'asPerson'
	 *         }, {
	 *             name: 'salary',
	 *             type: 'float' // sortType set to asFloat
	 *         }]
	 *     });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                      members    The members to add to this class.
		 * @param   {boolean}                     [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                     [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.SortTypes|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.SortTypes;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                      members
		 * @returns {Ext.data.SortTypes|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.SortTypes;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                      name
		 * @param   {object}                      member
		 * @returns {Ext.data.SortTypes|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.SortTypes;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                      fn
		 * @param   {object}                      scope
		 * @returns {Ext.data.SortTypes|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.SortTypes;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.Store {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
	 * The Store class encapsulates a client side cache of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) objects. Stores load data via a
	 * [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html), and also provide functions for [sorting](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort), [filtering](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter)
	 * and querying the [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances contained within it.
	 * 
	 * Creating a Store is easy - we just tell it the Model and the Proxy to use for loading and saving its data:
	 * 
	 *     // Set up a model to use in our Store
	 *     Ext.define('User', {
	 *         extend: 'Ext.data.Model',
	 *         fields: [
	 *             {name: 'firstName', type: 'string'},
	 *             {name: 'lastName',  type: 'string'},
	 *             {name: 'age',       type: 'int'},
	 *             {name: 'eyeColor',  type: 'string'}
	 *         ]
	 *     });
	 *    
	 *     var myStore = Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         proxy: {
	 *             type: 'ajax',
	 *             url: '/users.json',
	 *             reader: {
	 *                 type: 'json',
	 *                 rootProperty: 'users'
	 *             }
	 *         },
	 *         autoLoad: true
	 *     });
	 * 
	 * In the example above we configured an AJAX proxy to load data from the url '/users.json'. We told our Proxy to use a
	 * [JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) to parse the response from the server into Model object - [see the docs on JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) for details.
	 * 
	 * ## Inline data
	 * 
	 * Stores can also load data inline. Internally, Store converts each of the objects we pass in as [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-data) into
	 * Model instances:
	 * 
	 *     Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         data : [
	 *             {firstName: 'Peter',   lastName: 'Venkman'},
	 *             {firstName: 'Egon',    lastName: 'Spengler'},
	 *             {firstName: 'Ray',     lastName: 'Stantz'},
	 *             {firstName: 'Winston', lastName: 'Zeddemore'}
	 *         ]
	 *     });
	 * 
	 * Loading inline data using the method above is great if the data is in the correct format already (e.g. it doesn't
	 * need to be processed by a [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html)). If your inline data requires processing to decode
	 * the data structure, use a [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) instead (see the [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) docs for an example).
	 * 
	 * Additional data can also be loaded locally using [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
	 * 
	 * ## Dynamic Loading
	 * 
	 * Stores can be dynamically updated by calling the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load) method:
	 * 
	 *    store.load({
	 *        params: {
	 *            group: 3,
	 *            type: 'user'
	 *        },
	 *        callback: function(records, operation, success) {
	 *            // do something after the load finishes
	 *        },
	 *        scope: this
	 *    });
	 * 
	 * Here a bunch of arbitrary parameters is passed along with the load request and a callback function is set
	 * up to do something after the loading is over.
	 * 
	 * ## Loading Nested Data
	 * 
	 * Applications often need to load sets of associated data - for example a CRM system might load a User and her Orders.
	 * Instead of issuing an AJAX request for the User and a series of additional AJAX requests for each Order, we can load
	 * a nested dataset and allow the Reader to automatically populate the associated models. Below is a brief example, see
	 * the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) intro docs for a full explanation:
	 * 
	 *     var store = Ext.create('Ext.data.Store', {
	 *         autoLoad: true,
	 *         model: "User",
	 *         proxy: {
	 *             type: 'ajax',
	 *             url: 'users.json',
	 *             reader: {
	 *                 type: 'json',
	 *                 rootProperty: 'users'
	 *             }
	 *         }
	 *     });
	 * 
	 * Which would consume a response like this:
	 * 
	 *     {
	 *         "users": [{
	 *             "id": 1,
	 *             "name": "Peter",
	 *             "orders": [{
	 *                 "id": 10,
	 *                 "total": 10.76,
	 *                 "status": "invoiced"
	 *            },{
	 *                 "id": 11,
	 *                 "total": 13.45,
	 *                 "status": "shipped"
	 *            }]
	 *         }]
	 *     }
	 * 
	 * See the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) intro docs for a full explanation.
	 * 
	 * ## Filtering and Sorting
	 * 
	 * Stores can be sorted and filtered - in both cases either remotely or locally. The [sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-sorters) and
	 * [filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-filters) are held inside [Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) instances to make them easy to manage.
	 * Usually it is sufficient to either just specify sorters and filters in the Store configuration or call [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort)
	 * or [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter):
	 * 
	 *     var store = Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         sorters: [{
	 *             property: 'age',
	 *             direction: 'DESC'
	 *         }, {
	 *             property: 'firstName',
	 *             direction: 'ASC'
	 *         }],
	 *    
	 *         filters: [{
	 *             property: 'firstName',
	 *             value: /Peter/
	 *         }]
	 *     });
	 * 
	 * The new Store will keep the configured sorters and filters in the Collection instances mentioned above. By
	 * default, sorting and filtering are both performed locally by the Store - see [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) and
	 * [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteFilter) to allow the server to perform these operations instead.
	 * 
	 * Filtering and sorting after the Store has been instantiated is also easy. Calling [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) adds another filter
	 * to the Store and automatically filters the dataset (calling [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) with no arguments simply re-applies all
	 * existing filters).
	 * 
	 *    store.filter('eyeColor', 'Brown');
	 * 
	 * Change the sorting at any time by calling [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort):
	 * 
	 *    store.sort('height', 'ASC');
	 * 
	 * Note that all existing sorters will be removed in favor of the new sorter data (if [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort) is called with no
	 * arguments, the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new
	 * ones, just add them to the Collection:
	 * 
	 *    store.sorters.add(new Ext.util.Sorter({
	 *        property : 'shoeSize',
	 *        direction: 'ASC'
	 *    }));
	 *    
	 *    store.sort();
	 * 
	 * ## Registering with StoreManager
	 * 
	 * Any Store that is instantiated with a [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-storeId) will automatically be registered with the [StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html). This makes it easy to reuse the same store in multiple views:
	 * 
	 *    //this store can be used several times
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        storeId: 'usersStore'
	 *    });
	 *    
	 *    new Ext.List({
	 *        store: 'usersStore',
	 *        //other config goes here
	 *    });
	 *    
	 *    new Ext.view.View({
	 *        store: 'usersStore',
	 *        //other config goes here
	 *    });
	 * 
	 * ## Further Reading
	 * 
	 * Stores are backed up by an ecosystem of classes that enables their operation. To gain a full understanding of these
	 * pieces and how they fit together, see:
	 * 
	 * - [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) - overview of what Proxies are and how they are used
	 * - [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) - the core class in the data package
	 * - [Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) - used by any subclass of [ServerProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Server.html) to read a response
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                             members    The members to add to this class.
		 * @param   {boolean}                                                            [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                            [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                             members
		 * @returns {Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.Store;
		addStatics? (members: object): typeof Ext.data.ProxyStore;
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                             name
		 * @param   {object}                                                             member
		 * @returns {Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.Store;
		addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                             fn
		 * @param   {object}                                                             scope
		 * @returns {Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.StoreManager {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html)
	 * Contains a collection of all stores that are created that have an identifier. An identifier can be assigned by
	 * setting the [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId) property. When a store is in the StoreManager, it can be
	 * referred to via it's identifier:
	 * 
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'SomeModel',
	 *        storeId: 'myStore'
	 *    });
	 *    
	 *    var store = Ext.data.StoreManager.lookup('myStore');
	 * 
	 * Also note that the [lookup](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html#method-lookup) method is aliased to [Ext.getStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-getStore) for convenience.
	 * 
	 * If a store is registered with the StoreManager, you can also refer to the store by it's identifier when registering
	 * it with any Component that consumes data from a store:
	 * 
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'SomeModel',
	 *        storeId: 'myStore'
	 *    });
	 *    
	 *    Ext.create('Ext.view.View', {
	 *        store: 'myStore',
	 *        // other configuration here
	 *    });
	 * 
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                   members    The members to add to this class.
		 * @param   {boolean}                                                                                  [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                                  [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.StoreManager|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.StoreManager;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.util.MixedCollection;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.util.AbstractMixedCollection;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                   members
		 * @returns {Ext.data.StoreManager|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.StoreManager;
		addStatics? (members: object): typeof Ext.util.MixedCollection;
		addStatics? (members: object): typeof Ext.util.AbstractMixedCollection;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                   name
		 * @param   {object}                                                                                   member
		 * @returns {Ext.data.StoreManager|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.StoreManager;
		addMember? (name: object, member: object): typeof Ext.util.MixedCollection;
		addMember? (name: object, member: object): typeof Ext.util.AbstractMixedCollection;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                   fn
		 * @param   {object}                                                                                   scope
		 * @returns {Ext.data.StoreManager|Ext.util.MixedCollection|Ext.util.AbstractMixedCollection|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.StoreManager;
		onExtended? (fn: object, scope: object): typeof Ext.util.MixedCollection;
		onExtended? (fn: object, scope: object): typeof Ext.util.AbstractMixedCollection;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.TreeModel {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.TreeModel](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html)
	 * This class is used as a base class from which to derive Models used in Trees.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * @property
		 * @private (property)
		 * @static
		 * @default 'memory'
		 * @type {string}
		 */
		defaultProxy?: string;
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                     members    The members to add to this class.
		 * @param   {boolean}                                    [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                    [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.TreeModel|Ext.data.Model|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.TreeModel;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Model;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                     members
		 * @returns {Ext.data.TreeModel|Ext.data.Model|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.TreeModel;
		addStatics? (members: object): typeof Ext.data.Model;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Returns the configured Proxy for this Model.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {Ext.data.proxy.Proxy}  The proxy
		 */
		getProxy? (): Ext.data.proxy.Proxy;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * Sets the Proxy to use for this model. Accepts any options that can be accepted by
		 * [Ext.createByAlias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-createByAlias).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object|Ext.data.proxy.Proxy} proxy The proxy
		 * @returns {Ext.data.proxy.Proxy}                     
		 */
		setProxy? (proxy: string | object | Ext.data.proxy.Proxy): Ext.data.proxy.Proxy;
		/** 
		 * This method adds the given set of fields to this model class.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {string[]|object[]} newFields
		 * The new fields to add. Based on the `name`
		 * of a field this may replace a previous field definition.
		 * @returns {void}                        
		 */
		addFields? (newFields: string[] | object[]): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Removes the given set of fields from this model.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {boolean|string[]} removeFields
		 * The names of fields to remove or `true`
		 * to remove all existing fields. Removes are processed first followed by adds so
		 * if a field name appears in `newFields` as well that field will effectively be
		 * added (however, in that case there is no need to include the field in this
		 * array).
		 * @returns {void}                          
		 */
		removeFields? (removeFields: boolean | string[]): void;
		/** 
		 * This method replaces the specified set of fields with a given set of new fields.
		 * Fields should normally be considered immutable, but if the timing is right (that
		 * is, before derived classes are declared), it is permissible to change the fields
		 * collection.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {string[]|object[]} newFields
		 * The new fields to add. Based on the `name`
		 * of a field this may replace a previous field definition.
		 * @param   {boolean|string[]}  removeFields
		 * The names of fields to remove or `true`
		 * to remove all existing fields. Removes are processed first followed by adds so
		 * if a field name appears in `newFields` as well that field will effectively be
		 * added (however, in that case there is no need to include the field in this
		 * array).
		 * @returns {void}                           
		 */
		replaceFields? (newFields: string[] | object[], removeFields: boolean | string[]): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                     name
		 * @param   {object}                                     member
		 * @returns {Ext.data.TreeModel|Ext.data.Model|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.TreeModel;
		addMember? (name: object, member: object): typeof Ext.data.Model;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} id
		 * @param   {object} data
		 * @param   {object} session
		 * @returns {void}           
		 */
		createWithId? (id: object, data: object, session: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @returns {void}        
		 */
		getField? (name: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		getFields? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		getFieldsMap? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} data
		 * @returns {void}        
		 */
		getIdFromData? (data: object): void;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                     fn
		 * @param   {object}                                     scope
		 * @returns {Ext.data.TreeModel|Ext.data.Model|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.TreeModel;
		onExtended? (fn: object, scope: object): typeof Ext.data.Model;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.TreeStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html)
	 * The TreeStore is a store implementation that owns the [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root) of
	 * a tree, and provides methods to load either local or remote data as child nodes of the root
	 * and any descendant non-leaf node.
	 * 
	 * The TreeStore must be used as the store of a tree panel.
	 * 
	 * This class also relays many node events from the underlying node structure.
	 * 
	 * # Using Models
	 * 
	 * If no Model is specified, an implicit model will be created that extends [Ext.data.TreeModel](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html).
	 * The standard Tree fields will also be copied onto the Model for maintaining their state. These fields are listed
	 * in the [Ext.data.NodeInterface](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html) documentation.
	 * 
	 * # Reading Nested Data
	 * 
	 * For the tree to read nested data, the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) must be configured with a root property,
	 * so the reader can find nested data for each node (if a root is not specified, it will default to
	 * 'children'). This will tell the tree to look for any nested tree nodes by the same keyword, i.e., 'children'.
	 * If a root is specified in the config make sure that any nested nodes with children have the same name.
	 * 
	 * **Note:** Setting [defaultRootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-defaultRootProperty) accomplishes the same thing.
	 * 
	 * # rootProperty as a Function
	 * 
	 * You can pass a function as the data reader's rootProperty when the tree's dataset has
	 * mixed root properties. Child nodes can then be programmatically determined at read time.
	 * 
	 * For example, the child nodes may be passed via the 'children' property
	 * name, though you may have a top-level root property of 'items'.
	 * 
	 * See [rootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-rootProperty) for more information.
	 * 
	 * # Filtering
	 * 
	 * Filtering of nodes in a TreeStore is hierarchically top down by default. This means that if a non-leaf node does not
	 * pass the filter, then it, and all its descendants are filtered _out_ of the store.
	 * 
	 * To reverse this, so that any node which passes the filter causes all its ancestors to be visible, configure
	 * the `TreeStore` with '[filterer: 'bottomup'`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-filterer)
	 * 
	 * You may also programatically filter individual tree nodes by setting their `'visible'` field.
	 * 
	 * Setting this to `false` filters the node out so that it will not appear in the UI. Setting it to `true`
	 * filters the node in.
	 * 
	 * Note that if performing several filter operations, it is best to [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-suspendEvents)
	 * on the store first, and when all nodes have been modified, [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-resumeEvents) and fire the
	 * [refresh](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#event-refresh) event on the store.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                members    The members to add to this class.
		 * @param   {boolean}                                                                               [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                               [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.TreeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.TreeStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                members
		 * @returns {Ext.data.TreeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.TreeStore;
		addStatics? (members: object): typeof Ext.data.Store;
		addStatics? (members: object): typeof Ext.data.ProxyStore;
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                name
		 * @param   {object}                                                                                member
		 * @returns {Ext.data.TreeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.TreeStore;
		addMember? (name: object, member: object): typeof Ext.data.Store;
		addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                                fn
		 * @param   {object}                                                                                scope
		 * @returns {Ext.data.TreeStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.TreeStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.Types {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.Types](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Types.html)
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members    The members to add to this class.
		 * @param   {boolean}                 [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                 [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Types|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Types;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                  members
		 * @returns {Ext.data.Types|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.Types;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  name
		 * @param   {object}                  member
		 * @returns {Ext.data.Types|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.Types;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                  fn
		 * @param   {object}                  scope
		 * @returns {Ext.data.Types|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.Types;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.Validation {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.Validation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html)
	 * This class is used to hold validation errors for a record. The results of the record's
	 * [`validators`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-validators) are stored as the field values of this
	 * record. The first failed validation is all that is stored per field unless the Model
	 * class has defined a `validationSeparator` config.
	 * 
	 * Application code will not need to interact with this class specifically but rather just
	 * view the validation as a record.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                      members    The members to add to this class.
		 * @param   {boolean}                                     [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                     [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.Validation|Ext.data.Model|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Validation;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Model;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                      members
		 * @returns {Ext.data.Validation|Ext.data.Model|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.Validation;
		addStatics? (members: object): typeof Ext.data.Model;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Returns the configured Proxy for this Model.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {Ext.data.proxy.Proxy}  The proxy
		 */
		getProxy? (): Ext.data.proxy.Proxy;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * Sets the Proxy to use for this model. Accepts any options that can be accepted by
		 * [Ext.createByAlias](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-createByAlias).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object|Ext.data.proxy.Proxy} proxy The proxy
		 * @returns {Ext.data.proxy.Proxy}                     
		 */
		setProxy? (proxy: string | object | Ext.data.proxy.Proxy): Ext.data.proxy.Proxy;
		/** 
		 * This method adds the given set of fields to this model class.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {string[]|object[]} newFields
		 * The new fields to add. Based on the `name`
		 * of a field this may replace a previous field definition.
		 * @returns {void}                        
		 */
		addFields? (newFields: string[] | object[]): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Removes the given set of fields from this model.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {boolean|string[]} removeFields
		 * The names of fields to remove or `true`
		 * to remove all existing fields. Removes are processed first followed by adds so
		 * if a field name appears in `newFields` as well that field will effectively be
		 * added (however, in that case there is no need to include the field in this
		 * array).
		 * @returns {void}                          
		 */
		removeFields? (removeFields: boolean | string[]): void;
		/** 
		 * This method replaces the specified set of fields with a given set of new fields.
		 * Fields should normally be considered immutable, but if the timing is right (that
		 * is, before derived classes are declared), it is permissible to change the fields
		 * collection.
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {string[]|object[]} newFields
		 * The new fields to add. Based on the `name`
		 * of a field this may replace a previous field definition.
		 * @param   {boolean|string[]}  removeFields
		 * The names of fields to remove or `true`
		 * to remove all existing fields. Removes are processed first followed by adds so
		 * if a field name appears in `newFields` as well that field will effectively be
		 * added (however, in that case there is no need to include the field in this
		 * array).
		 * @returns {void}                           
		 */
		replaceFields? (newFields: string[] | object[], removeFields: boolean | string[]): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                      name
		 * @param   {object}                                      member
		 * @returns {Ext.data.Validation|Ext.data.Model|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.Validation;
		addMember? (name: object, member: object): typeof Ext.data.Model;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} id
		 * @param   {object} data
		 * @param   {object} session
		 * @returns {void}           
		 */
		createWithId? (id: object, data: object, session: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @returns {void}        
		 */
		getField? (name: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		getFields? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		getFieldsMap? (): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} data
		 * @returns {void}        
		 */
		getIdFromData? (data: object): void;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                      fn
		 * @param   {object}                                      scope
		 * @returns {Ext.data.Validation|Ext.data.Model|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.Validation;
		onExtended? (fn: object, scope: object): typeof Ext.data.Model;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.XmlStore {
	/** 
	 * @statics
	 * Class static members interface: 
	 * [Ext.data.XmlStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from XML data easier.
	 * A XmlStore will be automatically configured with a [Ext.data.reader.Xml](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Xml.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.XmlStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *        url: 'sheldon.xml', // automatically configures a HttpProxy
	 *        // reader configs
	 *        record: 'Item', // records will have an "Item" tag
	 *        idPath: 'ASIN',
	 *        totalRecords: '@TotalResults'
	 *        fields: [
	 *            // set up the fields mapping into the xml doc
	 *            // The first needs mapping, the others are very basic
	 *            {name: 'Author', mapping: 'ItemAttributes > Author'},
	 *            'Title', 'Manufacturer', 'ProductGroup'
	 *        ]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    &#60?xml version="1.0" encoding="UTF-8"?>
	 *    &#60ItemSearchResponse xmlns="http://webservices.amazon.com/AWSECommerceService/2009-05-15">
	 *        &#60Items>
	 *            &#60Request>
	 *                &#60IsValid>True&#60/IsValid>
	 *                &#60ItemSearchRequest>
	 *                    &#60Author>Sidney Sheldon&#60/Author>
	 *                    &#60SearchIndex>Books&#60/SearchIndex>
	 *                &#60/ItemSearchRequest>
	 *            &#60/Request>
	 *            &#60TotalResults>203&#60/TotalResults>
	 *            &#60TotalPages>21&#60/TotalPages>
	 *            &#60Item>
	 *                &#60ASIN>0446355453&#60/ASIN>
	 *                &#60DetailPageURL>
	 *                    http://www.amazon.com/
	 *                &#60/DetailPageURL>
	 *                &#60ItemAttributes>
	 *                    &#60Author>Sidney Sheldon&#60/Author>
	 *                    &#60Manufacturer>Warner Books&#60/Manufacturer>
	 *                    &#60ProductGroup>Book&#60/ProductGroup>
	 *                    &#60Title>Master of the Game&#60/Title>
	 *                &#60/ItemAttributes>
	 *            &#60/Item>
	 *        &#60/Items>
	 *    &#60/ItemSearchResponse>
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#cfg-data) config option.
	 * 
	 * **Note:** This class accepts all of the configuration options of
	 * **[XmlReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Xml.html)**.
	 */
	interface Statics extends Ext.base.Statics {
		/** 
		 * Add methods / properties to the prototype of this class.
		 * 
		 *    Ext.define('My.awesome.Cat', {
		 *        constructor: function() {
		 *            ...
		 *        }
		 *    });
		 *    
		 *     My.awesome.Cat.addMembers({
		 *         meow: function() {
		 *            alert('Meowww...');
		 *         }
		 *     });
		 *    
		 *     var kitty = new My.awesome.Cat();
		 *     kitty.meow();
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                               members    The members to add to this class.
		 * @param   {boolean}                                                                              [isStatic] Pass `true` if the members are static.
		 * @param   {boolean}                                                                              [privacy]
		 * Pass `true` if the members are private. This
		 * only has meaning in debug mode and only for methods.
		 * @returns {Ext.data.XmlStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}            
		 */
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.XmlStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.Store;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.ProxyStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.data.AbstractStore;
		addMembers? (members: object, isStatic?: boolean, privacy?: boolean): typeof Ext.Base;
		/** 
		 * Add / override static properties of this class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.addStatics({
		 *        someProperty: 'someValue',      // My.cool.Class.someProperty = 'someValue'
		 *        method1: function() { ... },    // My.cool.Class.method1 = function() { ... };
		 *        method2: function() { ... }     // My.cool.Class.method2 = function() { ... };
		 *    });
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                               members
		 * @returns {Ext.data.XmlStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}         this
		 */
		addStatics? (members: object): typeof Ext.data.XmlStore;
		addStatics? (members: object): typeof Ext.data.Store;
		addStatics? (members: object): typeof Ext.data.ProxyStore;
		addStatics? (members: object): typeof Ext.data.AbstractStore;
		addStatics? (members: object): typeof Ext.Base;
		/** 
		 * Create a new instance of this Class.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        ...
		 *    });
		 *    
		 *    My.cool.Class.create({
		 *        someConfig: true
		 *    });
		 * 
		 * All parameters are passed to the constructor of the class.
		 * @method
		 * @public (method)
		 * @static
		 * @returns {object}  the created instance.
		 */
		create? (): object;
		/** 
		 * Create aliases for existing prototype methods. Example:
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        method1: function() { ... },
		 *        method2: function() { ... }
		 *    });
		 *    
		 *    var test = new My.cool.Class();
		 *    
		 *    My.cool.Class.createAlias({
		 *        method3: 'method1',
		 *        method4: 'method2'
		 *    });
		 *    
		 *    test.method3(); // test.method1()
		 *    
		 *    My.cool.Class.createAlias('method5', 'method3');
		 *    
		 *    test.method5(); // test.method3() -&gt; test.method1()
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @param   {string|object} alias
		 * The new method name, or an object to set multiple aliases. See
		 * [flexSetter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-flexSetter)
		 * @param   {string|object} origin The original method name
		 * @returns {void}                 
		 */
		createAlias? (alias: string | object, origin: string | object): void;
		/** 
		 * Get the current class' name in string format.
		 * 
		 *    Ext.define('My.cool.Class', {
		 *        constructor: function() {
		 *            alert(this.self.getName()); // alerts 'My.cool.Class'
		 *        }
		 *    });
		 *    
		 *    My.cool.Class.getName(); // 'My.cool.Class'
		 * 
		 * @method
		 * @public (method)
		 * @static
		 * @returns {string}  className
		 */
		getName? (): string;
		/** 
		 * Override members of this class. Overridden methods can be invoked via
		 * [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent).
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * Direct use of this method should be rare. Use [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)
		 * instead:
		 * 
		 *    Ext.define('My.CatOverride', {
		 *        override: 'My.Cat',
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callParent(arguments);
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 * 
		 * The above accomplishes the same result but can be managed by the [Ext.Loader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Loader.html)
		 * which can properly order the override and its target class and the build process
		 * can determine whether the override is needed based on the required state of the
		 * target class (My.Cat).
		 * @method
		 * @public (method)
		 * @static
		 * @param   {object}   members
		 * The properties to add to this class. This should be
		 * specified as an object literal containing one or more properties.
		 * @returns {Ext.Base}         this class
		 */
		override? (members: object): Ext.Base;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callParent? (args: object): void;
		/** 
		 * @method
		 * @protected (method)
		 * @static
		 * @param   {object} args
		 * @returns {void}        
		 */
		callSuper? (args: object): void;
		/** 
		 * Adds new config properties to this class. This is called for classes when they
		 * are declared, then for any mixins that class may define and finally for any
		 * overrides defined that target the class.
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object}    config
		 * @param   {Ext.Class} [mixinClass] The mixin class if the configs are from a mixin.
		 * @returns {void}                   
		 */
		addConfig? (config: object, mixinClass?: Ext.Class): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} members
		 * @returns {void}           
		 */
		addInheritableStatics? (members: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                               name
		 * @param   {object}                                                                               member
		 * @returns {Ext.data.XmlStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}        
		 */
		addMember? (name: object, member: object): typeof Ext.data.XmlStore;
		addMember? (name: object, member: object): typeof Ext.data.Store;
		addMember? (name: object, member: object): typeof Ext.data.ProxyStore;
		addMember? (name: object, member: object): typeof Ext.data.AbstractStore;
		addMember? (name: object, member: object): typeof Ext.Base;
		/** 
		 * Borrow another class' members to the prototype of this class.
		 * 
		 *    Ext.define('Bank', {
		 *        money: '$$$',
		 *        printMoney: function() {
		 *            alert('$$$$$$$');
		 *        }
		 *    });
		 *    
		 *    Ext.define('Thief', {
		 *        ...
		 *    });
		 *    
		 *    Thief.borrow(Bank, ['money', 'printMoney']);
		 *    
		 *    var steve = new Thief();
		 *    
		 *    alert(steve.money); // alerts '$$$'
		 *    steve.printMoney(); // alerts '$$$$$$$'
		 * 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {Ext.Base}     fromClass The class to borrow members from
		 * @param   {any[]|string} members   The names of the members to borrow
		 * @returns {Ext.Base}               this
		 */
		borrow? (fromClass: Ext.Base, members: any[] | string): Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} config
		 * @returns {void}          
		 */
		extend? (config: object): void;
		/** 
		 * Returns the [`Ext.Configurator`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Configurator.html) for this class.
		 * @method
		 * @private (method)
		 * @static
		 * @returns {Ext.Configurator}  
		 */
		getConfigurator? (): Ext.Configurator;
		/** 
		 * Used internally by the mixins pre-processor
		 * @method
		 * @private (method)
		 * @static
		 * @param   {object} name
		 * @param   {object} mixinClass
		 * @returns {void}              
		 */
		mixin? (name: object, mixinClass: object): void;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @chainable
		 * @param   {object}                                                                               fn
		 * @param   {object}                                                                               scope
		 * @returns {Ext.data.XmlStore|Ext.data.Store|Ext.data.ProxyStore|Ext.data.AbstractStore|Ext.Base}       
		 */
		onExtended? (fn: object, scope: object): typeof Ext.data.XmlStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.Store;
		onExtended? (fn: object, scope: object): typeof Ext.data.ProxyStore;
		onExtended? (fn: object, scope: object): typeof Ext.data.AbstractStore;
		onExtended? (fn: object, scope: object): typeof Ext.Base;
		/** 
		 * @method
		 * @private (method)
		 * @static
		 * @returns {void}  
		 */
		triggerExtended? (): void;
	}
}
declare namespace Ext.data.AbstractStore.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.AbstractStore.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.AbstractStore.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.AbstractStore.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.ArrayStore.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ArrayStore.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.ArrayStore.methodParams.collect {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ArrayStore.collect](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#method-collect)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass true to allow null, undefined or empty string values.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowNull?: boolean;
		/** 
		 * Pass `true` to collect from all records, even ones which are filtered.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.ArrayStore.methodParams.each {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ArrayStore.each](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#method-each)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass `true` to include filtered out nodes in the iteration.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.ArrayStore.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ArrayStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#method-load)
	 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
	 * In addition to the options listed below, this object may contain properties to configure the
	 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function which is called when the response arrives.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.ArrayStore.methodParams.load.Options.callback}
		 */
		callback?: ((records?: Ext.data.Model[], operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * Specify as `true` to _add_ the incoming records rather than the
		 * default which is to have the incoming records _replace_ the existing store contents.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.ArrayStore.methodParams.loadRecords {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ArrayStore.loadRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#method-loadRecords)
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to add these records to the existing records, `false` to remove the Store's existing records first.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.ArrayStore.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ArrayStore.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.ArrayStore.methodParams.sync {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ArrayStore.sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#method-sync)
	 * Object containing one or more properties supported by the sync method (these get
	 * passed along to the underlying proxy's [batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-batch) method):
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created as needed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of the sync.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.ArrayStore.methodParams.sync.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the sync. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the failure function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.ArrayStore.methodParams.sync.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the sync. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.ArrayStore.methodParams.sync.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * Additional params to send during the sync Operation(s).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		params?: object;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the store's proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.Batch.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Batch.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.Batch.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Batch.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.BufferedStore.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.BufferedStore.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.BufferedStore.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.BufferedStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#method-load)
	 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
	 * In addition to the options listed below, this object may contain properties to configure the
	 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function which is called when the response arrives.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.BufferedStore.methodParams.load.Options.callback}
		 */
		callback?: ((records?: Ext.data.Model[], operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * Specify as `true` to _add_ the incoming records rather than the
		 * default which is to have the incoming records _replace_ the existing store contents.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.BufferedStore.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.BufferedStore.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.BufferedStore.methodParams.sync {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.BufferedStore.sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#method-sync)
	 * Object containing one or more properties supported by the sync method (these get
	 * passed along to the underlying proxy's [batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-batch) method):
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created as needed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of the sync.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.BufferedStore.methodParams.sync.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the sync. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the failure function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.BufferedStore.methodParams.sync.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the sync. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.BufferedStore.methodParams.sync.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * Additional params to send during the sync Operation(s).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		params?: object;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the store's proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.Connection.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Connection.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.Connection.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Connection.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.Connection.methodParams.request {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Connection.request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-request)
	 * An object which may contain the following properties:
	 * 
	 * (The options object may also contain any other property which might be needed to perform
	 * postprocessing in a callback because it is passed to callback functions.)
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The URL to which to send the request, or a function
		 * to call which returns a URL string. The scope of the function is specified by the `scope` option.
		 * Defaults to the configured `url`.
		 * @configuration
		 * @optional
		 * @type {string|Function}
		 */
		url?: ExtGlobalFunction | string;
		/** 
		 * `true` if this request should run asynchronously.
		 * Setting this to `false` should generally be avoided, since it will cause the UI to be
		 * blocked, the user won't be able to interact with the browser until the request completes.
		 * Defaults to `true`.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		async?: boolean;
		/** 
		 * An object containing properties which are
		 * used as parameters to the request, a url encoded string or a function to call to get either. The scope
		 * of the function is specified by the `scope` option.
		 * @configuration
		 * @optional
		 * @type {object|string|Function}
		 */
		params?: ExtGlobalFunction | object | string;
		/** 
		 * The HTTP method to use
		 * for the request. Defaults to the configured method, or if no method was configured,
		 * "GET" if no parameters are being sent, and "POST" if parameters are being sent.  Note that
		 * the method name is case-sensitive and should be all caps.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		method?: string;
		/** 
		 * The function to be called upon receipt of the HTTP response.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Connection.methodParams.request.Options.callback}
		 */
		callback?: ((options?: object, success?: boolean, response?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon success of the request.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Connection.methodParams.request.Options.success}
		 */
		success?: ((response?: object, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon failure of the request.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Connection.methodParams.request.Options.failure}
		 */
		failure?: ((response?: object, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callbacks: The "this" object for
		 * the callback function. If the `url`, or `params` options were specified as functions from which to
		 * draw values, then this also serves as the scope for those function calls. Defaults to the browser
		 * window.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The timeout in milliseconds to be used for this
		 * request.<br/>
		 * Defaults to 30000 milliseconds (30 seconds).
		 * 
		 * When a request fails due to timeout the XMLHttpRequest response object will
		 * contain:
		 * 
		 *    timedout: true
		 * 
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		timeout?: number;
		/** 
		 * The `&lt;form&gt;` Element or the id of the `&lt;form&gt;`
		 * to pull parameters from.
		 * @configuration
		 * @optional
		 * @type {Ext.Element|HTMLElement|string}
		 */
		form?: Ext.Element | HTMLElement | string;
		/** 
		 * **Only meaningful when used with the `form` option.**
		 * 
		 * True if the form object is a file upload (will be set automatically if the form was configured
		 * with **`enctype`** `"multipart/form-data"`).
		 * 
		 * File uploads are not performed using normal "Ajax" techniques, that is they are **not**
		 * performed using XMLHttpRequests. Instead the form is submitted in the standard manner with the
		 * DOM `&lt;form&gt;` element temporarily modified to have its [target](http://www.w3.org/TR/REC-html40/present/frames.html#adef-target) set to refer to a dynamically
		 * generated, hidden `&lt;iframe&gt;` which is inserted into the document but removed after the return data
		 * has been gathered.
		 * 
		 * The server response is parsed by the browser to create the document for the IFRAME. If the
		 * server is using JSON to send the return object, then the [Content-Type](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17) header must be set to
		 * "text/html" in order to tell the browser to insert the text unchanged into the document body.
		 * 
		 * The response text is retrieved from the document, and a fake XMLHttpRequest object is created
		 * containing a `responseText` property in order to conform to the requirements of event handlers
		 * and callbacks.
		 * 
		 * Be aware that file upload packets are sent with the content type [multipart/form](http://www.faqs.org/rfcs/rfc2388.html) and some server
		 * technologies (notably JEE) may require some custom processing in order to retrieve parameter names
		 * and parameter values from the packet content.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		isUpload?: boolean;
		/** 
		 * Request headers to set for the request.
		 * The XHR will attempt to set an appropriate Content-Type based on the params/data passed
		 * to the request. To prevent this, setting the Content-Type header to `null` or `undefined`
		 * will not attempt to set any Content-Type and it will be left to the browser.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		headers?: object;
		/** 
		 * XML document to use for the post. Note: This will be used instead
		 * of params for the post data. Any params will be appended to the URL.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		xmlData?: object;
		/** 
		 * JSON data to use as the post. Note: This will be used
		 * instead of params for the post data. Any params will be appended to the URL.
		 * @configuration
		 * @optional
		 * @type {object|string}
		 */
		jsonData?: object | string;
		/** 
		 * A raw string to use as the post. Note: This will be used
		 * instead of params for the post data. Any params will be appended to the URL.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		rawData?: string;
		/** 
		 * An array of bytes to submit in binary form. Any params will be appended to the URL. If binaryData is present, you must set [binary](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-binary) to <tt>true</tt> and options.method to <tt>POST</tt>.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		binaryData?: any[];
		/** 
		 * True to add a unique cache-buster param to GET requests.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		disableCaching?: boolean;
		/** 
		 * True to add the withCredentials property to the XHR object
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		withCredentials?: boolean;
		/** 
		 * The username to pass when using `withCredentials`.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		username?: string;
		/** 
		 * The password to pass when using `withCredentials`.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		password?: string;
		/** 
		 * True if the response should be treated as binary data.  If true, the binary
		 * data will be accessible as a "responseBytes" property on the response object.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		binary?: boolean;
	}
}
declare namespace Ext.data.DirectStore.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.DirectStore.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.DirectStore.methodParams.collect {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.DirectStore.collect](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html#method-collect)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass true to allow null, undefined or empty string values.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowNull?: boolean;
		/** 
		 * Pass `true` to collect from all records, even ones which are filtered.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.DirectStore.methodParams.each {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.DirectStore.each](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html#method-each)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass `true` to include filtered out nodes in the iteration.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.DirectStore.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.DirectStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html#method-load)
	 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
	 * In addition to the options listed below, this object may contain properties to configure the
	 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function which is called when the response arrives.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.DirectStore.methodParams.load.Options.callback}
		 */
		callback?: ((records?: Ext.data.Model[], operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * Specify as `true` to _add_ the incoming records rather than the
		 * default which is to have the incoming records _replace_ the existing store contents.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.DirectStore.methodParams.loadRecords {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.DirectStore.loadRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html#method-loadRecords)
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to add these records to the existing records, `false` to remove the Store's existing records first.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.DirectStore.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.DirectStore.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.DirectStore.methodParams.sync {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.DirectStore.sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html#method-sync)
	 * Object containing one or more properties supported by the sync method (these get
	 * passed along to the underlying proxy's [batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-batch) method):
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created as needed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of the sync.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.DirectStore.methodParams.sync.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the sync. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the failure function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.DirectStore.methodParams.sync.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the sync. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.DirectStore.methodParams.sync.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * Additional params to send during the sync Operation(s).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		params?: object;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the store's proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.ErrorCollection.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ErrorCollection.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.ErrorCollection.methodParams.constructor {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ErrorCollection.constructor](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html#method-constructor)
	 * A configuration object.
	 */
	interface Config extends Ext.base.Params {
		/** 
		 * Specify `true` if the [addAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html#method-addAll)
		 * function should add function references to the collection.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		allowFunctions?: boolean;
		/** 
		 * A function that can accept an item of the type(s) stored in this MixedCollection
		 * and return the key value for that item.  This is used when available to look up the key on items that
		 * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
		 * equivalent to overriding the [getKey](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html#method-getKey) method.
		 * @configuration
		 * @optional
		 * @type {Function}
		 */
		getKey?: ExtGlobalFunction;
	}
}
declare namespace Ext.data.ErrorCollection.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ErrorCollection.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.ChainedStore.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ChainedStore.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.ChainedStore.methodParams.collect {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ChainedStore.collect](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#method-collect)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass true to allow null, undefined or empty string values.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowNull?: boolean;
		/** 
		 * Pass `true` to collect from all records, even ones which are filtered.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.ChainedStore.methodParams.each {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ChainedStore.each](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#method-each)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass `true` to include filtered out nodes in the iteration.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.ChainedStore.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ChainedStore.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.JsonPStore.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonPStore.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.JsonPStore.methodParams.collect {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonPStore.collect](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#method-collect)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass true to allow null, undefined or empty string values.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowNull?: boolean;
		/** 
		 * Pass `true` to collect from all records, even ones which are filtered.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.JsonPStore.methodParams.each {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonPStore.each](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#method-each)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass `true` to include filtered out nodes in the iteration.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.JsonPStore.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonPStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#method-load)
	 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
	 * In addition to the options listed below, this object may contain properties to configure the
	 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function which is called when the response arrives.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.JsonPStore.methodParams.load.Options.callback}
		 */
		callback?: ((records?: Ext.data.Model[], operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * Specify as `true` to _add_ the incoming records rather than the
		 * default which is to have the incoming records _replace_ the existing store contents.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.JsonPStore.methodParams.loadRecords {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonPStore.loadRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#method-loadRecords)
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to add these records to the existing records, `false` to remove the Store's existing records first.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.JsonPStore.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonPStore.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.JsonPStore.methodParams.sync {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonPStore.sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#method-sync)
	 * Object containing one or more properties supported by the sync method (these get
	 * passed along to the underlying proxy's [batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-batch) method):
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created as needed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of the sync.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.JsonPStore.methodParams.sync.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the sync. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the failure function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.JsonPStore.methodParams.sync.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the sync. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.JsonPStore.methodParams.sync.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * Additional params to send during the sync Operation(s).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		params?: object;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the store's proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.JsonStore.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonStore.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.JsonStore.methodParams.collect {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonStore.collect](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#method-collect)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass true to allow null, undefined or empty string values.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowNull?: boolean;
		/** 
		 * Pass `true` to collect from all records, even ones which are filtered.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.JsonStore.methodParams.each {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonStore.each](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#method-each)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass `true` to include filtered out nodes in the iteration.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.JsonStore.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#method-load)
	 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
	 * In addition to the options listed below, this object may contain properties to configure the
	 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function which is called when the response arrives.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.JsonStore.methodParams.load.Options.callback}
		 */
		callback?: ((records?: Ext.data.Model[], operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * Specify as `true` to _add_ the incoming records rather than the
		 * default which is to have the incoming records _replace_ the existing store contents.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.JsonStore.methodParams.loadRecords {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonStore.loadRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#method-loadRecords)
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to add these records to the existing records, `false` to remove the Store's existing records first.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.JsonStore.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonStore.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.JsonStore.methodParams.sync {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.JsonStore.sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#method-sync)
	 * Object containing one or more properties supported by the sync method (these get
	 * passed along to the underlying proxy's [batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-batch) method):
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created as needed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of the sync.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.JsonStore.methodParams.sync.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the sync. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the failure function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.JsonStore.methodParams.sync.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the sync. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.JsonStore.methodParams.sync.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * Additional params to send during the sync Operation(s).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		params?: object;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the store's proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.LocalStore.methodParams.collect {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.LocalStore.collect](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#method-collect)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass true to allow null, undefined or empty string values.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowNull?: boolean;
		/** 
		 * Pass `true` to collect from all records, even ones which are filtered.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.LocalStore.methodParams.each {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.LocalStore.each](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html#method-each)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass `true` to include filtered out nodes in the iteration.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.Model.methodParams.erase {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Model.erase](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-erase)
	 * Options to pass to the proxy.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.methodParams.erase.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.methodParams.erase.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.methodParams.erase.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.Model.methodParams.getAssociatedData {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Model.getAssociatedData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-getAssociatedData)
	 * An object containing options describing the data
	 * desired.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to include associated data from
		 * other associated records.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		associated?: boolean;
		/** 
		 * Pass `true` to only include fields that
		 * have been modified. Note that field modifications are only tracked for fields that
		 * are not declared with `persist` set to `false`. In other words, only persistent
		 * fields have changes tracked so passing `true` for this means `options.persist` is
		 * redundant.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		changes?: boolean;
		/** 
		 * Pass `true` to include fields set as `critical`.
		 * This is only meaningful when `options.changes` is `true` since critical fields may
		 * not have been modified.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		critical?: boolean;
		/** 
		 * Pass `true` to only return persistent fields.
		 * This is implied when `options.changes` is set to `true`.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		persist?: boolean;
		/** 
		 * Pass `true` to invoke the `serialize`
		 * method on the returned fields.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		serialize?: boolean;
	}
}
declare namespace Ext.data.Model.methodParams.getData {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Model.getData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-getData)
	 * An object containing options describing the data
	 * desired. If `true` is passed it is treated as an object with `associated` set to
	 * `true`.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to include associated data.
		 * This is equivalent to pass `true` as the only argument. See `getAssociatedData`.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		associated?: boolean;
		/** 
		 * Pass `true` to only include fields that
		 * have been modified. Note that field modifications are only tracked for fields that
		 * are not declared with `persist` set to `false`. In other words, only persistent
		 * fields have changes tracked so passing `true` for this means `options.persist` is
		 * redundant.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		changes?: boolean;
		/** 
		 * Pass `true` to include fields set as `critical`.
		 * This is only meaningful when `options.changes` is `true` since critical fields may
		 * not have been modified.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		critical?: boolean;
		/** 
		 * Pass `true` to only return persistent fields.
		 * This is implied when `options.changes` is set to `true`.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		persist?: boolean;
		/** 
		 * Pass `true` to invoke the `serialize`
		 * method on the returned fields.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		serialize?: boolean;
	}
}
declare namespace Ext.data.Model.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Model.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-load)
	 * Options to pass to the proxy.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.methodParams.load.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.methodParams.load.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.methodParams.load.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.Model.methodParams.save {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Model.save](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-save)
	 * Options to pass to the proxy.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.methodParams.save.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.methodParams.save.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.methodParams.save.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.Model.methodParams.set {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Model.set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-set)
	 * Options for governing this update.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Set to `false` to  prevent any converters from
		 * being called during the set operation. This may be useful when setting a large bunch of
		 * raw values.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		convert?: boolean;
		/** 
		 * Pass `false` if the field values are to be
		 * understood as non-dirty (fresh from the server). When `true`, this change will be
		 * reflected in the `modified` collection.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * Pass `true` to call the [commit](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-commit) method
		 * after setting fields. If this option is passed, the usual after change processing will
		 * be bypassed. [Commit](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-commit) will be called even if there are no field changes.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		commit?: boolean;
		/** 
		 * Pass `true` to suppress notification of any
		 * changes made by this call. Use with caution.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		silent?: boolean;
	}
}
declare namespace Ext.data.Model.staticMethodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Model.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#static-method-load)
	 * The options param is an
	 * [Ext.data.operation.Read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) config object containing success, failure and
	 * callback functions, plus optional scope.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.staticMethodParams.load.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.staticMethodParams.load.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Model.staticMethodParams.load.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.NodeInterface.eventsParams.remove {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.NodeInterface.remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#event-remove)
	 * An object providing information about where the removed node came from. It contains the following properties:
	 */
	interface Context extends Ext.base.Params {
		/** 
		 * The node from which the removed node was removed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.NodeInterface}
		 */
		parentNode?: Ext.data.NodeInterface;
		/** 
		 * The removed node's former previous sibling.
		 * @configuration
		 * @optional
		 * @type {Ext.data.NodeInterface}
		 */
		previousSibling?: Ext.data.NodeInterface;
		/** 
		 * The removed node's former next sibling.
		 * (a side effect of calling [appendChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-appendChild) or
		 * [insertBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertBefore) with a node that already has a parentNode)
		 * @configuration
		 * @optional
		 * @type {Ext.data.NodeInterface}
		 */
		nextSibling?: Ext.data.NodeInterface;
	}
}
declare namespace Ext.data.NodeInterface.methodParams.cascade {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.NodeInterface.cascade](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-cascade)
	 * An object containing before and after functions, scope and an argument list.
	 */
	interface Spec extends Ext.base.Params {
		/** 
		 * A function to call on a node _before_ cascading down into child nodes.
		 * If it returns `false`, the child nodes are not traversed.
		 * @configuration
		 * @optional
		 * @type {Function}
		 */
		before?: ExtGlobalFunction;
		/** 
		 * A function to call on a node _after_ cascading down into child nodes.
		 * @configuration
		 * @optional
		 * @type {Function}
		 */
		after?: ExtGlobalFunction;
		/** 
		 * The scope (this reference) in which the functions are executed. Defaults to the current Node.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The args to call the function with. Defaults to passing the current Node.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
	}
}
declare namespace Ext.data.NodeInterface.methodParams.updateInfo {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.NodeInterface.updateInfo](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-updateInfo)
	 * The info to update. May contain any of the following
	 */
	interface Info extends Ext.base.Params {
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		isFirst?: object;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		isLast?: object;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		index?: object;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		depth?: object;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		parentId?: object;
	}
}
declare namespace Ext.data.NodeStore.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.NodeStore.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeStore.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.NodeStore.methodParams.collect {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.NodeStore.collect](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeStore.html#method-collect)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass true to allow null, undefined or empty string values.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowNull?: boolean;
		/** 
		 * Pass `true` to collect from all records, even ones which are filtered.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.NodeStore.methodParams.each {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.NodeStore.each](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeStore.html#method-each)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass `true` to include filtered out nodes in the iteration.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.NodeStore.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.NodeStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeStore.html#method-load)
	 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
	 * In addition to the options listed below, this object may contain properties to configure the
	 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function which is called when the response arrives.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.NodeStore.methodParams.load.Options.callback}
		 */
		callback?: ((records?: Ext.data.Model[], operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * Specify as `true` to _add_ the incoming records rather than the
		 * default which is to have the incoming records _replace_ the existing store contents.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.NodeStore.methodParams.loadRecords {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.NodeStore.loadRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeStore.html#method-loadRecords)
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to add these records to the existing records, `false` to remove the Store's existing records first.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.NodeStore.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.NodeStore.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeStore.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.NodeStore.methodParams.sync {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.NodeStore.sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeStore.html#method-sync)
	 * Object containing one or more properties supported by the sync method (these get
	 * passed along to the underlying proxy's [batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-batch) method):
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created as needed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of the sync.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.NodeStore.methodParams.sync.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the sync. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the failure function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.NodeStore.methodParams.sync.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the sync. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.NodeStore.methodParams.sync.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * Additional params to send during the sync Operation(s).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		params?: object;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the store's proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.PageMap.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.PageMap.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.PageMap.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.PageMap.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.PageMap.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.PageMap.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.ProxyStore.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ProxyStore.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.ProxyStore.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ProxyStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load)
	 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
	 * In addition to the options listed below, this object may contain properties to configure the
	 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function which is called when the response arrives.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.ProxyStore.methodParams.load.Options.callback}
		 */
		callback?: ((records?: Ext.data.Model[], operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * Specify as `true` to _add_ the incoming records rather than the
		 * default which is to have the incoming records _replace_ the existing store contents.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.ProxyStore.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ProxyStore.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.ProxyStore.methodParams.sync {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.ProxyStore.sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync)
	 * Object containing one or more properties supported by the sync method (these get
	 * passed along to the underlying proxy's [batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-batch) method):
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created as needed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of the sync.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.ProxyStore.methodParams.sync.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the sync. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the failure function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.ProxyStore.methodParams.sync.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the sync. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.ProxyStore.methodParams.sync.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * Additional params to send during the sync Operation(s).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		params?: object;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the store's proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.Session.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Session.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.Session.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Session.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.Session.methodParams.visitData {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Session.visitData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-visitData)
	 */
	interface Visitor extends Ext.base.Params {
		/** 
		 * This method is called to describe a record
		 * that is known but unchanged.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Session.methodParams.visitData.Visitor.onCleanRecord}
		 */
		onCleanRecord?: ((record?: Ext.data.Model) => void) | ExtGlobalFunction;
		/** 
		 * This method is called to describe a record
		 * that has either been created, dropped or modified.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Session.methodParams.visitData.Visitor.onDirtyRecord}
		 */
		onDirtyRecord?: ((record?: Ext.data.Model) => void) | ExtGlobalFunction;
		/** 
		 * This method is called to describe a
		 * change in a many-to-many association (a "matrix").
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Session.methodParams.visitData.Visitor.onMatrixChange}
		 */
		onMatrixChange?: ((association?: Ext.data.schema.Association, leftId?: any, rightId?: any, state?: number) => void) | ExtGlobalFunction;
	}
}
declare namespace Ext.data.Store.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Store.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.Store.methodParams.collect {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Store.collect](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-collect)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass true to allow null, undefined or empty string values.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowNull?: boolean;
		/** 
		 * Pass `true` to collect from all records, even ones which are filtered.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.Store.methodParams.each {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Store.each](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-each)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass `true` to include filtered out nodes in the iteration.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.Store.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Store.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load)
	 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
	 * In addition to the options listed below, this object may contain properties to configure the
	 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function which is called when the response arrives.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Store.methodParams.load.Options.callback}
		 */
		callback?: ((records?: Ext.data.Model[], operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * Specify as `true` to _add_ the incoming records rather than the
		 * default which is to have the incoming records _replace_ the existing store contents.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.Store.methodParams.loadRecords {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Store.loadRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadRecords)
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to add these records to the existing records, `false` to remove the Store's existing records first.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.Store.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Store.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.Store.methodParams.sync {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Store.sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sync)
	 * Object containing one or more properties supported by the sync method (these get
	 * passed along to the underlying proxy's [batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-batch) method):
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created as needed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of the sync.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Store.methodParams.sync.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the sync. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the failure function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Store.methodParams.sync.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the sync. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Store.methodParams.sync.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * Additional params to send during the sync Operation(s).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		params?: object;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the store's proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.StoreManager.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.StoreManager.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.StoreManager.methodParams.constructor {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.StoreManager.constructor](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html#method-constructor)
	 * A configuration object.
	 */
	interface Config extends Ext.base.Params {
		/** 
		 * Specify `true` if the [addAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html#method-addAll)
		 * function should add function references to the collection.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		allowFunctions?: boolean;
		/** 
		 * A function that can accept an item of the type(s) stored in this MixedCollection
		 * and return the key value for that item.  This is used when available to look up the key on items that
		 * were passed without an explicit key parameter to a MixedCollection method.  Passing this parameter is
		 * equivalent to overriding the [getKey](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html#method-getKey) method.
		 * @configuration
		 * @optional
		 * @type {Function}
		 */
		getKey?: ExtGlobalFunction;
	}
}
declare namespace Ext.data.StoreManager.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.StoreManager.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.TreeModel.methodParams.erase {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeModel.erase](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html#method-erase)
	 * Options to pass to the proxy.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.methodParams.erase.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.methodParams.erase.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.methodParams.erase.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.TreeModel.methodParams.getAssociatedData {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeModel.getAssociatedData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html#method-getAssociatedData)
	 * An object containing options describing the data
	 * desired.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to include associated data from
		 * other associated records.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		associated?: boolean;
		/** 
		 * Pass `true` to only include fields that
		 * have been modified. Note that field modifications are only tracked for fields that
		 * are not declared with `persist` set to `false`. In other words, only persistent
		 * fields have changes tracked so passing `true` for this means `options.persist` is
		 * redundant.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		changes?: boolean;
		/** 
		 * Pass `true` to include fields set as `critical`.
		 * This is only meaningful when `options.changes` is `true` since critical fields may
		 * not have been modified.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		critical?: boolean;
		/** 
		 * Pass `true` to only return persistent fields.
		 * This is implied when `options.changes` is set to `true`.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		persist?: boolean;
		/** 
		 * Pass `true` to invoke the `serialize`
		 * method on the returned fields.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		serialize?: boolean;
	}
}
declare namespace Ext.data.TreeModel.methodParams.getData {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeModel.getData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html#method-getData)
	 * An object containing options describing the data
	 * desired. If `true` is passed it is treated as an object with `associated` set to
	 * `true`.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to include associated data.
		 * This is equivalent to pass `true` as the only argument. See `getAssociatedData`.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		associated?: boolean;
		/** 
		 * Pass `true` to only include fields that
		 * have been modified. Note that field modifications are only tracked for fields that
		 * are not declared with `persist` set to `false`. In other words, only persistent
		 * fields have changes tracked so passing `true` for this means `options.persist` is
		 * redundant.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		changes?: boolean;
		/** 
		 * Pass `true` to include fields set as `critical`.
		 * This is only meaningful when `options.changes` is `true` since critical fields may
		 * not have been modified.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		critical?: boolean;
		/** 
		 * Pass `true` to only return persistent fields.
		 * This is implied when `options.changes` is set to `true`.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		persist?: boolean;
		/** 
		 * Pass `true` to invoke the `serialize`
		 * method on the returned fields.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		serialize?: boolean;
	}
}
declare namespace Ext.data.TreeModel.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeModel.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html#method-load)
	 * Options to pass to the proxy.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.methodParams.load.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.methodParams.load.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.methodParams.load.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.TreeModel.methodParams.save {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeModel.save](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html#method-save)
	 * Options to pass to the proxy.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.methodParams.save.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.methodParams.save.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.methodParams.save.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.TreeModel.methodParams.set {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeModel.set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html#method-set)
	 * Options for governing this update.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Set to `false` to  prevent any converters from
		 * being called during the set operation. This may be useful when setting a large bunch of
		 * raw values.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		convert?: boolean;
		/** 
		 * Pass `false` if the field values are to be
		 * understood as non-dirty (fresh from the server). When `true`, this change will be
		 * reflected in the `modified` collection.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * Pass `true` to call the [commit](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-commit) method
		 * after setting fields. If this option is passed, the usual after change processing will
		 * be bypassed. [Commit](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-commit) will be called even if there are no field changes.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		commit?: boolean;
		/** 
		 * Pass `true` to suppress notification of any
		 * changes made by this call. Use with caution.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		silent?: boolean;
	}
}
declare namespace Ext.data.TreeModel.staticMethodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeModel.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html#static-method-load)
	 * The options param is an
	 * [Ext.data.operation.Read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) config object containing success, failure and
	 * callback functions, plus optional scope.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.staticMethodParams.load.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.staticMethodParams.load.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeModel.staticMethodParams.load.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.TreeStore.eventsParams.noderemove {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeStore.noderemove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#event-noderemove)
	 * An object providing information about where the removed node came from. It contains the following properties:
	 */
	interface Context extends Ext.base.Params {
		/** 
		 * The node from which the removed node was removed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.NodeInterface}
		 */
		parentNode?: Ext.data.NodeInterface;
		/** 
		 * The removed node's former previous sibling.
		 * @configuration
		 * @optional
		 * @type {Ext.data.NodeInterface}
		 */
		previousSibling?: Ext.data.NodeInterface;
		/** 
		 * The removed node's former next sibling.
		 * (a side effect of calling [appendChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-appendChild) or
		 * [insertBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertBefore) with a node that already has a parentNode)
		 * @configuration
		 * @optional
		 * @type {Ext.data.NodeInterface}
		 */
		nextSibling?: Ext.data.NodeInterface;
	}
}
declare namespace Ext.data.TreeStore.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeStore.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.TreeStore.methodParams.collect {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeStore.collect](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-collect)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass true to allow null, undefined or empty string values.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowNull?: boolean;
		/** 
		 * Pass `true` to collect from all records, even ones which are filtered.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
		/** 
		 * Pass `true` to include nodes which are descendants of collapsed nodes.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		collapsed?: boolean;
	}
}
declare namespace Ext.data.TreeStore.methodParams.each {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeStore.each](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-each)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass `true` to include filtered out nodes in the iteration.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
		/** 
		 * Pass `true` to include nodes which are descendants of collapsed nodes.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		collapsed?: boolean;
	}
}
declare namespace Ext.data.TreeStore.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-load)
	 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
	 * The options can also contain a node, which indicates which node is to be loaded. If not specified, it will
	 * default to the root node.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The tree node to load. Defaults to the store's [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root)
		 * @configuration
		 * @optional
		 * @type {Ext.data.NodeInterface}
		 */
		node?: Ext.data.NodeInterface;
		/** 
		 * A function which is called when the response arrives.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeStore.methodParams.load.Options.callback}
		 */
		callback?: ((records?: Ext.data.Model[], operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
	}
}
declare namespace Ext.data.TreeStore.methodParams.loadRecords {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeStore.loadRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-loadRecords)
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to add these records to the existing records, `false` to remove the Store's existing records first.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.TreeStore.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeStore.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.TreeStore.methodParams.sync {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.TreeStore.sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-sync)
	 * Object containing one or more properties supported by the sync method (these get
	 * passed along to the underlying proxy's [batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-batch) method):
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created as needed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of the sync.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeStore.methodParams.sync.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the sync. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the failure function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeStore.methodParams.sync.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the sync. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.TreeStore.methodParams.sync.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * Additional params to send during the sync Operation(s).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		params?: object;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the store's proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.Validation.methodParams.erase {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Validation.erase](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html#method-erase)
	 * Options to pass to the proxy.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.methodParams.erase.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.methodParams.erase.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.methodParams.erase.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.Validation.methodParams.getAssociatedData {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Validation.getAssociatedData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html#method-getAssociatedData)
	 * An object containing options describing the data
	 * desired.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to include associated data from
		 * other associated records.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		associated?: boolean;
		/** 
		 * Pass `true` to only include fields that
		 * have been modified. Note that field modifications are only tracked for fields that
		 * are not declared with `persist` set to `false`. In other words, only persistent
		 * fields have changes tracked so passing `true` for this means `options.persist` is
		 * redundant.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		changes?: boolean;
		/** 
		 * Pass `true` to include fields set as `critical`.
		 * This is only meaningful when `options.changes` is `true` since critical fields may
		 * not have been modified.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		critical?: boolean;
		/** 
		 * Pass `true` to only return persistent fields.
		 * This is implied when `options.changes` is set to `true`.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		persist?: boolean;
		/** 
		 * Pass `true` to invoke the `serialize`
		 * method on the returned fields.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		serialize?: boolean;
	}
}
declare namespace Ext.data.Validation.methodParams.getData {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Validation.getData](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html#method-getData)
	 * An object containing options describing the data
	 * desired. If `true` is passed it is treated as an object with `associated` set to
	 * `true`.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to include associated data.
		 * This is equivalent to pass `true` as the only argument. See `getAssociatedData`.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		associated?: boolean;
		/** 
		 * Pass `true` to only include fields that
		 * have been modified. Note that field modifications are only tracked for fields that
		 * are not declared with `persist` set to `false`. In other words, only persistent
		 * fields have changes tracked so passing `true` for this means `options.persist` is
		 * redundant.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		changes?: boolean;
		/** 
		 * Pass `true` to include fields set as `critical`.
		 * This is only meaningful when `options.changes` is `true` since critical fields may
		 * not have been modified.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		critical?: boolean;
		/** 
		 * Pass `true` to only return persistent fields.
		 * This is implied when `options.changes` is set to `true`.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		persist?: boolean;
		/** 
		 * Pass `true` to invoke the `serialize`
		 * method on the returned fields.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		serialize?: boolean;
	}
}
declare namespace Ext.data.Validation.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Validation.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html#method-load)
	 * Options to pass to the proxy.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.methodParams.load.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.methodParams.load.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.methodParams.load.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.Validation.methodParams.save {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Validation.save](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html#method-save)
	 * Options to pass to the proxy.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.methodParams.save.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.methodParams.save.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.methodParams.save.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.Validation.methodParams.set {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Validation.set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html#method-set)
	 * Options for governing this update.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Set to `false` to  prevent any converters from
		 * being called during the set operation. This may be useful when setting a large bunch of
		 * raw values.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		convert?: boolean;
		/** 
		 * Pass `false` if the field values are to be
		 * understood as non-dirty (fresh from the server). When `true`, this change will be
		 * reflected in the `modified` collection.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * Pass `true` to call the [commit](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-commit) method
		 * after setting fields. If this option is passed, the usual after change processing will
		 * be bypassed. [Commit](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-commit) will be called even if there are no field changes.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		commit?: boolean;
		/** 
		 * Pass `true` to suppress notification of any
		 * changes made by this call. Use with caution.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		silent?: boolean;
	}
}
declare namespace Ext.data.Validation.staticMethodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.Validation.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html#static-method-load)
	 * The options param is an
	 * [Ext.data.operation.Read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) config object containing success, failure and
	 * callback functions, plus optional scope.
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function to be called when the
		 * model is processed by the proxy successfully.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.staticMethodParams.load.Options.success}
		 */
		success?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called when the
		 * model is unable to be processed by the server.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.staticMethodParams.load.Options.failure}
		 */
		failure?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation) => void) | ExtGlobalFunction;
		/** 
		 * A function to be called whether the proxy
		 * transaction was successful or not.
		 * The callback is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.Validation.staticMethodParams.load.Options.callback}
		 */
		callback?: ((record?: Ext.data.Model, operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * The scope in which to execute the callback
		 * functions.  Defaults to the model instance.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.XmlStore.methodParams.addListener {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.XmlStore.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#method-addListener)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.XmlStore.methodParams.collect {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.XmlStore.collect](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#method-collect)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass true to allow null, undefined or empty string values.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowNull?: boolean;
		/** 
		 * Pass `true` to collect from all records, even ones which are filtered.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.XmlStore.methodParams.each {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.XmlStore.each](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#method-each)
	 * An object which contains options which modify how the store is traversed.
	 */
	interface IncludeOptions extends Ext.base.Params {
		/** 
		 * Pass `true` to include filtered out nodes in the iteration.
		 * 
		 * Note that the `filtered` option can also be passed as a separate parameter for
		 * compatibility with previous versions.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		filtered?: boolean;
	}
}
declare namespace Ext.data.XmlStore.methodParams.load {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.XmlStore.load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#method-load)
	 * This is passed into the [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * object that is created and then sent to the proxy's [Ext.data.proxy.Proxy.read](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-read) function.
	 * In addition to the options listed below, this object may contain properties to configure the
	 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A function which is called when the response arrives.
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.XmlStore.methodParams.load.Options.callback}
		 */
		callback?: ((records?: Ext.data.Model[], operation?: Ext.data.operation.Operation, success?: boolean) => void) | ExtGlobalFunction;
		/** 
		 * Specify as `true` to _add_ the incoming records rather than the
		 * default which is to have the incoming records _replace_ the existing store contents.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.XmlStore.methodParams.loadRecords {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.XmlStore.loadRecords](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#method-loadRecords)
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * Pass `true` to add these records to the existing records, `false` to remove the Store's existing records first.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		addRecords?: boolean;
	}
}
declare namespace Ext.data.XmlStore.methodParams.on {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.XmlStore.on](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#method-on)
	 * An object containing handler configuration.
	 * 
	 * **Note:** The options object will also be passed as the last argument to every
	 * event handler.
	 * 
	 * This object may contain any of the following properties:
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * The scope (`this` reference) in which the handler function is executed. **If omitted,
		 *   defaults to the object which fired the event.**
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * The number of milliseconds to delay the invocation of the handler after the event
		 *   fires.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		delay?: number;
		/** 
		 * True to add a handler to handle just the next firing of the event, and then remove
		 *   itself.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		single?: boolean;
		/** 
		 * Causes the handler to be scheduled to run in an [Ext.util.DelayedTask](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.DelayedTask.html) delayed
		 *   by the specified number of milliseconds. If the event fires again within that time,
		 *   the original handler is _not_ invoked, but the new handler is scheduled in its place.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		buffer?: number;
		/** 
		 * Causes the handler to be scheduled to run at the next
		 *   [animation frame event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Function.html#method-requestAnimationFrame). If the
		 *   event fires again before that time, the handler is not rescheduled - the handler
		 *   will only be called once when the next animation frame is fired, with the last set
		 *   of arguments passed.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		onFrame?: number;
		/** 
		 * Only call the handler if the event was fired on the target Observable, _not_ if the
		 *   event was bubbled up from a child Observable.
		 * @configuration
		 * @optional
		 * @type {Ext.util.Observable}
		 */
		target?: Ext.util.Observable;
		/** 
		 * **This option is only valid for listeners bound to [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html).**
		 *   The name of a Component property which references an [element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html)
		 *   to add a listener to.
		 * 
		 *   This option is useful during Component construction to add DOM event listeners to
		 *   elements of [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html) which will exist only after the
		 *   Component is rendered.
		 * 
		 *   For example, to add a click listener to a Panel's body:
		 * 
		 *      var panel = new Ext.panel.Panel({
		 *          title: 'The title',
		 *          listeners: {
		 *              click: this.handlePanelClick,
		 *              element: 'body'
		 *          }
		 *      });
		 * 
		 * In order to remove listeners attached using the element, you'll need to reference
		 * the element itself as seen below.
		 * 
		 *     panel.body.un(...)
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		element?: string;
		/** 
		 * A simple selector to filter the event target or look for a descendant of the target.
		 * 
		 *   The "delegate" option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * 
		 *   See the _delegate_ example below.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		delegate?: string;
		/** 
		 * When set to `true`, the listener is fired in the capture phase of the event propagation
		 *  sequence, instead of the default bubble phase.
		 * 
		 *   The `capture` option is only available on [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) instances (or
		 *   when attaching a listener to a [Ext.dom.Element](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html) via a Component using the
		 *   element option).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		capture?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopPropagation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopPropagation) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopPropagation?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [preventDefault](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-preventDefault) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		preventDefault?: boolean;
		/** 
		 * **This option is only valid for listeners bound to [Elements](https://docs.sencha.com/extjs/6.2.0/modern/Ext.dom.Element.html).**
		 *   `true` to call [stopEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.event.Event.html#method-stopEvent) on the event object
		 *   before firing the handler.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		stopEvent?: boolean;
		/** 
		 * Optional arguments to pass to the handler function. Any additional arguments
		 *   passed to [fireEvent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-fireEvent) will be appended
		 *   to these arguments.
		 * @configuration
		 * @optional
		 * @type {any[]}
		 */
		args?: any[];
		/** 
		 * When specified as `true`, the function returns a `destroyable` object. An object
		 *   which implements the `destroy` method which removes all listeners added in this call.
		 *   This syntax can be a helpful shortcut to using [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un); particularly when
		 *   removing multiple listeners.  _NOTE_ - not compatible when using the _element_
		 *   option.  See [un](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-un) for the proper syntax for removing listeners added using the
		 *   _element_ config.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		destroyable?: boolean;
		/** 
		 * An optional numeric priority that determines the order in which event handlers
		 *   are run. Event handlers with no priority will be run as if they had a priority
		 *   of 0. Handlers with a higher priority will be prioritized to run sooner than
		 *   those with a lower priority.  Negative numbers can be used to set a priority
		 *   lower than the default. Internally, the framework uses a range of 1000 or
		 *   greater, and -1000 or lesser for handlers that are intended to run before or
		 *   after all others, so it is recommended to stay within the range of -999 to 999
		 *   when setting the priority of event handlers in application-level code.
		 *   A priority must be an integer to be valid.  Fractional values are reserved for
		 *   internal framework use.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		priority?: number;
		/** 
		 * A legacy option that is provided for backward compatibility.
		 *   It is recommended to use the `priority` option instead.  Available options are:
		 * 
		 * - `'before'`: equal to a priority of `100`
		 * - `'current'`: equal to a priority of `0` or default priority
		 * - `'after'`: equal to a priority of `-100`
		 * @configuration
		 * @optional
		 * @default 'current'
		 * @type {string}
		 */
		order?: string;
	}
}
declare namespace Ext.data.XmlStore.methodParams.sync {
	/** 
	 * @params
	 * Config interface to call method: 
	 * [Ext.data.XmlStore.sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#method-sync)
	 * Object containing one or more properties supported by the sync method (these get
	 * passed along to the underlying proxy's [batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html#method-batch) method):
	 */
	interface Options extends Ext.base.Params {
		/** 
		 * A [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html) object (or batch config to apply
		 * to the created batch). If unspecified a default batch will be auto-created as needed.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Batch|object}
		 */
		batch?: Ext.data.Batch | object;
		/** 
		 * The function to be called upon completion of the sync.
		 * The callback is called regardless of success or failure and is passed the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.XmlStore.methodParams.sync.Options.callback}
		 */
		callback?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon successful completion of the sync. The
		 * success function is called only if no exceptions were reported in any operations. If one or more exceptions
		 * occurred then the failure function will be called instead. The success function is called
		 * with the following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.XmlStore.methodParams.sync.Options.success}
		 */
		success?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * The function to be called upon unsuccessful completion of the sync. The
		 * failure function is called when one or more operations returns an exception during processing (even if some
		 * operations were also successful). In this case you can check the batch's [exceptions](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#property-exceptions) array to see exactly which operations had exceptions. The failure function is called with the
		 * following parameters:
		 * @configuration
		 * @optional
		 * @type {Function|Ext.data.XmlStore.methodParams.sync.Options.failure}
		 */
		failure?: ((batch?: Ext.data.Batch, options?: object) => void) | ExtGlobalFunction;
		/** 
		 * Additional params to send during the sync Operation(s).
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		params?: object;
		/** 
		 * The scope in which to execute any callbacks (i.e. the `this` object inside
		 * the callback, success and/or failure functions). Defaults to the store's proxy.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
	}
}
declare namespace Ext.data.AbstractStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.AbstractStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html)
	 * AbstractStore is a superclass of [Ext.data.ProxyStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html) and [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html). It's never used directly,
	 * but offers a set of methods used by both of those subclasses.
	 * 
	 * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
	 * you're probably looking for is [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The number of records considered to form a 'page'. This is used to power the built-in
		 * paging using the nextPage and previousPage functions when the grid is paged using a
		 * PagingToolbar Defaults to 25.
		 * 
		 * To disable paging, set the pageSize to `0`.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                         config
		 * @returns {Ext.data.AbstractStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.AbstractStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                  name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                         [value] The value to set for the name parameter.
		 * @returns {Ext.data.AbstractStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.AbstractStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.AbstractStore.Statics}  
		 */
		statics? (): Ext.data.AbstractStore.Statics;
	}
}
declare namespace Ext.data.ArrayStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.ArrayStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from Array data easier. An ArrayStore will be
	 * automatically configured with a [Ext.data.reader.Array](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Array.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = Ext.create('Ext.data.ArrayStore', {
	 *        // store configs
	 *        storeId: 'myStore',
	 *        // reader configs
	 *        fields: [
	 *           'company',
	 *           {name: 'price', type: 'float'},
	 *           {name: 'change', type: 'float'},
	 *           {name: 'pctChange', type: 'float'},
	 *           {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
	 *        ]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    var myData = [
	 *        ['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
	 *        ['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
	 *        ['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
	 *        ['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
	 *        ['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
	 *    ];
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#cfg-data) config option.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The owner of this store if the store is used as part of an association.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Model}
		 */
		associatedEntity?: Ext.data.Model;
		/** 
		 * This defaults to `true` when this store's [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy) is asynchronous, such as an
		 * [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html).
		 * 
		 * When the proxy is synchronous, such as a [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) memory proxy, this
		 * defaults to `false`.
		 * 
		 * _NOTE:_ This does not cause synchronous Ajax requests if configured `false` when an Ajax proxy
		 * is used. It causes immediate issuing of an Ajax request when [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) is called
		 * rather than issuing the request at the end of the current event handler run.
		 * 
		 * What this means is that when using an Ajax proxy, calls to
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) do not fire the request to the remote resource
		 * immediately, but schedule a request to be made. This is so that multiple
		 * requests are not fired when mutating a store's remote filters and sorters (as
		 * happens during state restoration). The request is made only once after all
		 * relevant store state is fully set.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		asynchronousLoad?: boolean;
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
		 * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
		 * 
		 * It's important to note that [Tree Stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) will<br/>
		 * load regardless of autoLoad's value if expand is set to true on the
		 * [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @configuration
		 * @optional
		 * @type {boolean|object}
		 */
		autoLoad?: boolean | object;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		autoSync?: boolean;
		/** 
		 * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
		 * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
		 * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
		 * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
		 * @configuration
		 * @optional
		 * @default 'operation'
		 * @type {string}
		 */
		batchUpdateMode?: string;
		/** 
		 * True to empty the store when loading another page via [loadPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadPage),
		 * [nextPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-nextPage) or [previousPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-previousPage). Setting to false keeps existing records, allowing
		 * large data sets to be loaded one page at a time but rendered all together.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearOnPageLoad?: boolean;
		/** 
		 * `true` to clear anything in the [removed](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#property-removed) record collection when the store loads.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearRemovedOnLoad?: boolean;
		/** 
		 * Array of Model instances or data objects to load locally. See "Inline data"
		 * above for details.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {object[]|Ext.data.Model[]}
		 */
		data?: object[] | Ext.data.Model[];
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		extraKeys?: object;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Name of the [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) associated with this store. See
		 * [Ext.data.Model.entityName](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-entityName).
		 * 
		 * May also be the actual Model subclass.
		 * 
		 * This config is required for the store to be able to read data unless you have defined
		 * the [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields) config which will create an anonymous [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html).
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The number of records considered to form a 'page'. This is used to power the built-in
		 * paging using the nextPage and previousPage functions when the grid is paged using a
		 * PagingToolbar Defaults to 25.
		 * 
		 * To disable paging, set the pageSize to `0`.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
		 * see [setProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#method-setProxy) for details.
		 * @configuration
		 * @optional
		 * @default {type: 'memory', reader: 'array'}
		 * @type {string|Ext.data.proxy.Proxy|object}
		 */
		proxy?: string | Ext.data.proxy.Proxy | object;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * The role for the [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @configuration
		 * @optional
		 * @type {Ext.data.schema.Role}
		 */
		role?: Ext.data.schema.Role;
		/** 
		 * The session for this store. By specifying a session, it ensures any records that are
		 * added to this store are also included in the session. This store does not become a member
		 * of the session itself.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Session}
		 */
		session?: Ext.data.Session;
		/** 
		 * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
		 * Defaults to true, ignored if [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) is true
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		sortOnLoad?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * This config controls whether removed records are remembered by this store for
		 * later saving to the server.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		trackRemoved?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.data.ArrayStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.ArrayStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.ArrayStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.ArrayStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.ArrayStore.Statics}  
		 */
		statics? (): Ext.data.ArrayStore.Statics;
	}
}
declare namespace Ext.data.Batch {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html)
	 * Provides a mechanism to run one or more [operations](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * in a given order. Fires the `operationcomplete` event after the completion of each
	 * Operation, and the `complete` event when all Operations have been successfully executed.
	 * Fires an `exception` event if any of the Operations encounter an exception.
	 * 
	 * Usually these are only used internally by [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) classes.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * True to pause the execution of the batch if any operation encounters an exception
		 * (defaults to false). If you set this to true you are responsible for implementing the appropriate
		 * handling logic and restarting or discarding the batch as needed. There are different ways you could
		 * do this, e.g. by handling the batch's [exception](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#event-exception) event directly, or perhaps by overriding
		 * [onBatchException](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-onBatchException) at the store level. If you do pause
		 * and attempt to handle the exception you can call [retry](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html#method-retry) to process the same operation again.
		 * 
		 * Note that [operations](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) are atomic, so any operations that may have succeeded
		 * prior to an exception (and up until pausing the batch) will be finalized at the server level and will
		 * not be automatically reversible. Any transactional / rollback behavior that might be desired would have
		 * to be implemented at the application level. Pausing on exception will likely be most beneficial when
		 * used in coordination with such a scheme, where an exception might actually affect subsequent operations
		 * in the same batch and so should be handled before continuing with the next operation.
		 * 
		 * If you have not implemented transactional operation handling then this option should typically be left
		 * to the default of false (e.g. process as many operations as possible, and handle any exceptions
		 * asynchronously without holding up the rest of the batch).
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		pauseOnException?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                 config
		 * @returns {Ext.data.Batch.Statics}        this
		 */
		initConfig? (config: object): Ext.data.Batch.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}          name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                 [value] The value to set for the name parameter.
		 * @returns {Ext.data.Batch.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Batch.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Batch.Statics}  
		 */
		statics? (): Ext.data.Batch.Statics;
	}
}
declare namespace Ext.data.BufferedStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html)
	 * A BufferedStore maintains a sparsely populated map of pages corresponding to an extremely large server-side dataset.
	 * 
	 * Use a BufferedStore when the dataset size is so large that the database and network latency, and client memory requirements
	 * preclude caching the entire dataset in a regular [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
	 * 
	 * When using a BufferedStore _not all of the dataset is present in the client_. Only pages which have been
	 * requested by the UI (usually a GridPanel) and surrounding pages will be present. Retention
	 * of viewed pages in the BufferedStore after they have been scrolled out of view is configurable. See [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone),
	 * [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone) and [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount).
	 * 
	 * To use a BufferedStore, initiate the loading process by loading the first page. The number of rows rendered are
	 * determined automatically, and the range of pages needed to keep the cache primed for scrolling is
	 * requested and cached.
	 * Example:
	 * 
	 *    myBufferedStore.loadPage(1); // Load page 1
	 * 
	 * A BufferedRenderer is instantiated which will monitor the scrolling in the grid, and
	 * refresh the view's rows from the page cache as needed. It will also pull new data into the page
	 * cache when scrolling of the view draws upon data near either end of the prefetched data.
	 * 
	 * The margins which trigger view refreshing from the prefetched data are Ext.grid.plugin.BufferedRenderer.numFromEdge,
	 * Ext.grid.plugin.BufferedRenderer.leadingBufferZone and Ext.grid.plugin.BufferedRenderer.trailingBufferZone.
	 * 
	 * The margins which trigger loading more data into the page cache are, [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone) and
	 * [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone).
	 * 
	 * By default, only 5 pages of data (in addition to the pages which over the visible region) are cached in the page cache,
	 * with old pages being evicted from the cache as the view moves down through the dataset. This is controlled by the
	 * [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount) setting.
	 * 
	 * Setting this value to zero means that no pages are _ever_ scrolled out of the page cache, and
	 * that eventually the whole dataset may become present in the page cache. This is sometimes desirable
	 * as long as datasets do not reach astronomical proportions.
	 * 
	 * Selection state may be maintained across page boundaries by configuring the SelectionModel not to discard
	 * records from its collection when those Records cycle out of the Store's primary collection. This is done
	 * by configuring the SelectionModel like this:
	 * 
	 *    selModel: {
	 *        pruneRemoved: false
	 *    }
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * This defaults to `true` when this store's [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy) is asynchronous, such as an
		 * [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html).
		 * 
		 * When the proxy is synchronous, such as a [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) memory proxy, this
		 * defaults to `false`.
		 * 
		 * _NOTE:_ This does not cause synchronous Ajax requests if configured `false` when an Ajax proxy
		 * is used. It causes immediate issuing of an Ajax request when [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) is called
		 * rather than issuing the request at the end of the current event handler run.
		 * 
		 * What this means is that when using an Ajax proxy, calls to
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) do not fire the request to the remote resource
		 * immediately, but schedule a request to be made. This is so that multiple
		 * requests are not fired when mutating a store's remote filters and sorters (as
		 * happens during state restoration). The request is made only once after all
		 * relevant store state is fully set.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		asynchronousLoad?: boolean;
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
		 * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
		 * 
		 * It's important to note that [Tree Stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) will<br/>
		 * load regardless of autoLoad's value if expand is set to true on the
		 * [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @configuration
		 * @optional
		 * @type {boolean|object}
		 */
		autoLoad?: boolean | object;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		autoSync?: boolean;
		/** 
		 * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
		 * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
		 * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
		 * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
		 * @configuration
		 * @optional
		 * @default 'operation'
		 * @type {string}
		 */
		batchUpdateMode?: string;
		/** 
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		data?: number;
		/** 
		 * The default view size to use until the [viewSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-viewSize) has been configured.
		 * @configuration
		 * @optional
		 * @default 100
		 * @type {number}
		 */
		defaultViewSize?: number;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * The number of extra rows to keep cached on the leading side of scrolling buffer
		 * as scrolling proceeds. A larger number means fewer replenishments from the server.
		 * @configuration
		 * @optional
		 * @default 200
		 * @type {number}
		 */
		leadingBufferZone?: number;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Name of the [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) associated with this store. See
		 * [Ext.data.Model.entityName](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-entityName).
		 * 
		 * May also be the actual Model subclass.
		 * 
		 * This config is required for the store to be able to read data unless you have defined
		 * the [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields) config which will create an anonymous [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html).
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The number of records considered to form a 'page'. This is used to power the built-in
		 * paging using the nextPage and previousPage functions when the grid is paged using a
		 * PagingToolbar Defaults to 25.
		 * 
		 * To disable paging, set the pageSize to `0`.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
		 * see [setProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-setProxy) for details.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.proxy.Proxy|object}
		 */
		proxy?: string | Ext.data.proxy.Proxy | object;
		/** 
		 * The number of pages _in addition to twice the required buffered range_ to keep in the prefetch cache before purging least recently used records.
		 * 
		 * For example, if the height of the view area and the configured [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone) and [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone) require that there
		 * are three pages in the cache, then a `purgePageCount` of 5 ensures that up to 11 pages can be in the page cache any any one time. This is enough
		 * to allow the user to scroll rapidly between different areas of the dataset without evicting pages which are still needed.
		 * 
		 * A value of 0 indicates to never purge the prefetched data.
		 * @configuration
		 * @optional
		 * @default 5
		 * @type {number}
		 */
		purgePageCount?: number;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
		 * Defaults to true, ignored if [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) is true
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		sortOnLoad?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * This config controls whether removed records are remembered by this store for
		 * later saving to the server.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		trackRemoved?: boolean;
		/** 
		 * The number of extra records to keep cached on the trailing side of scrolling buffer
		 * as scrolling proceeds. A larger number means fewer replenishments from the server.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		trailingBufferZone?: number;
		/** 
		 * The view size needed to fill the current view. Defaults to the [defaultViewSize](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-defaultViewSize).
		 * This will typically be set by the underlying view.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		viewSize?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                         config
		 * @returns {Ext.data.BufferedStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.BufferedStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                  name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                         [value] The value to set for the name parameter.
		 * @returns {Ext.data.BufferedStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.BufferedStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.BufferedStore.Statics}  
		 */
		statics? (): Ext.data.BufferedStore.Statics;
	}
}
declare namespace Ext.data.Connection {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.Connection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html)
	 * The Connection class encapsulates a connection to the page's originating domain, allowing requests to be made either
	 * to a configured URL, or to a URL specified at request time.
	 * 
	 * Requests made by this class are asynchronous, and will return immediately. No data from the server will be available
	 * to the statement immediately following the [request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-request) call. To process returned data, use a success callback
	 * in the request options object, or an [event listener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#event-requestcomplete).
	 * 
	 * # File Uploads
	 * 
	 * File uploads are not performed using normal "Ajax" techniques, that is they are not performed using XMLHttpRequests.
	 * Instead the form is submitted in the standard manner with the DOM &lt;form&gt; element temporarily modified to have its
	 * target set to refer to a dynamically generated, hidden &lt;iframe&gt; which is inserted into the document but removed
	 * after the return data has been gathered.
	 * 
	 * The server response is parsed by the browser to create the document for the IFRAME. If the server is using JSON to
	 * send the return object, then the Content-Type header must be set to "text/html" in order to tell the browser to
	 * insert the text unchanged into the document body.
	 * 
	 * Characters which are significant to an HTML parser must be sent as HTML entities, so encode `&lt;` as `&amp;lt;`, `&amp;` as
	 * `&amp;amp;` etc.
	 * 
	 * The response text is retrieved from the document, and a fake XMLHttpRequest object is created containing a
	 * responseText property in order to conform to the requirements of event handlers and callbacks.
	 * 
	 * Be aware that file upload packets are sent with the content type multipart/form and some server technologies
	 * (notably JEE) may require some custom processing in order to retrieve parameter names and parameter values from the
	 * packet content.
	 * 
	 * Also note that it's not possible to check the response code of the hidden iframe, so the success handler will ALWAYS fire.
	 * 
	 * # Binary Posts
	 * 
	 * The class supports posting binary data to the server by using native browser capabilities, or a flash polyfill plugin in browsers that do not support native binary posting (e.g. Internet Explorer version 9 or less). A number of limitations exist when the polyfill is used:
	 * 
	 * - Only asynchronous connections are supported.
	 * - Only the POST method can be used.
	 * - The return data can only be binary for now. Set the [binary](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-binary) parameter to <tt>true</tt>.
	 * - Only the 0, 1 and 4 (complete) readyState values will be reported to listeners.
	 * - The flash object will be injected at the bottom of the document and should be invisible.
	 * - Important: See note about packaing the flash plugin with the app in the documenetation of [BinaryXhr](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.flash.BinaryXhr.html).
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * `true` if this request should run asynchronously. Setting this to `false` should generally
		 * be avoided, since it will cause the UI to be blocked, the user won't be able to interact
		 * with the browser until the request completes.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		async?: boolean;
		/** 
		 * Whether this request should abort any pending requests.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		autoAbort?: boolean;
		/** 
		 * True if the response should be treated as binary data.  If true, the binary
		 * data will be accessible as a "responseBytes" property on the response object.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		binary?: boolean;
		/** 
		 * True to enable CORS support on the XHR object. Currently the only effect of this option
		 * is to use the XDomainRequest object instead of XMLHttpRequest if the browser is IE8 or above.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		cors?: boolean;
		/** 
		 * An object containing request headers which are added to each request made by this object.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		defaultHeaders?: object;
		/** 
		 * The default header to be sent out with any post request.
		 * @configuration
		 * @optional
		 * @default 'application/x-www-form-urlencoded; charset=UTF-8'
		 * @type {string}
		 */
		defaultPostHeader?: string;
		/** 
		 * @configuration
		 * @optional
		 * @default 'text/plain'
		 * @type {string}
		 */
		defaultXdrContentType?: string;
		/** 
		 * The header to send with Ajax requests. Also see [useDefaultXhrHeader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-useDefaultXhrHeader).
		 * @configuration
		 * @optional
		 * @default 'XMLHttpRequest'
		 * @type {string}
		 */
		defaultXhrHeader?: string;
		/** 
		 * True to add a unique cache-buster param to GET requests.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		disableCaching?: boolean;
		/** 
		 * Change the parameter which is sent went disabling caching through a cache buster.
		 * @configuration
		 * @optional
		 * @default '_dc'
		 * @type {string}
		 */
		disableCachingParam?: string;
		/** 
		 * Any parameters to be appended to the request.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		extraParams?: object;
		/** 
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		isXdr?: boolean;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The default HTTP method to be used for requests.
		 * 
		 * If not set, but [request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-request) params are present, POST will be used;
		 * otherwise, GET will be used.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		method?: string;
		/** 
		 * The password to pass when using [withCredentials](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-withCredentials).
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		password?: string;
		/** 
		 * The timeout in milliseconds to be used for
		 * requests.<br/>
		 * Defaults to 30000 milliseconds (30 seconds).
		 * 
		 * When a request fails due to timeout the XMLHttpRequest response object will
		 * contain:
		 * 
		 *    timedout: true
		 * 
		 * @configuration
		 * @optional
		 * @default 30000
		 * @type {number}
		 */
		timeout?: number;
		/** 
		 * The URL for this connection.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		url?: string;
		/** 
		 * `true` to send the [defaultXhrHeader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-defaultXhrHeader) along with any request.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		useDefaultXhrHeader?: boolean;
		/** 
		 * The username to pass when using [withCredentials](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-withCredentials).
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		username?: string;
		/** 
		 * True to set `withCredentials = true` on the XHR object
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		withCredentials?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.data.Connection.Statics}        this
		 */
		initConfig? (config: object): Ext.data.Connection.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.Connection.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Connection.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Connection.Statics}  
		 */
		statics? (): Ext.data.Connection.Statics;
	}
}
declare namespace Ext.data.DirectStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.DirectStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html)
	 * Small helper class to create an [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) configured with an [Ext.data.proxy.Direct](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html)
	 * and [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) to make interacting with an [Ext.direct.Manager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.direct.Manager.html) server-side
	 * [Provider](https://docs.sencha.com/extjs/6.2.0/modern/Ext.direct.Provider.html) easier. To create a different proxy/reader combination create a basic
	 * [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) configured as needed.
	 * 
	 * **Note:** Although they are not listed, this class inherits all of the config options of:
	 * 
	 * - **[Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)**
	 * - **[JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html)**
	 *   <ul>
	 *   <li>**[rootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html#cfg-rootProperty)**
	 * - **[totalProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html#cfg-totalProperty)**
	 * 
	 * </li>
	 * <li>
	 * 
	 * **[DirectProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html)**
	 * 
	 * - **[directFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-directFn)**
	 * - **[paramOrder](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-paramOrder)**
	 * - **[paramsAsHash](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-paramsAsHash)**
	 * 
	 * </li>
	 * </ul>
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The owner of this store if the store is used as part of an association.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Model}
		 */
		associatedEntity?: Ext.data.Model;
		/** 
		 * This defaults to `true` when this store's [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy) is asynchronous, such as an
		 * [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html).
		 * 
		 * When the proxy is synchronous, such as a [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) memory proxy, this
		 * defaults to `false`.
		 * 
		 * _NOTE:_ This does not cause synchronous Ajax requests if configured `false` when an Ajax proxy
		 * is used. It causes immediate issuing of an Ajax request when [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) is called
		 * rather than issuing the request at the end of the current event handler run.
		 * 
		 * What this means is that when using an Ajax proxy, calls to
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) do not fire the request to the remote resource
		 * immediately, but schedule a request to be made. This is so that multiple
		 * requests are not fired when mutating a store's remote filters and sorters (as
		 * happens during state restoration). The request is made only once after all
		 * relevant store state is fully set.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		asynchronousLoad?: boolean;
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
		 * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
		 * 
		 * It's important to note that [Tree Stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) will<br/>
		 * load regardless of autoLoad's value if expand is set to true on the
		 * [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @configuration
		 * @optional
		 * @type {boolean|object}
		 */
		autoLoad?: boolean | object;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		autoSync?: boolean;
		/** 
		 * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
		 * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
		 * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
		 * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
		 * @configuration
		 * @optional
		 * @default 'operation'
		 * @type {string}
		 */
		batchUpdateMode?: string;
		/** 
		 * True to empty the store when loading another page via [loadPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadPage),
		 * [nextPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-nextPage) or [previousPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-previousPage). Setting to false keeps existing records, allowing
		 * large data sets to be loaded one page at a time but rendered all together.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearOnPageLoad?: boolean;
		/** 
		 * `true` to clear anything in the [removed](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#property-removed) record collection when the store loads.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearRemovedOnLoad?: boolean;
		/** 
		 * Array of Model instances or data objects to load locally. See "Inline data"
		 * above for details.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {object[]|Ext.data.Model[]}
		 */
		data?: object[] | Ext.data.Model[];
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		extraKeys?: object;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Name of the [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) associated with this store. See
		 * [Ext.data.Model.entityName](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-entityName).
		 * 
		 * May also be the actual Model subclass.
		 * 
		 * This config is required for the store to be able to read data unless you have defined
		 * the [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields) config which will create an anonymous [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html).
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The number of records considered to form a 'page'. This is used to power the built-in
		 * paging using the nextPage and previousPage functions when the grid is paged using a
		 * PagingToolbar Defaults to 25.
		 * 
		 * To disable paging, set the pageSize to `0`.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
		 * see [setProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-setProxy) for details.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.proxy.Proxy|object}
		 */
		proxy?: string | Ext.data.proxy.Proxy | object;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * The role for the [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @configuration
		 * @optional
		 * @type {Ext.data.schema.Role}
		 */
		role?: Ext.data.schema.Role;
		/** 
		 * The session for this store. By specifying a session, it ensures any records that are
		 * added to this store are also included in the session. This store does not become a member
		 * of the session itself.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Session}
		 */
		session?: Ext.data.Session;
		/** 
		 * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
		 * Defaults to true, ignored if [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) is true
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		sortOnLoad?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * This config controls whether removed records are remembered by this store for
		 * later saving to the server.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		trackRemoved?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                       config
		 * @returns {Ext.data.DirectStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.DirectStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                       [value] The value to set for the name parameter.
		 * @returns {Ext.data.DirectStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.DirectStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.DirectStore.Statics}  
		 */
		statics? (): Ext.data.DirectStore.Statics;
	}
}
declare namespace Ext.data.Error {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.Error](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Error.html)
	 * This class hols the results of a validator for an [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html). These objects are
	 * placed in an [`Ext.data.ErrorCollection`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html) and returned by [`Ext.data.Model.validate`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate).
	 * 
	 * Usually this class does not need to be instantiated directly - instances are instead created
	 * automatically when [validate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate) on a model instance.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The name of the field this error belongs to.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		field?: string;
		/** 
		 * The message containing the description of the error.
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		message?: string;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                 config
		 * @returns {Ext.data.Error.Statics}        this
		 */
		initConfig? (config: object): Ext.data.Error.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}          name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                 [value] The value to set for the name parameter.
		 * @returns {Ext.data.Error.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Error.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Error.Statics}  
		 */
		statics? (): Ext.data.Error.Statics;
	}
}
declare namespace Ext.data.ErrorCollection {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.ErrorCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html)
	 * Wraps a collection of validation error responses and provides convenient functions for
	 * accessing and errors for specific fields.
	 * 
	 * Usually this class does not need to be instantiated directly - instances are instead
	 * created automatically when [validate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate) on a model instance:
	 * 
	 *     // Validate some existing model instance - in this case it returned 2 failures
	 *     // messages
	 *    
	 *     var errors = myModel.validate();
	 *     errors.isValid(); //false
	 *    
	 *     errors.length; //2
	 *     errors.getByField('name');  // [{field: 'name',  message: 'must be present'}]
	 *     errors.getByField('title'); // [{field: 'title', message: 'is too short'}]
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * Configure as `true` if the [addAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html#method-addAll) function should add function references to the collection.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowFunctions?: boolean;
		/** 
		 * The default sort direction to use if one is not specified.
		 * @configuration
		 * @optional
		 * @default "ASC"
		 * @type {string}
		 */
		defaultSortDirection?: string;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The maximum number of sorters which may be applied to this Sortable when using the "multi" insertion position
		 * when adding sorters.
		 * 
		 * New sorters added using the "multi" insertion position are inserted at the top of the sorters list becoming the
		 * new primary sort key.
		 * 
		 * If the sorters collection has grown to longer then **`multiSortLimit`**, then the it is trimmed.
		 * @configuration
		 * @optional
		 * @default 3
		 * @type {number}
		 */
		multiSortLimit?: number;
		/** 
		 * The property in each item that contains the data to sort.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		sortRoot?: string;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html).
		 * 
		 *    sorters: [{
		 *        property: 'age',
		 *        direction: 'DESC'
		 *    }, {
		 *        property: 'firstName',
		 *        direction: 'ASC'
		 *    }]
		 * 
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * A function which will be called, passing a newly added object
		 * when the object is added without a separate id.  The function
		 * should yield the key by which that object will be indexed.
		 * 
		 * If no key is yielded, then the object will be added, but it
		 * cannot be accessed or removed quickly. Finding it in this
		 * collection for interrogation or removal will require a linear
		 * scan of this collection's items.
		 * 
		 * The default implementation simply returns `item.id` but you can
		 * provide your own implementation to return a different value as
		 * in the following examples:
		 * 
		 *    // normal way
		 *    var mc = new Ext.util.MixedCollection();
		 *    mc.add(someEl.dom.id, someEl);
		 *    mc.add(otherEl.dom.id, otherEl);
		 *    //and so on
		 *    
		 *    // using getKey
		 *    var mc = new Ext.util.MixedCollection({
		 *        getKey: function(el){
		 *            return el.dom.id;
		 *        }
		 *    });
		 *    mc.add(someEl);
		 *    mc.add(otherEl);
		 * 
		 * @method
		 * @public (method)
		 * @template
		 * @param   {object} item
		 * @returns {object}      The key for the passed item.
		 */
		getKey? (item: object): object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                           config
		 * @returns {Ext.data.ErrorCollection.Statics}        this
		 */
		initConfig? (config: object): Ext.data.ErrorCollection.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                    name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                           [value] The value to set for the name parameter.
		 * @returns {Ext.data.ErrorCollection.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.ErrorCollection.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.ErrorCollection.Statics}  
		 */
		statics? (): Ext.data.ErrorCollection.Statics;
	}
}
declare namespace Ext.data.ChainedStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html)
	 * A chained store is a store that is a "view" of an existing store. The data comes from the
	 * [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source), however this view of the store may be sorted &amp; filtered independently without
	 * having any impact on the [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source) store.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		extraKeys?: object;
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The number of records considered to form a 'page'. This is used to power the built-in
		 * paging using the nextPage and previousPage functions when the grid is paged using a
		 * PagingToolbar Defaults to 25.
		 * 
		 * To disable paging, set the pageSize to `0`.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * The backing data source for this chained store. Either a store instance
		 * or the id of an existing store.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Store|string}
		 */
		source?: Ext.data.Store | string;
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                        config
		 * @returns {Ext.data.ChainedStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.ChainedStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                 name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                        [value] The value to set for the name parameter.
		 * @returns {Ext.data.ChainedStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.ChainedStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.ChainedStore.Statics}  
		 */
		statics? (): Ext.data.ChainedStore.Statics;
	}
}
declare namespace Ext.data.JsonPStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.JsonPStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from different domain JSON data easier.
	 * A JsonPStore will be automatically configured with a [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) and a [JsonPProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.JsonP.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.JsonPStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *    
	 *        // proxy configs
	 *        url: 'get-images.php',
	 *    
	 *        // reader configs
	 *        root: 'images',
	 *        fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    stcCallback({
	 *        images: [
	 *            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
	 *            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
	 *        ]
	 *    })
	 * 
	 * Where stcCallback is the callback name passed in the request to the remote domain. See [JsonPProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.JsonP.html)
	 * for details of how this works.
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#cfg-data) config option.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The owner of this store if the store is used as part of an association.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Model}
		 */
		associatedEntity?: Ext.data.Model;
		/** 
		 * This defaults to `true` when this store's [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy) is asynchronous, such as an
		 * [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html).
		 * 
		 * When the proxy is synchronous, such as a [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) memory proxy, this
		 * defaults to `false`.
		 * 
		 * _NOTE:_ This does not cause synchronous Ajax requests if configured `false` when an Ajax proxy
		 * is used. It causes immediate issuing of an Ajax request when [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) is called
		 * rather than issuing the request at the end of the current event handler run.
		 * 
		 * What this means is that when using an Ajax proxy, calls to
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) do not fire the request to the remote resource
		 * immediately, but schedule a request to be made. This is so that multiple
		 * requests are not fired when mutating a store's remote filters and sorters (as
		 * happens during state restoration). The request is made only once after all
		 * relevant store state is fully set.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		asynchronousLoad?: boolean;
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
		 * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
		 * 
		 * It's important to note that [Tree Stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) will<br/>
		 * load regardless of autoLoad's value if expand is set to true on the
		 * [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @configuration
		 * @optional
		 * @type {boolean|object}
		 */
		autoLoad?: boolean | object;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		autoSync?: boolean;
		/** 
		 * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
		 * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
		 * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
		 * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
		 * @configuration
		 * @optional
		 * @default 'operation'
		 * @type {string}
		 */
		batchUpdateMode?: string;
		/** 
		 * True to empty the store when loading another page via [loadPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadPage),
		 * [nextPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-nextPage) or [previousPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-previousPage). Setting to false keeps existing records, allowing
		 * large data sets to be loaded one page at a time but rendered all together.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearOnPageLoad?: boolean;
		/** 
		 * `true` to clear anything in the [removed](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#property-removed) record collection when the store loads.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearRemovedOnLoad?: boolean;
		/** 
		 * Array of Model instances or data objects to load locally. See "Inline data"
		 * above for details.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {object[]|Ext.data.Model[]}
		 */
		data?: object[] | Ext.data.Model[];
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		extraKeys?: object;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Name of the [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) associated with this store. See
		 * [Ext.data.Model.entityName](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-entityName).
		 * 
		 * May also be the actual Model subclass.
		 * 
		 * This config is required for the store to be able to read data unless you have defined
		 * the [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields) config which will create an anonymous [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html).
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The number of records considered to form a 'page'. This is used to power the built-in
		 * paging using the nextPage and previousPage functions when the grid is paged using a
		 * PagingToolbar Defaults to 25.
		 * 
		 * To disable paging, set the pageSize to `0`.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
		 * see [setProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-setProxy) for details.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.proxy.Proxy|object}
		 */
		proxy?: string | Ext.data.proxy.Proxy | object;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * The role for the [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @configuration
		 * @optional
		 * @type {Ext.data.schema.Role}
		 */
		role?: Ext.data.schema.Role;
		/** 
		 * The session for this store. By specifying a session, it ensures any records that are
		 * added to this store are also included in the session. This store does not become a member
		 * of the session itself.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Session}
		 */
		session?: Ext.data.Session;
		/** 
		 * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
		 * Defaults to true, ignored if [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) is true
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		sortOnLoad?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * This config controls whether removed records are remembered by this store for
		 * later saving to the server.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		trackRemoved?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.data.JsonPStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.JsonPStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.JsonPStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.JsonPStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.JsonPStore.Statics}  
		 */
		statics? (): Ext.data.JsonPStore.Statics;
	}
}
declare namespace Ext.data.JsonStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.JsonStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from JSON data easier.
	 * A JsonStore will be automatically configured with a [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.JsonStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *    
	 *        proxy: {
	 *            type: 'ajax',
	 *            url: 'get-images.php',
	 *            reader: {
	 *                type: 'json',
	 *                rootProperty: 'images'
	 *            }
	 *        },
	 *    
	 *        //alternatively, a Model name can be given (see Ext.data.Store for an example)
	 *        fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    {
	 *        images: [
	 *            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
	 *            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
	 *        ]
	 *    }
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#cfg-data) config option.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The owner of this store if the store is used as part of an association.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Model}
		 */
		associatedEntity?: Ext.data.Model;
		/** 
		 * This defaults to `true` when this store's [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy) is asynchronous, such as an
		 * [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html).
		 * 
		 * When the proxy is synchronous, such as a [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) memory proxy, this
		 * defaults to `false`.
		 * 
		 * _NOTE:_ This does not cause synchronous Ajax requests if configured `false` when an Ajax proxy
		 * is used. It causes immediate issuing of an Ajax request when [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) is called
		 * rather than issuing the request at the end of the current event handler run.
		 * 
		 * What this means is that when using an Ajax proxy, calls to
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) do not fire the request to the remote resource
		 * immediately, but schedule a request to be made. This is so that multiple
		 * requests are not fired when mutating a store's remote filters and sorters (as
		 * happens during state restoration). The request is made only once after all
		 * relevant store state is fully set.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		asynchronousLoad?: boolean;
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
		 * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
		 * 
		 * It's important to note that [Tree Stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) will<br/>
		 * load regardless of autoLoad's value if expand is set to true on the
		 * [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @configuration
		 * @optional
		 * @type {boolean|object}
		 */
		autoLoad?: boolean | object;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		autoSync?: boolean;
		/** 
		 * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
		 * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
		 * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
		 * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
		 * @configuration
		 * @optional
		 * @default 'operation'
		 * @type {string}
		 */
		batchUpdateMode?: string;
		/** 
		 * True to empty the store when loading another page via [loadPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadPage),
		 * [nextPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-nextPage) or [previousPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-previousPage). Setting to false keeps existing records, allowing
		 * large data sets to be loaded one page at a time but rendered all together.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearOnPageLoad?: boolean;
		/** 
		 * `true` to clear anything in the [removed](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#property-removed) record collection when the store loads.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearRemovedOnLoad?: boolean;
		/** 
		 * Array of Model instances or data objects to load locally. See "Inline data"
		 * above for details.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {object[]|Ext.data.Model[]}
		 */
		data?: object[] | Ext.data.Model[];
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		extraKeys?: object;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Name of the [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) associated with this store. See
		 * [Ext.data.Model.entityName](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-entityName).
		 * 
		 * May also be the actual Model subclass.
		 * 
		 * This config is required for the store to be able to read data unless you have defined
		 * the [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields) config which will create an anonymous [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html).
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The number of records considered to form a 'page'. This is used to power the built-in
		 * paging using the nextPage and previousPage functions when the grid is paged using a
		 * PagingToolbar Defaults to 25.
		 * 
		 * To disable paging, set the pageSize to `0`.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
		 * see [setProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-setProxy) for details.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.proxy.Proxy|object}
		 */
		proxy?: string | Ext.data.proxy.Proxy | object;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * The role for the [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @configuration
		 * @optional
		 * @type {Ext.data.schema.Role}
		 */
		role?: Ext.data.schema.Role;
		/** 
		 * The session for this store. By specifying a session, it ensures any records that are
		 * added to this store are also included in the session. This store does not become a member
		 * of the session itself.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Session}
		 */
		session?: Ext.data.Session;
		/** 
		 * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
		 * Defaults to true, ignored if [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) is true
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		sortOnLoad?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * This config controls whether removed records are remembered by this store for
		 * later saving to the server.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		trackRemoved?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                     config
		 * @returns {Ext.data.JsonStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.JsonStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}              name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                     [value] The value to set for the name parameter.
		 * @returns {Ext.data.JsonStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.JsonStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.JsonStore.Statics}  
		 */
		statics? (): Ext.data.JsonStore.Statics;
	}
}
declare namespace Ext.data.LocalStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.LocalStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.LocalStore.html)
	 * A mixin that provides common store methods for [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) &amp; [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html).
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		extraKeys?: object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.data.LocalStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.LocalStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.LocalStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.LocalStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.LocalStore.Statics}  
		 */
		statics? (): Ext.data.LocalStore.Statics;
	}
}
declare namespace Ext.data.Model {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html)
	 * A Model or Entity represents some object that your application manages. For example, one
	 * might define a Model for Users, Products, Cars, or other real-world object that we want
	 * to model in the system. Models are used by [stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html), which are in
	 * turn used by many of the data-bound components in Ext.
	 * 
	 * # Fields
	 * 
	 * Models are defined as a set of fields and any arbitrary methods and properties relevant
	 * to the model. For example:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            {name: 'name',  type: 'string'},
	 *            {name: 'age',   type: 'int', convert: null},
	 *            {name: 'phone', type: 'string'},
	 *            {name: 'alive', type: 'boolean', defaultValue: true, convert: null}
	 *        ],
	 *    
	 *        changeName: function() {
	 *            var oldName = this.get('name'),
	 *                newName = oldName + " The Barbarian";
	 *    
	 *            this.set('name', newName);
	 *        }
	 *    });
	 * 
	 * Now we can create instances of our User model and call any model logic we defined:
	 * 
	 *    var user = Ext.create('User', {
	 *        id   : 'ABCD12345',
	 *        name : 'Conan',
	 *        age  : 24,
	 *        phone: '555-555-5555'
	 *    });
	 *    
	 *    user.changeName();
	 *    user.get('name'); //returns "Conan The Barbarian"
	 * 
	 * By default, the built in field types such as number and boolean coerce string values
	 * in the raw data by virtue of their [Ext.data.field.Field.convert](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#method-convert) method.
	 * When the server can be relied upon to send data in a format that does not need to be
	 * converted, disabling this can improve performance. The [Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html)
	 * and [Array](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Array.html) readers are likely candidates for this
	 * optimization. To disable field conversions you simply specify `null` for the field's
	 * [convert config](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-convert).
	 * 
	 * ## The "id" Field and `idProperty`
	 * 
	 * A Model definition always has an _identifying field_ which should yield a unique key
	 * for each instance. By default, a field named "id" will be created with a
	 * [mapping](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-mapping) of "id". This happens because of the default
	 * [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) provided in Model definitions.
	 * 
	 * To alter which field is the identifying field, use the [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) config.
	 * 
	 * # Validators
	 * 
	 * Models have built-in support for field validators. Validators are added to models as in
	 * the follow example:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: [
	 *            { name: 'name',     type: 'string' },
	 *            { name: 'age',      type: 'int' },
	 *            { name: 'phone',    type: 'string' },
	 *            { name: 'gender',   type: 'string' },
	 *            { name: 'username', type: 'string' },
	 *            { name: 'alive',    type: 'boolean', defaultValue: true }
	 *        ],
	 *    
	 *        validators: {
	 *            age: 'presence',
	 *            name: { type: 'length', min: 2 },
	 *            gender: { type: 'inclusion', list: ['Male', 'Female'] },
	 *            username: [
	 *                { type: 'exclusion', list: ['Admin', 'Operator'] },
	 *                { type: 'format', matcher: /([a-z]+)[0-9]{2,3}/i }
	 *            ]
	 *        }
	 *    });
	 * 
	 * The derived type of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) can also provide validation. If `validators`
	 * need to be duplicated on multiple fields, instead consider creating a custom field type.
	 * 
	 * ## Validation
	 * 
	 * The results of the validators can be retrieved via the "associated" validation record:
	 * 
	 *    var instance = Ext.create('User', {
	 *        name: 'Ed',
	 *        gender: 'Male',
	 *        username: 'edspencer'
	 *    });
	 *    
	 *    var validation = instance.getValidation();
	 * 
	 * The returned object is an instance of [`Ext.data.Validation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html) and has as its fields the
	 * result of the field `validators`. The validation object is "dirty" if there are one or
	 * more validation errors present.
	 * 
	 * This record is also available when using data binding as a "pseudo-association" called
	 * "validation". This pseudo-association can be hidden by an explicitly declared
	 * association by the same name (for compatibility reasons), but doing so is not
	 * recommended.
	 * 
	 * The `Ext.Component.modelValidation` config can be used to enable automatic
	 * binding from the "validation" of a record to the form fields that may be bound to its
	 * values.
	 * 
	 * # Associations
	 * 
	 * Models often have associations with other Models. These associations can be defined by
	 * fields (often called "foreign keys") or by other data such as a many-to-many (or "matrix").
	 * See [Ext.data.schema.Association](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Association.html) for information about configuring and using associations.
	 * 
	 * # Using a Proxy
	 * 
	 * Models are great for representing types of data and relationships, but sooner or later we're going to want to load or
	 * save that data somewhere. All loading and saving of data is handled via a [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html), which
	 * can be set directly on the Model:
	 * 
	 *    Ext.define('User', {
	 *        extend: 'Ext.data.Model',
	 *        fields: ['id', 'name', 'email'],
	 *    
	 *        proxy: {
	 *            type: 'rest',
	 *            url : '/users'
	 *        }
	 *    });
	 * 
	 * Here we've set up a [Rest Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Rest.html), which knows how to load and save data to and from a
	 * RESTful backend. Let's see how this works:
	 * 
	 *    var user = Ext.create('User', {name: 'Ed Spencer', email: 'ed@sencha.com'});
	 *    
	 *    user.save(); //POST /users
	 * 
	 * Calling [save](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-save) on the new Model instance tells the configured RestProxy that we wish to persist this Model's
	 * data onto our server. RestProxy figures out that this Model hasn't been saved before because it doesn't have an id,
	 * and performs the appropriate action - in this case issuing a POST request to the url we configured (/users). We
	 * configure any Proxy on any Model and always follow this API - see [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) for a full list.
	 * 
	 * Loading data via the Proxy is accomplished with the static `load` method:
	 * 
	 *    //Uses the configured RestProxy to make a GET request to /users/123
	 *    User.load(123, {
	 *        success: function(user) {
	 *            console.log(user.getId()); //logs 123
	 *        }
	 *    });
	 * 
	 * Models can also be updated and destroyed easily:
	 * 
	 *    //the user Model we loaded in the last snippet:
	 *    user.set('name', 'Edward Spencer');
	 *    
	 *    //tells the Proxy to save the Model. In this case it will perform a PUT request to /users/123 as this Model already has an id
	 *    user.save({
	 *        success: function() {
	 *            console.log('The User was updated');
	 *        }
	 *    });
	 *    
	 *    //tells the Proxy to destroy the Model. Performs a DELETE request to /users/123
	 *    user.erase({
	 *        success: function() {
	 *            console.log('The User was destroyed!');
	 *        }
	 *    });
	 * 
	 * # HTTP Parameter names when using a [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html)
	 * 
	 * By default, the model ID is specified in an HTTP parameter named `id`. To change the
	 * name of this parameter use the Proxy's [idParam](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-idParam)
	 * configuration.
	 * 
	 * Parameters for other commonly passed values such as
	 * [page number](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-pageParam) or
	 * [start row](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html#cfg-startParam) may also be configured.
	 * 
	 * # Usage in Stores
	 * 
	 * It is very common to want to load a set of Model instances to be displayed and manipulated in the UI. We do this by
	 * creating a [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html):
	 * 
	 *    var store = Ext.create('Ext.data.Store', {
	 *        model: 'User'
	 *    });
	 *    
	 *    //uses the Proxy we set up on Model to load the Store data
	 *    store.load();
	 * 
	 * A Store is just a collection of Model instances - usually loaded from a server somewhere. Store can also maintain a
	 * set of added, updated and removed Model instances to be synchronized with the server via the Proxy. See the [Store docs](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) for more information on Stores.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * An array of [associations](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Association.html) for this model.
		 * 
		 * For further documentation, see [Ext.data.schema.Association](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Association.html).
		 * @configuration
		 * @optional
		 * @type {object[]}
		 */
		associations?: object[];
		/** 
		 * One or more `Ext.data.schema.BelongsTo` associations for this model.
		 * @configuration
		 * @optional
		 * @type {string|object|string[]|object[]}
		 */
		belongsTo?: string | object | string[] | object[];
		/** 
		 * The name of the property a server will use to send back a client-generated id in a
		 * `create` or `update` [`operation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
		 * 
		 * If specified, this property cannot have the same name as any other field.
		 * 
		 * For example:
		 * 
		 *     Ext.define('Person', {
		 *         idProperty: 'id',  // this is the default value (for clarity)
		 *    
		 *         clientIdProperty: 'clientId',
		 *    
		 *         identifier: 'negative', // to generate -1, -2 etc on the client
		 *    
		 *         fields: [ 'name' ]
		 *     });
		 *    
		 *     var person = new Person({
		 *         // no id provided, so -1 is generated
		 *         name: 'Clark Kent'
		 *     });
		 * 
		 * The server is given this data during the `create`:
		 * 
		 *     {
		 *         id: -1,
		 *         name: 'Clark Kent'
		 *     }
		 * 
		 * The server allocates a real id and responds like so:
		 * 
		 *     {
		 *         id: 427,
		 *         clientId: -1
		 *     }
		 * 
		 * This property is most useful when creating multiple entities in a single call to
		 * the server in a [`create operation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Create.html). Alternatively,
		 * the server could respond with records that correspond one-to-one to those sent in
		 * the `operation`.
		 * 
		 * For example the client could send a `create` with this data:
		 * 
		 *     [ { id: -1, name: 'Clark Kent' },
		 *       { id: -2, name: 'Peter Parker' },
		 *       { id: -3, name: 'Bruce Banner' } ]
		 * 
		 * And the server could respond in the same order:
		 * 
		 *     [ { id: 427 },      // updates id = -1
		 *       { id: 428 },      // updates id = -2
		 *       { id: 429 } ]     // updates id = -3
		 * 
		 * Or using `clientIdProperty` the server could respond in arbitrary order:
		 * 
		 *     [ { id: 427, clientId: -3 },
		 *       { id: 428, clientId: -1 },
		 *       { id: 429, clientId: -2 } ]
		 * 
		 * **IMPORTANT:** When upgrading from previous versions be aware that this property
		 * used to perform the role of [`Ext.data.writer.Writer.clientIdProperty`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.writer.Writer.html#cfg-clientIdProperty) as
		 * well as that described above. To continue send a client-generated id as other than
		 * the `idProperty`, set `clientIdProperty` on the `writer`. A better solution, however,
		 * is most likely a properly configured `identifier` as that would work better with
		 * associations.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		clientIdProperty?: string;
		/** 
		 * Set to `false` to prevent any converters from being called on fields specified in
		 * a [set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-set) operation.
		 * 
		 * **Note:** Setting the config to `false` will only prevent the convert / calculate
		 * call when the set `fieldName` param matches the field's `name`.  In the
		 * following example the calls to set `salary` will not execute the convert method
		 * on `set` while the calls to set `vested` will execute the convert method on the
		 * initial read as well as on `set`.
		 * 
		 * Example model definition:
		 * 
		 *    Ext.define('MyApp.model.Employee', {
		 *        extend: 'Ext.data.Model',
		 *        fields: ['yearsOfService', {
		 *            name: 'salary',
		 *            convert: function (val) {
		 *                var startingBonus = val * .1;
		 *                return val + startingBonus;
		 *            }
		 *        }, {
		 *            name: 'vested',
		 *            convert: function (val, record) {
		 *                return record.get('yearsOfService') &gt;= 4;
		 *            },
		 *            depends: 'yearsOfService'
		 *        }],
		 *        convertOnSet: false
		 *    });
		 *    
		 *    var tina = Ext.create('MyApp.model.Employee', {
		 *        salary: 50000,
		 *        yearsOfService: 3
		 *    });
		 *    
		 *    console.log(tina.get('salary')); // logs 55000
		 *    console.log(tina.get('vested')); // logs false
		 *    
		 *    tina.set({
		 *        salary: 60000,
		 *        yearsOfService: 4
		 *    });
		 *    console.log(tina.get('salary')); // logs 60000
		 *    console.log(tina.get('vested')); // logs true
		 * 
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		convertOnSet?: boolean;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * One or more [`Ext.data.schema.HasMany`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.HasMany.html) associations for this model.
		 * @configuration
		 * @optional
		 * @type {string|object|string[]|object[]}
		 */
		hasMany?: string | object | string[] | object[];
		/** 
		 * One or more [`Ext.data.schema.HasOne`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.HasOne.html) associations for this model.
		 * @configuration
		 * @optional
		 * @type {string|object|string[]|object[]}
		 */
		hasOne?: string | object | string[] | object[];
		/** 
		 * The name of the field treated as this Model's unique id.
		 * 
		 * If changing the idProperty in a subclass, the generated id field will replace the one
		 * generated by the superclass, for example;
		 * 
		 *     Ext.define('Super', {
		 *         extend: 'Ext.data.Model',
		 *         fields: ['name']
		 *     });
		 *    
		 *     Ext.define('Sub', {
		 *         extend: 'Super',
		 *         idProperty: 'customId'
		 *     });
		 *    
		 *     var fields = Super.getFields();
		 *     // Has 2 fields, "name" &amp; "id"
		 *     console.log(fields[0].name, fields[1].name, fields.length);
		 *    
		 *     fields = Sub.getFields();
		 *     // Has 2 fields, "name" &amp; "customId", "id" is replaced
		 *     console.log(fields[0].name, fields[1].name, fields.length);
		 * 
		 * The data values for this field must be unique or there will be id value collisions
		 * in the [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
		 * @configuration
		 * @optional
		 * @default 'id'
		 * @type {string}
		 */
		idProperty?: string;
		/** 
		 * The id generator to use for this model. The `identifier` generates values for the
		 * [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) when no value is given. Records with client-side generated
		 * values for [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) are called [phantom](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records since they are
		 * not yet known to the server.
		 * 
		 * This can be overridden at the model level to provide a custom generator for a model.
		 * The simplest form of this would be:
		 * 
		 *     Ext.define('MyApp.data.MyModel', {
		 *         extend: 'Ext.data.Model',
		 *         requires: ['Ext.data.identifier.Sequential'],
		 *         identifier: 'sequential',
		 *         ...
		 *     });
		 * 
		 * The above would generate [sequential](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.identifier.Sequential.html) id's such
		 * as 1, 2, 3 etc..
		 * 
		 * Another useful id generator is [Ext.data.identifier.Uuid](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.identifier.Uuid.html):
		 * 
		 *     Ext.define('MyApp.data.MyModel', {
		 *         extend: 'Ext.data.Model',
		 *         requires: ['Ext.data.identifier.Uuid'],
		 *         identifier: 'uuid',
		 *         ...
		 *     });
		 * 
		 * An id generator can also be further configured:
		 * 
		 *     Ext.define('MyApp.data.MyModel', {
		 *         extend: 'Ext.data.Model',
		 *         identifier: {
		 *             type: 'sequential',
		 *             seed: 1000,
		 *             prefix: 'ID_'
		 *         }
		 *     });
		 * 
		 * The above would generate id's such as ID_1000, ID_1001, ID_1002 etc..
		 * 
		 * If multiple models share an id space, a single generator can be shared:
		 * 
		 *     Ext.define('MyApp.data.MyModelX', {
		 *         extend: 'Ext.data.Model',
		 *         identifier: {
		 *             type: 'sequential',
		 *             id: 'xy'
		 *         }
		 *     });
		 *    
		 *     Ext.define('MyApp.data.MyModelY', {
		 *         extend: 'Ext.data.Model',
		 *         identifier: {
		 *             type: 'sequential',
		 *             id: 'xy'
		 *         }
		 *     });
		 * 
		 * For more complex, shared id generators, a custom generator is the best approach.
		 * See [Ext.data.identifier.Generator](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.identifier.Generator.html) for details on creating custom id generators.
		 * @configuration
		 * @optional
		 * @type {string|object}
		 */
		identifier?: string | object;
		/** 
		 * A config object for a [ManyToMany](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.ManyToMany.html) association.
		 * See the class description for [ManyToMany](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.ManyToMany.html) for
		 * configuration examples.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		manyToMany?: object;
		/** 
		 * The [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) to use for this class.
		 * @configuration
		 * @optional
		 * @type {string|object|Ext.data.proxy.Proxy}
		 */
		proxy?: string | object | Ext.data.proxy.Proxy;
		/** 
		 * The name of the [schema](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Schema.html) to which this entity and its
		 * associations belong. For details on custom schemas see [`Ext.data.schema.Schema`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Schema.html).
		 * @configuration
		 * @optional
		 * @default 'default'
		 * @type {string|object}
		 */
		schema?: string | object;
		/** 
		 * If specified this property is used to concatenate multiple errors for each field
		 * as reported by the `validators`.
		 * @configuration
		 * @optional
		 * @default null
		 * @type {string}
		 */
		validationSeparator?: string;
		/** 
		 * An array of [validators](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.validator.Validator.html) for this model.
		 * @configuration
		 * @optional
		 * @type {object[]}
		 */
		validators?: object[];
		/** 
		 * If specified, this is the name of the property that contains the entity "version".
		 * The version property is used to manage a long-running transaction and allows the
		 * detection of simultaneous modification.
		 * 
		 * The way a version property is used is that the client receives the version as it
		 * would any other entity property. When saving an entity, this property is always
		 * included in the request and the server uses the value in a "conditional update".
		 * If the current version of the entity on the server matches the version property
		 * sent by the client, the update is allowed. Otherwise, the update fails.
		 * 
		 * On successful update, both the client and server increment the version. This is
		 * done on the server in the conditional update and on the client when it receives a
		 * success on its update request.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		versionProperty?: string;
		/** 
		 * This method is called by the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) after loading a model from
		 * the server. This is after processing any inline associations that are available.
		 * @method
		 * @protected (method)
		 * @template
		 * @returns {void}  
		 */
		onLoad? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                 config
		 * @returns {Ext.data.Model.Statics}        this
		 */
		initConfig? (config: object): Ext.data.Model.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}          name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                 [value] The value to set for the name parameter.
		 * @returns {Ext.data.Model.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Model.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Model.Statics}  
		 */
		statics? (): Ext.data.Model.Statics;
	}
}
declare namespace Ext.data.NodeInterface {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.NodeInterface](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html)
	 * This class is used as a set of methods that are applied to the prototype of a
	 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) to decorate it with a Node API. This means that models
	 * used in conjunction with a tree will have all of the tree related methods available
	 * on the model. In general, this class will not be used directly by the developer.
	 * 
	 * This class also creates extra [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) on the model, if they do
	 * not exist, to help maintain the tree state and UI. These fields are documented as
	 * config options.
	 * 
	 * The data fields used to render a tree node are: [text](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-text), [leaf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-leaf),
	 * [children](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-children), and [expanded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-expanded).  Once a node is loaded to the tree store
	 * you can use [get()](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-get) to fetch the value of a given field
	 * name (provided there is not a convenience accessor on the Node for that field).
	 * 
	 *    Ext.tip.QuickTipManager.init(); // not required when using Ext.application()
	 *    
	 *    var root = {
	 *        expanded: true,
	 *        children: [{
	 *            text: "Leaf node (&lt;i&gt;no folder/arrow icon&lt;/i&gt;)",
	 *            leaf: true,
	 *            qtitle: 'Sample Tip Title',
	 *            qtip: 'Tip body'
	 *        }, {
	 *            text: "Parent node expanded",
	 *            expanded: true,
	 *            children: [{
	 *                text: "Expanded leaf node 1",
	 *                leaf: true
	 *            }, {
	 *                text: "Expanded leaf node 2",
	 *                leaf: true
	 *            }]
	 *        }, {
	 *            text: "Parent node collapsed",
	 *            children: [{
	 *                text: "Collapsed leaf node 1",
	 *                leaf: true
	 *            }, {
	 *                text: "Collapsed leaf node 2",
	 *                leaf: true
	 *            }]
	 *        }]
	 *    };
	 *    
	 *    var tree = Ext.create('Ext.tree.Panel', {
	 *        title: 'TreePanel',
	 *        width: 260,
	 *        height: 200,
	 *        root: root,
	 *        rootVisible: false,
	 *        renderTo: document.body,
	 *        bbar: ['The first node ', {
	 *            text: 'is a leaf?',
	 *            handler: function () {
	 *                var firstChild = tree.getRootNode().getChildAt(0);
	 *                Ext.Msg.alert('Is Leaf?', firstChild.isLeaf());
	 *            }
	 *        }, {
	 *            text: 'has text?',
	 *            handler: function () {
	 *                var firstChild = tree.getRootNode().getChildAt(0);
	 *                Ext.Msg.alert('Has Text:', firstChild.get('text'));
	 *            }
	 *        }]
	 *    });
	 * 
	 * The following configs have methods used to set the value / state of the node at
	 * runtime:
	 * 
	 * **[children](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-children) / [leaf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-leaf)**
	 * 
	 * - [appendChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-appendChild)
	 * - [hasChildNodes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-hasChildNodes)
	 * - [insertBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertBefore)
	 * - [insertChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertChild)
	 * - [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-remove)
	 * - [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-removeAll)
	 * - [removeChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-removeChild)
	 * - [replaceChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-replaceChild)
	 * 
	 * **[expanded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-expanded)**
	 * 
	 * - [expand](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-expand)
	 * - [expandChildren](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-expandChildren)
	 * - [collapse](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-collapse)
	 * - [collapseChildren](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-collapseChildren)
	 * 
	 * The remaining configs may be set using [set()](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-set).
	 * 
	 *    node.set('text', 'Changed Text'); // example showing how to change the node label
	 * 
	 * The [qtip](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtip), [qtitle](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtitle), and [qshowDelay](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qshowDelay) use QuickTips and
	 * requires initializing Ext.tip.QuickTipManager unless the application is
	 * created using [Ext.application](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-application).
	 * 
	 *    Ext.tip.QuickTipManager.init();
	 * 
	 * For additional information and examples see the description for
	 * Ext.tree.Panel.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * Set to false to deny dragging of this node.
		 * 
		 * Applicable when using the TreeViewDragDrop plugin.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		allowDrag?: boolean;
		/** 
		 * Set to false to deny dropping on this node.
		 * 
		 * Applicable when using the TreeViewDragDrop plugin.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		allowDrop?: boolean;
		/** 
		 * Set to true or false to show a checkbox alongside this node.
		 * 
		 * To fetch an array of checked nodes use getChecked().
		 * @configuration
		 * @optional
		 * @default null
		 * @type {boolean}
		 */
		checked?: boolean;
		/** 
		 * Array of child nodes.
		 * 
		 * **Note:** By default the child nodes root is `children`, but can be set using the
		 * reader [rootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-rootProperty) config on the
		 * [TreeStore's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-proxy).
		 * @configuration
		 * @optional
		 * @type {Ext.data.NodeInterface[]}
		 */
		children?: Ext.data.NodeInterface[];
		/** 
		 * CSS class to apply to this node.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		cls?: string;
		/** 
		 * The number of parents this node has. A root node has depth 0, a child of it depth 1, and so on...
		 * 
		 * See [getDepth](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-getDepth).
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		depth?: number;
		/** 
		 * False to prevent expanding/collapsing of this node.
		 * 
		 * See also: [isExpandable](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-isExpandable).
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		expandable?: boolean;
		/** 
		 * True if the node is expanded.
		 * 
		 * When the tree is asynchronously remote loaded, expanding a collapsed node loads
		 * the children of that node (if the node has not already been loaded previously).
		 * 
		 * See also: [isExpanded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-isExpanded).
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		expanded?: boolean;
		/** 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		glyph?: string;
		/** 
		 * A URL for a link that's created when this config is specified.
		 * 
		 * See also [hrefTarget](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-hrefTarget).
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		href?: string;
		/** 
		 * Target for link. Only applicable when [href](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-href) is also specified.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		hrefTarget?: string;
		/** 
		 * Path to an image to use as an icon.
		 * 
		 * For instructions on how you can use icon fonts including those distributed in
		 * the SDK see [iconCls](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-iconCls).
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		icon?: string;
		/** 
		 * One or more space separated CSS classes to be applied to the icon element.
		 * The CSS rule(s) applied should specify a background image to be used as the
		 * icon.
		 * 
		 * An example of specifying a custom icon class would be something like:
		 * 
		 *    // specify the property in the config for the class:
		 *    iconCls: 'my-home-icon'
		 *    
		 *    // css rule specifying the background image to be used as the icon image:
		 *    .my-home-icon {
		 *        background-image: url(../images/my-home-icon.gif) !important;
		 *    }
		 * 
		 * In addition to specifying your own classes, you can use the font icons
		 * provided in the SDK using the following syntax:
		 * 
		 *    // using Font Awesome
		 *    iconCls: 'x-fa fa-home'
		 *    
		 *    // using Pictos
		 *    iconCls: 'pictos pictos-home'
		 * 
		 * Depending on the theme you're using, you may need include the font icon
		 * packages in your application in order to use the icons included in the
		 * SDK.  For more information see:
		 * 
		 * - [Font Awesome icons](http://fortawesome.github.io/Font-Awesome/cheatsheet/)
		 * - [Pictos icons](http://docs.sencha.com/extjs/6.0/core_concepts/font_ext.html)
		 * - [Theming Guide](http://docs.sencha.com/extjs/6.0/core_concepts/theming.html)
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		iconCls?: string;
		/** 
		 * The position of the node inside its parent. When parent has 4 children and the node is third amongst them,
		 * index will be 2.
		 * 
		 * See [indexOf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-indexOf) and [indexOfId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-indexOfId).
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		index?: number;
		/** 
		 * True if this is the first node.
		 * 
		 * See [isFirst](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-isFirst).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		isFirst?: boolean;
		/** 
		 * True if this is the last node.
		 * 
		 * See [isLast](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-isLast).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		isLast?: boolean;
		/** 
		 * Set to true to indicate that this child can have no children. The expand icon/arrow will then not be
		 * rendered for this node.
		 * 
		 * See also: [isLeaf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-isLeaf).
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		leaf?: boolean;
		/** 
		 * True if the node has finished loading.
		 * 
		 * See [isLoaded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-isLoaded).
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		loaded?: boolean;
		/** 
		 * True if the node is currently loading.
		 * 
		 * See [isLoading](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-isLoading).
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		loading?: boolean;
		/** 
		 * ID of parent node.
		 * 
		 * See [parentNode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#property-parentNode).
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		parentId?: string;
		/** 
		 * Tooltip showDelay.
		 * 
		 * See also [qtip](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtip).
		 * See also [qtitle](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtitle).
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		qshowDelay?: number;
		/** 
		 * Tooltip text to show on this node.
		 * 
		 * See also [qtitle](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtitle).
		 * See also [qshowDelay](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qshowDelay).
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		qtip?: string;
		/** 
		 * Tooltip title.
		 * 
		 * See also [qtip](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtip).
		 * See also [qshowDelay](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qshowDelay).
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		qtitle?: string;
		/** 
		 * True if this is the root node.
		 * 
		 * See [isRoot](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-isRoot).
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		root?: boolean;
		/** 
		 * The text to show on node label (_html tags are accepted_).
		 * The default text for the root node is `ROOT`.  All other nodes default to ''.
		 * 
		 * **Note:** By default the node label is `text`, but can be set using the tree's
		 * displayField config.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		text?: string;
		/** 
		 * Implement this method in a tree record subclass if it needs to track whenever it is registered
		 * with a [TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html).
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.data.TreeStore} treeStore The TreeStore to which the node is being registered.
		 * @returns {void}                         
		 */
		onRegisterTreeNode? (treeStore: Ext.data.TreeStore): void;
		/** 
		 * Implement this method in a tree record subclass if it needs to track whenever it is unregistered
		 * from a [TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html).
		 * @method
		 * @public (method)
		 * @template
		 * @param   {Ext.data.TreeStore} treeStore The TreeStore from which the node is being unregistered.
		 * @returns {void}                         
		 */
		onUnregisterTreeNode? (treeStore: Ext.data.TreeStore): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                         config
		 * @returns {Ext.data.NodeInterface.Statics}        this
		 */
		initConfig? (config: object): Ext.data.NodeInterface.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                  name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                         [value] The value to set for the name parameter.
		 * @returns {Ext.data.NodeInterface.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.NodeInterface.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.NodeInterface.Statics}  
		 */
		statics? (): Ext.data.NodeInterface.Statics;
	}
}
declare namespace Ext.data.NodeStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.NodeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeStore.html)
	 * Node Store
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The owner of this store if the store is used as part of an association.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Model}
		 */
		associatedEntity?: Ext.data.Model;
		/** 
		 * This defaults to `true` when this store's [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy) is asynchronous, such as an
		 * [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html).
		 * 
		 * When the proxy is synchronous, such as a [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) memory proxy, this
		 * defaults to `false`.
		 * 
		 * _NOTE:_ This does not cause synchronous Ajax requests if configured `false` when an Ajax proxy
		 * is used. It causes immediate issuing of an Ajax request when [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) is called
		 * rather than issuing the request at the end of the current event handler run.
		 * 
		 * What this means is that when using an Ajax proxy, calls to
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) do not fire the request to the remote resource
		 * immediately, but schedule a request to be made. This is so that multiple
		 * requests are not fired when mutating a store's remote filters and sorters (as
		 * happens during state restoration). The request is made only once after all
		 * relevant store state is fully set.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		asynchronousLoad?: boolean;
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
		 * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
		 * 
		 * It's important to note that [Tree Stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) will<br/>
		 * load regardless of autoLoad's value if expand is set to true on the
		 * [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @configuration
		 * @optional
		 * @type {boolean|object}
		 */
		autoLoad?: boolean | object;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		autoSync?: boolean;
		/** 
		 * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
		 * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
		 * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
		 * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
		 * @configuration
		 * @optional
		 * @default 'operation'
		 * @type {string}
		 */
		batchUpdateMode?: string;
		/** 
		 * True to empty the store when loading another page via [loadPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadPage),
		 * [nextPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-nextPage) or [previousPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-previousPage). Setting to false keeps existing records, allowing
		 * large data sets to be loaded one page at a time but rendered all together.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearOnPageLoad?: boolean;
		/** 
		 * `true` to clear anything in the [removed](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#property-removed) record collection when the store loads.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearRemovedOnLoad?: boolean;
		/** 
		 * Array of Model instances or data objects to load locally. See "Inline data"
		 * above for details.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {object[]|Ext.data.Model[]}
		 */
		data?: object[] | Ext.data.Model[];
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		extraKeys?: object;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * Set to `true` to automatically prepend a leaf sorter.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		folderSort?: boolean;
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Name of the [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) associated with this store. See
		 * [Ext.data.Model.entityName](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-entityName).
		 * 
		 * May also be the actual Model subclass.
		 * 
		 * This config is required for the store to be able to read data unless you have defined
		 * the [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields) config which will create an anonymous [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html).
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The Record you want to bind this Store to. Note that
		 * this record will be decorated with the [Ext.data.NodeInterface](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html) if this is not the
		 * case yet.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Model}
		 */
		node?: Ext.data.Model;
		/** 
		 * The number of records considered to form a 'page'. This is used to power the built-in
		 * paging using the nextPage and previousPage functions when the grid is paged using a
		 * PagingToolbar Defaults to 25.
		 * 
		 * To disable paging, set the pageSize to `0`.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
		 * see [setProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-setProxy) for details.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.proxy.Proxy|object}
		 */
		proxy?: string | Ext.data.proxy.Proxy | object;
		/** 
		 * Set this to `true` if you want this NodeStore to represent
		 * all the descendants of the node in its flat data collection. This is useful for
		 * rendering a tree structure to a DataView and is being used internally by
		 * the TreeView. Any records that are moved, removed, inserted or appended to the
		 * node at any depth below the node this store is bound to will be automatically
		 * updated in this Store's internal flat data structure.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		recursive?: boolean;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * The role for the [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @configuration
		 * @optional
		 * @type {Ext.data.schema.Role}
		 */
		role?: Ext.data.schema.Role;
		/** 
		 * `false` to not include the root node in this Stores collection.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		rootVisible?: boolean;
		/** 
		 * The session for this store. By specifying a session, it ensures any records that are
		 * added to this store are also included in the session. This store does not become a member
		 * of the session itself.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Session}
		 */
		session?: Ext.data.Session;
		/** 
		 * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
		 * Defaults to true, ignored if [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) is true
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		sortOnLoad?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * This config controls whether removed records are remembered by this store for
		 * later saving to the server.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		trackRemoved?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                     config
		 * @returns {Ext.data.NodeStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.NodeStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}              name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                     [value] The value to set for the name parameter.
		 * @returns {Ext.data.NodeStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.NodeStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.NodeStore.Statics}  
		 */
		statics? (): Ext.data.NodeStore.Statics;
	}
}
declare namespace Ext.data.PageMap {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.PageMap](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.PageMap.html)
	 * Private class for use by only Store when configured `buffered: true`.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * A function that is used to retrieve a default key for a passed object.
		 * A default is provided that returns the `id` property on the object. This function is only used
		 * if the `add` method is called with a single argument.
		 * @configuration
		 * @optional
		 */
		keyFn?: ExtGlobalFunction;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The maximum size the cache is allowed to grow to before further additions cause
		 * removal of the least recently used entry.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		maxSize?: number;
		/** 
		 * The size of pages in this map.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * The root property to use for aggregation, filtering and sorting. By default
		 * this is `null` but when containing things like [records](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html)
		 * this config would likely be set to "data" so that property names are applied
		 * to the fields of each record.
		 * @configuration
		 * @optional
		 * @default ''
		 * @type {string}
		 */
		rootProperty?: string;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		store?: object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                   config
		 * @returns {Ext.data.PageMap.Statics}        this
		 */
		initConfig? (config: object): Ext.data.PageMap.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}            name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                   [value] The value to set for the name parameter.
		 * @returns {Ext.data.PageMap.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.PageMap.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.PageMap.Statics}  
		 */
		statics? (): Ext.data.PageMap.Statics;
	}
}
declare namespace Ext.data.ProxyStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.ProxyStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html)
	 * ProxyStore is a superclass of [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) and [Ext.data.BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html). It's never used directly,
	 * but offers a set of methods used by both of those subclasses.
	 * 
	 * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
	 * you're probably looking for is [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html). If you're still interested, here's a brief description of what
	 * ProxyStore is and is not.
	 * 
	 * ProxyStore provides the basic configuration for anything that can be considered a Store. It expects to be
	 * given a [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) that represents the type of data in the Store. It also expects to be given a
	 * [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) that handles the loading of data into the Store.
	 * 
	 * ProxyStore provides a few helpful methods such as [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) and [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync), which load and save data
	 * respectively, passing the requests through the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
	 * 
	 * Built-in Store subclasses add extra behavior to each of these functions. Note also that each ProxyStore subclass
	 * has its own way of storing data - in [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) the data is saved as a flat [Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html),
	 * whereas in [BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html) we use a [Ext.data.PageMap](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.PageMap.html) to maintain a client side cache of pages of records.
	 * 
	 * The store provides filtering and sorting support. This sorting/filtering can happen on the client side
	 * or can be completed on the server. This is controlled by the [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) and
	 * [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteFilter) config options. For more information see the [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sort) and
	 * [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) methods.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * This defaults to `true` when this store's [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy) is asynchronous, such as an
		 * [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html).
		 * 
		 * When the proxy is synchronous, such as a [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) memory proxy, this
		 * defaults to `false`.
		 * 
		 * _NOTE:_ This does not cause synchronous Ajax requests if configured `false` when an Ajax proxy
		 * is used. It causes immediate issuing of an Ajax request when [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) is called
		 * rather than issuing the request at the end of the current event handler run.
		 * 
		 * What this means is that when using an Ajax proxy, calls to
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) do not fire the request to the remote resource
		 * immediately, but schedule a request to be made. This is so that multiple
		 * requests are not fired when mutating a store's remote filters and sorters (as
		 * happens during state restoration). The request is made only once after all
		 * relevant store state is fully set.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		asynchronousLoad?: boolean;
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
		 * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
		 * 
		 * It's important to note that [Tree Stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) will<br/>
		 * load regardless of autoLoad's value if expand is set to true on the
		 * [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @configuration
		 * @optional
		 * @type {boolean|object}
		 */
		autoLoad?: boolean | object;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		autoSync?: boolean;
		/** 
		 * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
		 * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
		 * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
		 * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
		 * @configuration
		 * @optional
		 * @default 'operation'
		 * @type {string}
		 */
		batchUpdateMode?: string;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Name of the [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) associated with this store. See
		 * [Ext.data.Model.entityName](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-entityName).
		 * 
		 * May also be the actual Model subclass.
		 * 
		 * This config is required for the store to be able to read data unless you have defined
		 * the [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields) config which will create an anonymous [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html).
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The number of records considered to form a 'page'. This is used to power the built-in
		 * paging using the nextPage and previousPage functions when the grid is paged using a
		 * PagingToolbar Defaults to 25.
		 * 
		 * To disable paging, set the pageSize to `0`.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
		 * see [setProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-setProxy) for details.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.proxy.Proxy|object}
		 */
		proxy?: string | Ext.data.proxy.Proxy | object;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
		 * Defaults to true, ignored if [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) is true
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		sortOnLoad?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * This config controls whether removed records are remembered by this store for
		 * later saving to the server.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		trackRemoved?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.data.ProxyStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.ProxyStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.ProxyStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.ProxyStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.ProxyStore.Statics}  
		 */
		statics? (): Ext.data.ProxyStore.Statics;
	}
}
declare namespace Ext.data.Request {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.Request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Request.html)
	 * Simple class that represents a Request that will be made by any [Ext.data.proxy.Server](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Server.html) subclass.
	 * All this class does is standardize the representation of a Request as used by any ServerProxy subclass,
	 * it does not contain any actual logic or perform the request itself.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The name of the action this Request represents. Usually one of 'create', 'read', 'update' or 'destroy'.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		action?: string;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		args?: object;
		/** 
		 * True to request binary data from the server.  This feature requires
		 * the use of a binary reader such as AMF Reader
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		binary?: boolean;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		callback?: object;
		/** 
		 * Some requests (like JsonP) want to send an additional key that contains
		 * the name of the callback function.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		callbackKey?: string;
		/** 
		 * The following two configurations are only used by [Ext.data.proxy.Direct](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html) and are just
		 * for being able to retrieve them after the request comes back from the server.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		directFn?: object;
		/** 
		 * Whether or not to disable caching for this request.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		disableCaching?: boolean;
		/** 
		 * Some requests (like XMLHttpRequests) want to send additional server headers.
		 * This configuration can be set for those types of requests.
		 * @configuration
		 * @optional
		 * @default {}
		 * @type {object}
		 */
		headers?: object;
		/** 
		 * This is used by some write actions to attach data to the request without encoding it
		 * as a parameter.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		jsonData?: object;
		/** 
		 * The HTTP method to use on this Request. Should be one of 'GET', 'POST', 'PUT' or 'DELETE'.
		 * @configuration
		 * @optional
		 * @default 'GET'
		 * @type {string}
		 */
		method?: string;
		/** 
		 * The operation this request belongs to.
		 * @configuration
		 * @optional
		 * @type {Ext.data.operation.Operation}
		 */
		operation?: Ext.data.operation.Operation;
		/** 
		 * HTTP request params. The Proxy and its Writer have access to and can modify this object.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		params?: object;
		/** 
		 * Most oData feeds require basic HTTP authentication. This configuration allows
		 * you to specify the password.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		password?: string;
		/** 
		 * The proxy this request belongs to.
		 * @configuration
		 * @optional
		 * @type {Ext.data.proxy.Proxy}
		 */
		proxy?: Ext.data.proxy.Proxy;
		/** 
		 * Set the raw request object (Ajax/JsonP/Other)
		 * @configuration
		 * @optional
		 * @type {Ext.data.JsonP}
		 */
		rawRequest?: Ext.data.JsonP;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		records?: object;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		scope?: object;
		/** 
		 * @configuration
		 * @optional
		 * @default 30000
		 * @type {number}
		 */
		timeout?: number;
		/** 
		 * The url to access on this Request.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		url?: string;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		useDefaultXhrHeader?: object;
		/** 
		 * Most oData feeds require basic HTTP authentication. This configuration allows
		 * you to specify the username.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		username?: string;
		/** 
		 * This field is necessary when using cross-origin resource sharing.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		withCredentials?: boolean;
		/** 
		 * This is used by some write actions to attach data to the request without encoding it
		 * as a parameter, but instead sending it as XML.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		xmlData?: object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                   config
		 * @returns {Ext.data.Request.Statics}        this
		 */
		initConfig? (config: object): Ext.data.Request.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}            name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                   [value] The value to set for the name parameter.
		 * @returns {Ext.data.Request.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Request.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Request.Statics}  
		 */
		statics? (): Ext.data.Request.Statics;
	}
}
declare namespace Ext.data.ResultSet {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.ResultSet](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html)
	 * Simple wrapper class that represents a set of records returned by a Proxy.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The number of records in this ResultSet. Note that total may differ from this number.
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		count?: number;
		/** 
		 * True if the records have already been loaded. This is only meaningful when dealing with
		 * SQL-backed proxies.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		loaded?: boolean;
		/** 
		 * The message that was read in from the data
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		message?: string;
		/** 
		 * The metadata object from a server sourced JSON data packet.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		metadata?: object;
		/** 
		 * The array of record instances or record config objects.
		 * @configuration
		 * @required
		 * @type {Ext.data.Model[]|object[]}
		 */
		records: Ext.data.Model[] | object[];
		/** 
		 * True if the ResultSet loaded successfully, false if any errors were encountered.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		success?: boolean;
		/** 
		 * The total number of records reported by the data source. This ResultSet may form a subset of
		 * those records (see [count](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ResultSet.html#cfg-count)).
		 * @configuration
		 * @optional
		 * @type {number}
		 */
		total?: number;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                     config
		 * @returns {Ext.data.ResultSet.Statics}        this
		 */
		initConfig? (config: object): Ext.data.ResultSet.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}              name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                     [value] The value to set for the name parameter.
		 * @returns {Ext.data.ResultSet.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.ResultSet.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.ResultSet.Statics}  
		 */
		statics? (): Ext.data.ResultSet.Statics;
	}
}
declare namespace Ext.data.Session {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.Session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html)
	 * This class manages models and their associations. Instances of `Session` are typically
	 * associated with some `Component` (perhaps the Viewport or a Window) and then used by
	 * their [`view models`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.app.ViewModel.html) to enable data binding.
	 * 
	 * The primary job of a Session is to manage a collection of records of many different
	 * types and their associations. This often starts by loading records when requested (via
	 * bind - see below) and culminates when it is time to save to the server.
	 * 
	 * Because the Session tracks all records it loads, it ensures that for any given type of
	 * model, only one record exists with a given `id`. This means that all edits of that
	 * record are properly targeted at that one instance.
	 * 
	 * Similarly, when associations are loaded, the [`Ext.data.Store`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) created to hold the
	 * associated records is tracked by the Session. So all requests for the "OrderItems" of
	 * a particular Order id will result in the same Store. Adding and removing items from
	 * that Order then is sure to remain consistent.
	 * 
	 * # Data
	 * 
	 * Since the Session is managing all this data, there are several methods it provides
	 * to give convenient access to that data. The most important of these is `update` and
	 * `getChanges`.
	 * 
	 * The `update` and `getChanges` methods both operate on object that contains a summary
	 * of records and associations and different CRUD operations.
	 * 
	 * ## Saving
	 * 
	 * There are two basic ways to save the contents of a Session: `getChanges` and
	 * `getSaveBatch`. We've already seen `getChanges`. The data contained in the CRUD object
	 * can be translated into whatever shape is needed by the server.
	 * 
	 * To leverage the [`proxy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-proxy) facilities defined by each Model
	 * class, there is the `getSaveBatch` method. That method returns an [`Ext.data.Batch`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html)
	 * object populated with the necessary `create`, `update` and `destory` operations to
	 * save all of the changes in the Session.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * `true` to automatically destroy this session when a component it is attached
		 * to is destroyed. This should be set to false if the session is intended to be
		 * used across multiple root level components.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * @configuration
		 * @optional
		 * @default {create: 'C', read: 'R', update: 'U', drop: 'D'}
		 * @type {object}
		 */
		crudProperties?: object;
		/** 
		 * This config property describes the modified state of this object. In most
		 * cases this config's value is maintained by the object and should be considered
		 * readonly. The class implementor should be the only one to call the setter.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		dirty?: boolean;
		/** 
		 * This config property indicates that the `dirty` state of this object should be
		 * ignored. Because this capability is mixed in at a class level, this config can
		 * be helpful when some instances do not participate in dirty state tracking.
		 * 
		 * This option should be set at construction time. When set to `true`, the object
		 * will always have `dirty` value of `false`.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		ignoreDirty?: boolean;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The parent session for this session.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Session}
		 */
		parent?: Ext.data.Session;
		/** 
		 * Set this config at construction time (or on the class body) to automatically set
		 * the `dirty` state based on the records passed to `trackRecordState`.
		 * 
		 * This config defaults to `true` but only has an effect when the record tracking
		 * methods are called (`trackRecordState`, `untrackRecordState` and `clearRecordStates`).
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		recordStateIsDirtyState?: boolean;
		/** 
		 * @configuration
		 * @optional
		 * @default 'default'
		 * @type {string|Ext.data.schema.Schema}
		 */
		schema?: string | Ext.data.schema.Schema;
		/** 
		 * Triggered when an associated item from [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-update) references a record
		 * that does not exist in the session.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.Class} entityType The entity type.
		 * @param   {object}    id         The id of the model.
		 * @returns {void}                 
		 */
		onInvalidAssociationEntity? (entityType: Ext.Class, id: object): void;
		/** 
		 * Triggered when an drop block from [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-update) tries to create a record
		 * that already exists.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.Class} entityType The entity type.
		 * @param   {object}    id         The id of the model.
		 * @returns {void}                 
		 */
		onInvalidEntityCreate? (entityType: Ext.Class, id: object): void;
		/** 
		 * Triggered when an drop block from [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-update) references a record
		 * that does not exist in the session.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.Class} entityType The entity type.
		 * @param   {object}    id         The id of the model.
		 * @returns {void}                 
		 */
		onInvalidEntityDrop? (entityType: Ext.Class, id: object): void;
		/** 
		 * Triggered when an drop block from [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-update) tries to create a record
		 * that already exists.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.Class} entityType The entity type.
		 * @param   {object}    id         The id of the model.
		 * @returns {void}                 
		 */
		onInvalidEntityRead? (entityType: Ext.Class, id: object): void;
		/** 
		 * Triggered when an update block from [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html#method-update) references a record
		 * that does not exist in the session.
		 * @method
		 * @protected (method)
		 * @template
		 * @param   {Ext.Class} entityType The entity type.
		 * @param   {object}    id         The id of the model.
		 * @param   {boolean}   dropped    `true` if the record was dropped.
		 * @returns {void}                 
		 */
		onInvalidEntityUpdate? (entityType: Ext.Class, id: object, dropped: boolean): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                   config
		 * @returns {Ext.data.Session.Statics}        this
		 */
		initConfig? (config: object): Ext.data.Session.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}            name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                   [value] The value to set for the name parameter.
		 * @returns {Ext.data.Session.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Session.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Session.Statics}  
		 */
		statics? (): Ext.data.Session.Statics;
	}
}
declare namespace Ext.data.Store {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
	 * The Store class encapsulates a client side cache of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) objects. Stores load data via a
	 * [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html), and also provide functions for [sorting](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort), [filtering](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter)
	 * and querying the [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances contained within it.
	 * 
	 * Creating a Store is easy - we just tell it the Model and the Proxy to use for loading and saving its data:
	 * 
	 *     // Set up a model to use in our Store
	 *     Ext.define('User', {
	 *         extend: 'Ext.data.Model',
	 *         fields: [
	 *             {name: 'firstName', type: 'string'},
	 *             {name: 'lastName',  type: 'string'},
	 *             {name: 'age',       type: 'int'},
	 *             {name: 'eyeColor',  type: 'string'}
	 *         ]
	 *     });
	 *    
	 *     var myStore = Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         proxy: {
	 *             type: 'ajax',
	 *             url: '/users.json',
	 *             reader: {
	 *                 type: 'json',
	 *                 rootProperty: 'users'
	 *             }
	 *         },
	 *         autoLoad: true
	 *     });
	 * 
	 * In the example above we configured an AJAX proxy to load data from the url '/users.json'. We told our Proxy to use a
	 * [JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) to parse the response from the server into Model object - [see the docs on JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) for details.
	 * 
	 * ## Inline data
	 * 
	 * Stores can also load data inline. Internally, Store converts each of the objects we pass in as [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-data) into
	 * Model instances:
	 * 
	 *     Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         data : [
	 *             {firstName: 'Peter',   lastName: 'Venkman'},
	 *             {firstName: 'Egon',    lastName: 'Spengler'},
	 *             {firstName: 'Ray',     lastName: 'Stantz'},
	 *             {firstName: 'Winston', lastName: 'Zeddemore'}
	 *         ]
	 *     });
	 * 
	 * Loading inline data using the method above is great if the data is in the correct format already (e.g. it doesn't
	 * need to be processed by a [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html)). If your inline data requires processing to decode
	 * the data structure, use a [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) instead (see the [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) docs for an example).
	 * 
	 * Additional data can also be loaded locally using [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
	 * 
	 * ## Dynamic Loading
	 * 
	 * Stores can be dynamically updated by calling the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load) method:
	 * 
	 *    store.load({
	 *        params: {
	 *            group: 3,
	 *            type: 'user'
	 *        },
	 *        callback: function(records, operation, success) {
	 *            // do something after the load finishes
	 *        },
	 *        scope: this
	 *    });
	 * 
	 * Here a bunch of arbitrary parameters is passed along with the load request and a callback function is set
	 * up to do something after the loading is over.
	 * 
	 * ## Loading Nested Data
	 * 
	 * Applications often need to load sets of associated data - for example a CRM system might load a User and her Orders.
	 * Instead of issuing an AJAX request for the User and a series of additional AJAX requests for each Order, we can load
	 * a nested dataset and allow the Reader to automatically populate the associated models. Below is a brief example, see
	 * the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) intro docs for a full explanation:
	 * 
	 *     var store = Ext.create('Ext.data.Store', {
	 *         autoLoad: true,
	 *         model: "User",
	 *         proxy: {
	 *             type: 'ajax',
	 *             url: 'users.json',
	 *             reader: {
	 *                 type: 'json',
	 *                 rootProperty: 'users'
	 *             }
	 *         }
	 *     });
	 * 
	 * Which would consume a response like this:
	 * 
	 *     {
	 *         "users": [{
	 *             "id": 1,
	 *             "name": "Peter",
	 *             "orders": [{
	 *                 "id": 10,
	 *                 "total": 10.76,
	 *                 "status": "invoiced"
	 *            },{
	 *                 "id": 11,
	 *                 "total": 13.45,
	 *                 "status": "shipped"
	 *            }]
	 *         }]
	 *     }
	 * 
	 * See the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) intro docs for a full explanation.
	 * 
	 * ## Filtering and Sorting
	 * 
	 * Stores can be sorted and filtered - in both cases either remotely or locally. The [sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-sorters) and
	 * [filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-filters) are held inside [Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) instances to make them easy to manage.
	 * Usually it is sufficient to either just specify sorters and filters in the Store configuration or call [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort)
	 * or [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter):
	 * 
	 *     var store = Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         sorters: [{
	 *             property: 'age',
	 *             direction: 'DESC'
	 *         }, {
	 *             property: 'firstName',
	 *             direction: 'ASC'
	 *         }],
	 *    
	 *         filters: [{
	 *             property: 'firstName',
	 *             value: /Peter/
	 *         }]
	 *     });
	 * 
	 * The new Store will keep the configured sorters and filters in the Collection instances mentioned above. By
	 * default, sorting and filtering are both performed locally by the Store - see [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) and
	 * [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteFilter) to allow the server to perform these operations instead.
	 * 
	 * Filtering and sorting after the Store has been instantiated is also easy. Calling [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) adds another filter
	 * to the Store and automatically filters the dataset (calling [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) with no arguments simply re-applies all
	 * existing filters).
	 * 
	 *    store.filter('eyeColor', 'Brown');
	 * 
	 * Change the sorting at any time by calling [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort):
	 * 
	 *    store.sort('height', 'ASC');
	 * 
	 * Note that all existing sorters will be removed in favor of the new sorter data (if [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort) is called with no
	 * arguments, the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new
	 * ones, just add them to the Collection:
	 * 
	 *    store.sorters.add(new Ext.util.Sorter({
	 *        property : 'shoeSize',
	 *        direction: 'ASC'
	 *    }));
	 *    
	 *    store.sort();
	 * 
	 * ## Registering with StoreManager
	 * 
	 * Any Store that is instantiated with a [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-storeId) will automatically be registered with the [StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html). This makes it easy to reuse the same store in multiple views:
	 * 
	 *    //this store can be used several times
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        storeId: 'usersStore'
	 *    });
	 *    
	 *    new Ext.List({
	 *        store: 'usersStore',
	 *        //other config goes here
	 *    });
	 *    
	 *    new Ext.view.View({
	 *        store: 'usersStore',
	 *        //other config goes here
	 *    });
	 * 
	 * ## Further Reading
	 * 
	 * Stores are backed up by an ecosystem of classes that enables their operation. To gain a full understanding of these
	 * pieces and how they fit together, see:
	 * 
	 * - [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) - overview of what Proxies are and how they are used
	 * - [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) - the core class in the data package
	 * - [Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) - used by any subclass of [ServerProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Server.html) to read a response
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The owner of this store if the store is used as part of an association.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Model}
		 */
		associatedEntity?: Ext.data.Model;
		/** 
		 * This defaults to `true` when this store's [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy) is asynchronous, such as an
		 * [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html).
		 * 
		 * When the proxy is synchronous, such as a [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) memory proxy, this
		 * defaults to `false`.
		 * 
		 * _NOTE:_ This does not cause synchronous Ajax requests if configured `false` when an Ajax proxy
		 * is used. It causes immediate issuing of an Ajax request when [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) is called
		 * rather than issuing the request at the end of the current event handler run.
		 * 
		 * What this means is that when using an Ajax proxy, calls to
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) do not fire the request to the remote resource
		 * immediately, but schedule a request to be made. This is so that multiple
		 * requests are not fired when mutating a store's remote filters and sorters (as
		 * happens during state restoration). The request is made only once after all
		 * relevant store state is fully set.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		asynchronousLoad?: boolean;
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
		 * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
		 * 
		 * It's important to note that [Tree Stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) will<br/>
		 * load regardless of autoLoad's value if expand is set to true on the
		 * [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @configuration
		 * @optional
		 * @type {boolean|object}
		 */
		autoLoad?: boolean | object;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		autoSync?: boolean;
		/** 
		 * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
		 * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
		 * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
		 * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
		 * @configuration
		 * @optional
		 * @default 'operation'
		 * @type {string}
		 */
		batchUpdateMode?: string;
		/** 
		 * True to empty the store when loading another page via [loadPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadPage),
		 * [nextPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-nextPage) or [previousPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-previousPage). Setting to false keeps existing records, allowing
		 * large data sets to be loaded one page at a time but rendered all together.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearOnPageLoad?: boolean;
		/** 
		 * `true` to clear anything in the [removed](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#property-removed) record collection when the store loads.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearRemovedOnLoad?: boolean;
		/** 
		 * Array of Model instances or data objects to load locally. See "Inline data"
		 * above for details.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {object[]|Ext.data.Model[]}
		 */
		data?: object[] | Ext.data.Model[];
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		extraKeys?: object;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Name of the [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) associated with this store. See
		 * [Ext.data.Model.entityName](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-entityName).
		 * 
		 * May also be the actual Model subclass.
		 * 
		 * This config is required for the store to be able to read data unless you have defined
		 * the [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields) config which will create an anonymous [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html).
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The number of records considered to form a 'page'. This is used to power the built-in
		 * paging using the nextPage and previousPage functions when the grid is paged using a
		 * PagingToolbar Defaults to 25.
		 * 
		 * To disable paging, set the pageSize to `0`.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
		 * see [setProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-setProxy) for details.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.proxy.Proxy|object}
		 */
		proxy?: string | Ext.data.proxy.Proxy | object;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * The role for the [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @configuration
		 * @optional
		 * @type {Ext.data.schema.Role}
		 */
		role?: Ext.data.schema.Role;
		/** 
		 * The session for this store. By specifying a session, it ensures any records that are
		 * added to this store are also included in the session. This store does not become a member
		 * of the session itself.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Session}
		 */
		session?: Ext.data.Session;
		/** 
		 * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
		 * Defaults to true, ignored if [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) is true
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		sortOnLoad?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * This config controls whether removed records are remembered by this store for
		 * later saving to the server.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		trackRemoved?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                 config
		 * @returns {Ext.data.Store.Statics}        this
		 */
		initConfig? (config: object): Ext.data.Store.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}          name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                 [value] The value to set for the name parameter.
		 * @returns {Ext.data.Store.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Store.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Store.Statics}  
		 */
		statics? (): Ext.data.Store.Statics;
	}
}
declare namespace Ext.data.StoreManager {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html)
	 * Contains a collection of all stores that are created that have an identifier. An identifier can be assigned by
	 * setting the [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId) property. When a store is in the StoreManager, it can be
	 * referred to via it's identifier:
	 * 
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'SomeModel',
	 *        storeId: 'myStore'
	 *    });
	 *    
	 *    var store = Ext.data.StoreManager.lookup('myStore');
	 * 
	 * Also note that the [lookup](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html#method-lookup) method is aliased to [Ext.getStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-getStore) for convenience.
	 * 
	 * If a store is registered with the StoreManager, you can also refer to the store by it's identifier when registering
	 * it with any Component that consumes data from a store:
	 * 
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'SomeModel',
	 *        storeId: 'myStore'
	 *    });
	 *    
	 *    Ext.create('Ext.view.View', {
	 *        store: 'myStore',
	 *        // other configuration here
	 *    });
	 * 
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * Configure as `true` if the [addAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.MixedCollection.html#method-addAll) function should add function references to the collection.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		allowFunctions?: boolean;
		/** 
		 * The default sort direction to use if one is not specified.
		 * @configuration
		 * @optional
		 * @default "ASC"
		 * @type {string}
		 */
		defaultSortDirection?: string;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * The maximum number of sorters which may be applied to this Sortable when using the "multi" insertion position
		 * when adding sorters.
		 * 
		 * New sorters added using the "multi" insertion position are inserted at the top of the sorters list becoming the
		 * new primary sort key.
		 * 
		 * If the sorters collection has grown to longer then **`multiSortLimit`**, then the it is trimmed.
		 * @configuration
		 * @optional
		 * @default 3
		 * @type {number}
		 */
		multiSortLimit?: number;
		/** 
		 * The property in each item that contains the data to sort.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		sortRoot?: string;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html).
		 * 
		 *    sorters: [{
		 *        property: 'age',
		 *        direction: 'DESC'
		 *    }, {
		 *        property: 'firstName',
		 *        direction: 'ASC'
		 *    }]
		 * 
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * getKey implementation for MixedCollection
		 * @method
		 * @public (method)
		 * @template
		 * @param   {object} o
		 * @returns {object}   The key for the passed item.
		 */
		getKey? (o: object): object;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                        config
		 * @returns {Ext.data.StoreManager.Statics}        this
		 */
		initConfig? (config: object): Ext.data.StoreManager.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}                 name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                        [value] The value to set for the name parameter.
		 * @returns {Ext.data.StoreManager.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.StoreManager.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.StoreManager.Statics}  
		 */
		statics? (): Ext.data.StoreManager.Statics;
	}
}
declare namespace Ext.data.TreeModel {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.TreeModel](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html)
	 * This class is used as a base class from which to derive Models used in Trees.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * An array of [associations](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Association.html) for this model.
		 * 
		 * For further documentation, see [Ext.data.schema.Association](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Association.html).
		 * @configuration
		 * @optional
		 * @type {object[]}
		 */
		associations?: object[];
		/** 
		 * One or more `Ext.data.schema.BelongsTo` associations for this model.
		 * @configuration
		 * @optional
		 * @type {string|object|string[]|object[]}
		 */
		belongsTo?: string | object | string[] | object[];
		/** 
		 * The class name of child nodes to create when reading child nodes from
		 * raw data. By default the type configured into the TreeStore is used.
		 * 
		 * This is one way of creating heterogeneous nodes in a tree.
		 * 
		 * To do this through data types passed from the server, use the [Ext.data.reader.Reader.typeProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-typeProperty).
		 * 
		 * for example in the case of a hidden root node, you'd use the default type at level zero. See TreePanel's
		 * documentation for an example.
		 * 
		 * _Important_
		 * If you are using this declaration on your tree models, and have a hidden root node, you
		 * MUST create a special root model definition which declares the type of its children.
		 * 
		 * If you allow the TreeStore to create a root node of the same type as the first level of _visible_ nodes
		 * then the reader will atempt to read the wrong type of child node for the root.
		 * 
		 * Example:
		 * 
		 *     Ext.define('myApp.World', {
		 *         childType: 'Territory'
		 *     });
		 *     ...
		 *     store: {
		 *         id: 'myTreeStore',
		 *         model: 'myApp.World' // The hidden root will know to create 'Territory' type children.
		 *     }
		 * 
		 * If the root is hidden, and the first level of visible nodes are going to be the `myApp.Territory` class,
		 *  then the hidden root must not be of the `myApp.Territory` class. Otherwise, it would try to read in the
		 *  territory data as its childType - most likely 'Country'.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		childType?: string;
		/** 
		 * The name of the property a server will use to send back a client-generated id in a
		 * `create` or `update` [`operation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
		 * 
		 * If specified, this property cannot have the same name as any other field.
		 * 
		 * For example:
		 * 
		 *     Ext.define('Person', {
		 *         idProperty: 'id',  // this is the default value (for clarity)
		 *    
		 *         clientIdProperty: 'clientId',
		 *    
		 *         identifier: 'negative', // to generate -1, -2 etc on the client
		 *    
		 *         fields: [ 'name' ]
		 *     });
		 *    
		 *     var person = new Person({
		 *         // no id provided, so -1 is generated
		 *         name: 'Clark Kent'
		 *     });
		 * 
		 * The server is given this data during the `create`:
		 * 
		 *     {
		 *         id: -1,
		 *         name: 'Clark Kent'
		 *     }
		 * 
		 * The server allocates a real id and responds like so:
		 * 
		 *     {
		 *         id: 427,
		 *         clientId: -1
		 *     }
		 * 
		 * This property is most useful when creating multiple entities in a single call to
		 * the server in a [`create operation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Create.html). Alternatively,
		 * the server could respond with records that correspond one-to-one to those sent in
		 * the `operation`.
		 * 
		 * For example the client could send a `create` with this data:
		 * 
		 *     [ { id: -1, name: 'Clark Kent' },
		 *       { id: -2, name: 'Peter Parker' },
		 *       { id: -3, name: 'Bruce Banner' } ]
		 * 
		 * And the server could respond in the same order:
		 * 
		 *     [ { id: 427 },      // updates id = -1
		 *       { id: 428 },      // updates id = -2
		 *       { id: 429 } ]     // updates id = -3
		 * 
		 * Or using `clientIdProperty` the server could respond in arbitrary order:
		 * 
		 *     [ { id: 427, clientId: -3 },
		 *       { id: 428, clientId: -1 },
		 *       { id: 429, clientId: -2 } ]
		 * 
		 * **IMPORTANT:** When upgrading from previous versions be aware that this property
		 * used to perform the role of [`Ext.data.writer.Writer.clientIdProperty`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.writer.Writer.html#cfg-clientIdProperty) as
		 * well as that described above. To continue send a client-generated id as other than
		 * the `idProperty`, set `clientIdProperty` on the `writer`. A better solution, however,
		 * is most likely a properly configured `identifier` as that would work better with
		 * associations.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		clientIdProperty?: string;
		/** 
		 * Set to `false` to prevent any converters from being called on fields specified in
		 * a [set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-set) operation.
		 * 
		 * **Note:** Setting the config to `false` will only prevent the convert / calculate
		 * call when the set `fieldName` param matches the field's `name`.  In the
		 * following example the calls to set `salary` will not execute the convert method
		 * on `set` while the calls to set `vested` will execute the convert method on the
		 * initial read as well as on `set`.
		 * 
		 * Example model definition:
		 * 
		 *    Ext.define('MyApp.model.Employee', {
		 *        extend: 'Ext.data.Model',
		 *        fields: ['yearsOfService', {
		 *            name: 'salary',
		 *            convert: function (val) {
		 *                var startingBonus = val * .1;
		 *                return val + startingBonus;
		 *            }
		 *        }, {
		 *            name: 'vested',
		 *            convert: function (val, record) {
		 *                return record.get('yearsOfService') &gt;= 4;
		 *            },
		 *            depends: 'yearsOfService'
		 *        }],
		 *        convertOnSet: false
		 *    });
		 *    
		 *    var tina = Ext.create('MyApp.model.Employee', {
		 *        salary: 50000,
		 *        yearsOfService: 3
		 *    });
		 *    
		 *    console.log(tina.get('salary')); // logs 55000
		 *    console.log(tina.get('vested')); // logs false
		 *    
		 *    tina.set({
		 *        salary: 60000,
		 *        yearsOfService: 4
		 *    });
		 *    console.log(tina.get('salary')); // logs 60000
		 *    console.log(tina.get('vested')); // logs true
		 * 
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		convertOnSet?: boolean;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * One or more [`Ext.data.schema.HasMany`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.HasMany.html) associations for this model.
		 * @configuration
		 * @optional
		 * @type {string|object|string[]|object[]}
		 */
		hasMany?: string | object | string[] | object[];
		/** 
		 * One or more [`Ext.data.schema.HasOne`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.HasOne.html) associations for this model.
		 * @configuration
		 * @optional
		 * @type {string|object|string[]|object[]}
		 */
		hasOne?: string | object | string[] | object[];
		/** 
		 * The name of the field treated as this Model's unique id.
		 * 
		 * If changing the idProperty in a subclass, the generated id field will replace the one
		 * generated by the superclass, for example;
		 * 
		 *     Ext.define('Super', {
		 *         extend: 'Ext.data.Model',
		 *         fields: ['name']
		 *     });
		 *    
		 *     Ext.define('Sub', {
		 *         extend: 'Super',
		 *         idProperty: 'customId'
		 *     });
		 *    
		 *     var fields = Super.getFields();
		 *     // Has 2 fields, "name" &amp; "id"
		 *     console.log(fields[0].name, fields[1].name, fields.length);
		 *    
		 *     fields = Sub.getFields();
		 *     // Has 2 fields, "name" &amp; "customId", "id" is replaced
		 *     console.log(fields[0].name, fields[1].name, fields.length);
		 * 
		 * The data values for this field must be unique or there will be id value collisions
		 * in the [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
		 * @configuration
		 * @optional
		 * @default 'id'
		 * @type {string}
		 */
		idProperty?: string;
		/** 
		 * The id generator to use for this model. The `identifier` generates values for the
		 * [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) when no value is given. Records with client-side generated
		 * values for [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) are called [phantom](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records since they are
		 * not yet known to the server.
		 * 
		 * This can be overridden at the model level to provide a custom generator for a model.
		 * The simplest form of this would be:
		 * 
		 *     Ext.define('MyApp.data.MyModel', {
		 *         extend: 'Ext.data.Model',
		 *         requires: ['Ext.data.identifier.Sequential'],
		 *         identifier: 'sequential',
		 *         ...
		 *     });
		 * 
		 * The above would generate [sequential](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.identifier.Sequential.html) id's such
		 * as 1, 2, 3 etc..
		 * 
		 * Another useful id generator is [Ext.data.identifier.Uuid](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.identifier.Uuid.html):
		 * 
		 *     Ext.define('MyApp.data.MyModel', {
		 *         extend: 'Ext.data.Model',
		 *         requires: ['Ext.data.identifier.Uuid'],
		 *         identifier: 'uuid',
		 *         ...
		 *     });
		 * 
		 * An id generator can also be further configured:
		 * 
		 *     Ext.define('MyApp.data.MyModel', {
		 *         extend: 'Ext.data.Model',
		 *         identifier: {
		 *             type: 'sequential',
		 *             seed: 1000,
		 *             prefix: 'ID_'
		 *         }
		 *     });
		 * 
		 * The above would generate id's such as ID_1000, ID_1001, ID_1002 etc..
		 * 
		 * If multiple models share an id space, a single generator can be shared:
		 * 
		 *     Ext.define('MyApp.data.MyModelX', {
		 *         extend: 'Ext.data.Model',
		 *         identifier: {
		 *             type: 'sequential',
		 *             id: 'xy'
		 *         }
		 *     });
		 *    
		 *     Ext.define('MyApp.data.MyModelY', {
		 *         extend: 'Ext.data.Model',
		 *         identifier: {
		 *             type: 'sequential',
		 *             id: 'xy'
		 *         }
		 *     });
		 * 
		 * For more complex, shared id generators, a custom generator is the best approach.
		 * See [Ext.data.identifier.Generator](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.identifier.Generator.html) for details on creating custom id generators.
		 * @configuration
		 * @optional
		 * @type {string|object}
		 */
		identifier?: string | object;
		/** 
		 * A config object for a [ManyToMany](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.ManyToMany.html) association.
		 * See the class description for [ManyToMany](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.ManyToMany.html) for
		 * configuration examples.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		manyToMany?: object;
		/** 
		 * The [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) to use for this class.
		 * @configuration
		 * @optional
		 * @type {string|object|Ext.data.proxy.Proxy}
		 */
		proxy?: string | object | Ext.data.proxy.Proxy;
		/** 
		 * The name of the [schema](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Schema.html) to which this entity and its
		 * associations belong. For details on custom schemas see [`Ext.data.schema.Schema`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Schema.html).
		 * @configuration
		 * @optional
		 * @default 'default'
		 * @type {string|object}
		 */
		schema?: string | object;
		/** 
		 * If specified this property is used to concatenate multiple errors for each field
		 * as reported by the `validators`.
		 * @configuration
		 * @optional
		 * @default null
		 * @type {string}
		 */
		validationSeparator?: string;
		/** 
		 * An array of [validators](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.validator.Validator.html) for this model.
		 * @configuration
		 * @optional
		 * @type {object[]}
		 */
		validators?: object[];
		/** 
		 * If specified, this is the name of the property that contains the entity "version".
		 * The version property is used to manage a long-running transaction and allows the
		 * detection of simultaneous modification.
		 * 
		 * The way a version property is used is that the client receives the version as it
		 * would any other entity property. When saving an entity, this property is always
		 * included in the request and the server uses the value in a "conditional update".
		 * If the current version of the entity on the server matches the version property
		 * sent by the client, the update is allowed. Otherwise, the update fails.
		 * 
		 * On successful update, both the client and server increment the version. This is
		 * done on the server in the conditional update and on the client when it receives a
		 * success on its update request.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		versionProperty?: string;
		/** 
		 * This method is called by the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) after loading a model from
		 * the server. This is after processing any inline associations that are available.
		 * @method
		 * @protected (method)
		 * @template
		 * @returns {void}  
		 */
		onLoad? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                     config
		 * @returns {Ext.data.TreeModel.Statics}        this
		 */
		initConfig? (config: object): Ext.data.TreeModel.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}              name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                     [value] The value to set for the name parameter.
		 * @returns {Ext.data.TreeModel.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.TreeModel.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.TreeModel.Statics}  
		 */
		statics? (): Ext.data.TreeModel.Statics;
	}
}
declare namespace Ext.data.TreeStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html)
	 * The TreeStore is a store implementation that owns the [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root) of
	 * a tree, and provides methods to load either local or remote data as child nodes of the root
	 * and any descendant non-leaf node.
	 * 
	 * The TreeStore must be used as the store of a tree panel.
	 * 
	 * This class also relays many node events from the underlying node structure.
	 * 
	 * # Using Models
	 * 
	 * If no Model is specified, an implicit model will be created that extends [Ext.data.TreeModel](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html).
	 * The standard Tree fields will also be copied onto the Model for maintaining their state. These fields are listed
	 * in the [Ext.data.NodeInterface](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html) documentation.
	 * 
	 * # Reading Nested Data
	 * 
	 * For the tree to read nested data, the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) must be configured with a root property,
	 * so the reader can find nested data for each node (if a root is not specified, it will default to
	 * 'children'). This will tell the tree to look for any nested tree nodes by the same keyword, i.e., 'children'.
	 * If a root is specified in the config make sure that any nested nodes with children have the same name.
	 * 
	 * **Note:** Setting [defaultRootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-defaultRootProperty) accomplishes the same thing.
	 * 
	 * # rootProperty as a Function
	 * 
	 * You can pass a function as the data reader's rootProperty when the tree's dataset has
	 * mixed root properties. Child nodes can then be programmatically determined at read time.
	 * 
	 * For example, the child nodes may be passed via the 'children' property
	 * name, though you may have a top-level root property of 'items'.
	 * 
	 * See [rootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-rootProperty) for more information.
	 * 
	 * # Filtering
	 * 
	 * Filtering of nodes in a TreeStore is hierarchically top down by default. This means that if a non-leaf node does not
	 * pass the filter, then it, and all its descendants are filtered _out_ of the store.
	 * 
	 * To reverse this, so that any node which passes the filter causes all its ancestors to be visible, configure
	 * the `TreeStore` with '[filterer: 'bottomup'`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-filterer)
	 * 
	 * You may also programatically filter individual tree nodes by setting their `'visible'` field.
	 * 
	 * Setting this to `false` filters the node out so that it will not appear in the UI. Setting it to `true`
	 * filters the node in.
	 * 
	 * Note that if performing several filter operations, it is best to [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-suspendEvents)
	 * on the store first, and when all nodes have been modified, [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-resumeEvents) and fire the
	 * [refresh](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#event-refresh) event on the store.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The owner of this store if the store is used as part of an association.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Model}
		 */
		associatedEntity?: Ext.data.Model;
		/** 
		 * This defaults to `true` when this store's [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy) is asynchronous, such as an
		 * [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html).
		 * 
		 * When the proxy is synchronous, such as a [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) memory proxy, this
		 * defaults to `false`.
		 * 
		 * _NOTE:_ This does not cause synchronous Ajax requests if configured `false` when an Ajax proxy
		 * is used. It causes immediate issuing of an Ajax request when [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) is called
		 * rather than issuing the request at the end of the current event handler run.
		 * 
		 * What this means is that when using an Ajax proxy, calls to
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) do not fire the request to the remote resource
		 * immediately, but schedule a request to be made. This is so that multiple
		 * requests are not fired when mutating a store's remote filters and sorters (as
		 * happens during state restoration). The request is made only once after all
		 * relevant store state is fully set.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		asynchronousLoad?: boolean;
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
		 * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
		 * 
		 * It's important to note that [Tree Stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) will<br/>
		 * load regardless of autoLoad's value if expand is set to true on the
		 * [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @configuration
		 * @optional
		 * @type {boolean|object}
		 */
		autoLoad?: boolean | object;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		autoSync?: boolean;
		/** 
		 * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
		 * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
		 * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
		 * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
		 * @configuration
		 * @optional
		 * @default 'operation'
		 * @type {string}
		 */
		batchUpdateMode?: string;
		/** 
		 * Remove previously existing child nodes before loading.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearOnLoad?: boolean;
		/** 
		 * True to empty the store when loading another page via [loadPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadPage),
		 * [nextPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-nextPage) or [previousPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-previousPage). Setting to false keeps existing records, allowing
		 * large data sets to be loaded one page at a time but rendered all together.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearOnPageLoad?: boolean;
		/** 
		 * If `true`, when a node is reloaded, any records in the [removed](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#property-removed) record collection that were previously descendants of the node being reloaded will be cleared from the [removed](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#property-removed) collection.
		 * Only applicable if [clearOnLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-clearOnLoad) is `true`.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearRemovedOnLoad?: boolean;
		/** 
		 * Array of Model instances or data objects to load locally. See "Inline data"
		 * above for details.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {object[]|Ext.data.Model[]}
		 */
		data?: object[] | Ext.data.Model[];
		/** 
		 * The default root id.
		 * @configuration
		 * @optional
		 * @default "root"
		 * @type {string}
		 */
		defaultRootId?: string;
		/** 
		 * @configuration
		 * @optional
		 * @default "children"
		 * @type {string}
		 */
		defaultRootProperty?: string;
		/** 
		 * The default root text (if not specified)
		 * @configuration
		 * @optional
		 * @default "Root"
		 * @type {string}
		 */
		defaultRootText?: string;
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		extraKeys?: object;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * The order in which to prioritize how filters are applied to nodes.
		 * 
		 * The default, `'topdown'` means that if a parent node does _not_ pass the filter, then the branch
		 * ends there, and no descendant nodes are filtered in, even if they would pass the filter.
		 * 
		 * By specifying `'bottomup'`, if a leaf node passes the filter, then all its ancestor nodes are filtered
		 * in to allow it to be visible.
		 * @configuration
		 * @optional
		 * @default topdown
		 * @type {string}
		 */
		filterer?: string;
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * Set to true to automatically prepend a leaf sorter.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		folderSort?: boolean;
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * Set to true to prevent child nodes from being loaded until the the node is
		 * expanded or loaded explicitly.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		lazyFill?: boolean;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Name of the [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) associated with this store. See
		 * [Ext.data.Model.entityName](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-entityName).
		 * 
		 * May also be the actual Model subclass.
		 * 
		 * This config is required for the store to be able to read data unless you have defined
		 * the [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields) config which will create an anonymous [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html).
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The name of the parameter sent to the server which contains the identifier of the node.
		 * @configuration
		 * @optional
		 * @default "node"
		 * @type {string}
		 */
		nodeParam?: string;
		/** 
		 * This config allows node data to be returned from the server in linear format without having to structure it into `children`
		 * arrays.
		 * 
		 * This property specifies which property name in the raw node data yields the id of the parent node.
		 * 
		 * For example the following data would be read into a geographic tree by configuring the TreeStore with `parentIdProperty: 'parentId'`.
		 * The node data contains an upward link to a parent node.
		 * 
		 *    data: [{
		 *        name: 'North America',
		 *        id: 'NA'
		 *    }, {
		 *        name: 'Unites States',
		 *        id: 'USA',
		 *        parentId: 'NA'
		 *    }, {
		 *        name: 'Redwood City',
		 *        leaf: true,
		 *        parentId: 'USA'
		 *    }, {
		 *        name: 'Frederick, MD',
		 *        leaf: true,
		 *        parentId: 'USA'
		 *    }]
		 * 
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		parentIdProperty?: string;
		/** 
		 * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
		 * see [setProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-setProxy) for details.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.proxy.Proxy|object}
		 */
		proxy?: string | Ext.data.proxy.Proxy | object;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * The role for the [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @configuration
		 * @optional
		 * @type {Ext.data.schema.Role}
		 */
		role?: Ext.data.schema.Role;
		/** 
		 * The root node for this store. For example:
		 * 
		 *    root: {
		 *        expanded: true,
		 *        text: "My Root",
		 *        children: [
		 *            { text: "Child 1", leaf: true },
		 *            { text: "Child 2", expanded: true, children: [
		 *                { text: "GrandChild", leaf: true }
		 *            ] }
		 *        ]
		 *    }
		 * 
		 * Setting the `root` config option is the same as calling [setRootNode](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-setRootNode).
		 * 
		 * It's important to note that setting expanded to true on the root node will cause
		 * the tree store to attempt to load.  This will occur regardless the value of
		 * [autoLoad](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoLoad). If you you do not want the store
		 * to load on instantiation, ensure expanded is false and load the store when you're ready.
		 * @configuration
		 * @optional
		 * @type {Ext.data.TreeModel|Ext.data.NodeInterface|object}
		 */
		root?: Ext.data.TreeModel | Ext.data.NodeInterface | object;
		/** 
		 * `false` to not include the root node in this Stores collection.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		rootVisible?: boolean;
		/** 
		 * The session for this store. By specifying a session, it ensures any records that are
		 * added to this store are also included in the session. This store does not become a member
		 * of the session itself.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Session}
		 */
		session?: Ext.data.Session;
		/** 
		 * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
		 * Defaults to true, ignored if [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) is true
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		sortOnLoad?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * This config controls whether removed records are remembered by this store for
		 * later saving to the server.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		trackRemoved?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                     config
		 * @returns {Ext.data.TreeStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.TreeStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}              name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                     [value] The value to set for the name parameter.
		 * @returns {Ext.data.TreeStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.TreeStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.TreeStore.Statics}  
		 */
		statics? (): Ext.data.TreeStore.Statics;
	}
}
declare namespace Ext.data.Validation {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.Validation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Validation.html)
	 * This class is used to hold validation errors for a record. The results of the record's
	 * [`validators`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-validators) are stored as the field values of this
	 * record. The first failed validation is all that is stored per field unless the Model
	 * class has defined a `validationSeparator` config.
	 * 
	 * Application code will not need to interact with this class specifically but rather just
	 * view the validation as a record.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * An array of [associations](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Association.html) for this model.
		 * 
		 * For further documentation, see [Ext.data.schema.Association](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Association.html).
		 * @configuration
		 * @optional
		 * @type {object[]}
		 */
		associations?: object[];
		/** 
		 * One or more `Ext.data.schema.BelongsTo` associations for this model.
		 * @configuration
		 * @optional
		 * @type {string|object|string[]|object[]}
		 */
		belongsTo?: string | object | string[] | object[];
		/** 
		 * The name of the property a server will use to send back a client-generated id in a
		 * `create` or `update` [`operation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html).
		 * 
		 * If specified, this property cannot have the same name as any other field.
		 * 
		 * For example:
		 * 
		 *     Ext.define('Person', {
		 *         idProperty: 'id',  // this is the default value (for clarity)
		 *    
		 *         clientIdProperty: 'clientId',
		 *    
		 *         identifier: 'negative', // to generate -1, -2 etc on the client
		 *    
		 *         fields: [ 'name' ]
		 *     });
		 *    
		 *     var person = new Person({
		 *         // no id provided, so -1 is generated
		 *         name: 'Clark Kent'
		 *     });
		 * 
		 * The server is given this data during the `create`:
		 * 
		 *     {
		 *         id: -1,
		 *         name: 'Clark Kent'
		 *     }
		 * 
		 * The server allocates a real id and responds like so:
		 * 
		 *     {
		 *         id: 427,
		 *         clientId: -1
		 *     }
		 * 
		 * This property is most useful when creating multiple entities in a single call to
		 * the server in a [`create operation`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Create.html). Alternatively,
		 * the server could respond with records that correspond one-to-one to those sent in
		 * the `operation`.
		 * 
		 * For example the client could send a `create` with this data:
		 * 
		 *     [ { id: -1, name: 'Clark Kent' },
		 *       { id: -2, name: 'Peter Parker' },
		 *       { id: -3, name: 'Bruce Banner' } ]
		 * 
		 * And the server could respond in the same order:
		 * 
		 *     [ { id: 427 },      // updates id = -1
		 *       { id: 428 },      // updates id = -2
		 *       { id: 429 } ]     // updates id = -3
		 * 
		 * Or using `clientIdProperty` the server could respond in arbitrary order:
		 * 
		 *     [ { id: 427, clientId: -3 },
		 *       { id: 428, clientId: -1 },
		 *       { id: 429, clientId: -2 } ]
		 * 
		 * **IMPORTANT:** When upgrading from previous versions be aware that this property
		 * used to perform the role of [`Ext.data.writer.Writer.clientIdProperty`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.writer.Writer.html#cfg-clientIdProperty) as
		 * well as that described above. To continue send a client-generated id as other than
		 * the `idProperty`, set `clientIdProperty` on the `writer`. A better solution, however,
		 * is most likely a properly configured `identifier` as that would work better with
		 * associations.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		clientIdProperty?: string;
		/** 
		 * Set to `false` to prevent any converters from being called on fields specified in
		 * a [set](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-set) operation.
		 * 
		 * **Note:** Setting the config to `false` will only prevent the convert / calculate
		 * call when the set `fieldName` param matches the field's `name`.  In the
		 * following example the calls to set `salary` will not execute the convert method
		 * on `set` while the calls to set `vested` will execute the convert method on the
		 * initial read as well as on `set`.
		 * 
		 * Example model definition:
		 * 
		 *    Ext.define('MyApp.model.Employee', {
		 *        extend: 'Ext.data.Model',
		 *        fields: ['yearsOfService', {
		 *            name: 'salary',
		 *            convert: function (val) {
		 *                var startingBonus = val * .1;
		 *                return val + startingBonus;
		 *            }
		 *        }, {
		 *            name: 'vested',
		 *            convert: function (val, record) {
		 *                return record.get('yearsOfService') &gt;= 4;
		 *            },
		 *            depends: 'yearsOfService'
		 *        }],
		 *        convertOnSet: false
		 *    });
		 *    
		 *    var tina = Ext.create('MyApp.model.Employee', {
		 *        salary: 50000,
		 *        yearsOfService: 3
		 *    });
		 *    
		 *    console.log(tina.get('salary')); // logs 55000
		 *    console.log(tina.get('vested')); // logs false
		 *    
		 *    tina.set({
		 *        salary: 60000,
		 *        yearsOfService: 4
		 *    });
		 *    console.log(tina.get('salary')); // logs 60000
		 *    console.log(tina.get('vested')); // logs true
		 * 
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		convertOnSet?: boolean;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * One or more [`Ext.data.schema.HasMany`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.HasMany.html) associations for this model.
		 * @configuration
		 * @optional
		 * @type {string|object|string[]|object[]}
		 */
		hasMany?: string | object | string[] | object[];
		/** 
		 * One or more [`Ext.data.schema.HasOne`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.HasOne.html) associations for this model.
		 * @configuration
		 * @optional
		 * @type {string|object|string[]|object[]}
		 */
		hasOne?: string | object | string[] | object[];
		/** 
		 * The name of the field treated as this Model's unique id.
		 * 
		 * If changing the idProperty in a subclass, the generated id field will replace the one
		 * generated by the superclass, for example;
		 * 
		 *     Ext.define('Super', {
		 *         extend: 'Ext.data.Model',
		 *         fields: ['name']
		 *     });
		 *    
		 *     Ext.define('Sub', {
		 *         extend: 'Super',
		 *         idProperty: 'customId'
		 *     });
		 *    
		 *     var fields = Super.getFields();
		 *     // Has 2 fields, "name" &amp; "id"
		 *     console.log(fields[0].name, fields[1].name, fields.length);
		 *    
		 *     fields = Sub.getFields();
		 *     // Has 2 fields, "name" &amp; "customId", "id" is replaced
		 *     console.log(fields[0].name, fields[1].name, fields.length);
		 * 
		 * The data values for this field must be unique or there will be id value collisions
		 * in the [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
		 * @configuration
		 * @optional
		 * @default 'id'
		 * @type {string}
		 */
		idProperty?: string;
		/** 
		 * The id generator to use for this model. The `identifier` generates values for the
		 * [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) when no value is given. Records with client-side generated
		 * values for [idProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-idProperty) are called [phantom](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-phantom) records since they are
		 * not yet known to the server.
		 * 
		 * This can be overridden at the model level to provide a custom generator for a model.
		 * The simplest form of this would be:
		 * 
		 *     Ext.define('MyApp.data.MyModel', {
		 *         extend: 'Ext.data.Model',
		 *         requires: ['Ext.data.identifier.Sequential'],
		 *         identifier: 'sequential',
		 *         ...
		 *     });
		 * 
		 * The above would generate [sequential](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.identifier.Sequential.html) id's such
		 * as 1, 2, 3 etc..
		 * 
		 * Another useful id generator is [Ext.data.identifier.Uuid](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.identifier.Uuid.html):
		 * 
		 *     Ext.define('MyApp.data.MyModel', {
		 *         extend: 'Ext.data.Model',
		 *         requires: ['Ext.data.identifier.Uuid'],
		 *         identifier: 'uuid',
		 *         ...
		 *     });
		 * 
		 * An id generator can also be further configured:
		 * 
		 *     Ext.define('MyApp.data.MyModel', {
		 *         extend: 'Ext.data.Model',
		 *         identifier: {
		 *             type: 'sequential',
		 *             seed: 1000,
		 *             prefix: 'ID_'
		 *         }
		 *     });
		 * 
		 * The above would generate id's such as ID_1000, ID_1001, ID_1002 etc..
		 * 
		 * If multiple models share an id space, a single generator can be shared:
		 * 
		 *     Ext.define('MyApp.data.MyModelX', {
		 *         extend: 'Ext.data.Model',
		 *         identifier: {
		 *             type: 'sequential',
		 *             id: 'xy'
		 *         }
		 *     });
		 *    
		 *     Ext.define('MyApp.data.MyModelY', {
		 *         extend: 'Ext.data.Model',
		 *         identifier: {
		 *             type: 'sequential',
		 *             id: 'xy'
		 *         }
		 *     });
		 * 
		 * For more complex, shared id generators, a custom generator is the best approach.
		 * See [Ext.data.identifier.Generator](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.identifier.Generator.html) for details on creating custom id generators.
		 * @configuration
		 * @optional
		 * @type {string|object}
		 */
		identifier?: string | object;
		/** 
		 * A config object for a [ManyToMany](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.ManyToMany.html) association.
		 * See the class description for [ManyToMany](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.ManyToMany.html) for
		 * configuration examples.
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		manyToMany?: object;
		/** 
		 * The [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) to use for this class.
		 * @configuration
		 * @optional
		 * @type {string|object|Ext.data.proxy.Proxy}
		 */
		proxy?: string | object | Ext.data.proxy.Proxy;
		/** 
		 * The name of the [schema](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Schema.html) to which this entity and its
		 * associations belong. For details on custom schemas see [`Ext.data.schema.Schema`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.schema.Schema.html).
		 * @configuration
		 * @optional
		 * @default 'default'
		 * @type {string|object}
		 */
		schema?: string | object;
		/** 
		 * If specified this property is used to concatenate multiple errors for each field
		 * as reported by the `validators`.
		 * @configuration
		 * @optional
		 * @default null
		 * @type {string}
		 */
		validationSeparator?: string;
		/** 
		 * An array of [validators](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.validator.Validator.html) for this model.
		 * @configuration
		 * @optional
		 * @type {object[]}
		 */
		validators?: object[];
		/** 
		 * If specified, this is the name of the property that contains the entity "version".
		 * The version property is used to manage a long-running transaction and allows the
		 * detection of simultaneous modification.
		 * 
		 * The way a version property is used is that the client receives the version as it
		 * would any other entity property. When saving an entity, this property is always
		 * included in the request and the server uses the value in a "conditional update".
		 * If the current version of the entity on the server matches the version property
		 * sent by the client, the update is allowed. Otherwise, the update fails.
		 * 
		 * On successful update, both the client and server increment the version. This is
		 * done on the server in the conditional update and on the client when it receives a
		 * success on its update request.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		versionProperty?: string;
		/** 
		 * This method is called by the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) after loading a model from
		 * the server. This is after processing any inline associations that are available.
		 * @method
		 * @protected (method)
		 * @template
		 * @returns {void}  
		 */
		onLoad? (): void;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                      config
		 * @returns {Ext.data.Validation.Statics}        this
		 */
		initConfig? (config: object): Ext.data.Validation.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}               name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                      [value] The value to set for the name parameter.
		 * @returns {Ext.data.Validation.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.Validation.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.Validation.Statics}  
		 */
		statics? (): Ext.data.Validation.Statics;
	}
}
declare namespace Ext.data.XmlStore {
	/** 
	 * @configurations
	 * Config interface to create class: 
	 * [Ext.data.XmlStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from XML data easier.
	 * A XmlStore will be automatically configured with a [Ext.data.reader.Xml](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Xml.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.XmlStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *        url: 'sheldon.xml', // automatically configures a HttpProxy
	 *        // reader configs
	 *        record: 'Item', // records will have an "Item" tag
	 *        idPath: 'ASIN',
	 *        totalRecords: '@TotalResults'
	 *        fields: [
	 *            // set up the fields mapping into the xml doc
	 *            // The first needs mapping, the others are very basic
	 *            {name: 'Author', mapping: 'ItemAttributes > Author'},
	 *            'Title', 'Manufacturer', 'ProductGroup'
	 *        ]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    &#60?xml version="1.0" encoding="UTF-8"?>
	 *    &#60ItemSearchResponse xmlns="http://webservices.amazon.com/AWSECommerceService/2009-05-15">
	 *        &#60Items>
	 *            &#60Request>
	 *                &#60IsValid>True&#60/IsValid>
	 *                &#60ItemSearchRequest>
	 *                    &#60Author>Sidney Sheldon&#60/Author>
	 *                    &#60SearchIndex>Books&#60/SearchIndex>
	 *                &#60/ItemSearchRequest>
	 *            &#60/Request>
	 *            &#60TotalResults>203&#60/TotalResults>
	 *            &#60TotalPages>21&#60/TotalPages>
	 *            &#60Item>
	 *                &#60ASIN>0446355453&#60/ASIN>
	 *                &#60DetailPageURL>
	 *                    http://www.amazon.com/
	 *                &#60/DetailPageURL>
	 *                &#60ItemAttributes>
	 *                    &#60Author>Sidney Sheldon&#60/Author>
	 *                    &#60Manufacturer>Warner Books&#60/Manufacturer>
	 *                    &#60ProductGroup>Book&#60/ProductGroup>
	 *                    &#60Title>Master of the Game&#60/Title>
	 *                &#60/ItemAttributes>
	 *            &#60/Item>
	 *        &#60/Items>
	 *    &#60/ItemSearchResponse>
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#cfg-data) config option.
	 * 
	 * **Note:** This class accepts all of the configuration options of
	 * **[XmlReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Xml.html)**.
	 */
	interface Cfg extends Ext.base.Configs {
		/** 
		 * The owner of this store if the store is used as part of an association.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Model}
		 */
		associatedEntity?: Ext.data.Model;
		/** 
		 * This defaults to `true` when this store's [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy) is asynchronous, such as an
		 * [Ajax proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Ajax.html).
		 * 
		 * When the proxy is synchronous, such as a [Ext.data.proxy.Memory](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) memory proxy, this
		 * defaults to `false`.
		 * 
		 * _NOTE:_ This does not cause synchronous Ajax requests if configured `false` when an Ajax proxy
		 * is used. It causes immediate issuing of an Ajax request when [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) is called
		 * rather than issuing the request at the end of the current event handler run.
		 * 
		 * What this means is that when using an Ajax proxy, calls to
		 * [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) do not fire the request to the remote resource
		 * immediately, but schedule a request to be made. This is so that multiple
		 * requests are not fired when mutating a store's remote filters and sorters (as
		 * happens during state restoration). The request is made only once after all
		 * relevant store state is fully set.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		asynchronousLoad?: boolean;
		/** 
		 * When a Store is used by only one DataView, and should only exist for the lifetime of that view, then
		 * configure the autoDestroy flag as `true`. This causes the destruction of the view to trigger the destruction of its Store.
		 * @configuration
		 * @optional
		 * @type {boolean}
		 */
		autoDestroy?: boolean;
		/** 
		 * If data is not specified, and if autoLoad is true or an Object, this store's load method is automatically called
		 * after creation. If the value of autoLoad is an Object, this Object will be passed to the store's load method.
		 * 
		 * It's important to note that [Tree Stores](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html) will<br/>
		 * load regardless of autoLoad's value if expand is set to true on the
		 * [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root).
		 * @configuration
		 * @optional
		 * @type {boolean|object}
		 */
		autoLoad?: boolean | object;
		/** 
		 * `true` to maintain sorted order when records
		 * are added regardless of requested insertion point, or when an item mutation
		 * results in a new sort position.
		 * 
		 * This does not affect a ChainedStore's reaction to mutations of the source
		 * Store. If sorters are present when the source Store is mutated, this ChainedStore's
		 * sort order will always be maintained.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		autoSort?: boolean;
		/** 
		 * True to automatically sync the Store with its Proxy after every edit to one of its Records. Defaults to false.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		autoSync?: boolean;
		/** 
		 * Sets the updating behavior based on batch synchronization. 'operation' (the default) will update the Store's
		 * internal representation of the data after each operation of the batch has completed, 'complete' will wait until
		 * the entire batch has been completed before updating the Store's data. 'complete' is a good choice for local
		 * storage proxies, 'operation' is better for remote proxies, where there is a comparatively high latency.
		 * @configuration
		 * @optional
		 * @default 'operation'
		 * @type {string}
		 */
		batchUpdateMode?: string;
		/** 
		 * True to empty the store when loading another page via [loadPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-loadPage),
		 * [nextPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-nextPage) or [previousPage](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-previousPage). Setting to false keeps existing records, allowing
		 * large data sets to be loaded one page at a time but rendered all together.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearOnPageLoad?: boolean;
		/** 
		 * `true` to clear anything in the [removed](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#property-removed) record collection when the store loads.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		clearRemovedOnLoad?: boolean;
		/** 
		 * Array of Model instances or data objects to load locally. See "Inline data"
		 * above for details.
		 * @configuration
		 * @optional
		 * @default 0
		 * @type {object[]|Ext.data.Model[]}
		 */
		data?: object[] | Ext.data.Model[];
		/** 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		extraKeys?: object;
		/** 
		 * An Array of [`Ext.data.field.Field`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config objects, simply the field
		 * [name](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html#cfg-name), or a mix of config objects and strings.
		 * If just a name is given, the field type defaults to `auto`.
		 * 
		 * In a [Field](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) config object you may pass the alias of
		 * the `Ext.data.field.*` type using the `type` config option.
		 * 
		 *    // two fields are set:
		 *    // - an 'auto' field with a name of 'firstName'
		 *    // - and an Ext.data.field.Integer field with a name of 'age'
		 *    fields: ['firstName', {
		 *        type: 'int',
		 *        name: 'age'
		 *    }]
		 * 
		 * Fields will automatically be created at read time for any for any keys in the
		 * data passed to the Model's [proxy's](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) whose name is not explicitly configured in
		 * the `fields` config.
		 * 
		 * Extending a Model class will inherit all the `fields` from the superclass /
		 * ancestor classes.
		 * @configuration
		 * @optional
		 * @type {object[]|string[]}
		 */
		fields?: object[] | string[];
		/** 
		 * Array of [Filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html) for this store. Can also be passed array of
		 * functions which will be used as the [filterFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Filter.html#cfg-filterFn) config
		 * for filters:
		 * 
		 *    filters: [
		 *        function(item) {
		 *            return item.weight &gt; 0;
		 *        }
		 *    ]
		 * 
		 * To filter after the grid is loaded use the [filterBy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filterBy) function.
		 * @configuration
		 * @optional
		 * @type {Function[]|object[]}
		 */
		filters?: Function[] | object[];
		/** 
		 * The direction in which sorting should be applied when grouping. Supported values are "ASC" and "DESC".
		 * @configuration
		 * @optional
		 * @default 'ASC'
		 * @type {string}
		 */
		groupDir?: string;
		/** 
		 * The field by which to group data in the store. Internally, grouping is very similar to sorting - the
		 * groupField and [groupDir](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupDir) are injected as the first sorter (see [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-sort)). Stores support a single
		 * level of grouping, and groups can be fetched via the [getGroups](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-getGroups) method.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		groupField?: string;
		/** 
		 * The grouper by which to group the data store. May also be specified by the [groupField](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-groupField) config, however
		 * they should not be used together.
		 * @configuration
		 * @optional
		 * @type {object|Ext.util.Grouper}
		 */
		grouper?: object | Ext.util.Grouper;
		/** 
		 * A config object containing one or more event handlers to be added to this object during initialization. This
		 * should be a valid listeners config object as specified in the
		 * [addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener) example for attaching
		 * multiple handlers at once.
		 * 
		 * **DOM events from Ext JS [Components](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Component.html)**
		 * 
		 * While _some_ Ext JS Component classes export selected DOM events (e.g. "click", "mouseover" etc), this is usually
		 * only done when extra value can be added. For example the DataView's **`itemclick`** event passing the node clicked on. To access DOM events directly from a
		 * child element of a Component, we need to specify the `element` option to identify the Component property to add a
		 * DOM listener to:
		 * 
		 *    new Ext.panel.Panel({
		 *        width: 400,
		 *        height: 200,
		 *        dockedItems: [{
		 *            xtype: 'toolbar'
		 *        }],
		 *        listeners: {
		 *            click: {
		 *                element: 'el', //bind to the underlying el property on the panel
		 *                fn: function(){ console.log('click el'); }
		 *            },
		 *            dblclick: {
		 *                element: 'body', //bind to the underlying body property on the panel
		 *                fn: function(){ console.log('dblclick body'); }
		 *            }
		 *        }
		 *    });
		 * 
		 * @configuration
		 * @optional
		 * @type {object}
		 */
		listeners?: object;
		/** 
		 * Name of the [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) associated with this store. See
		 * [Ext.data.Model.entityName](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#property-entityName).
		 * 
		 * May also be the actual Model subclass.
		 * 
		 * This config is required for the store to be able to read data unless you have defined
		 * the [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-fields) config which will create an anonymous [`Ext.data.Model`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html).
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.Model}
		 */
		model?: string | Ext.data.Model;
		/** 
		 * The number of records considered to form a 'page'. This is used to power the built-in
		 * paging using the nextPage and previousPage functions when the grid is paged using a
		 * PagingToolbar Defaults to 25.
		 * 
		 * To disable paging, set the pageSize to `0`.
		 * @configuration
		 * @optional
		 * @default 25
		 * @type {number}
		 */
		pageSize?: number;
		/** 
		 * The Proxy to use for this Store. This can be either a string, a config object or a Proxy instance -
		 * see [setProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-setProxy) for details.
		 * @configuration
		 * @optional
		 * @type {string|Ext.data.proxy.Proxy|object}
		 */
		proxy?: string | Ext.data.proxy.Proxy | object;
		/** 
		 * `true` to defer any filtering operation to the server. If `false`, filtering is done locally on the client.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteFilter?: boolean;
		/** 
		 * `true` if the sorting should be performed on the server side, false if it is local only.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		remoteSort?: boolean;
		/** 
		 * The role for the [associatedEntity](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-associatedEntity).
		 * @configuration
		 * @optional
		 * @type {Ext.data.schema.Role}
		 */
		role?: Ext.data.schema.Role;
		/** 
		 * The session for this store. By specifying a session, it ensures any records that are
		 * added to this store are also included in the session. This store does not become a member
		 * of the session itself.
		 * @configuration
		 * @optional
		 * @type {Ext.data.Session}
		 */
		session?: Ext.data.Session;
		/** 
		 * If true, any sorters attached to this Store will be run after loading data, before the datachanged event is fired.
		 * Defaults to true, ignored if [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) is true
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		sortOnLoad?: boolean;
		/** 
		 * The initial set of [Sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Sorter.html)
		 * @configuration
		 * @optional
		 * @type {Ext.util.Sorter[]|object[]}
		 */
		sorters?: Ext.util.Sorter[] | object[];
		/** 
		 * Configure as `true` to have the filters saved when a client grid saves its state.
		 * @configuration
		 * @optional
		 * @default false
		 * @type {boolean}
		 */
		statefulFilters?: boolean;
		/** 
		 * Unique identifier for this store. If present, this Store will be registered with the [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html),
		 * making it easy to reuse elsewhere.
		 * 
		 * Note that when a store is instantiated by a Controller, the storeId will default
		 * to the name of the store if not specified in the class.
		 * @configuration
		 * @optional
		 * @type {string}
		 */
		storeId?: string;
		/** 
		 * This config controls whether removed records are remembered by this store for
		 * later saving to the server.
		 * @configuration
		 * @optional
		 * @default true
		 * @type {boolean}
		 */
		trackRemoved?: boolean;
		/** 
		 * Call the original method that was previously overridden with [override](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#static-method-override)
		 * 
		 *    Ext.define('My.Cat', {
		 *        constructor: function() {
		 *            alert("I'm a cat!");
		 *        }
		 *    });
		 *    
		 *    My.Cat.override({
		 *        constructor: function() {
		 *            alert("I'm going to be a cat!");
		 *    
		 *            this.callOverridden();
		 *    
		 *            alert("Meeeeoooowwww");
		 *        }
		 *    });
		 *    
		 *    var kitty = new My.Cat(); // alerts "I'm going to be a cat!"
		 *                              // alerts "I'm a cat!"
		 *                              // alerts "Meeeeoooowwww"
		 * 
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callOverridden(arguments)`
		 * @returns {object}                Returns the result of calling the overridden method
		 */
		callOverridden? (args: any[] | IArguments): object;
		/** 
		 * Call the "parent" method of the current method. That is the method previously
		 * overridden by derivation or by an override (see [Ext.define](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-define)).
		 * 
		 *     Ext.define('My.Base', {
		 *         constructor: function (x) {
		 *             this.x = x;
		 *         },
		 *    
		 *         statics: {
		 *             method: function (x) {
		 *                 return x;
		 *             }
		 *         }
		 *     });
		 *    
		 *     Ext.define('My.Derived', {
		 *         extend: 'My.Base',
		 *    
		 *         constructor: function () {
		 *             this.callParent([21]);
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // alerts 21
		 * 
		 * This can be used with an override as follows:
		 * 
		 *     Ext.define('My.DerivedOverride', {
		 *         override: 'My.Derived',
		 *    
		 *         constructor: function (x) {
		 *             this.callParent([x*2]); // calls original My.Derived constructor
		 *         }
		 *     });
		 *    
		 *     var obj = new My.Derived();
		 *    
		 *     alert(obj.x);  // now alerts 42
		 * 
		 * This also works with static and private methods.
		 * 
		 *     Ext.define('My.Derived2', {
		 *         extend: 'My.Base',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Base.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Base.method(10));     // alerts 10
		 *     alert(My.Derived2.method(10)); // alerts 20
		 * 
		 * Lastly, it also works with overridden static methods.
		 * 
		 *     Ext.define('My.Derived2Override', {
		 *         override: 'My.Derived2',
		 *    
		 *         // privates: {
		 *         statics: {
		 *             method: function (x) {
		 *                 return this.callParent([x*2]); // calls My.Derived2.method
		 *             }
		 *         }
		 *     });
		 *    
		 *     alert(My.Derived2.method(10); // now alerts 40
		 * 
		 * To override a method and replace it and also call the superclass method, use
		 * [callSuper](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callSuper). This is often done to patch a method to fix a bug.
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callParent(arguments)`
		 * @returns {object}                Returns the result of calling the parent method
		 */
		callParent? (args: any[] | IArguments): object;
		/** 
		 * This method is used by an **override** to call the superclass method but
		 * bypass any overridden method. This is often done to "patch" a method that
		 * contains a bug but for whatever reason cannot be fixed directly.
		 * 
		 * Consider:
		 * 
		 *     Ext.define('Ext.some.Class', {
		 *         method: function () {
		 *             console.log('Good');
		 *         }
		 *     });
		 *    
		 *     Ext.define('Ext.some.DerivedClass', {
		 *         extend: 'Ext.some.Class',
		 *    
		 *         method: function () {
		 *             console.log('Bad');
		 *    
		 *             // ... logic but with a bug ...
		 *    
		 *             this.callParent();
		 *         }
		 *     });
		 * 
		 * To patch the bug in `Ext.some.DerivedClass.method`, the typical solution is to create an
		 * override:
		 * 
		 *     Ext.define('App.patches.DerivedClass', {
		 *         override: 'Ext.some.DerivedClass',
		 *    
		 *         method: function () {
		 *             console.log('Fixed');
		 *    
		 *             // ... logic but with bug fixed ...
		 *    
		 *             this.callSuper();
		 *         }
		 *     });
		 * 
		 * The patch method cannot use [callParent](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#method-callParent) to call the superclass
		 * `method` since that would call the overridden method containing the bug. In
		 * other words, the above patch would only produce "Fixed" then "Good" in the
		 * console log, whereas, using `callParent` would produce "Fixed" then "Bad"
		 * then "Good".
		 * @method
		 * @protected (method)
		 * @param   {any[]|IArguments} args
		 * The arguments, either an array or the `arguments` object
		 * from the current method, for example: `this.callSuper(arguments)`
		 * @returns {object}                Returns the result of calling the superclass method
		 */
		callSuper? (args: any[] | IArguments): object;
		/** 
		 * This method is called to cleanup an object and its resources. After calling
		 * this method, the object should not be used any further in any way, including
		 * access to its methods and properties.
		 * 
		 * To prevent potential memory leaks, all object references will be nulled
		 * at the end of destruction sequence, unless [clearPropertiesOnDestroy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-clearPropertiesOnDestroy)
		 * is set to `false`.
		 * @method
		 * @public (method)
		 * @returns {void}  
		 */
		destroy? (): void;
		/** 
		 * Returns a specified config property value. If the name parameter is not passed,
		 * all current configuration options will be returned as key value pairs.
		 * @method
		 * @public (method)
		 * @param   {string}  [name] The name of the config property to get.
		 * @param   {boolean} [peek] `true` to peek at the raw value without calling the getter.
		 * @returns {object}         The config property value.
		 */
		getConfig? (name?: string, peek?: boolean): object;
		/** 
		 * Returns the initial configuration passed to the constructor when
		 * instantiating this class.
		 * 
		 * Given this example Ext.button.Button definition and instance:
		 * 
		 *    Ext.define('MyApp.view.Button', {
		 *        extend: 'Ext.button.Button',
		 *        xtype: 'mybutton',
		 *    
		 *        scale: 'large',
		 *        enableToggle: true
		 *    });
		 *    
		 *    var btn = Ext.create({
		 *        xtype: 'mybutton',
		 *        renderTo: Ext.getBody(),
		 *        text: 'Test Button'
		 *    });
		 * 
		 * Calling `btn.getInitialConfig()` would return an object including the config
		 * options passed to the `create` method:
		 * 
		 *    xtype: 'mybutton',
		 *    renderTo: // The document body itself
		 *    text: 'Test Button'
		 * 
		 * Calling `btn.getInitialConfig('text')`returns **'Test Button'**.
		 * @method
		 * @public (method)
		 * @param   {string}     [name] Name of the config option to return.
		 * @returns {object|any} 
		 * The full config object or a single config value
		 * when `name` parameter specified.
		 */
		getInitialConfig? (name?: string): object | any;
		/** 
		 * Initialize configuration for this class. a typical example:
		 * 
		 *    Ext.define('My.awesome.Class', {
		 *        // The default config
		 *        config: {
		 *            name: 'Awesome',
		 *            isAwesome: true
		 *        },
		 *    
		 *        constructor: function(config) {
		 *            this.initConfig(config);
		 *        }
		 *    });
		 *    
		 *    var awesome = new My.awesome.Class({
		 *        name: 'Super Awesome'
		 *    });
		 *    
		 *    alert(awesome.getName()); // 'Super Awesome'
		 * 
		 * @method
		 * @protected (method)
		 * @chainable
		 * @param   {object}                    config
		 * @returns {Ext.data.XmlStore.Statics}        this
		 */
		initConfig? (config: object): Ext.data.XmlStore.Statics;
		/** 
		 * Sets a single/multiple configuration options.
		 * @method
		 * @public (method)
		 * @chainable
		 * @param   {string|object}             name    The name of the property to set, or a set of key value pairs to set.
		 * @param   {object}                    [value] The value to set for the name parameter.
		 * @returns {Ext.data.XmlStore.Statics}         this
		 */
		setConfig? (name: string | object, value?: object): Ext.data.XmlStore.Statics;
		/** 
		 * Get the reference to the class from which this object was instantiated. Note that unlike [self](https://docs.sencha.com/extjs/6.2.0/modern/Ext.Base.html#property-self),
		 * `this.statics()` is scope-independent and it always returns the class from which it was called, regardless of what
		 * `this` points to during run-time
		 * 
		 *    Ext.define('My.Cat', {
		 *        statics: {
		 *            totalCreated: 0,
		 *            speciesName: 'Cat' // My.Cat.speciesName = 'Cat'
		 *        },
		 *    
		 *        constructor: function() {
		 *            var statics = this.statics();
		 *    
		 *            alert(statics.speciesName);     // always equals to 'Cat' no matter what 'this' refers to
		 *                                            // equivalent to: My.Cat.speciesName
		 *    
		 *            alert(this.self.speciesName);   // dependent on 'this'
		 *    
		 *            statics.totalCreated++;
		 *        },
		 *    
		 *        clone: function() {
		 *            var cloned = new this.self();   // dependent on 'this'
		 *    
		 *            cloned.groupName = this.statics().speciesName;   // equivalent to: My.Cat.speciesName
		 *    
		 *            return cloned;
		 *        }
		 *    });
		 *    
		 *    
		 *    Ext.define('My.SnowLeopard', {
		 *        extend: 'My.Cat',
		 *    
		 *        statics: {
		 *            speciesName: 'Snow Leopard'     // My.SnowLeopard.speciesName = 'Snow Leopard'
		 *        },
		 *    
		 *        constructor: function() {
		 *            this.callParent();
		 *        }
		 *    });
		 *    
		 *    var cat = new My.Cat();                 // alerts 'Cat', then alerts 'Cat'
		 *    
		 *    var snowLeopard = new My.SnowLeopard(); // alerts 'Cat', then alerts 'Snow Leopard'
		 *    
		 *    var clone = snowLeopard.clone();
		 *    alert(Ext.getClassName(clone));         // alerts 'My.SnowLeopard'
		 *    alert(clone.groupName);                 // alerts 'Cat'
		 *    
		 *    alert(My.Cat.totalCreated);             // alerts 3
		 * 
		 * @method
		 * @protected (method)
		 * @returns {Ext.data.XmlStore.Statics}  
		 */
		statics? (): Ext.data.XmlStore.Statics;
	}
}
declare namespace Ext.data.AbstractStore {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.AbstractStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html)
	 * AbstractStore is a superclass of [Ext.data.ProxyStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html) and [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html). It's never used directly,
	 * but offers a set of methods used by both of those subclasses.
	 * 
	 * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
	 * you're probably looking for is [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when a Model instance has been added to this Store.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.data.Model[]} records The records that were added.
		 * @param   {number}           index   The index at which the records were inserted.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		add? (store: Ext.data.Store, records: Ext.data.Model[], index: number, eOpts: object): void;
		/** 
		 * Fires before a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be just before the load operation triggered by changing the
		 * store's sorters.
		 * 
		 * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store}    store   The store being sorted
		 * @param   {Ext.util.Sorter[]} sorters Array of sorters applied to the store
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (store: Ext.data.Store, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fires when the [beginUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beginupdate? (eOpts: object): void;
		/** 
		 * Fired after the [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-removeAll) method is called.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		clear? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires whenever records are added to or removed from the Store.
		 * 
		 * To hook into modifications of records in this Store use the [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-update) event.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		datachanged? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		endupdate? (eOpts: object): void;
		/** 
		 * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
		 * widget that is using this Store as a Record cache should refresh its view.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		refresh? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fired when one or more records have been removed from this Store.
		 * 
		 * **The signature for this event has changed in 5.0: **
		 * @event
		 * @param   {Ext.data.Store}   store   The Store object
		 * @param   {Ext.data.Model[]} records
		 * The records that were removed. In previous
		 * releases this was a single record, not an array.
		 * @param   {number}           index   The index at which the records were removed.
		 * @param   {boolean}          isMove
		 * `true` if the child node is being removed so it can be
		 * moved to another position in this Store.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		remove? (store: Ext.data.Store, records: Ext.data.Model[], index: number, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires after a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be upon the success of a load operation triggered by
		 * changing the store's sorters.
		 * 
		 * For locally sorted stores, this will be just after the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store} store The store being sorted
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		sort? (store: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when a Model instance has been updated.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {Ext.data.Model} record             The Model instance that was updated
		 * @param   {string}         operation
		 * The update operation being performed. Value may be one of:
		 * 
		 *    Ext.data.Model.EDIT
		 *    Ext.data.Model.REJECT
		 *    Ext.data.Model.COMMIT
		 * 
		 * @param   {string[]}       modifiedFieldNames Array of field names changed during edit.
		 * @param   {object}         details
		 * An object describing the change. See the
		 * [itemchange event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#event-itemchange) of the store's backing collection
		 * @param   {object}         eOpts              The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		update? (_this: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string[], details: object, eOpts: object): void;
	}
}
declare namespace Ext.data.ArrayStore {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.ArrayStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from Array data easier. An ArrayStore will be
	 * automatically configured with a [Ext.data.reader.Array](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Array.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = Ext.create('Ext.data.ArrayStore', {
	 *        // store configs
	 *        storeId: 'myStore',
	 *        // reader configs
	 *        fields: [
	 *           'company',
	 *           {name: 'price', type: 'float'},
	 *           {name: 'change', type: 'float'},
	 *           {name: 'pctChange', type: 'float'},
	 *           {name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
	 *        ]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    var myData = [
	 *        ['3m Co',71.72,0.02,0.03,'9/1 12:00am'],
	 *        ['Alcoa Inc',29.01,0.42,1.47,'9/1 12:00am'],
	 *        ['Boeing Co.',75.43,0.53,0.71,'9/1 12:00am'],
	 *        ['Hewlett-Packard Co.',36.53,-0.03,-0.08,'9/1 12:00am'],
	 *        ['Wal-Mart Stores, Inc.',45.45,0.73,1.63,'9/1 12:00am']
	 *    ];
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ArrayStore.html#cfg-data) config option.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when a Model instance has been added to this Store.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.data.Model[]} records The records that were added.
		 * @param   {number}           index   The index at which the records were inserted.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		add? (store: Ext.data.Store, records: Ext.data.Model[], index: number, eOpts: object): void;
		/** 
		 * Fires before a request is made for a new data object. If the beforeload handler returns false the load
		 * action will be canceled.
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that will be passed to the Proxy to
		 * load the Store
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeload? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a prefetch occurs. Return `false` to cancel.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.operation.Operation} operation The associated operation.
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeprefetch? (_this: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be just before the load operation triggered by changing the
		 * store's sorters.
		 * 
		 * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store}    store   The store being sorted
		 * @param   {Ext.util.Sorter[]} sorters Array of sorters applied to the store
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (store: Ext.data.Store, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fired before a call to [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) is executed. Return false from any listener to cancel the sync
		 * @event
		 * @param   {object} options Hash of all records to be synchronized, broken down into create, update and destroy
		 * @param   {object} eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beforesync? (options: object, eOpts: object): void;
		/** 
		 * Fires when the [beginUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beginupdate? (eOpts: object): void;
		/** 
		 * Fired after the [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-removeAll) method is called.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		clear? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires whenever records are added to or removed from the Store.
		 * 
		 * To hook into modifications of records in this Store use the [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-update) event.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		datachanged? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		endupdate? (eOpts: object): void;
		/** 
		 * Fired whenever the filter set changes.
		 * @event
		 * @param   {Ext.data.Store}    store   The store.
		 * @param   {Ext.util.Filter[]} filters The array of Filter objects.
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		filterchange? (store: Ext.data.Store, filters: Ext.util.Filter[], eOpts: object): void;
		/** 
		 * Fired whenever the grouping in the grid changes.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.util.Grouper} grouper The grouper object.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		groupchange? (store: Ext.data.Store, grouper: Ext.util.Grouper, eOpts: object): void;
		/** 
		 * Fires whenever the store reads data from a remote data source.
		 * @event
		 * @param   {Ext.data.Store}          _this
		 * @param   {Ext.data.Model[]}        records    An array of records
		 * @param   {boolean}                 successful True if the operation was successful.
		 * @param   {Ext.data.operation.Read} operation
		 * The
		 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) object that was used in the data
		 * load call
		 * @param   {object}                  eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                    
		 */
		load? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Read, eOpts: object): void;
		/** 
		 * Fires when this store's underlying reader (available via the proxy) provides new metadata.
		 * Metadata usually consists of new field definitions, but can include any configuration data
		 * required by an application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         meta  The JSON metadata
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		metachange? (_this: Ext.data.Store, meta: object, eOpts: object): void;
		/** 
		 * Fires whenever records have been prefetched.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.Model[]}             records    An array of records.
		 * @param   {boolean}                      successful `true` if the operation was successful.
		 * @param   {Ext.data.operation.Operation} operation  The associated operation.
		 * @param   {object}                       eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		prefetch? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
		 * widget that is using this Store as a Record cache should refresh its view.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		refresh? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fired when one or more records have been removed from this Store.
		 * 
		 * **The signature for this event has changed in 5.0: **
		 * @event
		 * @param   {Ext.data.Store}   store   The Store object
		 * @param   {Ext.data.Model[]} records
		 * The records that were removed. In previous
		 * releases this was a single record, not an array.
		 * @param   {number}           index   The index at which the records were removed.
		 * @param   {boolean}          isMove
		 * `true` if the child node is being removed so it can be
		 * moved to another position in this Store.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		remove? (store: Ext.data.Store, records: Ext.data.Model[], index: number, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires after a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be upon the success of a load operation triggered by
		 * changing the store's sorters.
		 * 
		 * For locally sorted stores, this will be just after the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store} store The store being sorted
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		sort? (store: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when a Model instance has been updated.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {Ext.data.Model} record             The Model instance that was updated
		 * @param   {string}         operation
		 * The update operation being performed. Value may be one of:
		 * 
		 *    Ext.data.Model.EDIT
		 *    Ext.data.Model.REJECT
		 *    Ext.data.Model.COMMIT
		 * 
		 * @param   {string[]}       modifiedFieldNames Array of field names changed during edit.
		 * @param   {object}         details
		 * An object describing the change. See the
		 * [itemchange event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#event-itemchange) of the store's backing collection
		 * @param   {object}         eOpts              The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		update? (_this: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string[], details: object, eOpts: object): void;
		/** 
		 * Fires whenever a successful write has been made via the configured [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that was used in
		 * the write
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		write? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
	}
}
declare namespace Ext.data.Batch {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.Batch](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html)
	 * Provides a mechanism to run one or more [operations](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html)
	 * in a given order. Fires the `operationcomplete` event after the completion of each
	 * Operation, and the `complete` event when all Operations have been successfully executed.
	 * Fires an `exception` event if any of the Operations encounter an exception.
	 * 
	 * Usually these are only used internally by [Ext.data.proxy.Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) classes.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when all operations of this batch have been completed
		 * @event
		 * @param   {Ext.data.Batch} batch     The batch object
		 * @param   {object}         operation The last operation that was executed
		 * @param   {object}         eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		complete? (batch: Ext.data.Batch, operation: object, eOpts: object): void;
		/** 
		 * Fired when a operation encountered an exception
		 * @event
		 * @param   {Ext.data.Batch} batch     The batch object
		 * @param   {object}         operation The operation that encountered the exception
		 * @param   {object}         eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		exception? (batch: Ext.data.Batch, operation: object, eOpts: object): void;
		/** 
		 * Fired when each operation of the batch completes
		 * @event
		 * @param   {Ext.data.Batch} batch     The batch object
		 * @param   {object}         operation The operation that just completed
		 * @param   {object}         eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		operationcomplete? (batch: Ext.data.Batch, operation: object, eOpts: object): void;
	}
}
declare namespace Ext.data.BufferedStore {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html)
	 * A BufferedStore maintains a sparsely populated map of pages corresponding to an extremely large server-side dataset.
	 * 
	 * Use a BufferedStore when the dataset size is so large that the database and network latency, and client memory requirements
	 * preclude caching the entire dataset in a regular [Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html).
	 * 
	 * When using a BufferedStore _not all of the dataset is present in the client_. Only pages which have been
	 * requested by the UI (usually a GridPanel) and surrounding pages will be present. Retention
	 * of viewed pages in the BufferedStore after they have been scrolled out of view is configurable. See [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone),
	 * [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone) and [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount).
	 * 
	 * To use a BufferedStore, initiate the loading process by loading the first page. The number of rows rendered are
	 * determined automatically, and the range of pages needed to keep the cache primed for scrolling is
	 * requested and cached.
	 * Example:
	 * 
	 *    myBufferedStore.loadPage(1); // Load page 1
	 * 
	 * A BufferedRenderer is instantiated which will monitor the scrolling in the grid, and
	 * refresh the view's rows from the page cache as needed. It will also pull new data into the page
	 * cache when scrolling of the view draws upon data near either end of the prefetched data.
	 * 
	 * The margins which trigger view refreshing from the prefetched data are Ext.grid.plugin.BufferedRenderer.numFromEdge,
	 * Ext.grid.plugin.BufferedRenderer.leadingBufferZone and Ext.grid.plugin.BufferedRenderer.trailingBufferZone.
	 * 
	 * The margins which trigger loading more data into the page cache are, [leadingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-leadingBufferZone) and
	 * [trailingBufferZone](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-trailingBufferZone).
	 * 
	 * By default, only 5 pages of data (in addition to the pages which over the visible region) are cached in the page cache,
	 * with old pages being evicted from the cache as the view moves down through the dataset. This is controlled by the
	 * [purgePageCount](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html#cfg-purgePageCount) setting.
	 * 
	 * Setting this value to zero means that no pages are _ever_ scrolled out of the page cache, and
	 * that eventually the whole dataset may become present in the page cache. This is sometimes desirable
	 * as long as datasets do not reach astronomical proportions.
	 * 
	 * Selection state may be maintained across page boundaries by configuring the SelectionModel not to discard
	 * records from its collection when those Records cycle out of the Store's primary collection. This is done
	 * by configuring the SelectionModel like this:
	 * 
	 *    selModel: {
	 *        pruneRemoved: false
	 *    }
	 * 
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when a Model instance has been added to this Store.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.data.Model[]} records The records that were added.
		 * @param   {number}           index   The index at which the records were inserted.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		add? (store: Ext.data.Store, records: Ext.data.Model[], index: number, eOpts: object): void;
		/** 
		 * Fires before a request is made for a new data object. If the beforeload handler returns false the load
		 * action will be canceled.
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that will be passed to the Proxy to
		 * load the Store
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeload? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be just before the load operation triggered by changing the
		 * store's sorters.
		 * 
		 * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store}    store   The store being sorted
		 * @param   {Ext.util.Sorter[]} sorters Array of sorters applied to the store
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (store: Ext.data.Store, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fired before a call to [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) is executed. Return false from any listener to cancel the sync
		 * @event
		 * @param   {object} options Hash of all records to be synchronized, broken down into create, update and destroy
		 * @param   {object} eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beforesync? (options: object, eOpts: object): void;
		/** 
		 * Fires when the [beginUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beginupdate? (eOpts: object): void;
		/** 
		 * Fired after the [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-removeAll) method is called.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		clear? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires whenever records are added to or removed from the Store.
		 * 
		 * To hook into modifications of records in this Store use the [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-update) event.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		datachanged? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		endupdate? (eOpts: object): void;
		/** 
		 * Fires whenever the store reads data from a remote data source.
		 * @event
		 * @param   {Ext.data.Store}          _this
		 * @param   {Ext.data.Model[]}        records    An array of records
		 * @param   {boolean}                 successful True if the operation was successful.
		 * @param   {Ext.data.operation.Read} operation
		 * The
		 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) object that was used in the data
		 * load call
		 * @param   {object}                  eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                    
		 */
		load? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Read, eOpts: object): void;
		/** 
		 * Fires when this store's underlying reader (available via the proxy) provides new metadata.
		 * Metadata usually consists of new field definitions, but can include any configuration data
		 * required by an application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         meta  The JSON metadata
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		metachange? (_this: Ext.data.Store, meta: object, eOpts: object): void;
		/** 
		 * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
		 * widget that is using this Store as a Record cache should refresh its view.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		refresh? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fired when one or more records have been removed from this Store.
		 * 
		 * **The signature for this event has changed in 5.0: **
		 * @event
		 * @param   {Ext.data.Store}   store   The Store object
		 * @param   {Ext.data.Model[]} records
		 * The records that were removed. In previous
		 * releases this was a single record, not an array.
		 * @param   {number}           index   The index at which the records were removed.
		 * @param   {boolean}          isMove
		 * `true` if the child node is being removed so it can be
		 * moved to another position in this Store.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		remove? (store: Ext.data.Store, records: Ext.data.Model[], index: number, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires after a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be upon the success of a load operation triggered by
		 * changing the store's sorters.
		 * 
		 * For locally sorted stores, this will be just after the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store} store The store being sorted
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		sort? (store: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when a Model instance has been updated.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {Ext.data.Model} record             The Model instance that was updated
		 * @param   {string}         operation
		 * The update operation being performed. Value may be one of:
		 * 
		 *    Ext.data.Model.EDIT
		 *    Ext.data.Model.REJECT
		 *    Ext.data.Model.COMMIT
		 * 
		 * @param   {string[]}       modifiedFieldNames Array of field names changed during edit.
		 * @param   {object}         details
		 * An object describing the change. See the
		 * [itemchange event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#event-itemchange) of the store's backing collection
		 * @param   {object}         eOpts              The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		update? (_this: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string[], details: object, eOpts: object): void;
		/** 
		 * Fires whenever a successful write has been made via the configured [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that was used in
		 * the write
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		write? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
	}
}
declare namespace Ext.data.Connection {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.Connection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html)
	 * The Connection class encapsulates a connection to the page's originating domain, allowing requests to be made either
	 * to a configured URL, or to a URL specified at request time.
	 * 
	 * Requests made by this class are asynchronous, and will return immediately. No data from the server will be available
	 * to the statement immediately following the [request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-request) call. To process returned data, use a success callback
	 * in the request options object, or an [event listener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#event-requestcomplete).
	 * 
	 * # File Uploads
	 * 
	 * File uploads are not performed using normal "Ajax" techniques, that is they are not performed using XMLHttpRequests.
	 * Instead the form is submitted in the standard manner with the DOM &lt;form&gt; element temporarily modified to have its
	 * target set to refer to a dynamically generated, hidden &lt;iframe&gt; which is inserted into the document but removed
	 * after the return data has been gathered.
	 * 
	 * The server response is parsed by the browser to create the document for the IFRAME. If the server is using JSON to
	 * send the return object, then the Content-Type header must be set to "text/html" in order to tell the browser to
	 * insert the text unchanged into the document body.
	 * 
	 * Characters which are significant to an HTML parser must be sent as HTML entities, so encode `&lt;` as `&amp;lt;`, `&amp;` as
	 * `&amp;amp;` etc.
	 * 
	 * The response text is retrieved from the document, and a fake XMLHttpRequest object is created containing a
	 * responseText property in order to conform to the requirements of event handlers and callbacks.
	 * 
	 * Be aware that file upload packets are sent with the content type multipart/form and some server technologies
	 * (notably JEE) may require some custom processing in order to retrieve parameter names and parameter values from the
	 * packet content.
	 * 
	 * Also note that it's not possible to check the response code of the hidden iframe, so the success handler will ALWAYS fire.
	 * 
	 * # Binary Posts
	 * 
	 * The class supports posting binary data to the server by using native browser capabilities, or a flash polyfill plugin in browsers that do not support native binary posting (e.g. Internet Explorer version 9 or less). A number of limitations exist when the polyfill is used:
	 * 
	 * - Only asynchronous connections are supported.
	 * - Only the POST method can be used.
	 * - The return data can only be binary for now. Set the [binary](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#cfg-binary) parameter to <tt>true</tt>.
	 * - Only the 0, 1 and 4 (complete) readyState values will be reported to listeners.
	 * - The flash object will be injected at the bottom of the document and should be invisible.
	 * - Important: See note about packaing the flash plugin with the app in the documenetation of [BinaryXhr](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.flash.BinaryXhr.html).
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires before a network request is made to retrieve a data object.
		 * @event
		 * @param   {Ext.data.Connection} conn    This Connection object.
		 * @param   {object}              options The options config object passed to the [request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-request) method.
		 * @param   {object}              eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                
		 */
		beforerequest? (conn: Ext.data.Connection, options: object, eOpts: object): void;
		/** 
		 * Fires if the request was successfully completed.
		 * @event
		 * @param   {Ext.data.Connection} conn     This Connection object.
		 * @param   {object}              response
		 * The XHR object containing the response data.
		 * See [The XMLHttpRequest Object](http://www.w3.org/TR/XMLHttpRequest/) for details.
		 * @param   {object}              options  The options config object passed to the [request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-request) method.
		 * @param   {object}              eOpts    The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                
		 */
		requestcomplete? (conn: Ext.data.Connection, response: object, options: object, eOpts: object): void;
		/** 
		 * Fires if an error HTTP status was returned from the server. This event may also
		 * be listened to in the event that a request has timed out or has been aborted.
		 * See [HTTP Status Code Definitions](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)
		 * for details of HTTP status codes.
		 * @event
		 * @param   {Ext.data.Connection} conn     This Connection object.
		 * @param   {object}              response
		 * The XHR object containing the response data.
		 * See [The XMLHttpRequest Object](http://www.w3.org/TR/XMLHttpRequest/) for details.
		 * @param   {object}              options  The options config object passed to the [request](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Connection.html#method-request) method.
		 * @param   {object}              eOpts    The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                
		 */
		requestexception? (conn: Ext.data.Connection, response: object, options: object, eOpts: object): void;
	}
}
declare namespace Ext.data.DirectStore {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.DirectStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.DirectStore.html)
	 * Small helper class to create an [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) configured with an [Ext.data.proxy.Direct](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html)
	 * and [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) to make interacting with an [Ext.direct.Manager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.direct.Manager.html) server-side
	 * [Provider](https://docs.sencha.com/extjs/6.2.0/modern/Ext.direct.Provider.html) easier. To create a different proxy/reader combination create a basic
	 * [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) configured as needed.
	 * 
	 * **Note:** Although they are not listed, this class inherits all of the config options of:
	 * 
	 * - **[Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)**
	 * - **[JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html)**
	 *   <ul>
	 *   <li>**[rootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html#cfg-rootProperty)**
	 * - **[totalProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html#cfg-totalProperty)**
	 * 
	 * </li>
	 * <li>
	 * 
	 * **[DirectProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html)**
	 * 
	 * - **[directFn](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-directFn)**
	 * - **[paramOrder](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-paramOrder)**
	 * - **[paramsAsHash](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Direct.html#cfg-paramsAsHash)**
	 * 
	 * </li>
	 * </ul>
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when a Model instance has been added to this Store.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.data.Model[]} records The records that were added.
		 * @param   {number}           index   The index at which the records were inserted.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		add? (store: Ext.data.Store, records: Ext.data.Model[], index: number, eOpts: object): void;
		/** 
		 * Fires before a request is made for a new data object. If the beforeload handler returns false the load
		 * action will be canceled.
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that will be passed to the Proxy to
		 * load the Store
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeload? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a prefetch occurs. Return `false` to cancel.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.operation.Operation} operation The associated operation.
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeprefetch? (_this: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be just before the load operation triggered by changing the
		 * store's sorters.
		 * 
		 * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store}    store   The store being sorted
		 * @param   {Ext.util.Sorter[]} sorters Array of sorters applied to the store
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (store: Ext.data.Store, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fired before a call to [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) is executed. Return false from any listener to cancel the sync
		 * @event
		 * @param   {object} options Hash of all records to be synchronized, broken down into create, update and destroy
		 * @param   {object} eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beforesync? (options: object, eOpts: object): void;
		/** 
		 * Fires when the [beginUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beginupdate? (eOpts: object): void;
		/** 
		 * Fired after the [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-removeAll) method is called.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		clear? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires whenever records are added to or removed from the Store.
		 * 
		 * To hook into modifications of records in this Store use the [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-update) event.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		datachanged? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		endupdate? (eOpts: object): void;
		/** 
		 * Fired whenever the filter set changes.
		 * @event
		 * @param   {Ext.data.Store}    store   The store.
		 * @param   {Ext.util.Filter[]} filters The array of Filter objects.
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		filterchange? (store: Ext.data.Store, filters: Ext.util.Filter[], eOpts: object): void;
		/** 
		 * Fired whenever the grouping in the grid changes.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.util.Grouper} grouper The grouper object.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		groupchange? (store: Ext.data.Store, grouper: Ext.util.Grouper, eOpts: object): void;
		/** 
		 * Fires whenever the store reads data from a remote data source.
		 * @event
		 * @param   {Ext.data.Store}          _this
		 * @param   {Ext.data.Model[]}        records    An array of records
		 * @param   {boolean}                 successful True if the operation was successful.
		 * @param   {Ext.data.operation.Read} operation
		 * The
		 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) object that was used in the data
		 * load call
		 * @param   {object}                  eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                    
		 */
		load? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Read, eOpts: object): void;
		/** 
		 * Fires when this store's underlying reader (available via the proxy) provides new metadata.
		 * Metadata usually consists of new field definitions, but can include any configuration data
		 * required by an application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         meta  The JSON metadata
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		metachange? (_this: Ext.data.Store, meta: object, eOpts: object): void;
		/** 
		 * Fires whenever records have been prefetched.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.Model[]}             records    An array of records.
		 * @param   {boolean}                      successful `true` if the operation was successful.
		 * @param   {Ext.data.operation.Operation} operation  The associated operation.
		 * @param   {object}                       eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		prefetch? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
		 * widget that is using this Store as a Record cache should refresh its view.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		refresh? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fired when one or more records have been removed from this Store.
		 * 
		 * **The signature for this event has changed in 5.0: **
		 * @event
		 * @param   {Ext.data.Store}   store   The Store object
		 * @param   {Ext.data.Model[]} records
		 * The records that were removed. In previous
		 * releases this was a single record, not an array.
		 * @param   {number}           index   The index at which the records were removed.
		 * @param   {boolean}          isMove
		 * `true` if the child node is being removed so it can be
		 * moved to another position in this Store.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		remove? (store: Ext.data.Store, records: Ext.data.Model[], index: number, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires after a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be upon the success of a load operation triggered by
		 * changing the store's sorters.
		 * 
		 * For locally sorted stores, this will be just after the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store} store The store being sorted
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		sort? (store: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when a Model instance has been updated.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {Ext.data.Model} record             The Model instance that was updated
		 * @param   {string}         operation
		 * The update operation being performed. Value may be one of:
		 * 
		 *    Ext.data.Model.EDIT
		 *    Ext.data.Model.REJECT
		 *    Ext.data.Model.COMMIT
		 * 
		 * @param   {string[]}       modifiedFieldNames Array of field names changed during edit.
		 * @param   {object}         details
		 * An object describing the change. See the
		 * [itemchange event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#event-itemchange) of the store's backing collection
		 * @param   {object}         eOpts              The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		update? (_this: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string[], details: object, eOpts: object): void;
		/** 
		 * Fires whenever a successful write has been made via the configured [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that was used in
		 * the write
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		write? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
	}
}
declare namespace Ext.data.ErrorCollection {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.ErrorCollection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ErrorCollection.html)
	 * Wraps a collection of validation error responses and provides convenient functions for
	 * accessing and errors for specific fields.
	 * 
	 * Usually this class does not need to be instantiated directly - instances are instead
	 * created automatically when [validate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-validate) on a model instance:
	 * 
	 *     // Validate some existing model instance - in this case it returned 2 failures
	 *     // messages
	 *    
	 *     var errors = myModel.validate();
	 *     errors.isValid(); //false
	 *    
	 *     errors.length; //2
	 *     errors.getByField('name');  // [{field: 'name',  message: 'must be present'}]
	 *     errors.getByField('title'); // [{field: 'title', message: 'is too short'}]
	 * 
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when an item is added to the collection.
		 * @event
		 * @param   {number} index The index at which the item was added.
		 * @param   {object} o     The item added.
		 * @param   {string} key   The key associated with the added item.
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		add? (index: number, o: object, key: string, eOpts: object): void;
		/** 
		 * Fires before a sort occurs.
		 * @event
		 * @param   {Ext.util.Sortable} me      This object.
		 * @param   {Ext.util.Sorter[]} sorters The collection of Sorters being used to generate the comparator function.
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (me: Ext.util.Sortable, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fires when the collection is cleared.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		clear? (eOpts: object): void;
		/** 
		 * Fires when an item is removed from the collection.
		 * @event
		 * @param   {object} o     The item being removed.
		 * @param   {string} key   The key associated with the removed item.
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		remove? (o: object, key: string, eOpts: object): void;
		/** 
		 * Fires when an item is replaced in the collection.
		 * @event
		 * @param   {string} key   he key associated with the new added.
		 * @param   {object} old   The item being replaced.
		 * @param   {object} _new  The new item.
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		replace? (key: string, old: object, _new: object, eOpts: object): void;
	}
}
declare namespace Ext.data.ChainedStore {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.ChainedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html)
	 * A chained store is a store that is a "view" of an existing store. The data comes from the
	 * [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source), however this view of the store may be sorted &amp; filtered independently without
	 * having any impact on the [source](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ChainedStore.html#cfg-source) store.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when a Model instance has been added to this Store.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.data.Model[]} records The records that were added.
		 * @param   {number}           index   The index at which the records were inserted.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		add? (store: Ext.data.Store, records: Ext.data.Model[], index: number, eOpts: object): void;
		/** 
		 * Fires before a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be just before the load operation triggered by changing the
		 * store's sorters.
		 * 
		 * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store}    store   The store being sorted
		 * @param   {Ext.util.Sorter[]} sorters Array of sorters applied to the store
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (store: Ext.data.Store, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fires when the [beginUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beginupdate? (eOpts: object): void;
		/** 
		 * Fired after the [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-removeAll) method is called.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		clear? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires whenever records are added to or removed from the Store.
		 * 
		 * To hook into modifications of records in this Store use the [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-update) event.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		datachanged? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		endupdate? (eOpts: object): void;
		/** 
		 * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
		 * widget that is using this Store as a Record cache should refresh its view.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		refresh? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fired when one or more records have been removed from this Store.
		 * 
		 * **The signature for this event has changed in 5.0: **
		 * @event
		 * @param   {Ext.data.Store}   store   The Store object
		 * @param   {Ext.data.Model[]} records
		 * The records that were removed. In previous
		 * releases this was a single record, not an array.
		 * @param   {number}           index   The index at which the records were removed.
		 * @param   {boolean}          isMove
		 * `true` if the child node is being removed so it can be
		 * moved to another position in this Store.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		remove? (store: Ext.data.Store, records: Ext.data.Model[], index: number, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires after a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be upon the success of a load operation triggered by
		 * changing the store's sorters.
		 * 
		 * For locally sorted stores, this will be just after the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store} store The store being sorted
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		sort? (store: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when a Model instance has been updated.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {Ext.data.Model} record             The Model instance that was updated
		 * @param   {string}         operation
		 * The update operation being performed. Value may be one of:
		 * 
		 *    Ext.data.Model.EDIT
		 *    Ext.data.Model.REJECT
		 *    Ext.data.Model.COMMIT
		 * 
		 * @param   {string[]}       modifiedFieldNames Array of field names changed during edit.
		 * @param   {object}         details
		 * An object describing the change. See the
		 * [itemchange event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#event-itemchange) of the store's backing collection
		 * @param   {object}         eOpts              The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		update? (_this: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string[], details: object, eOpts: object): void;
	}
}
declare namespace Ext.data.JsonPStore {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.JsonPStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from different domain JSON data easier.
	 * A JsonPStore will be automatically configured with a [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) and a [JsonPProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.JsonP.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.JsonPStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *    
	 *        // proxy configs
	 *        url: 'get-images.php',
	 *    
	 *        // reader configs
	 *        root: 'images',
	 *        fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    stcCallback({
	 *        images: [
	 *            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
	 *            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
	 *        ]
	 *    })
	 * 
	 * Where stcCallback is the callback name passed in the request to the remote domain. See [JsonPProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.JsonP.html)
	 * for details of how this works.
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonPStore.html#cfg-data) config option.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when a Model instance has been added to this Store.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.data.Model[]} records The records that were added.
		 * @param   {number}           index   The index at which the records were inserted.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		add? (store: Ext.data.Store, records: Ext.data.Model[], index: number, eOpts: object): void;
		/** 
		 * Fires before a request is made for a new data object. If the beforeload handler returns false the load
		 * action will be canceled.
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that will be passed to the Proxy to
		 * load the Store
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeload? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a prefetch occurs. Return `false` to cancel.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.operation.Operation} operation The associated operation.
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeprefetch? (_this: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be just before the load operation triggered by changing the
		 * store's sorters.
		 * 
		 * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store}    store   The store being sorted
		 * @param   {Ext.util.Sorter[]} sorters Array of sorters applied to the store
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (store: Ext.data.Store, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fired before a call to [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) is executed. Return false from any listener to cancel the sync
		 * @event
		 * @param   {object} options Hash of all records to be synchronized, broken down into create, update and destroy
		 * @param   {object} eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beforesync? (options: object, eOpts: object): void;
		/** 
		 * Fires when the [beginUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beginupdate? (eOpts: object): void;
		/** 
		 * Fired after the [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-removeAll) method is called.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		clear? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires whenever records are added to or removed from the Store.
		 * 
		 * To hook into modifications of records in this Store use the [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-update) event.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		datachanged? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		endupdate? (eOpts: object): void;
		/** 
		 * Fired whenever the filter set changes.
		 * @event
		 * @param   {Ext.data.Store}    store   The store.
		 * @param   {Ext.util.Filter[]} filters The array of Filter objects.
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		filterchange? (store: Ext.data.Store, filters: Ext.util.Filter[], eOpts: object): void;
		/** 
		 * Fired whenever the grouping in the grid changes.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.util.Grouper} grouper The grouper object.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		groupchange? (store: Ext.data.Store, grouper: Ext.util.Grouper, eOpts: object): void;
		/** 
		 * Fires whenever the store reads data from a remote data source.
		 * @event
		 * @param   {Ext.data.Store}          _this
		 * @param   {Ext.data.Model[]}        records    An array of records
		 * @param   {boolean}                 successful True if the operation was successful.
		 * @param   {Ext.data.operation.Read} operation
		 * The
		 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) object that was used in the data
		 * load call
		 * @param   {object}                  eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                    
		 */
		load? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Read, eOpts: object): void;
		/** 
		 * Fires when this store's underlying reader (available via the proxy) provides new metadata.
		 * Metadata usually consists of new field definitions, but can include any configuration data
		 * required by an application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         meta  The JSON metadata
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		metachange? (_this: Ext.data.Store, meta: object, eOpts: object): void;
		/** 
		 * Fires whenever records have been prefetched.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.Model[]}             records    An array of records.
		 * @param   {boolean}                      successful `true` if the operation was successful.
		 * @param   {Ext.data.operation.Operation} operation  The associated operation.
		 * @param   {object}                       eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		prefetch? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
		 * widget that is using this Store as a Record cache should refresh its view.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		refresh? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fired when one or more records have been removed from this Store.
		 * 
		 * **The signature for this event has changed in 5.0: **
		 * @event
		 * @param   {Ext.data.Store}   store   The Store object
		 * @param   {Ext.data.Model[]} records
		 * The records that were removed. In previous
		 * releases this was a single record, not an array.
		 * @param   {number}           index   The index at which the records were removed.
		 * @param   {boolean}          isMove
		 * `true` if the child node is being removed so it can be
		 * moved to another position in this Store.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		remove? (store: Ext.data.Store, records: Ext.data.Model[], index: number, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires after a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be upon the success of a load operation triggered by
		 * changing the store's sorters.
		 * 
		 * For locally sorted stores, this will be just after the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store} store The store being sorted
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		sort? (store: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when a Model instance has been updated.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {Ext.data.Model} record             The Model instance that was updated
		 * @param   {string}         operation
		 * The update operation being performed. Value may be one of:
		 * 
		 *    Ext.data.Model.EDIT
		 *    Ext.data.Model.REJECT
		 *    Ext.data.Model.COMMIT
		 * 
		 * @param   {string[]}       modifiedFieldNames Array of field names changed during edit.
		 * @param   {object}         details
		 * An object describing the change. See the
		 * [itemchange event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#event-itemchange) of the store's backing collection
		 * @param   {object}         eOpts              The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		update? (_this: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string[], details: object, eOpts: object): void;
		/** 
		 * Fires whenever a successful write has been made via the configured [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that was used in
		 * the write
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		write? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
	}
}
declare namespace Ext.data.JsonStore {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.JsonStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from JSON data easier.
	 * A JsonStore will be automatically configured with a [Ext.data.reader.Json](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.JsonStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *    
	 *        proxy: {
	 *            type: 'ajax',
	 *            url: 'get-images.php',
	 *            reader: {
	 *                type: 'json',
	 *                rootProperty: 'images'
	 *            }
	 *        },
	 *    
	 *        //alternatively, a Model name can be given (see Ext.data.Store for an example)
	 *        fields: ['name', 'url', {name:'size', type: 'float'}, {name:'lastmod', type:'date'}]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    {
	 *        images: [
	 *            {name: 'Image one', url:'/GetImage.php?id=1', size:46.5, lastmod: new Date(2007, 10, 29)},
	 *            {name: 'Image Two', url:'/GetImage.php?id=2', size:43.2, lastmod: new Date(2007, 10, 30)}
	 *        ]
	 *    }
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.JsonStore.html#cfg-data) config option.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when a Model instance has been added to this Store.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.data.Model[]} records The records that were added.
		 * @param   {number}           index   The index at which the records were inserted.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		add? (store: Ext.data.Store, records: Ext.data.Model[], index: number, eOpts: object): void;
		/** 
		 * Fires before a request is made for a new data object. If the beforeload handler returns false the load
		 * action will be canceled.
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that will be passed to the Proxy to
		 * load the Store
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeload? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a prefetch occurs. Return `false` to cancel.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.operation.Operation} operation The associated operation.
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeprefetch? (_this: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be just before the load operation triggered by changing the
		 * store's sorters.
		 * 
		 * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store}    store   The store being sorted
		 * @param   {Ext.util.Sorter[]} sorters Array of sorters applied to the store
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (store: Ext.data.Store, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fired before a call to [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) is executed. Return false from any listener to cancel the sync
		 * @event
		 * @param   {object} options Hash of all records to be synchronized, broken down into create, update and destroy
		 * @param   {object} eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beforesync? (options: object, eOpts: object): void;
		/** 
		 * Fires when the [beginUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beginupdate? (eOpts: object): void;
		/** 
		 * Fired after the [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-removeAll) method is called.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		clear? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires whenever records are added to or removed from the Store.
		 * 
		 * To hook into modifications of records in this Store use the [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-update) event.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		datachanged? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		endupdate? (eOpts: object): void;
		/** 
		 * Fired whenever the filter set changes.
		 * @event
		 * @param   {Ext.data.Store}    store   The store.
		 * @param   {Ext.util.Filter[]} filters The array of Filter objects.
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		filterchange? (store: Ext.data.Store, filters: Ext.util.Filter[], eOpts: object): void;
		/** 
		 * Fired whenever the grouping in the grid changes.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.util.Grouper} grouper The grouper object.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		groupchange? (store: Ext.data.Store, grouper: Ext.util.Grouper, eOpts: object): void;
		/** 
		 * Fires whenever the store reads data from a remote data source.
		 * @event
		 * @param   {Ext.data.Store}          _this
		 * @param   {Ext.data.Model[]}        records    An array of records
		 * @param   {boolean}                 successful True if the operation was successful.
		 * @param   {Ext.data.operation.Read} operation
		 * The
		 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) object that was used in the data
		 * load call
		 * @param   {object}                  eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                    
		 */
		load? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Read, eOpts: object): void;
		/** 
		 * Fires when this store's underlying reader (available via the proxy) provides new metadata.
		 * Metadata usually consists of new field definitions, but can include any configuration data
		 * required by an application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         meta  The JSON metadata
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		metachange? (_this: Ext.data.Store, meta: object, eOpts: object): void;
		/** 
		 * Fires whenever records have been prefetched.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.Model[]}             records    An array of records.
		 * @param   {boolean}                      successful `true` if the operation was successful.
		 * @param   {Ext.data.operation.Operation} operation  The associated operation.
		 * @param   {object}                       eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		prefetch? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
		 * widget that is using this Store as a Record cache should refresh its view.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		refresh? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fired when one or more records have been removed from this Store.
		 * 
		 * **The signature for this event has changed in 5.0: **
		 * @event
		 * @param   {Ext.data.Store}   store   The Store object
		 * @param   {Ext.data.Model[]} records
		 * The records that were removed. In previous
		 * releases this was a single record, not an array.
		 * @param   {number}           index   The index at which the records were removed.
		 * @param   {boolean}          isMove
		 * `true` if the child node is being removed so it can be
		 * moved to another position in this Store.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		remove? (store: Ext.data.Store, records: Ext.data.Model[], index: number, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires after a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be upon the success of a load operation triggered by
		 * changing the store's sorters.
		 * 
		 * For locally sorted stores, this will be just after the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store} store The store being sorted
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		sort? (store: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when a Model instance has been updated.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {Ext.data.Model} record             The Model instance that was updated
		 * @param   {string}         operation
		 * The update operation being performed. Value may be one of:
		 * 
		 *    Ext.data.Model.EDIT
		 *    Ext.data.Model.REJECT
		 *    Ext.data.Model.COMMIT
		 * 
		 * @param   {string[]}       modifiedFieldNames Array of field names changed during edit.
		 * @param   {object}         details
		 * An object describing the change. See the
		 * [itemchange event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#event-itemchange) of the store's backing collection
		 * @param   {object}         eOpts              The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		update? (_this: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string[], details: object, eOpts: object): void;
		/** 
		 * Fires whenever a successful write has been made via the configured [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that was used in
		 * the write
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		write? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
	}
}
declare namespace Ext.data.NodeInterface {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.NodeInterface](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html)
	 * This class is used as a set of methods that are applied to the prototype of a
	 * [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) to decorate it with a Node API. This means that models
	 * used in conjunction with a tree will have all of the tree related methods available
	 * on the model. In general, this class will not be used directly by the developer.
	 * 
	 * This class also creates extra [fields](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.field.Field.html) on the model, if they do
	 * not exist, to help maintain the tree state and UI. These fields are documented as
	 * config options.
	 * 
	 * The data fields used to render a tree node are: [text](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-text), [leaf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-leaf),
	 * [children](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-children), and [expanded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-expanded).  Once a node is loaded to the tree store
	 * you can use [get()](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-get) to fetch the value of a given field
	 * name (provided there is not a convenience accessor on the Node for that field).
	 * 
	 *    Ext.tip.QuickTipManager.init(); // not required when using Ext.application()
	 *    
	 *    var root = {
	 *        expanded: true,
	 *        children: [{
	 *            text: "Leaf node (&lt;i&gt;no folder/arrow icon&lt;/i&gt;)",
	 *            leaf: true,
	 *            qtitle: 'Sample Tip Title',
	 *            qtip: 'Tip body'
	 *        }, {
	 *            text: "Parent node expanded",
	 *            expanded: true,
	 *            children: [{
	 *                text: "Expanded leaf node 1",
	 *                leaf: true
	 *            }, {
	 *                text: "Expanded leaf node 2",
	 *                leaf: true
	 *            }]
	 *        }, {
	 *            text: "Parent node collapsed",
	 *            children: [{
	 *                text: "Collapsed leaf node 1",
	 *                leaf: true
	 *            }, {
	 *                text: "Collapsed leaf node 2",
	 *                leaf: true
	 *            }]
	 *        }]
	 *    };
	 *    
	 *    var tree = Ext.create('Ext.tree.Panel', {
	 *        title: 'TreePanel',
	 *        width: 260,
	 *        height: 200,
	 *        root: root,
	 *        rootVisible: false,
	 *        renderTo: document.body,
	 *        bbar: ['The first node ', {
	 *            text: 'is a leaf?',
	 *            handler: function () {
	 *                var firstChild = tree.getRootNode().getChildAt(0);
	 *                Ext.Msg.alert('Is Leaf?', firstChild.isLeaf());
	 *            }
	 *        }, {
	 *            text: 'has text?',
	 *            handler: function () {
	 *                var firstChild = tree.getRootNode().getChildAt(0);
	 *                Ext.Msg.alert('Has Text:', firstChild.get('text'));
	 *            }
	 *        }]
	 *    });
	 * 
	 * The following configs have methods used to set the value / state of the node at
	 * runtime:
	 * 
	 * **[children](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-children) / [leaf](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-leaf)**
	 * 
	 * - [appendChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-appendChild)
	 * - [hasChildNodes](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-hasChildNodes)
	 * - [insertBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertBefore)
	 * - [insertChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertChild)
	 * - [remove](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-remove)
	 * - [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-removeAll)
	 * - [removeChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-removeChild)
	 * - [replaceChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-replaceChild)
	 * 
	 * **[expanded](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-expanded)**
	 * 
	 * - [expand](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-expand)
	 * - [expandChildren](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-expandChildren)
	 * - [collapse](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-collapse)
	 * - [collapseChildren](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-collapseChildren)
	 * 
	 * The remaining configs may be set using [set()](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#method-set).
	 * 
	 *    node.set('text', 'Changed Text'); // example showing how to change the node label
	 * 
	 * The [qtip](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtip), [qtitle](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qtitle), and [qshowDelay](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#cfg-qshowDelay) use QuickTips and
	 * requires initializing Ext.tip.QuickTipManager unless the application is
	 * created using [Ext.application](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-application).
	 * 
	 *    Ext.tip.QuickTipManager.init();
	 * 
	 * For additional information and examples see the description for
	 * Ext.tree.Panel.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when a new child node is appended
		 * @event
		 * @param   {Ext.data.NodeInterface} _this This node
		 * @param   {Ext.data.NodeInterface} node  The newly appended node
		 * @param   {number}                 index The index of the newly appended node
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		append? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, index: number, eOpts: object): void;
		/** 
		 * Fires before a new child is appended, return false to cancel the append.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this This node
		 * @param   {Ext.data.NodeInterface} node  The child node to be appended
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		beforeappend? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires before this node is collapsed.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this The collapsing node
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		beforecollapse? (_this: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires before this node is expanded.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this The expanding node
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		beforeexpand? (_this: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires before a new child is inserted, return false to cancel the insert.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this   This node
		 * @param   {Ext.data.NodeInterface} node    The child node to be inserted
		 * @param   {Ext.data.NodeInterface} refNode The child node the node is being inserted before
		 * @param   {object}                 eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		beforeinsert? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, refNode: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires before this node is moved to a new location in the tree. Return false to cancel the move.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this     This node
		 * @param   {Ext.data.NodeInterface} oldParent The parent of this node
		 * @param   {Ext.data.NodeInterface} newParent The new parent this node is moving to
		 * @param   {number}                 index     The index it is being moved to
		 * @param   {object}                 eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		beforemove? (_this: Ext.data.NodeInterface, oldParent: Ext.data.NodeInterface, newParent: Ext.data.NodeInterface, index: number, eOpts: object): void;
		/** 
		 * Fires before a child is removed, return false to cancel the remove.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this  This node
		 * @param   {Ext.data.NodeInterface} node   The child node to be removed
		 * @param   {boolean}                isMove
		 * `true` if the child node is being removed so it can be moved to another position in the tree.
		 * (a side effect of calling [appendChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-appendChild) or
		 * [insertBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertBefore) with a node that already has a parentNode)
		 * @param   {object}                 eOpts  The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		beforeremove? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires when this node is collapsed.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this The collapsing node
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		collapse? (_this: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires when this node is expanded.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this The expanding node
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		expand? (_this: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires when a new child node is inserted.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this   This node
		 * @param   {Ext.data.NodeInterface} node    The child node inserted
		 * @param   {Ext.data.NodeInterface} refNode The child node the node was inserted before
		 * @param   {object}                 eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		insert? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, refNode: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires when this node is moved to a new location in the tree
		 * @event
		 * @param   {Ext.data.NodeInterface} _this     This node
		 * @param   {Ext.data.NodeInterface} oldParent The old parent of this node
		 * @param   {Ext.data.NodeInterface} newParent The new parent of this node
		 * @param   {number}                 index     The index it was moved to
		 * @param   {object}                 eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		move? (_this: Ext.data.NodeInterface, oldParent: Ext.data.NodeInterface, newParent: Ext.data.NodeInterface, index: number, eOpts: object): void;
		/** 
		 * Fires when a child node is removed
		 * @event
		 * @param   {Ext.data.NodeInterface}                                    _this   This node
		 * @param   {Ext.data.NodeInterface}                                    node    The removed node
		 * @param   {boolean}                                                   isMove  `true` if the child node is being removed so it can be moved to another position in the tree.
		 * @param   {object|Ext.data.NodeInterface.eventsParams.remove.Context} context An object providing information about where the removed node came from. It contains the following properties:
		 * @param   {object}                                                    eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                                                      
		 */
		remove? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, isMove: boolean, context: object | Ext.data.NodeInterface.eventsParams.remove.Context, eOpts: object): void;
		/** 
		 * Fires when this node's childNodes are sorted.
		 * @event
		 * @param   {Ext.data.NodeInterface}   _this      This node.
		 * @param   {Ext.data.NodeInterface[]} childNodes The childNodes of this node.
		 * @param   {object}                   eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                     
		 */
		sort? (_this: Ext.data.NodeInterface, childNodes: Ext.data.NodeInterface[], eOpts: object): void;
	}
}
declare namespace Ext.data.ProxyStore {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.ProxyStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html)
	 * ProxyStore is a superclass of [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) and [Ext.data.BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html). It's never used directly,
	 * but offers a set of methods used by both of those subclasses.
	 * 
	 * We've left it here in the docs for reference purposes, but unless you need to make a whole new type of Store, what
	 * you're probably looking for is [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html). If you're still interested, here's a brief description of what
	 * ProxyStore is and is not.
	 * 
	 * ProxyStore provides the basic configuration for anything that can be considered a Store. It expects to be
	 * given a [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) that represents the type of data in the Store. It also expects to be given a
	 * [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) that handles the loading of data into the Store.
	 * 
	 * ProxyStore provides a few helpful methods such as [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-load) and [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync), which load and save data
	 * respectively, passing the requests through the configured [proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy).
	 * 
	 * Built-in Store subclasses add extra behavior to each of these functions. Note also that each ProxyStore subclass
	 * has its own way of storing data - in [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) the data is saved as a flat [Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html),
	 * whereas in [BufferedStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.BufferedStore.html) we use a [Ext.data.PageMap](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.PageMap.html) to maintain a client side cache of pages of records.
	 * 
	 * The store provides filtering and sorting support. This sorting/filtering can happen on the client side
	 * or can be completed on the server. This is controlled by the [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) and
	 * [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteFilter) config options. For more information see the [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sort) and
	 * [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) methods.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when a Model instance has been added to this Store.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.data.Model[]} records The records that were added.
		 * @param   {number}           index   The index at which the records were inserted.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		add? (store: Ext.data.Store, records: Ext.data.Model[], index: number, eOpts: object): void;
		/** 
		 * Fires before a request is made for a new data object. If the beforeload handler returns false the load
		 * action will be canceled.
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that will be passed to the Proxy to
		 * load the Store
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeload? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be just before the load operation triggered by changing the
		 * store's sorters.
		 * 
		 * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store}    store   The store being sorted
		 * @param   {Ext.util.Sorter[]} sorters Array of sorters applied to the store
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (store: Ext.data.Store, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fired before a call to [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) is executed. Return false from any listener to cancel the sync
		 * @event
		 * @param   {object} options Hash of all records to be synchronized, broken down into create, update and destroy
		 * @param   {object} eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beforesync? (options: object, eOpts: object): void;
		/** 
		 * Fires when the [beginUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beginupdate? (eOpts: object): void;
		/** 
		 * Fired after the [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-removeAll) method is called.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		clear? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires whenever records are added to or removed from the Store.
		 * 
		 * To hook into modifications of records in this Store use the [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-update) event.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		datachanged? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		endupdate? (eOpts: object): void;
		/** 
		 * Fires whenever the store reads data from a remote data source.
		 * @event
		 * @param   {Ext.data.Store}          _this
		 * @param   {Ext.data.Model[]}        records    An array of records
		 * @param   {boolean}                 successful True if the operation was successful.
		 * @param   {Ext.data.operation.Read} operation
		 * The
		 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) object that was used in the data
		 * load call
		 * @param   {object}                  eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                    
		 */
		load? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Read, eOpts: object): void;
		/** 
		 * Fires when this store's underlying reader (available via the proxy) provides new metadata.
		 * Metadata usually consists of new field definitions, but can include any configuration data
		 * required by an application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         meta  The JSON metadata
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		metachange? (_this: Ext.data.Store, meta: object, eOpts: object): void;
		/** 
		 * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
		 * widget that is using this Store as a Record cache should refresh its view.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		refresh? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fired when one or more records have been removed from this Store.
		 * 
		 * **The signature for this event has changed in 5.0: **
		 * @event
		 * @param   {Ext.data.Store}   store   The Store object
		 * @param   {Ext.data.Model[]} records
		 * The records that were removed. In previous
		 * releases this was a single record, not an array.
		 * @param   {number}           index   The index at which the records were removed.
		 * @param   {boolean}          isMove
		 * `true` if the child node is being removed so it can be
		 * moved to another position in this Store.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		remove? (store: Ext.data.Store, records: Ext.data.Model[], index: number, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires after a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be upon the success of a load operation triggered by
		 * changing the store's sorters.
		 * 
		 * For locally sorted stores, this will be just after the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store} store The store being sorted
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		sort? (store: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when a Model instance has been updated.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {Ext.data.Model} record             The Model instance that was updated
		 * @param   {string}         operation
		 * The update operation being performed. Value may be one of:
		 * 
		 *    Ext.data.Model.EDIT
		 *    Ext.data.Model.REJECT
		 *    Ext.data.Model.COMMIT
		 * 
		 * @param   {string[]}       modifiedFieldNames Array of field names changed during edit.
		 * @param   {object}         details
		 * An object describing the change. See the
		 * [itemchange event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#event-itemchange) of the store's backing collection
		 * @param   {object}         eOpts              The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		update? (_this: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string[], details: object, eOpts: object): void;
		/** 
		 * Fires whenever a successful write has been made via the configured [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that was used in
		 * the write
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		write? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
	}
}
declare namespace Ext.data.Session {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.Session](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Session.html)
	 * This class manages models and their associations. Instances of `Session` are typically
	 * associated with some `Component` (perhaps the Viewport or a Window) and then used by
	 * their [`view models`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.app.ViewModel.html) to enable data binding.
	 * 
	 * The primary job of a Session is to manage a collection of records of many different
	 * types and their associations. This often starts by loading records when requested (via
	 * bind - see below) and culminates when it is time to save to the server.
	 * 
	 * Because the Session tracks all records it loads, it ensures that for any given type of
	 * model, only one record exists with a given `id`. This means that all edits of that
	 * record are properly targeted at that one instance.
	 * 
	 * Similarly, when associations are loaded, the [`Ext.data.Store`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html) created to hold the
	 * associated records is tracked by the Session. So all requests for the "OrderItems" of
	 * a particular Order id will result in the same Store. Adding and removing items from
	 * that Order then is sure to remain consistent.
	 * 
	 * # Data
	 * 
	 * Since the Session is managing all this data, there are several methods it provides
	 * to give convenient access to that data. The most important of these is `update` and
	 * `getChanges`.
	 * 
	 * The `update` and `getChanges` methods both operate on object that contains a summary
	 * of records and associations and different CRUD operations.
	 * 
	 * ## Saving
	 * 
	 * There are two basic ways to save the contents of a Session: `getChanges` and
	 * `getSaveBatch`. We've already seen `getChanges`. The data contained in the CRUD object
	 * can be translated into whatever shape is needed by the server.
	 * 
	 * To leverage the [`proxy`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html#cfg-proxy) facilities defined by each Model
	 * class, there is the `getSaveBatch` method. That method returns an [`Ext.data.Batch`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Batch.html)
	 * object populated with the necessary `create`, `update` and `destory` operations to
	 * save all of the changes in the Session.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when a change in the object's [dirty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Dirty.html#cfg-dirty) state is detected.
		 * 
		 * **Note:** In order for this event to fire, the class that mixes in this mixin
		 * must be [`Observable`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.mixin.Observable.html).
		 * @event
		 * @param   {Ext.Base} _this
		 * @param   {boolean}  dirty Whether or not the object is now dirty.
		 * @param   {object}   eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}     
		 */
		dirtychange? (_this: Ext.Base, dirty: boolean, eOpts: object): void;
	}
}
declare namespace Ext.data.Store {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)
	 * The Store class encapsulates a client side cache of [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) objects. Stores load data via a
	 * [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html), and also provide functions for [sorting](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort), [filtering](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter)
	 * and querying the [model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) instances contained within it.
	 * 
	 * Creating a Store is easy - we just tell it the Model and the Proxy to use for loading and saving its data:
	 * 
	 *     // Set up a model to use in our Store
	 *     Ext.define('User', {
	 *         extend: 'Ext.data.Model',
	 *         fields: [
	 *             {name: 'firstName', type: 'string'},
	 *             {name: 'lastName',  type: 'string'},
	 *             {name: 'age',       type: 'int'},
	 *             {name: 'eyeColor',  type: 'string'}
	 *         ]
	 *     });
	 *    
	 *     var myStore = Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         proxy: {
	 *             type: 'ajax',
	 *             url: '/users.json',
	 *             reader: {
	 *                 type: 'json',
	 *                 rootProperty: 'users'
	 *             }
	 *         },
	 *         autoLoad: true
	 *     });
	 * 
	 * In the example above we configured an AJAX proxy to load data from the url '/users.json'. We told our Proxy to use a
	 * [JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) to parse the response from the server into Model object - [see the docs on JsonReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Json.html) for details.
	 * 
	 * ## Inline data
	 * 
	 * Stores can also load data inline. Internally, Store converts each of the objects we pass in as [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-data) into
	 * Model instances:
	 * 
	 *     Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         data : [
	 *             {firstName: 'Peter',   lastName: 'Venkman'},
	 *             {firstName: 'Egon',    lastName: 'Spengler'},
	 *             {firstName: 'Ray',     lastName: 'Stantz'},
	 *             {firstName: 'Winston', lastName: 'Zeddemore'}
	 *         ]
	 *     });
	 * 
	 * Loading inline data using the method above is great if the data is in the correct format already (e.g. it doesn't
	 * need to be processed by a [reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html)). If your inline data requires processing to decode
	 * the data structure, use a [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) instead (see the [MemoryProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Memory.html) docs for an example).
	 * 
	 * Additional data can also be loaded locally using [add](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-add).
	 * 
	 * ## Dynamic Loading
	 * 
	 * Stores can be dynamically updated by calling the [load](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-load) method:
	 * 
	 *    store.load({
	 *        params: {
	 *            group: 3,
	 *            type: 'user'
	 *        },
	 *        callback: function(records, operation, success) {
	 *            // do something after the load finishes
	 *        },
	 *        scope: this
	 *    });
	 * 
	 * Here a bunch of arbitrary parameters is passed along with the load request and a callback function is set
	 * up to do something after the loading is over.
	 * 
	 * ## Loading Nested Data
	 * 
	 * Applications often need to load sets of associated data - for example a CRM system might load a User and her Orders.
	 * Instead of issuing an AJAX request for the User and a series of additional AJAX requests for each Order, we can load
	 * a nested dataset and allow the Reader to automatically populate the associated models. Below is a brief example, see
	 * the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) intro docs for a full explanation:
	 * 
	 *     var store = Ext.create('Ext.data.Store', {
	 *         autoLoad: true,
	 *         model: "User",
	 *         proxy: {
	 *             type: 'ajax',
	 *             url: 'users.json',
	 *             reader: {
	 *                 type: 'json',
	 *                 rootProperty: 'users'
	 *             }
	 *         }
	 *     });
	 * 
	 * Which would consume a response like this:
	 * 
	 *     {
	 *         "users": [{
	 *             "id": 1,
	 *             "name": "Peter",
	 *             "orders": [{
	 *                 "id": 10,
	 *                 "total": 10.76,
	 *                 "status": "invoiced"
	 *            },{
	 *                 "id": 11,
	 *                 "total": 13.45,
	 *                 "status": "shipped"
	 *            }]
	 *         }]
	 *     }
	 * 
	 * See the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) intro docs for a full explanation.
	 * 
	 * ## Filtering and Sorting
	 * 
	 * Stores can be sorted and filtered - in both cases either remotely or locally. The [sorters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-sorters) and
	 * [filters](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-filters) are held inside [Collection](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html) instances to make them easy to manage.
	 * Usually it is sufficient to either just specify sorters and filters in the Store configuration or call [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort)
	 * or [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter):
	 * 
	 *     var store = Ext.create('Ext.data.Store', {
	 *         model: 'User',
	 *         sorters: [{
	 *             property: 'age',
	 *             direction: 'DESC'
	 *         }, {
	 *             property: 'firstName',
	 *             direction: 'ASC'
	 *         }],
	 *    
	 *         filters: [{
	 *             property: 'firstName',
	 *             value: /Peter/
	 *         }]
	 *     });
	 * 
	 * The new Store will keep the configured sorters and filters in the Collection instances mentioned above. By
	 * default, sorting and filtering are both performed locally by the Store - see [remoteSort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteSort) and
	 * [remoteFilter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-remoteFilter) to allow the server to perform these operations instead.
	 * 
	 * Filtering and sorting after the Store has been instantiated is also easy. Calling [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) adds another filter
	 * to the Store and automatically filters the dataset (calling [filter](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-filter) with no arguments simply re-applies all
	 * existing filters).
	 * 
	 *    store.filter('eyeColor', 'Brown');
	 * 
	 * Change the sorting at any time by calling [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort):
	 * 
	 *    store.sort('height', 'ASC');
	 * 
	 * Note that all existing sorters will be removed in favor of the new sorter data (if [sort](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-sort) is called with no
	 * arguments, the existing sorters are just reapplied instead of being removed). To keep existing sorters and add new
	 * ones, just add them to the Collection:
	 * 
	 *    store.sorters.add(new Ext.util.Sorter({
	 *        property : 'shoeSize',
	 *        direction: 'ASC'
	 *    }));
	 *    
	 *    store.sort();
	 * 
	 * ## Registering with StoreManager
	 * 
	 * Any Store that is instantiated with a [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#cfg-storeId) will automatically be registered with the [StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html). This makes it easy to reuse the same store in multiple views:
	 * 
	 *    //this store can be used several times
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'User',
	 *        storeId: 'usersStore'
	 *    });
	 *    
	 *    new Ext.List({
	 *        store: 'usersStore',
	 *        //other config goes here
	 *    });
	 *    
	 *    new Ext.view.View({
	 *        store: 'usersStore',
	 *        //other config goes here
	 *    });
	 * 
	 * ## Further Reading
	 * 
	 * Stores are backed up by an ecosystem of classes that enables their operation. To gain a full understanding of these
	 * pieces and how they fit together, see:
	 * 
	 * - [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Proxy.html) - overview of what Proxies are and how they are used
	 * - [Model](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Model.html) - the core class in the data package
	 * - [Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) - used by any subclass of [ServerProxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.proxy.Server.html) to read a response
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when a Model instance has been added to this Store.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.data.Model[]} records The records that were added.
		 * @param   {number}           index   The index at which the records were inserted.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		add? (store: Ext.data.Store, records: Ext.data.Model[], index: number, eOpts: object): void;
		/** 
		 * Fires before a request is made for a new data object. If the beforeload handler returns false the load
		 * action will be canceled.
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that will be passed to the Proxy to
		 * load the Store
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeload? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a prefetch occurs. Return `false` to cancel.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.operation.Operation} operation The associated operation.
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeprefetch? (_this: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be just before the load operation triggered by changing the
		 * store's sorters.
		 * 
		 * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store}    store   The store being sorted
		 * @param   {Ext.util.Sorter[]} sorters Array of sorters applied to the store
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (store: Ext.data.Store, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fired before a call to [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) is executed. Return false from any listener to cancel the sync
		 * @event
		 * @param   {object} options Hash of all records to be synchronized, broken down into create, update and destroy
		 * @param   {object} eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beforesync? (options: object, eOpts: object): void;
		/** 
		 * Fires when the [beginUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beginupdate? (eOpts: object): void;
		/** 
		 * Fired after the [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-removeAll) method is called.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		clear? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires whenever records are added to or removed from the Store.
		 * 
		 * To hook into modifications of records in this Store use the [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-update) event.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		datachanged? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		endupdate? (eOpts: object): void;
		/** 
		 * Fired whenever the filter set changes.
		 * @event
		 * @param   {Ext.data.Store}    store   The store.
		 * @param   {Ext.util.Filter[]} filters The array of Filter objects.
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		filterchange? (store: Ext.data.Store, filters: Ext.util.Filter[], eOpts: object): void;
		/** 
		 * Fired whenever the grouping in the grid changes.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.util.Grouper} grouper The grouper object.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		groupchange? (store: Ext.data.Store, grouper: Ext.util.Grouper, eOpts: object): void;
		/** 
		 * Fires whenever the store reads data from a remote data source.
		 * @event
		 * @param   {Ext.data.Store}          _this
		 * @param   {Ext.data.Model[]}        records    An array of records
		 * @param   {boolean}                 successful True if the operation was successful.
		 * @param   {Ext.data.operation.Read} operation
		 * The
		 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) object that was used in the data
		 * load call
		 * @param   {object}                  eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                    
		 */
		load? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Read, eOpts: object): void;
		/** 
		 * Fires when this store's underlying reader (available via the proxy) provides new metadata.
		 * Metadata usually consists of new field definitions, but can include any configuration data
		 * required by an application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         meta  The JSON metadata
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		metachange? (_this: Ext.data.Store, meta: object, eOpts: object): void;
		/** 
		 * Fires whenever records have been prefetched.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.Model[]}             records    An array of records.
		 * @param   {boolean}                      successful `true` if the operation was successful.
		 * @param   {Ext.data.operation.Operation} operation  The associated operation.
		 * @param   {object}                       eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		prefetch? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
		 * widget that is using this Store as a Record cache should refresh its view.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		refresh? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fired when one or more records have been removed from this Store.
		 * 
		 * **The signature for this event has changed in 5.0: **
		 * @event
		 * @param   {Ext.data.Store}   store   The Store object
		 * @param   {Ext.data.Model[]} records
		 * The records that were removed. In previous
		 * releases this was a single record, not an array.
		 * @param   {number}           index   The index at which the records were removed.
		 * @param   {boolean}          isMove
		 * `true` if the child node is being removed so it can be
		 * moved to another position in this Store.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		remove? (store: Ext.data.Store, records: Ext.data.Model[], index: number, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires after a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be upon the success of a load operation triggered by
		 * changing the store's sorters.
		 * 
		 * For locally sorted stores, this will be just after the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store} store The store being sorted
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		sort? (store: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when a Model instance has been updated.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {Ext.data.Model} record             The Model instance that was updated
		 * @param   {string}         operation
		 * The update operation being performed. Value may be one of:
		 * 
		 *    Ext.data.Model.EDIT
		 *    Ext.data.Model.REJECT
		 *    Ext.data.Model.COMMIT
		 * 
		 * @param   {string[]}       modifiedFieldNames Array of field names changed during edit.
		 * @param   {object}         details
		 * An object describing the change. See the
		 * [itemchange event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#event-itemchange) of the store's backing collection
		 * @param   {object}         eOpts              The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		update? (_this: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string[], details: object, eOpts: object): void;
		/** 
		 * Fires whenever a successful write has been made via the configured [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that was used in
		 * the write
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		write? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
	}
}
declare namespace Ext.data.StoreManager {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.StoreManager](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html)
	 * Contains a collection of all stores that are created that have an identifier. An identifier can be assigned by
	 * setting the [storeId](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-storeId) property. When a store is in the StoreManager, it can be
	 * referred to via it's identifier:
	 * 
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'SomeModel',
	 *        storeId: 'myStore'
	 *    });
	 *    
	 *    var store = Ext.data.StoreManager.lookup('myStore');
	 * 
	 * Also note that the [lookup](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.StoreManager.html#method-lookup) method is aliased to [Ext.getStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.html#method-getStore) for convenience.
	 * 
	 * If a store is registered with the StoreManager, you can also refer to the store by it's identifier when registering
	 * it with any Component that consumes data from a store:
	 * 
	 *    Ext.create('Ext.data.Store', {
	 *        model: 'SomeModel',
	 *        storeId: 'myStore'
	 *    });
	 *    
	 *    Ext.create('Ext.view.View', {
	 *        store: 'myStore',
	 *        // other configuration here
	 *    });
	 * 
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fires when an item is added to the collection.
		 * @event
		 * @param   {number} index The index at which the item was added.
		 * @param   {object} o     The item added.
		 * @param   {string} key   The key associated with the added item.
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		add? (index: number, o: object, key: string, eOpts: object): void;
		/** 
		 * Fires before a sort occurs.
		 * @event
		 * @param   {Ext.util.Sortable} me      This object.
		 * @param   {Ext.util.Sorter[]} sorters The collection of Sorters being used to generate the comparator function.
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (me: Ext.util.Sortable, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fires when the collection is cleared.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		clear? (eOpts: object): void;
		/** 
		 * Fires when an item is removed from the collection.
		 * @event
		 * @param   {object} o     The item being removed.
		 * @param   {string} key   The key associated with the removed item.
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		remove? (o: object, key: string, eOpts: object): void;
		/** 
		 * Fires when an item is replaced in the collection.
		 * @event
		 * @param   {string} key   he key associated with the new added.
		 * @param   {object} old   The item being replaced.
		 * @param   {object} _new  The new item.
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		replace? (key: string, old: object, _new: object, eOpts: object): void;
	}
}
declare namespace Ext.data.TreeStore {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.TreeStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html)
	 * The TreeStore is a store implementation that owns the [root node](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-root) of
	 * a tree, and provides methods to load either local or remote data as child nodes of the root
	 * and any descendant non-leaf node.
	 * 
	 * The TreeStore must be used as the store of a tree panel.
	 * 
	 * This class also relays many node events from the underlying node structure.
	 * 
	 * # Using Models
	 * 
	 * If no Model is specified, an implicit model will be created that extends [Ext.data.TreeModel](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeModel.html).
	 * The standard Tree fields will also be copied onto the Model for maintaining their state. These fields are listed
	 * in the [Ext.data.NodeInterface](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html) documentation.
	 * 
	 * # Reading Nested Data
	 * 
	 * For the tree to read nested data, the [Ext.data.reader.Reader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html) must be configured with a root property,
	 * so the reader can find nested data for each node (if a root is not specified, it will default to
	 * 'children'). This will tell the tree to look for any nested tree nodes by the same keyword, i.e., 'children'.
	 * If a root is specified in the config make sure that any nested nodes with children have the same name.
	 * 
	 * **Note:** Setting [defaultRootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-defaultRootProperty) accomplishes the same thing.
	 * 
	 * # rootProperty as a Function
	 * 
	 * You can pass a function as the data reader's rootProperty when the tree's dataset has
	 * mixed root properties. Child nodes can then be programmatically determined at read time.
	 * 
	 * For example, the child nodes may be passed via the 'children' property
	 * name, though you may have a top-level root property of 'items'.
	 * 
	 * See [rootProperty](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Reader.html#cfg-rootProperty) for more information.
	 * 
	 * # Filtering
	 * 
	 * Filtering of nodes in a TreeStore is hierarchically top down by default. This means that if a non-leaf node does not
	 * pass the filter, then it, and all its descendants are filtered _out_ of the store.
	 * 
	 * To reverse this, so that any node which passes the filter causes all its ancestors to be visible, configure
	 * the `TreeStore` with '[filterer: 'bottomup'`](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#cfg-filterer)
	 * 
	 * You may also programatically filter individual tree nodes by setting their `'visible'` field.
	 * 
	 * Setting this to `false` filters the node out so that it will not appear in the UI. Setting it to `true`
	 * filters the node in.
	 * 
	 * Note that if performing several filter operations, it is best to [suspendEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-suspendEvents)
	 * on the store first, and when all nodes have been modified, [resumeEvents](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#method-resumeEvents) and fire the
	 * [refresh](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.TreeStore.html#event-refresh) event on the store.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when a Model instance has been added to this Store.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.data.Model[]} records The records that were added.
		 * @param   {number}           index   The index at which the records were inserted.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		add? (store: Ext.data.Store, records: Ext.data.Model[], index: number, eOpts: object): void;
		/** 
		 * Fires before a request is made for a new data object. If the beforeload handler returns false the load
		 * action will be canceled.
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that will be passed to the Proxy to
		 * load the Store
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeload? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a prefetch occurs. Return `false` to cancel.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.operation.Operation} operation The associated operation.
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeprefetch? (_this: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be just before the load operation triggered by changing the
		 * store's sorters.
		 * 
		 * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store}    store   The store being sorted
		 * @param   {Ext.util.Sorter[]} sorters Array of sorters applied to the store
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (store: Ext.data.Store, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fired before a call to [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) is executed. Return false from any listener to cancel the sync
		 * @event
		 * @param   {object} options Hash of all records to be synchronized, broken down into create, update and destroy
		 * @param   {object} eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beforesync? (options: object, eOpts: object): void;
		/** 
		 * Fires when the [beginUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beginupdate? (eOpts: object): void;
		/** 
		 * Fired after the [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-removeAll) method is called.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		clear? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires whenever records are added to or removed from the Store.
		 * 
		 * To hook into modifications of records in this Store use the [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-update) event.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		datachanged? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		endupdate? (eOpts: object): void;
		/** 
		 * Fired whenever the filter set changes.
		 * @event
		 * @param   {Ext.data.Store}    store   The store.
		 * @param   {Ext.util.Filter[]} filters The array of Filter objects.
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		filterchange? (store: Ext.data.Store, filters: Ext.util.Filter[], eOpts: object): void;
		/** 
		 * Fired whenever the grouping in the grid changes.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.util.Grouper} grouper The grouper object.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		groupchange? (store: Ext.data.Store, grouper: Ext.util.Grouper, eOpts: object): void;
		/** 
		 * Fires whenever the store reads data from a remote data source.
		 * @event
		 * @param   {Ext.data.TreeStore}     _this
		 * @param   {Ext.data.TreeModel[]}   records    An array of records.
		 * @param   {boolean}                successful True if the operation was successful.
		 * @param   {Ext.data.Operation}     operation  The operation that triggered this load.
		 * @param   {Ext.data.NodeInterface} node       The node that was loaded.
		 * @param   {object}                 eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		load? (_this: Ext.data.TreeStore, records: Ext.data.TreeModel[], successful: boolean, operation: Ext.data.Operation, node: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires when this store's underlying reader (available via the proxy) provides new metadata.
		 * Metadata usually consists of new field definitions, but can include any configuration data
		 * required by an application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         meta  The JSON metadata
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		metachange? (_this: Ext.data.Store, meta: object, eOpts: object): void;
		/** 
		 * Fires when a new child node is appended
		 * @event
		 * @param   {Ext.data.NodeInterface} _this This node
		 * @param   {Ext.data.NodeInterface} node  The newly appended node
		 * @param   {number}                 index The index of the newly appended node
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		nodeappend? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, index: number, eOpts: object): void;
		/** 
		 * Fires before a new child is appended, return false to cancel the append.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this This node
		 * @param   {Ext.data.NodeInterface} node  The child node to be appended
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		nodebeforeappend? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires before this node is collapsed.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this The collapsing node
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		nodebeforecollapse? (_this: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires before this node is expanded.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this The expanding node
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		nodebeforeexpand? (_this: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires before a new child is inserted, return false to cancel the insert.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this   This node
		 * @param   {Ext.data.NodeInterface} node    The child node to be inserted
		 * @param   {Ext.data.NodeInterface} refNode The child node the node is being inserted before
		 * @param   {object}                 eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		nodebeforeinsert? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, refNode: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires before this node is moved to a new location in the tree. Return false to cancel the move.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this     This node
		 * @param   {Ext.data.NodeInterface} oldParent The parent of this node
		 * @param   {Ext.data.NodeInterface} newParent The new parent this node is moving to
		 * @param   {number}                 index     The index it is being moved to
		 * @param   {object}                 eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		nodebeforemove? (_this: Ext.data.NodeInterface, oldParent: Ext.data.NodeInterface, newParent: Ext.data.NodeInterface, index: number, eOpts: object): void;
		/** 
		 * Fires before a child is removed, return false to cancel the remove.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this  This node
		 * @param   {Ext.data.NodeInterface} node   The child node to be removed
		 * @param   {boolean}                isMove
		 * `true` if the child node is being removed so it can be moved to another position in the tree.
		 * (a side effect of calling [appendChild](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-appendChild) or
		 * [insertBefore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.NodeInterface.html#method-insertBefore) with a node that already has a parentNode)
		 * @param   {object}                 eOpts  The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		nodebeforeremove? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires when this node is collapsed.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this The collapsing node
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		nodecollapse? (_this: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires when this node is expanded.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this The expanding node
		 * @param   {object}                 eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		nodeexpand? (_this: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires when a new child node is inserted.
		 * @event
		 * @param   {Ext.data.NodeInterface} _this   This node
		 * @param   {Ext.data.NodeInterface} node    The child node inserted
		 * @param   {Ext.data.NodeInterface} refNode The child node the node was inserted before
		 * @param   {object}                 eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		nodeinsert? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, refNode: Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires when this node is moved to a new location in the tree
		 * @event
		 * @param   {Ext.data.NodeInterface} _this     This node
		 * @param   {Ext.data.NodeInterface} oldParent The old parent of this node
		 * @param   {Ext.data.NodeInterface} newParent The new parent of this node
		 * @param   {number}                 index     The index it was moved to
		 * @param   {object}                 eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                   
		 */
		nodemove? (_this: Ext.data.NodeInterface, oldParent: Ext.data.NodeInterface, newParent: Ext.data.NodeInterface, index: number, eOpts: object): void;
		/** 
		 * Fires when a child node is removed
		 * @event
		 * @param   {Ext.data.NodeInterface}                                    _this   This node
		 * @param   {Ext.data.NodeInterface}                                    node    The removed node
		 * @param   {boolean}                                                   isMove  `true` if the child node is being removed so it can be moved to another position in the tree.
		 * @param   {object|Ext.data.TreeStore.eventsParams.noderemove.Context} context An object providing information about where the removed node came from. It contains the following properties:
		 * @param   {object}                                                    eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                                                      
		 */
		noderemove? (_this: Ext.data.NodeInterface, node: Ext.data.NodeInterface, isMove: boolean, context: object | Ext.data.TreeStore.eventsParams.noderemove.Context, eOpts: object): void;
		/** 
		 * Fires when this node's childNodes are sorted.
		 * @event
		 * @param   {Ext.data.NodeInterface}   _this      This node.
		 * @param   {Ext.data.NodeInterface[]} childNodes The childNodes of this node.
		 * @param   {object}                   eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                     
		 */
		nodesort? (_this: Ext.data.NodeInterface, childNodes: Ext.data.NodeInterface[], eOpts: object): void;
		/** 
		 * Fires whenever records have been prefetched.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.Model[]}             records    An array of records.
		 * @param   {boolean}                      successful `true` if the operation was successful.
		 * @param   {Ext.data.operation.Operation} operation  The associated operation.
		 * @param   {object}                       eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		prefetch? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
		 * widget that is using this Store as a Record cache should refresh its view.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		refresh? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fired when one or more records have been removed from this Store.
		 * 
		 * **The signature for this event has changed in 5.0: **
		 * @event
		 * @param   {Ext.data.Store}   store   The Store object
		 * @param   {Ext.data.Model[]} records
		 * The records that were removed. In previous
		 * releases this was a single record, not an array.
		 * @param   {number}           index   The index at which the records were removed.
		 * @param   {boolean}          isMove
		 * `true` if the child node is being removed so it can be
		 * moved to another position in this Store.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		remove? (store: Ext.data.Store, records: Ext.data.Model[], index: number, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires any time the tree's root node changes.
		 * @event
		 * @param   {Ext.data.TreeModel|Ext.data.NodeInterface} newRoot The new root
		 * @param   {Ext.data.TreeModel|Ext.data.NodeInterface} oldRoot The old root
		 * @param   {object}                                    eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                                      
		 */
		rootchange? (newRoot: Ext.data.TreeModel | Ext.data.NodeInterface, oldRoot: Ext.data.TreeModel | Ext.data.NodeInterface, eOpts: object): void;
		/** 
		 * Fires after a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be upon the success of a load operation triggered by
		 * changing the store's sorters.
		 * 
		 * For locally sorted stores, this will be just after the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store} store The store being sorted
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		sort? (store: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when a Model instance has been updated.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {Ext.data.Model} record             The Model instance that was updated
		 * @param   {string}         operation
		 * The update operation being performed. Value may be one of:
		 * 
		 *    Ext.data.Model.EDIT
		 *    Ext.data.Model.REJECT
		 *    Ext.data.Model.COMMIT
		 * 
		 * @param   {string[]}       modifiedFieldNames Array of field names changed during edit.
		 * @param   {object}         details
		 * An object describing the change. See the
		 * [itemchange event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#event-itemchange) of the store's backing collection
		 * @param   {object}         eOpts              The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		update? (_this: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string[], details: object, eOpts: object): void;
		/** 
		 * Fires whenever a successful write has been made via the configured [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that was used in
		 * the write
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		write? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
	}
}
declare namespace Ext.data.XmlStore {
	/** 
	 * @events
	 * Config interface for class listeners: 
	 * [Ext.data.XmlStore](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html)
	 * Small helper class to make creating [Ext.data.Store](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html)s from XML data easier.
	 * A XmlStore will be automatically configured with a [Ext.data.reader.Xml](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Xml.html).
	 * 
	 * A store configuration would be something like:
	 * 
	 *    var store = new Ext.data.XmlStore({
	 *        // store configs
	 *        storeId: 'myStore',
	 *        url: 'sheldon.xml', // automatically configures a HttpProxy
	 *        // reader configs
	 *        record: 'Item', // records will have an "Item" tag
	 *        idPath: 'ASIN',
	 *        totalRecords: '@TotalResults'
	 *        fields: [
	 *            // set up the fields mapping into the xml doc
	 *            // The first needs mapping, the others are very basic
	 *            {name: 'Author', mapping: 'ItemAttributes > Author'},
	 *            'Title', 'Manufacturer', 'ProductGroup'
	 *        ]
	 *    });
	 * 
	 * This store is configured to consume a returned object of the form:
	 * 
	 *    &#60?xml version="1.0" encoding="UTF-8"?>
	 *    &#60ItemSearchResponse xmlns="http://webservices.amazon.com/AWSECommerceService/2009-05-15">
	 *        &#60Items>
	 *            &#60Request>
	 *                &#60IsValid>True&#60/IsValid>
	 *                &#60ItemSearchRequest>
	 *                    &#60Author>Sidney Sheldon&#60/Author>
	 *                    &#60SearchIndex>Books&#60/SearchIndex>
	 *                &#60/ItemSearchRequest>
	 *            &#60/Request>
	 *            &#60TotalResults>203&#60/TotalResults>
	 *            &#60TotalPages>21&#60/TotalPages>
	 *            &#60Item>
	 *                &#60ASIN>0446355453&#60/ASIN>
	 *                &#60DetailPageURL>
	 *                    http://www.amazon.com/
	 *                &#60/DetailPageURL>
	 *                &#60ItemAttributes>
	 *                    &#60Author>Sidney Sheldon&#60/Author>
	 *                    &#60Manufacturer>Warner Books&#60/Manufacturer>
	 *                    &#60ProductGroup>Book&#60/ProductGroup>
	 *                    &#60Title>Master of the Game&#60/Title>
	 *                &#60/ItemAttributes>
	 *            &#60/Item>
	 *        &#60/Items>
	 *    &#60/ItemSearchResponse>
	 * 
	 * An object literal of this form could also be used as the [data](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.XmlStore.html#cfg-data) config option.
	 * 
	 * **Note:** This class accepts all of the configuration options of
	 * **[XmlReader](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.reader.Xml.html)**.
	 */
	interface Events extends Ext.base.Events {
		/** 
		 * Fired when a Model instance has been added to this Store.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.data.Model[]} records The records that were added.
		 * @param   {number}           index   The index at which the records were inserted.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		add? (store: Ext.data.Store, records: Ext.data.Model[], index: number, eOpts: object): void;
		/** 
		 * Fires before a request is made for a new data object. If the beforeload handler returns false the load
		 * action will be canceled.
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Ext.data.operation.Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that will be passed to the Proxy to
		 * load the Store
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeload? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a prefetch occurs. Return `false` to cancel.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.operation.Operation} operation The associated operation.
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		beforeprefetch? (_this: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires before a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be just before the load operation triggered by changing the
		 * store's sorters.
		 * 
		 * For locally sorted stores, this will be just before the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store}    store   The store being sorted
		 * @param   {Ext.util.Sorter[]} sorters Array of sorters applied to the store
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		beforesort? (store: Ext.data.Store, sorters: Ext.util.Sorter[], eOpts: object): void;
		/** 
		 * Fired before a call to [sync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#method-sync) is executed. Return false from any listener to cancel the sync
		 * @event
		 * @param   {object} options Hash of all records to be synchronized, broken down into create, update and destroy
		 * @param   {object} eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beforesync? (options: object, eOpts: object): void;
		/** 
		 * Fires when the [beginUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-beginUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		beginupdate? (eOpts: object): void;
		/** 
		 * Fired after the [removeAll](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.Store.html#method-removeAll) method is called.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		clear? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires whenever records are added to or removed from the Store.
		 * 
		 * To hook into modifications of records in this Store use the [update](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#event-update) event.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		datachanged? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called. Automatic synchronization as configured
		 * by the [autoSync](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-autoSync) flag is deferred until the [endUpdate](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#method-endUpdate) method is called, so multiple
		 * mutations can be coalesced into one synchronization operation.
		 * @event
		 * @param   {object} eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}   
		 */
		endupdate? (eOpts: object): void;
		/** 
		 * Fired whenever the filter set changes.
		 * @event
		 * @param   {Ext.data.Store}    store   The store.
		 * @param   {Ext.util.Filter[]} filters The array of Filter objects.
		 * @param   {object}            eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}              
		 */
		filterchange? (store: Ext.data.Store, filters: Ext.util.Filter[], eOpts: object): void;
		/** 
		 * Fired whenever the grouping in the grid changes.
		 * @event
		 * @param   {Ext.data.Store}   store   The store.
		 * @param   {Ext.util.Grouper} grouper The grouper object.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		groupchange? (store: Ext.data.Store, grouper: Ext.util.Grouper, eOpts: object): void;
		/** 
		 * Fires whenever the store reads data from a remote data source.
		 * @event
		 * @param   {Ext.data.Store}          _this
		 * @param   {Ext.data.Model[]}        records    An array of records
		 * @param   {boolean}                 successful True if the operation was successful.
		 * @param   {Ext.data.operation.Read} operation
		 * The
		 * [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Read.html) object that was used in the data
		 * load call
		 * @param   {object}                  eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                    
		 */
		load? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Read, eOpts: object): void;
		/** 
		 * Fires when this store's underlying reader (available via the proxy) provides new metadata.
		 * Metadata usually consists of new field definitions, but can include any configuration data
		 * required by an application, and can be processed as needed in the event handler.
		 * This event is currently only fired for JsonReaders.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {object}         meta  The JSON metadata
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		metachange? (_this: Ext.data.Store, meta: object, eOpts: object): void;
		/** 
		 * Fires whenever records have been prefetched.
		 * @event
		 * @param   {Ext.data.Store}               _this
		 * @param   {Ext.data.Model[]}             records    An array of records.
		 * @param   {boolean}                      successful `true` if the operation was successful.
		 * @param   {Ext.data.operation.Operation} operation  The associated operation.
		 * @param   {object}                       eOpts      The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		prefetch? (_this: Ext.data.Store, records: Ext.data.Model[], successful: boolean, operation: Ext.data.operation.Operation, eOpts: object): void;
		/** 
		 * Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a
		 * widget that is using this Store as a Record cache should refresh its view.
		 * @event
		 * @param   {Ext.data.Store} _this The data store
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		refresh? (_this: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fired when one or more records have been removed from this Store.
		 * 
		 * **The signature for this event has changed in 5.0: **
		 * @event
		 * @param   {Ext.data.Store}   store   The Store object
		 * @param   {Ext.data.Model[]} records
		 * The records that were removed. In previous
		 * releases this was a single record, not an array.
		 * @param   {number}           index   The index at which the records were removed.
		 * @param   {boolean}          isMove
		 * `true` if the child node is being removed so it can be
		 * moved to another position in this Store.
		 * @param   {object}           eOpts   The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}             
		 */
		remove? (store: Ext.data.Store, records: Ext.data.Model[], index: number, isMove: boolean, eOpts: object): void;
		/** 
		 * Fires after a store is sorted.
		 * 
		 * For [remotely sorted](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.AbstractStore.html#cfg-remoteSort) stores, this will be upon the success of a load operation triggered by
		 * changing the store's sorters.
		 * 
		 * For locally sorted stores, this will be just after the data items in the store's backing collection are sorted.
		 * @event
		 * @param   {Ext.data.Store} store The store being sorted
		 * @param   {object}         eOpts The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		sort? (store: Ext.data.Store, eOpts: object): void;
		/** 
		 * Fires when a Model instance has been updated.
		 * @event
		 * @param   {Ext.data.Store} _this
		 * @param   {Ext.data.Model} record             The Model instance that was updated
		 * @param   {string}         operation
		 * The update operation being performed. Value may be one of:
		 * 
		 *    Ext.data.Model.EDIT
		 *    Ext.data.Model.REJECT
		 *    Ext.data.Model.COMMIT
		 * 
		 * @param   {string[]}       modifiedFieldNames Array of field names changed during edit.
		 * @param   {object}         details
		 * An object describing the change. See the
		 * [itemchange event](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Collection.html#event-itemchange) of the store's backing collection
		 * @param   {object}         eOpts              The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}           
		 */
		update? (_this: Ext.data.Store, record: Ext.data.Model, operation: string, modifiedFieldNames: string[], details: object, eOpts: object): void;
		/** 
		 * Fires whenever a successful write has been made via the configured [Proxy](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.ProxyStore.html#cfg-proxy)
		 * @event
		 * @param   {Ext.data.Store}               store     This Store
		 * @param   {Ext.data.operation.Operation} operation
		 * The [Operation](https://docs.sencha.com/extjs/6.2.0/modern/Ext.data.operation.Operation.html) object that was used in
		 * the write
		 * @param   {object}                       eOpts     The options object passed to [Ext.util.Observable.addListener](https://docs.sencha.com/extjs/6.2.0/modern/Ext.util.Observable.html#method-addListener).
		 * @returns {void}                         
		 */
		write? (store: Ext.data.Store, operation: Ext.data.operation.Operation, eOpts: object): void;
	}
}
